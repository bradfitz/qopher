{
	"description": "all: use strings.IndexByte instead of Index where possible",
	"cc": [
		"golang-dev@googlegroups.com",
		"khr@golang.org"
	],
	"reviewers": [
		"dave@cheney.net",
		"r@golang.org",
		"rsc@golang.org"
	],
	"messages": [
		{
			"sender": "khr@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/08/05 22:37:42, bradfitz wrote:\n> Hello mailto:golang-dev@googlegroups.com,\n> \n> I'd like you to review this change to\n> https://go.googlecode.com/hg/\n\nLGTM.",
			"disapproval": false,
			"date": "2013-08-05 22:43:29.233260",
			"approval": true
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Do you think it is worthy of a vet check, or go fix -s?\r\n\r\nOn 06/08/2013, at 8:50, Brad Fitzpatrick <bradfitz@golang.org> wrote:\r\n\r\n> grep -r -E -l 'strings.Index.*\".\"' pkg | grep go$ | xargs perl -pi -e \"s:strings.Index\\((.+), \\\"(.)\\\":strings.IndexByte(\\$1, '\\$2':\"\r\n> \r\n> \r\n> On Mon, Aug 5, 2013 at 3:48 PM, Dave Cheney <dave@cheney.net> wrote:\r\n>> Is there a vet rule for this, or did you just hit it with the grep hammer ?\r\n>> \r\n>> On 06/08/2013, at 8:37, bradfitz@golang.org wrote:\r\n>> \r\n>> > Reviewers: golang-dev1,\r\n>> >\r\n>> > Message:\r\n>> > Hello golang-dev@googlegroups.com,\r\n>> >\r\n>> > I'd like you to review this change to\r\n>> > https://go.googlecode.com/hg/\r\n>> >\r\n>> >\r\n>> > Description:\r\n>> > all: use strings.IndexByte instead of Index where possible\r\n>> >\r\n>> > Please review this at https://codereview.appspot.com/12486043/\r\n>> >\r\n>> > Affected files:\r\n>> >  M src/pkg/crypto/x509/pem_decrypt.go\r\n>> >  M src/pkg/debug/gosym/symtab.go\r\n>> >  M src/pkg/encoding/json/tags.go\r\n>> >  M src/pkg/encoding/xml/typeinfo.go\r\n>> >  M src/pkg/encoding/xml/xml.go\r\n>> >  M src/pkg/go/build/build.go\r\n>> >  M src/pkg/go/printer/printer.go\r\n>> >  M src/pkg/math/big/rat.go\r\n>> >  M src/pkg/mime/mediatype.go\r\n>> >  M src/pkg/net/http/cgi/child.go\r\n>> >  M src/pkg/net/http/cookie.go\r\n>> >  M src/pkg/net/http/fs.go\r\n>> >  M src/pkg/net/http/request.go\r\n>> >  M src/pkg/net/http/server.go\r\n>> >  M src/pkg/net/url/url.go\r\n>> >  M src/pkg/os/os_test.go\r\n>> >  M src/pkg/os/user/lookup_unix.go\r\n>> >  M src/pkg/path/match.go\r\n>> >  M src/pkg/regexp/exec_test.go\r\n>> >  M src/pkg/regexp/regexp.go\r\n>> >  M src/pkg/unicode/maketables.go\r\n>> >\r\n>> >\r\n>> > Index: src/pkg/crypto/x509/pem_decrypt.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/crypto/x509/pem_decrypt.go\r\n>> > +++ b/src/pkg/crypto/x509/pem_decrypt.go\r\n>> > @@ -115,7 +115,7 @@\r\n>> >        return nil, errors.New(\"x509: no DEK-Info header in block\")\r\n>> >    }\r\n>> >\r\n>> > -    idx := strings.Index(dek, \",\")\r\n>> > +    idx := strings.IndexByte(dek, ',')\r\n>> >    if idx == -1 {\r\n>> >        return nil, errors.New(\"x509: malformed DEK-Info header\")\r\n>> >    }\r\n>> > Index: src/pkg/debug/gosym/symtab.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/debug/gosym/symtab.go\r\n>> > +++ b/src/pkg/debug/gosym/symtab.go\r\n>> > @@ -40,7 +40,7 @@\r\n>> > // PackageName returns the package part of the symbol name,\r\n>> > // or the empty string if there is none.\r\n>> > func (s *Sym) PackageName() string {\r\n>> > -    if i := strings.Index(s.Name, \".\"); i != -1 {\r\n>> > +    if i := strings.IndexByte(s.Name, '.'); i != -1 {\r\n>> >        return s.Name[0:i]\r\n>> >    }\r\n>> >    return \"\"\r\n>> > @@ -49,7 +49,7 @@\r\n>> > // ReceiverName returns the receiver type name of this symbol,\r\n>> > // or the empty string if there is none.\r\n>> > func (s *Sym) ReceiverName() string {\r\n>> > -    l := strings.Index(s.Name, \".\")\r\n>> > +    l := strings.IndexByte(s.Name, '.')\r\n>> >    r := strings.LastIndex(s.Name, \".\")\r\n>> >    if l == -1 || r == -1 || l == r {\r\n>> >        return \"\"\r\n>> > Index: src/pkg/encoding/json/tags.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/encoding/json/tags.go\r\n>> > +++ b/src/pkg/encoding/json/tags.go\r\n>> > @@ -15,7 +15,7 @@\r\n>> > // parseTag splits a struct field's json tag into its name and\r\n>> > // comma-separated options.\r\n>> > func parseTag(tag string) (string, tagOptions) {\r\n>> > -    if idx := strings.Index(tag, \",\"); idx != -1 {\r\n>> > +    if idx := strings.IndexByte(tag, ','); idx != -1 {\r\n>> >        return tag[:idx], tagOptions(tag[idx+1:])\r\n>> >    }\r\n>> >    return tag, tagOptions(\"\")\r\n>> > @@ -31,7 +31,7 @@\r\n>> >    s := string(o)\r\n>> >    for s != \"\" {\r\n>> >        var next string\r\n>> > -        i := strings.Index(s, \",\")\r\n>> > +        i := strings.IndexByte(s, ',')\r\n>> >        if i >= 0 {\r\n>> >            s, next = s[:i], s[i+1:]\r\n>> >        }\r\n>> > Index: src/pkg/encoding/xml/typeinfo.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/encoding/xml/typeinfo.go\r\n>> > +++ b/src/pkg/encoding/xml/typeinfo.go\r\n>> > @@ -113,7 +113,7 @@\r\n>> >\r\n>> >    // Split the tag from the xml namespace if necessary.\r\n>> >    tag := f.Tag.Get(\"xml\")\r\n>> > -    if i := strings.Index(tag, \" \"); i >= 0 {\r\n>> > +    if i := strings.IndexByte(tag, ' '); i >= 0 {\r\n>> >        finfo.xmlns, tag = tag[:i], tag[i+1:]\r\n>> >    }\r\n>> >\r\n>> > Index: src/pkg/encoding/xml/xml.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/encoding/xml/xml.go\r\n>> > +++ b/src/pkg/encoding/xml/xml.go\r\n>> > @@ -1026,7 +1026,7 @@\r\n>> >    if !ok {\r\n>> >        return\r\n>> >    }\r\n>> > -    i := strings.Index(s, \":\")\r\n>> > +    i := strings.IndexByte(s, ':')\r\n>> >    if i < 0 {\r\n>> >        name.Local = s\r\n>> >    } else {\r\n>> > Index: src/pkg/go/build/build.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/go/build/build.go\r\n>> > +++ b/src/pkg/go/build/build.go\r\n>> > @@ -877,7 +877,7 @@\r\n>> >\r\n>> >        // Split at colon.\r\n>> >        line = strings.TrimSpace(line[4:])\r\n>> > -        i := strings.Index(line, \":\")\r\n>> > +        i := strings.IndexByte(line, ':')\r\n>> >        if i < 0 {\r\n>> >            return fmt.Errorf(\"%s: invalid #cgo line: %s\", filename, orig)\r\n>> >        }\r\n>> > @@ -1022,7 +1022,7 @@\r\n>> >    if name == \"\" {\r\n>> >        return false\r\n>> >    }\r\n>> > -    if i := strings.Index(name, \",\"); i >= 0 {\r\n>> > +    if i := strings.IndexByte(name, ','); i >= 0 {\r\n>> >        // comma-separated list\r\n>> >        return ctxt.match(name[:i]) && ctxt.match(name[i+1:])\r\n>> >    }\r\n>> > @@ -1076,7 +1076,7 @@\r\n>> > //     name_$(GOOS)_$(GOARCH)_test.*\r\n>> > //\r\n>> > func (ctxt *Context) goodOSArchFile(name string) bool {\r\n>> > -    if dot := strings.Index(name, \".\"); dot != -1 {\r\n>> > +    if dot := strings.IndexByte(name, '.'); dot != -1 {\r\n>> >        name = name[:dot]\r\n>> >    }\r\n>> >    l := strings.Split(name, \"_\")\r\n>> > Index: src/pkg/go/printer/printer.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/go/printer/printer.go\r\n>> > +++ b/src/pkg/go/printer/printer.go\r\n>> > @@ -474,7 +474,7 @@\r\n>> >     * Check for vertical \"line of stars\" and correct prefix accordingly.\r\n>> >     */\r\n>> >    lineOfStars := false\r\n>> > -    if i := strings.Index(prefix, \"*\"); i >= 0 {\r\n>> > +    if i := strings.IndexByte(prefix, '*'); i >= 0 {\r\n>> >        // Line of stars present.\r\n>> >        if i > 0 && prefix[i-1] == ' ' {\r\n>> >            i-- // remove trailing blank from prefix so stars remain aligned\r\n>> > Index: src/pkg/math/big/rat.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/math/big/rat.go\r\n>> > +++ b/src/pkg/math/big/rat.go\r\n>> > @@ -429,7 +429,7 @@\r\n>> >    }\r\n>> >\r\n>> >    // check for a quotient\r\n>> > -    sep := strings.Index(s, \"/\")\r\n>> > +    sep := strings.IndexByte(s, '/')\r\n>> >    if sep >= 0 {\r\n>> >        if _, ok := z.a.SetString(s[0:sep], 10); !ok {\r\n>> >            return nil, false\r\n>> > @@ -443,7 +443,7 @@\r\n>> >    }\r\n>> >\r\n>> >    // check for a decimal point\r\n>> > -    sep = strings.Index(s, \".\")\r\n>> > +    sep = strings.IndexByte(s, '.')\r\n>> >    // check for an exponent\r\n>> >    e := strings.IndexAny(s, \"eE\")\r\n>> >    var exp Int\r\n>> > Index: src/pkg/mime/mediatype.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/mime/mediatype.go\r\n>> > +++ b/src/pkg/mime/mediatype.go\r\n>> > @@ -18,7 +18,7 @@\r\n>> > // When any of the arguments result in a standard violation then\r\n>> > // FormatMediaType returns the empty string.\r\n>> > func FormatMediaType(t string, param map[string]string) string {\r\n>> > -    slash := strings.Index(t, \"/\")\r\n>> > +    slash := strings.IndexByte(t, '/')\r\n>> >    if slash == -1 {\r\n>> >        return \"\"\r\n>> >    }\r\n>> > @@ -91,7 +91,7 @@\r\n>> > // The returned map, params, maps from the lowercase\r\n>> > // attribute to the attribute value with its case preserved.\r\n>> > func ParseMediaType(v string) (mediatype string, params map[string]string, err error) {\r\n>> > -    i := strings.Index(v, \";\")\r\n>> > +    i := strings.IndexByte(v, ';')\r\n>> >    if i == -1 {\r\n>> >        i = len(v)\r\n>> >    }\r\n>> > @@ -127,7 +127,7 @@\r\n>> >        }\r\n>> >\r\n>> >        pmap := params\r\n>> > -        if idx := strings.Index(key, \"*\"); idx != -1 {\r\n>> > +        if idx := strings.IndexByte(key, '*'); idx != -1 {\r\n>> >            baseName := key[:idx]\r\n>> >            if continuation == nil {\r\n>> >                continuation = make(map[string]map[string]string)\r\n>> > Index: src/pkg/net/http/cgi/child.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/http/cgi/child.go\r\n>> > +++ b/src/pkg/net/http/cgi/child.go\r\n>> > @@ -40,7 +40,7 @@\r\n>> > func envMap(env []string) map[string]string {\r\n>> >    m := make(map[string]string)\r\n>> >    for _, kv := range env {\r\n>> > -        if idx := strings.Index(kv, \"=\"); idx != -1 {\r\n>> > +        if idx := strings.IndexByte(kv, '='); idx != -1 {\r\n>> >            m[kv[:idx]] = kv[idx+1:]\r\n>> >        }\r\n>> >    }\r\n>> > Index: src/pkg/net/http/cookie.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/http/cookie.go\r\n>> > +++ b/src/pkg/net/http/cookie.go\r\n>> > @@ -47,7 +47,7 @@\r\n>> >            continue\r\n>> >        }\r\n>> >        parts[0] = strings.TrimSpace(parts[0])\r\n>> > -        j := strings.Index(parts[0], \"=\")\r\n>> > +        j := strings.IndexByte(parts[0], '=')\r\n>> >        if j < 0 {\r\n>> >            continue\r\n>> >        }\r\n>> > @@ -71,7 +71,7 @@\r\n>> >            }\r\n>> >\r\n>> >            attr, val := parts[i], \"\"\r\n>> > -            if j := strings.Index(attr, \"=\"); j >= 0 {\r\n>> > +            if j := strings.IndexByte(attr, '='); j >= 0 {\r\n>> >                attr, val = attr[:j], attr[j+1:]\r\n>> >            }\r\n>> >            lowerAttr := strings.ToLower(attr)\r\n>> > @@ -188,7 +188,7 @@\r\n>> >                continue\r\n>> >            }\r\n>> >            name, val := parts[i], \"\"\r\n>> > -            if j := strings.Index(name, \"=\"); j >= 0 {\r\n>> > +            if j := strings.IndexByte(name, '='); j >= 0 {\r\n>> >                name, val = name[:j], name[j+1:]\r\n>> >            }\r\n>> >            if !isCookieNameValid(name) {\r\n>> > Index: src/pkg/net/http/fs.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/http/fs.go\r\n>> > +++ b/src/pkg/net/http/fs.go\r\n>> > @@ -467,7 +467,7 @@\r\n>> >        if ra == \"\" {\r\n>> >            continue\r\n>> >        }\r\n>> > -        i := strings.Index(ra, \"-\")\r\n>> > +        i := strings.IndexByte(ra, '-')\r\n>> >        if i < 0 {\r\n>> >            return nil, errors.New(\"invalid range\")\r\n>> >        }\r\n>> > Index: src/pkg/net/http/request.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/http/request.go\r\n>> > +++ b/src/pkg/net/http/request.go\r\n>> > @@ -408,7 +408,7 @@\r\n>> >    if !strings.HasPrefix(vers, \"HTTP/\") {\r\n>> >        return 0, 0, false\r\n>> >    }\r\n>> > -    dot := strings.Index(vers, \".\")\r\n>> > +    dot := strings.IndexByte(vers, '.')\r\n>> >    if dot < 0 {\r\n>> >        return 0, 0, false\r\n>> >    }\r\n>> > @@ -473,8 +473,8 @@\r\n>> >\r\n>> > // parseRequestLine parses \"GET /foo HTTP/1.1\" into its three parts.\r\n>> > func parseRequestLine(line string) (method, requestURI, proto string, ok bool) {\r\n>> > -    s1 := strings.Index(line, \" \")\r\n>> > -    s2 := strings.Index(line[s1+1:], \" \")\r\n>> > +    s1 := strings.IndexByte(line, ' ')\r\n>> > +    s2 := strings.IndexByte(line[s1+1:], ' ')\r\n>> >    if s1 < 0 || s2 < 0 {\r\n>> >        return\r\n>> >    }\r\n>> > Index: src/pkg/net/http/server.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/http/server.go\r\n>> > +++ b/src/pkg/net/http/server.go\r\n>> > @@ -1262,7 +1262,7 @@\r\n>> >            }\r\n>> >\r\n>> >            var query string\r\n>> > -            if i := strings.Index(urlStr, \"?\"); i != -1 {\r\n>> > +            if i := strings.IndexByte(urlStr, '?'); i != -1 {\r\n>> >                urlStr, query = urlStr[:i], urlStr[i:]\r\n>> >            }\r\n>> >\r\n>> > @@ -1494,7 +1494,7 @@\r\n>> >        if pattern[0] != '/' {\r\n>> >            // In pattern, at least the last character is a '/', so\r\n>> >            // strings.Index can't be -1.\r\n>> > -            path = pattern[strings.Index(pattern, \"/\"):]\r\n>> > +            path = pattern[strings.IndexByte(pattern, '/'):]\r\n>> >        }\r\n>> >        mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(path, StatusMovedPermanently), pattern: pattern}\r\n>> >    }\r\n>> > Index: src/pkg/net/url/url.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/url/url.go\r\n>> > +++ b/src/pkg/net/url/url.go\r\n>> > @@ -421,7 +421,7 @@\r\n>> >        return\r\n>> >    }\r\n>> >    userinfo, host := authority[:i], authority[i+1:]\r\n>> > -    if strings.Index(userinfo, \":\") < 0 {\r\n>> > +    if strings.IndexByte(userinfo, ':') < 0 {\r\n>> >        if userinfo, err = unescape(userinfo, encodeUserPassword); err != nil {\r\n>> >            return\r\n>> >        }\r\n>> > @@ -536,7 +536,7 @@\r\n>> >            continue\r\n>> >        }\r\n>> >        value := \"\"\r\n>> > -        if i := strings.Index(key, \"=\"); i >= 0 {\r\n>> > +        if i := strings.IndexByte(key, '='); i >= 0 {\r\n>> >            key, value = key[:i], key[i+1:]\r\n>> >        }\r\n>> >        key, err1 := QueryUnescape(key)\r\n>> > Index: src/pkg/os/os_test.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/os/os_test.go\r\n>> > +++ b/src/pkg/os/os_test.go\r\n>> > @@ -890,7 +890,7 @@\r\n>> >    }\r\n>> >    want := run(t, []string{\"/bin/hostname\"})\r\n>> >    if hostname != want {\r\n>> > -        i := strings.Index(hostname, \".\")\r\n>> > +        i := strings.IndexByte(hostname, '.')\r\n>> >        if i < 0 || hostname[0:i] != want {\r\n>> >            t.Errorf(\"Hostname() = %q, want %q\", hostname, want)\r\n>> >        }\r\n>> > Index: src/pkg/os/user/lookup_unix.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/os/user/lookup_unix.go\r\n>> > +++ b/src/pkg/os/user/lookup_unix.go\r\n>> > @@ -105,7 +105,7 @@\r\n>> >    // say: \"It is expected to be a comma separated list of\r\n>> >    // personal data where the first item is the full name of the\r\n>> >    // user.\"\r\n>> > -    if i := strings.Index(u.Name, \",\"); i >= 0 {\r\n>> > +    if i := strings.IndexByte(u.Name, ','); i >= 0 {\r\n>> >        u.Name = u.Name[:i]\r\n>> >    }\r\n>> >    return u, nil\r\n>> > Index: src/pkg/path/match.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/path/match.go\r\n>> > +++ b/src/pkg/path/match.go\r\n>> > @@ -43,7 +43,7 @@\r\n>> >        star, chunk, pattern = scanChunk(pattern)\r\n>> >        if star && chunk == \"\" {\r\n>> >            // Trailing * matches rest of string unless it has a /.\r\n>> > -            return strings.Index(name, \"/\") < 0, nil\r\n>> > +            return strings.IndexByte(name, '/') < 0, nil\r\n>> >        }\r\n>> >        // Look for match at current position.\r\n>> >        t, ok, err := matchChunk(chunk, name)\r\n>> > Index: src/pkg/regexp/exec_test.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/regexp/exec_test.go\r\n>> > +++ b/src/pkg/regexp/exec_test.go\r\n>> > @@ -293,7 +293,7 @@\r\n>> >                out[n] = -1\r\n>> >                out[n+1] = -1\r\n>> >            } else {\r\n>> > -                k := strings.Index(pair, \"-\")\r\n>> > +                k := strings.IndexByte(pair, '-')\r\n>> >                if k < 0 {\r\n>> >                    t.Fatalf(\"%s:%d: invalid pair %s\", file, lineno, pair)\r\n>> >                }\r\n>> > @@ -456,7 +456,7 @@\r\n>> >                continue Reading\r\n>> >            }\r\n>> >        case ':':\r\n>> > -            i := strings.Index(flag[1:], \":\")\r\n>> > +            i := strings.IndexByte(flag[1:], ':')\r\n>> >            if i < 0 {\r\n>> >                t.Logf(\"skip: %s\", line)\r\n>> >                continue Reading\r\n>> > Index: src/pkg/regexp/regexp.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/regexp/regexp.go\r\n>> > +++ b/src/pkg/regexp/regexp.go\r\n>> > @@ -429,7 +429,7 @@\r\n>> > // in Expand, so for instance $1 represents the text of the first submatch.\r\n>> > func (re *Regexp) ReplaceAllString(src, repl string) string {\r\n>> >    n := 2\r\n>> > -    if strings.Index(repl, \"$\") >= 0 {\r\n>> > +    if strings.IndexByte(repl, '$') >= 0 {\r\n>> >        n = 2 * (re.numSubexp + 1)\r\n>> >    }\r\n>> >    b := re.replaceAll(nil, src, n, func(dst []byte, match []int) []byte {\r\n>> > @@ -753,7 +753,7 @@\r\n>> >\r\n>> > func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte {\r\n>> >    for len(template) > 0 {\r\n>> > -        i := strings.Index(template, \"$\")\r\n>> > +        i := strings.IndexByte(template, '$')\r\n>> >        if i < 0 {\r\n>> >            break\r\n>> >        }\r\n>> > Index: src/pkg/unicode/maketables.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/unicode/maketables.go\r\n>> > +++ b/src/pkg/unicode/maketables.go\r\n>> > @@ -616,7 +616,7 @@\r\n>> > }\r\n>> >\r\n>> > func parseScript(line string, scripts map[string][]Script) {\r\n>> > -    comment := strings.Index(line, \"#\")\r\n>> > +    comment := strings.IndexByte(line, '#')\r\n>> >    if comment >= 0 {\r\n>> >        line = line[0:comment]\r\n>> >    }\r\n>> >\r\n>> >\r\n>> > --\r\n>> >\r\n>> > ---You received this message because you are subscribed to the Google Groups \"golang-dev\" group.\r\n>> > To unsubscribe from this group and stop receiving emails from it, send an email to golang-dev+unsubscribe@googlegroups.com.\r\n>> > For more options, visit https://groups.google.com/groups/opt_out.\r\n>> >\r\n>> >\r\n> \r\n",
			"disapproval": false,
			"date": "2013-08-05 22:55:06.450970",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "not lgtm\r\n\r\nThis is exactly why strings.IndexByte didn't exist. This code is uglier and\r\nnot faster.\r\n",
			"disapproval": true,
			"date": "2013-08-05 22:57:46.881270",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2013-08-05 22:37:42.338620",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=ab644299d124 ***\n\nall: use strings.IndexByte instead of Index where possible\n\nR=golang-dev, khr\nCC=golang-dev\nhttps://codereview.appspot.com/12486043",
			"disapproval": false,
			"date": "2013-08-05 22:46:09.545580",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "No.\r\n\r\n\r\nOn Tue, Aug 6, 2013 at 8:54 AM, Dave Cheney <dave@cheney.net> wrote:\r\n\r\n> Do you think it is worthy of a vet check, or go fix -s?\r\n>\r\n> On 06/08/2013, at 8:50, Brad Fitzpatrick <bradfitz@golang.org> wrote:\r\n>\r\n> grep -r -E -l 'strings.Index.*\".\"' pkg | grep go$ | xargs perl -pi -e\r\n> \"s:strings.Index\\((.+), \\\"(.)\\\":strings.IndexByte(\\$1, '\\$2':\"\r\n>\r\n>\r\n> On Mon, Aug 5, 2013 at 3:48 PM, Dave Cheney <dave@cheney.net> wrote:\r\n>\r\n>> Is there a vet rule for this, or did you just hit it with the grep hammer\r\n>> ?\r\n>>\r\n>> On 06/08/2013, at 8:37, bradfitz@golang.org wrote:\r\n>>\r\n>> > Reviewers: golang-dev1,\r\n>> >\r\n>> > Message:\r\n>> > Hello golang-dev@googlegroups.com,\r\n>> >\r\n>> > I'd like you to review this change to\r\n>> > https://go.googlecode.com/hg/\r\n>> >\r\n>> >\r\n>> > Description:\r\n>> > all: use strings.IndexByte instead of Index where possible\r\n>> >\r\n>> > Please review this at https://codereview.appspot.com/12486043/\r\n>> >\r\n>> > Affected files:\r\n>> >  M src/pkg/crypto/x509/pem_decrypt.go\r\n>> >  M src/pkg/debug/gosym/symtab.go\r\n>> >  M src/pkg/encoding/json/tags.go\r\n>> >  M src/pkg/encoding/xml/typeinfo.go\r\n>> >  M src/pkg/encoding/xml/xml.go\r\n>> >  M src/pkg/go/build/build.go\r\n>> >  M src/pkg/go/printer/printer.go\r\n>> >  M src/pkg/math/big/rat.go\r\n>> >  M src/pkg/mime/mediatype.go\r\n>> >  M src/pkg/net/http/cgi/child.go\r\n>> >  M src/pkg/net/http/cookie.go\r\n>> >  M src/pkg/net/http/fs.go\r\n>> >  M src/pkg/net/http/request.go\r\n>> >  M src/pkg/net/http/server.go\r\n>> >  M src/pkg/net/url/url.go\r\n>> >  M src/pkg/os/os_test.go\r\n>> >  M src/pkg/os/user/lookup_unix.go\r\n>> >  M src/pkg/path/match.go\r\n>> >  M src/pkg/regexp/exec_test.go\r\n>> >  M src/pkg/regexp/regexp.go\r\n>> >  M src/pkg/unicode/maketables.go\r\n>> >\r\n>> >\r\n>> > Index: src/pkg/crypto/x509/pem_decrypt.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/crypto/x509/pem_decrypt.go\r\n>> > +++ b/src/pkg/crypto/x509/pem_decrypt.go\r\n>> > @@ -115,7 +115,7 @@\r\n>> >        return nil, errors.New(\"x509: no DEK-Info header in block\")\r\n>> >    }\r\n>> >\r\n>> > -    idx := strings.Index(dek, \",\")\r\n>> > +    idx := strings.IndexByte(dek, ',')\r\n>> >    if idx == -1 {\r\n>> >        return nil, errors.New(\"x509: malformed DEK-Info header\")\r\n>> >    }\r\n>> > Index: src/pkg/debug/gosym/symtab.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/debug/gosym/symtab.go\r\n>> > +++ b/src/pkg/debug/gosym/symtab.go\r\n>> > @@ -40,7 +40,7 @@\r\n>> > // PackageName returns the package part of the symbol name,\r\n>> > // or the empty string if there is none.\r\n>> > func (s *Sym) PackageName() string {\r\n>> > -    if i := strings.Index(s.Name, \".\"); i != -1 {\r\n>> > +    if i := strings.IndexByte(s.Name, '.'); i != -1 {\r\n>> >        return s.Name[0:i]\r\n>> >    }\r\n>> >    return \"\"\r\n>> > @@ -49,7 +49,7 @@\r\n>> > // ReceiverName returns the receiver type name of this symbol,\r\n>> > // or the empty string if there is none.\r\n>> > func (s *Sym) ReceiverName() string {\r\n>> > -    l := strings.Index(s.Name, \".\")\r\n>> > +    l := strings.IndexByte(s.Name, '.')\r\n>> >    r := strings.LastIndex(s.Name, \".\")\r\n>> >    if l == -1 || r == -1 || l == r {\r\n>> >        return \"\"\r\n>> > Index: src/pkg/encoding/json/tags.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/encoding/json/tags.go\r\n>> > +++ b/src/pkg/encoding/json/tags.go\r\n>> > @@ -15,7 +15,7 @@\r\n>> > // parseTag splits a struct field's json tag into its name and\r\n>> > // comma-separated options.\r\n>> > func parseTag(tag string) (string, tagOptions) {\r\n>> > -    if idx := strings.Index(tag, \",\"); idx != -1 {\r\n>> > +    if idx := strings.IndexByte(tag, ','); idx != -1 {\r\n>> >        return tag[:idx], tagOptions(tag[idx+1:])\r\n>> >    }\r\n>> >    return tag, tagOptions(\"\")\r\n>> > @@ -31,7 +31,7 @@\r\n>> >    s := string(o)\r\n>> >    for s != \"\" {\r\n>> >        var next string\r\n>> > -        i := strings.Index(s, \",\")\r\n>> > +        i := strings.IndexByte(s, ',')\r\n>> >        if i >= 0 {\r\n>> >            s, next = s[:i], s[i+1:]\r\n>> >        }\r\n>> > Index: src/pkg/encoding/xml/typeinfo.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/encoding/xml/typeinfo.go\r\n>> > +++ b/src/pkg/encoding/xml/typeinfo.go\r\n>> > @@ -113,7 +113,7 @@\r\n>> >\r\n>> >    // Split the tag from the xml namespace if necessary.\r\n>> >    tag := f.Tag.Get(\"xml\")\r\n>> > -    if i := strings.Index(tag, \" \"); i >= 0 {\r\n>> > +    if i := strings.IndexByte(tag, ' '); i >= 0 {\r\n>> >        finfo.xmlns, tag = tag[:i], tag[i+1:]\r\n>> >    }\r\n>> >\r\n>> > Index: src/pkg/encoding/xml/xml.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/encoding/xml/xml.go\r\n>> > +++ b/src/pkg/encoding/xml/xml.go\r\n>> > @@ -1026,7 +1026,7 @@\r\n>> >    if !ok {\r\n>> >        return\r\n>> >    }\r\n>> > -    i := strings.Index(s, \":\")\r\n>> > +    i := strings.IndexByte(s, ':')\r\n>> >    if i < 0 {\r\n>> >        name.Local = s\r\n>> >    } else {\r\n>> > Index: src/pkg/go/build/build.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/go/build/build.go\r\n>> > +++ b/src/pkg/go/build/build.go\r\n>> > @@ -877,7 +877,7 @@\r\n>> >\r\n>> >        // Split at colon.\r\n>> >        line = strings.TrimSpace(line[4:])\r\n>> > -        i := strings.Index(line, \":\")\r\n>> > +        i := strings.IndexByte(line, ':')\r\n>> >        if i < 0 {\r\n>> >            return fmt.Errorf(\"%s: invalid #cgo line: %s\", filename,\r\n>> orig)\r\n>> >        }\r\n>> > @@ -1022,7 +1022,7 @@\r\n>> >    if name == \"\" {\r\n>> >        return false\r\n>> >    }\r\n>> > -    if i := strings.Index(name, \",\"); i >= 0 {\r\n>> > +    if i := strings.IndexByte(name, ','); i >= 0 {\r\n>> >        // comma-separated list\r\n>> >        return ctxt.match(name[:i]) && ctxt.match(name[i+1:])\r\n>> >    }\r\n>> > @@ -1076,7 +1076,7 @@\r\n>> > //     name_$(GOOS)_$(GOARCH)_test.*\r\n>> > //\r\n>> > func (ctxt *Context) goodOSArchFile(name string) bool {\r\n>> > -    if dot := strings.Index(name, \".\"); dot != -1 {\r\n>> > +    if dot := strings.IndexByte(name, '.'); dot != -1 {\r\n>> >        name = name[:dot]\r\n>> >    }\r\n>> >    l := strings.Split(name, \"_\")\r\n>> > Index: src/pkg/go/printer/printer.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/go/printer/printer.go\r\n>> > +++ b/src/pkg/go/printer/printer.go\r\n>> > @@ -474,7 +474,7 @@\r\n>> >     * Check for vertical \"line of stars\" and correct prefix accordingly.\r\n>> >     */\r\n>> >    lineOfStars := false\r\n>> > -    if i := strings.Index(prefix, \"*\"); i >= 0 {\r\n>> > +    if i := strings.IndexByte(prefix, '*'); i >= 0 {\r\n>> >        // Line of stars present.\r\n>> >        if i > 0 && prefix[i-1] == ' ' {\r\n>> >            i-- // remove trailing blank from prefix so stars remain\r\n>> aligned\r\n>> > Index: src/pkg/math/big/rat.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/math/big/rat.go\r\n>> > +++ b/src/pkg/math/big/rat.go\r\n>> > @@ -429,7 +429,7 @@\r\n>> >    }\r\n>> >\r\n>> >    // check for a quotient\r\n>> > -    sep := strings.Index(s, \"/\")\r\n>> > +    sep := strings.IndexByte(s, '/')\r\n>> >    if sep >= 0 {\r\n>> >        if _, ok := z.a.SetString(s[0:sep], 10); !ok {\r\n>> >            return nil, false\r\n>> > @@ -443,7 +443,7 @@\r\n>> >    }\r\n>> >\r\n>> >    // check for a decimal point\r\n>> > -    sep = strings.Index(s, \".\")\r\n>> > +    sep = strings.IndexByte(s, '.')\r\n>> >    // check for an exponent\r\n>> >    e := strings.IndexAny(s, \"eE\")\r\n>> >    var exp Int\r\n>> > Index: src/pkg/mime/mediatype.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/mime/mediatype.go\r\n>> > +++ b/src/pkg/mime/mediatype.go\r\n>> > @@ -18,7 +18,7 @@\r\n>> > // When any of the arguments result in a standard violation then\r\n>> > // FormatMediaType returns the empty string.\r\n>> > func FormatMediaType(t string, param map[string]string) string {\r\n>> > -    slash := strings.Index(t, \"/\")\r\n>> > +    slash := strings.IndexByte(t, '/')\r\n>> >    if slash == -1 {\r\n>> >        return \"\"\r\n>> >    }\r\n>> > @@ -91,7 +91,7 @@\r\n>> > // The returned map, params, maps from the lowercase\r\n>> > // attribute to the attribute value with its case preserved.\r\n>> > func ParseMediaType(v string) (mediatype string, params\r\n>> map[string]string, err error) {\r\n>> > -    i := strings.Index(v, \";\")\r\n>> > +    i := strings.IndexByte(v, ';')\r\n>> >    if i == -1 {\r\n>> >        i = len(v)\r\n>> >    }\r\n>> > @@ -127,7 +127,7 @@\r\n>> >        }\r\n>> >\r\n>> >        pmap := params\r\n>> > -        if idx := strings.Index(key, \"*\"); idx != -1 {\r\n>> > +        if idx := strings.IndexByte(key, '*'); idx != -1 {\r\n>> >            baseName := key[:idx]\r\n>> >            if continuation == nil {\r\n>> >                continuation = make(map[string]map[string]string)\r\n>> > Index: src/pkg/net/http/cgi/child.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/http/cgi/child.go\r\n>> > +++ b/src/pkg/net/http/cgi/child.go\r\n>> > @@ -40,7 +40,7 @@\r\n>> > func envMap(env []string) map[string]string {\r\n>> >    m := make(map[string]string)\r\n>> >    for _, kv := range env {\r\n>> > -        if idx := strings.Index(kv, \"=\"); idx != -1 {\r\n>> > +        if idx := strings.IndexByte(kv, '='); idx != -1 {\r\n>> >            m[kv[:idx]] = kv[idx+1:]\r\n>> >        }\r\n>> >    }\r\n>> > Index: src/pkg/net/http/cookie.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/http/cookie.go\r\n>> > +++ b/src/pkg/net/http/cookie.go\r\n>> > @@ -47,7 +47,7 @@\r\n>> >            continue\r\n>> >        }\r\n>> >        parts[0] = strings.TrimSpace(parts[0])\r\n>> > -        j := strings.Index(parts[0], \"=\")\r\n>> > +        j := strings.IndexByte(parts[0], '=')\r\n>> >        if j < 0 {\r\n>> >            continue\r\n>> >        }\r\n>> > @@ -71,7 +71,7 @@\r\n>> >            }\r\n>> >\r\n>> >            attr, val := parts[i], \"\"\r\n>> > -            if j := strings.Index(attr, \"=\"); j >= 0 {\r\n>> > +            if j := strings.IndexByte(attr, '='); j >= 0 {\r\n>> >                attr, val = attr[:j], attr[j+1:]\r\n>> >            }\r\n>> >            lowerAttr := strings.ToLower(attr)\r\n>> > @@ -188,7 +188,7 @@\r\n>> >                continue\r\n>> >            }\r\n>> >            name, val := parts[i], \"\"\r\n>> > -            if j := strings.Index(name, \"=\"); j >= 0 {\r\n>> > +            if j := strings.IndexByte(name, '='); j >= 0 {\r\n>> >                name, val = name[:j], name[j+1:]\r\n>> >            }\r\n>> >            if !isCookieNameValid(name) {\r\n>> > Index: src/pkg/net/http/fs.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/http/fs.go\r\n>> > +++ b/src/pkg/net/http/fs.go\r\n>> > @@ -467,7 +467,7 @@\r\n>> >        if ra == \"\" {\r\n>> >            continue\r\n>> >        }\r\n>> > -        i := strings.Index(ra, \"-\")\r\n>> > +        i := strings.IndexByte(ra, '-')\r\n>> >        if i < 0 {\r\n>> >            return nil, errors.New(\"invalid range\")\r\n>> >        }\r\n>> > Index: src/pkg/net/http/request.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/http/request.go\r\n>> > +++ b/src/pkg/net/http/request.go\r\n>> > @@ -408,7 +408,7 @@\r\n>> >    if !strings.HasPrefix(vers, \"HTTP/\") {\r\n>> >        return 0, 0, false\r\n>> >    }\r\n>> > -    dot := strings.Index(vers, \".\")\r\n>> > +    dot := strings.IndexByte(vers, '.')\r\n>> >    if dot < 0 {\r\n>> >        return 0, 0, false\r\n>> >    }\r\n>> > @@ -473,8 +473,8 @@\r\n>> >\r\n>> > // parseRequestLine parses \"GET /foo HTTP/1.1\" into its three parts.\r\n>> > func parseRequestLine(line string) (method, requestURI, proto string,\r\n>> ok bool) {\r\n>> > -    s1 := strings.Index(line, \" \")\r\n>> > -    s2 := strings.Index(line[s1+1:], \" \")\r\n>> > +    s1 := strings.IndexByte(line, ' ')\r\n>> > +    s2 := strings.IndexByte(line[s1+1:], ' ')\r\n>> >    if s1 < 0 || s2 < 0 {\r\n>> >        return\r\n>> >    }\r\n>> > Index: src/pkg/net/http/server.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/http/server.go\r\n>> > +++ b/src/pkg/net/http/server.go\r\n>> > @@ -1262,7 +1262,7 @@\r\n>> >            }\r\n>> >\r\n>> >            var query string\r\n>> > -            if i := strings.Index(urlStr, \"?\"); i != -1 {\r\n>> > +            if i := strings.IndexByte(urlStr, '?'); i != -1 {\r\n>> >                urlStr, query = urlStr[:i], urlStr[i:]\r\n>> >            }\r\n>> >\r\n>> > @@ -1494,7 +1494,7 @@\r\n>> >        if pattern[0] != '/' {\r\n>> >            // In pattern, at least the last character is a '/', so\r\n>> >            // strings.Index can't be -1.\r\n>> > -            path = pattern[strings.Index(pattern, \"/\"):]\r\n>> > +            path = pattern[strings.IndexByte(pattern, '/'):]\r\n>> >        }\r\n>> >        mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(path,\r\n>> StatusMovedPermanently), pattern: pattern}\r\n>> >    }\r\n>> > Index: src/pkg/net/url/url.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/net/url/url.go\r\n>> > +++ b/src/pkg/net/url/url.go\r\n>> > @@ -421,7 +421,7 @@\r\n>> >        return\r\n>> >    }\r\n>> >    userinfo, host := authority[:i], authority[i+1:]\r\n>> > -    if strings.Index(userinfo, \":\") < 0 {\r\n>> > +    if strings.IndexByte(userinfo, ':') < 0 {\r\n>> >        if userinfo, err = unescape(userinfo, encodeUserPassword); err\r\n>> != nil {\r\n>> >            return\r\n>> >        }\r\n>> > @@ -536,7 +536,7 @@\r\n>> >            continue\r\n>> >        }\r\n>> >        value := \"\"\r\n>> > -        if i := strings.Index(key, \"=\"); i >= 0 {\r\n>> > +        if i := strings.IndexByte(key, '='); i >= 0 {\r\n>> >            key, value = key[:i], key[i+1:]\r\n>> >        }\r\n>> >        key, err1 := QueryUnescape(key)\r\n>> > Index: src/pkg/os/os_test.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/os/os_test.go\r\n>> > +++ b/src/pkg/os/os_test.go\r\n>> > @@ -890,7 +890,7 @@\r\n>> >    }\r\n>> >    want := run(t, []string{\"/bin/hostname\"})\r\n>> >    if hostname != want {\r\n>> > -        i := strings.Index(hostname, \".\")\r\n>> > +        i := strings.IndexByte(hostname, '.')\r\n>> >        if i < 0 || hostname[0:i] != want {\r\n>> >            t.Errorf(\"Hostname() = %q, want %q\", hostname, want)\r\n>> >        }\r\n>> > Index: src/pkg/os/user/lookup_unix.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/os/user/lookup_unix.go\r\n>> > +++ b/src/pkg/os/user/lookup_unix.go\r\n>> > @@ -105,7 +105,7 @@\r\n>> >    // say: \"It is expected to be a comma separated list of\r\n>> >    // personal data where the first item is the full name of the\r\n>> >    // user.\"\r\n>> > -    if i := strings.Index(u.Name, \",\"); i >= 0 {\r\n>> > +    if i := strings.IndexByte(u.Name, ','); i >= 0 {\r\n>> >        u.Name = u.Name[:i]\r\n>> >    }\r\n>> >    return u, nil\r\n>> > Index: src/pkg/path/match.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/path/match.go\r\n>> > +++ b/src/pkg/path/match.go\r\n>> > @@ -43,7 +43,7 @@\r\n>> >        star, chunk, pattern = scanChunk(pattern)\r\n>> >        if star && chunk == \"\" {\r\n>> >            // Trailing * matches rest of string unless it has a /.\r\n>> > -            return strings.Index(name, \"/\") < 0, nil\r\n>> > +            return strings.IndexByte(name, '/') < 0, nil\r\n>> >        }\r\n>> >        // Look for match at current position.\r\n>> >        t, ok, err := matchChunk(chunk, name)\r\n>> > Index: src/pkg/regexp/exec_test.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/regexp/exec_test.go\r\n>> > +++ b/src/pkg/regexp/exec_test.go\r\n>> > @@ -293,7 +293,7 @@\r\n>> >                out[n] = -1\r\n>> >                out[n+1] = -1\r\n>> >            } else {\r\n>> > -                k := strings.Index(pair, \"-\")\r\n>> > +                k := strings.IndexByte(pair, '-')\r\n>> >                if k < 0 {\r\n>> >                    t.Fatalf(\"%s:%d: invalid pair %s\", file, lineno,\r\n>> pair)\r\n>> >                }\r\n>> > @@ -456,7 +456,7 @@\r\n>> >                continue Reading\r\n>> >            }\r\n>> >        case ':':\r\n>> > -            i := strings.Index(flag[1:], \":\")\r\n>> > +            i := strings.IndexByte(flag[1:], ':')\r\n>> >            if i < 0 {\r\n>> >                t.Logf(\"skip: %s\", line)\r\n>> >                continue Reading\r\n>> > Index: src/pkg/regexp/regexp.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/regexp/regexp.go\r\n>> > +++ b/src/pkg/regexp/regexp.go\r\n>> > @@ -429,7 +429,7 @@\r\n>> > // in Expand, so for instance $1 represents the text of the first\r\n>> submatch.\r\n>> > func (re *Regexp) ReplaceAllString(src, repl string) string {\r\n>> >    n := 2\r\n>> > -    if strings.Index(repl, \"$\") >= 0 {\r\n>> > +    if strings.IndexByte(repl, '$') >= 0 {\r\n>> >        n = 2 * (re.numSubexp + 1)\r\n>> >    }\r\n>> >    b := re.replaceAll(nil, src, n, func(dst []byte, match []int) []byte\r\n>> {\r\n>> > @@ -753,7 +753,7 @@\r\n>> >\r\n>> > func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src\r\n>> string, match []int) []byte {\r\n>> >    for len(template) > 0 {\r\n>> > -        i := strings.Index(template, \"$\")\r\n>> > +        i := strings.IndexByte(template, '$')\r\n>> >        if i < 0 {\r\n>> >            break\r\n>> >        }\r\n>> > Index: src/pkg/unicode/maketables.go\r\n>> > ===================================================================\r\n>> > --- a/src/pkg/unicode/maketables.go\r\n>> > +++ b/src/pkg/unicode/maketables.go\r\n>> > @@ -616,7 +616,7 @@\r\n>> > }\r\n>> >\r\n>> > func parseScript(line string, scripts map[string][]Script) {\r\n>> > -    comment := strings.Index(line, \"#\")\r\n>> > +    comment := strings.IndexByte(line, '#')\r\n>> >    if comment >= 0 {\r\n>> >        line = line[0:comment]\r\n>> >    }\r\n>> >\r\n>> >\r\n>> > --\r\n>> >\r\n>> > ---You received this message because you are subscribed to the Google\r\n>> Groups \"golang-dev\" group.\r\n>> > To unsubscribe from this group and stop receiving emails from it, send\r\n>> an email to golang-dev+unsubscribe@googlegroups.com.\r\n>> > For more options, visit https://groups.google.com/groups/opt_out.\r\n>> >\r\n>> >\r\n>>\r\n>\r\n>  --\r\n>\r\n> ---\r\n> You received this message because you are subscribed to the Google Groups\r\n> \"golang-dev\" group.\r\n> To unsubscribe from this group and stop receiving emails from it, send an\r\n> email to golang-dev+unsubscribe@googlegroups.com.\r\n> For more options, visit https://groups.google.com/groups/opt_out.\r\n>\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-08-05 22:57:41.061330",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Is there a vet rule for this, or did you just hit it with the grep hammer ?\r\n\r\nOn 06/08/2013, at 8:37, bradfitz@golang.org wrote:\r\n\r\n> Reviewers: golang-dev1,\r\n> \r\n> Message:\r\n> Hello golang-dev@googlegroups.com,\r\n> \r\n> I'd like you to review this change to\r\n> https://go.googlecode.com/hg/\r\n> \r\n> \r\n> Description:\r\n> all: use strings.IndexByte instead of Index where possible\r\n> \r\n> Please review this at https://codereview.appspot.com/12486043/\r\n> \r\n> Affected files:\r\n>  M src/pkg/crypto/x509/pem_decrypt.go\r\n>  M src/pkg/debug/gosym/symtab.go\r\n>  M src/pkg/encoding/json/tags.go\r\n>  M src/pkg/encoding/xml/typeinfo.go\r\n>  M src/pkg/encoding/xml/xml.go\r\n>  M src/pkg/go/build/build.go\r\n>  M src/pkg/go/printer/printer.go\r\n>  M src/pkg/math/big/rat.go\r\n>  M src/pkg/mime/mediatype.go\r\n>  M src/pkg/net/http/cgi/child.go\r\n>  M src/pkg/net/http/cookie.go\r\n>  M src/pkg/net/http/fs.go\r\n>  M src/pkg/net/http/request.go\r\n>  M src/pkg/net/http/server.go\r\n>  M src/pkg/net/url/url.go\r\n>  M src/pkg/os/os_test.go\r\n>  M src/pkg/os/user/lookup_unix.go\r\n>  M src/pkg/path/match.go\r\n>  M src/pkg/regexp/exec_test.go\r\n>  M src/pkg/regexp/regexp.go\r\n>  M src/pkg/unicode/maketables.go\r\n> \r\n> \r\n> Index: src/pkg/crypto/x509/pem_decrypt.go\r\n> ===================================================================\r\n> --- a/src/pkg/crypto/x509/pem_decrypt.go\r\n> +++ b/src/pkg/crypto/x509/pem_decrypt.go\r\n> @@ -115,7 +115,7 @@\r\n>        return nil, errors.New(\"x509: no DEK-Info header in block\")\r\n>    }\r\n> \r\n> -    idx := strings.Index(dek, \",\")\r\n> +    idx := strings.IndexByte(dek, ',')\r\n>    if idx == -1 {\r\n>        return nil, errors.New(\"x509: malformed DEK-Info header\")\r\n>    }\r\n> Index: src/pkg/debug/gosym/symtab.go\r\n> ===================================================================\r\n> --- a/src/pkg/debug/gosym/symtab.go\r\n> +++ b/src/pkg/debug/gosym/symtab.go\r\n> @@ -40,7 +40,7 @@\r\n> // PackageName returns the package part of the symbol name,\r\n> // or the empty string if there is none.\r\n> func (s *Sym) PackageName() string {\r\n> -    if i := strings.Index(s.Name, \".\"); i != -1 {\r\n> +    if i := strings.IndexByte(s.Name, '.'); i != -1 {\r\n>        return s.Name[0:i]\r\n>    }\r\n>    return \"\"\r\n> @@ -49,7 +49,7 @@\r\n> // ReceiverName returns the receiver type name of this symbol,\r\n> // or the empty string if there is none.\r\n> func (s *Sym) ReceiverName() string {\r\n> -    l := strings.Index(s.Name, \".\")\r\n> +    l := strings.IndexByte(s.Name, '.')\r\n>    r := strings.LastIndex(s.Name, \".\")\r\n>    if l == -1 || r == -1 || l == r {\r\n>        return \"\"\r\n> Index: src/pkg/encoding/json/tags.go\r\n> ===================================================================\r\n> --- a/src/pkg/encoding/json/tags.go\r\n> +++ b/src/pkg/encoding/json/tags.go\r\n> @@ -15,7 +15,7 @@\r\n> // parseTag splits a struct field's json tag into its name and\r\n> // comma-separated options.\r\n> func parseTag(tag string) (string, tagOptions) {\r\n> -    if idx := strings.Index(tag, \",\"); idx != -1 {\r\n> +    if idx := strings.IndexByte(tag, ','); idx != -1 {\r\n>        return tag[:idx], tagOptions(tag[idx+1:])\r\n>    }\r\n>    return tag, tagOptions(\"\")\r\n> @@ -31,7 +31,7 @@\r\n>    s := string(o)\r\n>    for s != \"\" {\r\n>        var next string\r\n> -        i := strings.Index(s, \",\")\r\n> +        i := strings.IndexByte(s, ',')\r\n>        if i >= 0 {\r\n>            s, next = s[:i], s[i+1:]\r\n>        }\r\n> Index: src/pkg/encoding/xml/typeinfo.go\r\n> ===================================================================\r\n> --- a/src/pkg/encoding/xml/typeinfo.go\r\n> +++ b/src/pkg/encoding/xml/typeinfo.go\r\n> @@ -113,7 +113,7 @@\r\n> \r\n>    // Split the tag from the xml namespace if necessary.\r\n>    tag := f.Tag.Get(\"xml\")\r\n> -    if i := strings.Index(tag, \" \"); i >= 0 {\r\n> +    if i := strings.IndexByte(tag, ' '); i >= 0 {\r\n>        finfo.xmlns, tag = tag[:i], tag[i+1:]\r\n>    }\r\n> \r\n> Index: src/pkg/encoding/xml/xml.go\r\n> ===================================================================\r\n> --- a/src/pkg/encoding/xml/xml.go\r\n> +++ b/src/pkg/encoding/xml/xml.go\r\n> @@ -1026,7 +1026,7 @@\r\n>    if !ok {\r\n>        return\r\n>    }\r\n> -    i := strings.Index(s, \":\")\r\n> +    i := strings.IndexByte(s, ':')\r\n>    if i < 0 {\r\n>        name.Local = s\r\n>    } else {\r\n> Index: src/pkg/go/build/build.go\r\n> ===================================================================\r\n> --- a/src/pkg/go/build/build.go\r\n> +++ b/src/pkg/go/build/build.go\r\n> @@ -877,7 +877,7 @@\r\n> \r\n>        // Split at colon.\r\n>        line = strings.TrimSpace(line[4:])\r\n> -        i := strings.Index(line, \":\")\r\n> +        i := strings.IndexByte(line, ':')\r\n>        if i < 0 {\r\n>            return fmt.Errorf(\"%s: invalid #cgo line: %s\", filename, orig)\r\n>        }\r\n> @@ -1022,7 +1022,7 @@\r\n>    if name == \"\" {\r\n>        return false\r\n>    }\r\n> -    if i := strings.Index(name, \",\"); i >= 0 {\r\n> +    if i := strings.IndexByte(name, ','); i >= 0 {\r\n>        // comma-separated list\r\n>        return ctxt.match(name[:i]) && ctxt.match(name[i+1:])\r\n>    }\r\n> @@ -1076,7 +1076,7 @@\r\n> //     name_$(GOOS)_$(GOARCH)_test.*\r\n> //\r\n> func (ctxt *Context) goodOSArchFile(name string) bool {\r\n> -    if dot := strings.Index(name, \".\"); dot != -1 {\r\n> +    if dot := strings.IndexByte(name, '.'); dot != -1 {\r\n>        name = name[:dot]\r\n>    }\r\n>    l := strings.Split(name, \"_\")\r\n> Index: src/pkg/go/printer/printer.go\r\n> ===================================================================\r\n> --- a/src/pkg/go/printer/printer.go\r\n> +++ b/src/pkg/go/printer/printer.go\r\n> @@ -474,7 +474,7 @@\r\n>     * Check for vertical \"line of stars\" and correct prefix accordingly.\r\n>     */\r\n>    lineOfStars := false\r\n> -    if i := strings.Index(prefix, \"*\"); i >= 0 {\r\n> +    if i := strings.IndexByte(prefix, '*'); i >= 0 {\r\n>        // Line of stars present.\r\n>        if i > 0 && prefix[i-1] == ' ' {\r\n>            i-- // remove trailing blank from prefix so stars remain aligned\r\n> Index: src/pkg/math/big/rat.go\r\n> ===================================================================\r\n> --- a/src/pkg/math/big/rat.go\r\n> +++ b/src/pkg/math/big/rat.go\r\n> @@ -429,7 +429,7 @@\r\n>    }\r\n> \r\n>    // check for a quotient\r\n> -    sep := strings.Index(s, \"/\")\r\n> +    sep := strings.IndexByte(s, '/')\r\n>    if sep >= 0 {\r\n>        if _, ok := z.a.SetString(s[0:sep], 10); !ok {\r\n>            return nil, false\r\n> @@ -443,7 +443,7 @@\r\n>    }\r\n> \r\n>    // check for a decimal point\r\n> -    sep = strings.Index(s, \".\")\r\n> +    sep = strings.IndexByte(s, '.')\r\n>    // check for an exponent\r\n>    e := strings.IndexAny(s, \"eE\")\r\n>    var exp Int\r\n> Index: src/pkg/mime/mediatype.go\r\n> ===================================================================\r\n> --- a/src/pkg/mime/mediatype.go\r\n> +++ b/src/pkg/mime/mediatype.go\r\n> @@ -18,7 +18,7 @@\r\n> // When any of the arguments result in a standard violation then\r\n> // FormatMediaType returns the empty string.\r\n> func FormatMediaType(t string, param map[string]string) string {\r\n> -    slash := strings.Index(t, \"/\")\r\n> +    slash := strings.IndexByte(t, '/')\r\n>    if slash == -1 {\r\n>        return \"\"\r\n>    }\r\n> @@ -91,7 +91,7 @@\r\n> // The returned map, params, maps from the lowercase\r\n> // attribute to the attribute value with its case preserved.\r\n> func ParseMediaType(v string) (mediatype string, params map[string]string, err error) {\r\n> -    i := strings.Index(v, \";\")\r\n> +    i := strings.IndexByte(v, ';')\r\n>    if i == -1 {\r\n>        i = len(v)\r\n>    }\r\n> @@ -127,7 +127,7 @@\r\n>        }\r\n> \r\n>        pmap := params\r\n> -        if idx := strings.Index(key, \"*\"); idx != -1 {\r\n> +        if idx := strings.IndexByte(key, '*'); idx != -1 {\r\n>            baseName := key[:idx]\r\n>            if continuation == nil {\r\n>                continuation = make(map[string]map[string]string)\r\n> Index: src/pkg/net/http/cgi/child.go\r\n> ===================================================================\r\n> --- a/src/pkg/net/http/cgi/child.go\r\n> +++ b/src/pkg/net/http/cgi/child.go\r\n> @@ -40,7 +40,7 @@\r\n> func envMap(env []string) map[string]string {\r\n>    m := make(map[string]string)\r\n>    for _, kv := range env {\r\n> -        if idx := strings.Index(kv, \"=\"); idx != -1 {\r\n> +        if idx := strings.IndexByte(kv, '='); idx != -1 {\r\n>            m[kv[:idx]] = kv[idx+1:]\r\n>        }\r\n>    }\r\n> Index: src/pkg/net/http/cookie.go\r\n> ===================================================================\r\n> --- a/src/pkg/net/http/cookie.go\r\n> +++ b/src/pkg/net/http/cookie.go\r\n> @@ -47,7 +47,7 @@\r\n>            continue\r\n>        }\r\n>        parts[0] = strings.TrimSpace(parts[0])\r\n> -        j := strings.Index(parts[0], \"=\")\r\n> +        j := strings.IndexByte(parts[0], '=')\r\n>        if j < 0 {\r\n>            continue\r\n>        }\r\n> @@ -71,7 +71,7 @@\r\n>            }\r\n> \r\n>            attr, val := parts[i], \"\"\r\n> -            if j := strings.Index(attr, \"=\"); j >= 0 {\r\n> +            if j := strings.IndexByte(attr, '='); j >= 0 {\r\n>                attr, val = attr[:j], attr[j+1:]\r\n>            }\r\n>            lowerAttr := strings.ToLower(attr)\r\n> @@ -188,7 +188,7 @@\r\n>                continue\r\n>            }\r\n>            name, val := parts[i], \"\"\r\n> -            if j := strings.Index(name, \"=\"); j >= 0 {\r\n> +            if j := strings.IndexByte(name, '='); j >= 0 {\r\n>                name, val = name[:j], name[j+1:]\r\n>            }\r\n>            if !isCookieNameValid(name) {\r\n> Index: src/pkg/net/http/fs.go\r\n> ===================================================================\r\n> --- a/src/pkg/net/http/fs.go\r\n> +++ b/src/pkg/net/http/fs.go\r\n> @@ -467,7 +467,7 @@\r\n>        if ra == \"\" {\r\n>            continue\r\n>        }\r\n> -        i := strings.Index(ra, \"-\")\r\n> +        i := strings.IndexByte(ra, '-')\r\n>        if i < 0 {\r\n>            return nil, errors.New(\"invalid range\")\r\n>        }\r\n> Index: src/pkg/net/http/request.go\r\n> ===================================================================\r\n> --- a/src/pkg/net/http/request.go\r\n> +++ b/src/pkg/net/http/request.go\r\n> @@ -408,7 +408,7 @@\r\n>    if !strings.HasPrefix(vers, \"HTTP/\") {\r\n>        return 0, 0, false\r\n>    }\r\n> -    dot := strings.Index(vers, \".\")\r\n> +    dot := strings.IndexByte(vers, '.')\r\n>    if dot < 0 {\r\n>        return 0, 0, false\r\n>    }\r\n> @@ -473,8 +473,8 @@\r\n> \r\n> // parseRequestLine parses \"GET /foo HTTP/1.1\" into its three parts.\r\n> func parseRequestLine(line string) (method, requestURI, proto string, ok bool) {\r\n> -    s1 := strings.Index(line, \" \")\r\n> -    s2 := strings.Index(line[s1+1:], \" \")\r\n> +    s1 := strings.IndexByte(line, ' ')\r\n> +    s2 := strings.IndexByte(line[s1+1:], ' ')\r\n>    if s1 < 0 || s2 < 0 {\r\n>        return\r\n>    }\r\n> Index: src/pkg/net/http/server.go\r\n> ===================================================================\r\n> --- a/src/pkg/net/http/server.go\r\n> +++ b/src/pkg/net/http/server.go\r\n> @@ -1262,7 +1262,7 @@\r\n>            }\r\n> \r\n>            var query string\r\n> -            if i := strings.Index(urlStr, \"?\"); i != -1 {\r\n> +            if i := strings.IndexByte(urlStr, '?'); i != -1 {\r\n>                urlStr, query = urlStr[:i], urlStr[i:]\r\n>            }\r\n> \r\n> @@ -1494,7 +1494,7 @@\r\n>        if pattern[0] != '/' {\r\n>            // In pattern, at least the last character is a '/', so\r\n>            // strings.Index can't be -1.\r\n> -            path = pattern[strings.Index(pattern, \"/\"):]\r\n> +            path = pattern[strings.IndexByte(pattern, '/'):]\r\n>        }\r\n>        mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(path, StatusMovedPermanently), pattern: pattern}\r\n>    }\r\n> Index: src/pkg/net/url/url.go\r\n> ===================================================================\r\n> --- a/src/pkg/net/url/url.go\r\n> +++ b/src/pkg/net/url/url.go\r\n> @@ -421,7 +421,7 @@\r\n>        return\r\n>    }\r\n>    userinfo, host := authority[:i], authority[i+1:]\r\n> -    if strings.Index(userinfo, \":\") < 0 {\r\n> +    if strings.IndexByte(userinfo, ':') < 0 {\r\n>        if userinfo, err = unescape(userinfo, encodeUserPassword); err != nil {\r\n>            return\r\n>        }\r\n> @@ -536,7 +536,7 @@\r\n>            continue\r\n>        }\r\n>        value := \"\"\r\n> -        if i := strings.Index(key, \"=\"); i >= 0 {\r\n> +        if i := strings.IndexByte(key, '='); i >= 0 {\r\n>            key, value = key[:i], key[i+1:]\r\n>        }\r\n>        key, err1 := QueryUnescape(key)\r\n> Index: src/pkg/os/os_test.go\r\n> ===================================================================\r\n> --- a/src/pkg/os/os_test.go\r\n> +++ b/src/pkg/os/os_test.go\r\n> @@ -890,7 +890,7 @@\r\n>    }\r\n>    want := run(t, []string{\"/bin/hostname\"})\r\n>    if hostname != want {\r\n> -        i := strings.Index(hostname, \".\")\r\n> +        i := strings.IndexByte(hostname, '.')\r\n>        if i < 0 || hostname[0:i] != want {\r\n>            t.Errorf(\"Hostname() = %q, want %q\", hostname, want)\r\n>        }\r\n> Index: src/pkg/os/user/lookup_unix.go\r\n> ===================================================================\r\n> --- a/src/pkg/os/user/lookup_unix.go\r\n> +++ b/src/pkg/os/user/lookup_unix.go\r\n> @@ -105,7 +105,7 @@\r\n>    // say: \"It is expected to be a comma separated list of\r\n>    // personal data where the first item is the full name of the\r\n>    // user.\"\r\n> -    if i := strings.Index(u.Name, \",\"); i >= 0 {\r\n> +    if i := strings.IndexByte(u.Name, ','); i >= 0 {\r\n>        u.Name = u.Name[:i]\r\n>    }\r\n>    return u, nil\r\n> Index: src/pkg/path/match.go\r\n> ===================================================================\r\n> --- a/src/pkg/path/match.go\r\n> +++ b/src/pkg/path/match.go\r\n> @@ -43,7 +43,7 @@\r\n>        star, chunk, pattern = scanChunk(pattern)\r\n>        if star && chunk == \"\" {\r\n>            // Trailing * matches rest of string unless it has a /.\r\n> -            return strings.Index(name, \"/\") < 0, nil\r\n> +            return strings.IndexByte(name, '/') < 0, nil\r\n>        }\r\n>        // Look for match at current position.\r\n>        t, ok, err := matchChunk(chunk, name)\r\n> Index: src/pkg/regexp/exec_test.go\r\n> ===================================================================\r\n> --- a/src/pkg/regexp/exec_test.go\r\n> +++ b/src/pkg/regexp/exec_test.go\r\n> @@ -293,7 +293,7 @@\r\n>                out[n] = -1\r\n>                out[n+1] = -1\r\n>            } else {\r\n> -                k := strings.Index(pair, \"-\")\r\n> +                k := strings.IndexByte(pair, '-')\r\n>                if k < 0 {\r\n>                    t.Fatalf(\"%s:%d: invalid pair %s\", file, lineno, pair)\r\n>                }\r\n> @@ -456,7 +456,7 @@\r\n>                continue Reading\r\n>            }\r\n>        case ':':\r\n> -            i := strings.Index(flag[1:], \":\")\r\n> +            i := strings.IndexByte(flag[1:], ':')\r\n>            if i < 0 {\r\n>                t.Logf(\"skip: %s\", line)\r\n>                continue Reading\r\n> Index: src/pkg/regexp/regexp.go\r\n> ===================================================================\r\n> --- a/src/pkg/regexp/regexp.go\r\n> +++ b/src/pkg/regexp/regexp.go\r\n> @@ -429,7 +429,7 @@\r\n> // in Expand, so for instance $1 represents the text of the first submatch.\r\n> func (re *Regexp) ReplaceAllString(src, repl string) string {\r\n>    n := 2\r\n> -    if strings.Index(repl, \"$\") >= 0 {\r\n> +    if strings.IndexByte(repl, '$') >= 0 {\r\n>        n = 2 * (re.numSubexp + 1)\r\n>    }\r\n>    b := re.replaceAll(nil, src, n, func(dst []byte, match []int) []byte {\r\n> @@ -753,7 +753,7 @@\r\n> \r\n> func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte {\r\n>    for len(template) > 0 {\r\n> -        i := strings.Index(template, \"$\")\r\n> +        i := strings.IndexByte(template, '$')\r\n>        if i < 0 {\r\n>            break\r\n>        }\r\n> Index: src/pkg/unicode/maketables.go\r\n> ===================================================================\r\n> --- a/src/pkg/unicode/maketables.go\r\n> +++ b/src/pkg/unicode/maketables.go\r\n> @@ -616,7 +616,7 @@\r\n> }\r\n> \r\n> func parseScript(line string, scripts map[string][]Script) {\r\n> -    comment := strings.Index(line, \"#\")\r\n> +    comment := strings.IndexByte(line, '#')\r\n>    if comment >= 0 {\r\n>        line = line[0:comment]\r\n>    }\r\n> \r\n> \r\n> -- \r\n> \r\n> ---You received this message because you are subscribed to the Google Groups \"golang-dev\" group.\r\n> To unsubscribe from this group and stop receiving emails from it, send an email to golang-dev+unsubscribe@googlegroups.com.\r\n> For more options, visit https://groups.google.com/groups/opt_out.\r\n> \r\n> \r\n",
			"disapproval": false,
			"date": "2013-08-05 22:48:21.005260",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "grep -r -E -l 'strings.Index.*\".\"' pkg | grep go$ | xargs perl -pi -e\r\n\"s:strings.Index\\((.+), \\\"(.)\\\":strings.IndexByte(\\$1, '\\$2':\"\r\n\r\n\r\nOn Mon, Aug 5, 2013 at 3:48 PM, Dave Cheney <dave@cheney.net> wrote:\r\n\r\n> Is there a vet rule for this, or did you just hit it with the grep hammer ?\r\n>\r\n> On 06/08/2013, at 8:37, bradfitz@golang.org wrote:\r\n>\r\n> > Reviewers: golang-dev1,\r\n> >\r\n> > Message:\r\n> > Hello golang-dev@googlegroups.com,\r\n> >\r\n> > I'd like you to review this change to\r\n> > https://go.googlecode.com/hg/\r\n> >\r\n> >\r\n> > Description:\r\n> > all: use strings.IndexByte instead of Index where possible\r\n> >\r\n> > Please review this at https://codereview.appspot.com/12486043/\r\n> >\r\n> > Affected files:\r\n> >  M src/pkg/crypto/x509/pem_decrypt.go\r\n> >  M src/pkg/debug/gosym/symtab.go\r\n> >  M src/pkg/encoding/json/tags.go\r\n> >  M src/pkg/encoding/xml/typeinfo.go\r\n> >  M src/pkg/encoding/xml/xml.go\r\n> >  M src/pkg/go/build/build.go\r\n> >  M src/pkg/go/printer/printer.go\r\n> >  M src/pkg/math/big/rat.go\r\n> >  M src/pkg/mime/mediatype.go\r\n> >  M src/pkg/net/http/cgi/child.go\r\n> >  M src/pkg/net/http/cookie.go\r\n> >  M src/pkg/net/http/fs.go\r\n> >  M src/pkg/net/http/request.go\r\n> >  M src/pkg/net/http/server.go\r\n> >  M src/pkg/net/url/url.go\r\n> >  M src/pkg/os/os_test.go\r\n> >  M src/pkg/os/user/lookup_unix.go\r\n> >  M src/pkg/path/match.go\r\n> >  M src/pkg/regexp/exec_test.go\r\n> >  M src/pkg/regexp/regexp.go\r\n> >  M src/pkg/unicode/maketables.go\r\n> >\r\n> >\r\n> > Index: src/pkg/crypto/x509/pem_decrypt.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/crypto/x509/pem_decrypt.go\r\n> > +++ b/src/pkg/crypto/x509/pem_decrypt.go\r\n> > @@ -115,7 +115,7 @@\r\n> >        return nil, errors.New(\"x509: no DEK-Info header in block\")\r\n> >    }\r\n> >\r\n> > -    idx := strings.Index(dek, \",\")\r\n> > +    idx := strings.IndexByte(dek, ',')\r\n> >    if idx == -1 {\r\n> >        return nil, errors.New(\"x509: malformed DEK-Info header\")\r\n> >    }\r\n> > Index: src/pkg/debug/gosym/symtab.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/debug/gosym/symtab.go\r\n> > +++ b/src/pkg/debug/gosym/symtab.go\r\n> > @@ -40,7 +40,7 @@\r\n> > // PackageName returns the package part of the symbol name,\r\n> > // or the empty string if there is none.\r\n> > func (s *Sym) PackageName() string {\r\n> > -    if i := strings.Index(s.Name, \".\"); i != -1 {\r\n> > +    if i := strings.IndexByte(s.Name, '.'); i != -1 {\r\n> >        return s.Name[0:i]\r\n> >    }\r\n> >    return \"\"\r\n> > @@ -49,7 +49,7 @@\r\n> > // ReceiverName returns the receiver type name of this symbol,\r\n> > // or the empty string if there is none.\r\n> > func (s *Sym) ReceiverName() string {\r\n> > -    l := strings.Index(s.Name, \".\")\r\n> > +    l := strings.IndexByte(s.Name, '.')\r\n> >    r := strings.LastIndex(s.Name, \".\")\r\n> >    if l == -1 || r == -1 || l == r {\r\n> >        return \"\"\r\n> > Index: src/pkg/encoding/json/tags.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/encoding/json/tags.go\r\n> > +++ b/src/pkg/encoding/json/tags.go\r\n> > @@ -15,7 +15,7 @@\r\n> > // parseTag splits a struct field's json tag into its name and\r\n> > // comma-separated options.\r\n> > func parseTag(tag string) (string, tagOptions) {\r\n> > -    if idx := strings.Index(tag, \",\"); idx != -1 {\r\n> > +    if idx := strings.IndexByte(tag, ','); idx != -1 {\r\n> >        return tag[:idx], tagOptions(tag[idx+1:])\r\n> >    }\r\n> >    return tag, tagOptions(\"\")\r\n> > @@ -31,7 +31,7 @@\r\n> >    s := string(o)\r\n> >    for s != \"\" {\r\n> >        var next string\r\n> > -        i := strings.Index(s, \",\")\r\n> > +        i := strings.IndexByte(s, ',')\r\n> >        if i >= 0 {\r\n> >            s, next = s[:i], s[i+1:]\r\n> >        }\r\n> > Index: src/pkg/encoding/xml/typeinfo.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/encoding/xml/typeinfo.go\r\n> > +++ b/src/pkg/encoding/xml/typeinfo.go\r\n> > @@ -113,7 +113,7 @@\r\n> >\r\n> >    // Split the tag from the xml namespace if necessary.\r\n> >    tag := f.Tag.Get(\"xml\")\r\n> > -    if i := strings.Index(tag, \" \"); i >= 0 {\r\n> > +    if i := strings.IndexByte(tag, ' '); i >= 0 {\r\n> >        finfo.xmlns, tag = tag[:i], tag[i+1:]\r\n> >    }\r\n> >\r\n> > Index: src/pkg/encoding/xml/xml.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/encoding/xml/xml.go\r\n> > +++ b/src/pkg/encoding/xml/xml.go\r\n> > @@ -1026,7 +1026,7 @@\r\n> >    if !ok {\r\n> >        return\r\n> >    }\r\n> > -    i := strings.Index(s, \":\")\r\n> > +    i := strings.IndexByte(s, ':')\r\n> >    if i < 0 {\r\n> >        name.Local = s\r\n> >    } else {\r\n> > Index: src/pkg/go/build/build.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/go/build/build.go\r\n> > +++ b/src/pkg/go/build/build.go\r\n> > @@ -877,7 +877,7 @@\r\n> >\r\n> >        // Split at colon.\r\n> >        line = strings.TrimSpace(line[4:])\r\n> > -        i := strings.Index(line, \":\")\r\n> > +        i := strings.IndexByte(line, ':')\r\n> >        if i < 0 {\r\n> >            return fmt.Errorf(\"%s: invalid #cgo line: %s\", filename, orig)\r\n> >        }\r\n> > @@ -1022,7 +1022,7 @@\r\n> >    if name == \"\" {\r\n> >        return false\r\n> >    }\r\n> > -    if i := strings.Index(name, \",\"); i >= 0 {\r\n> > +    if i := strings.IndexByte(name, ','); i >= 0 {\r\n> >        // comma-separated list\r\n> >        return ctxt.match(name[:i]) && ctxt.match(name[i+1:])\r\n> >    }\r\n> > @@ -1076,7 +1076,7 @@\r\n> > //     name_$(GOOS)_$(GOARCH)_test.*\r\n> > //\r\n> > func (ctxt *Context) goodOSArchFile(name string) bool {\r\n> > -    if dot := strings.Index(name, \".\"); dot != -1 {\r\n> > +    if dot := strings.IndexByte(name, '.'); dot != -1 {\r\n> >        name = name[:dot]\r\n> >    }\r\n> >    l := strings.Split(name, \"_\")\r\n> > Index: src/pkg/go/printer/printer.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/go/printer/printer.go\r\n> > +++ b/src/pkg/go/printer/printer.go\r\n> > @@ -474,7 +474,7 @@\r\n> >     * Check for vertical \"line of stars\" and correct prefix accordingly.\r\n> >     */\r\n> >    lineOfStars := false\r\n> > -    if i := strings.Index(prefix, \"*\"); i >= 0 {\r\n> > +    if i := strings.IndexByte(prefix, '*'); i >= 0 {\r\n> >        // Line of stars present.\r\n> >        if i > 0 && prefix[i-1] == ' ' {\r\n> >            i-- // remove trailing blank from prefix so stars remain\r\n> aligned\r\n> > Index: src/pkg/math/big/rat.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/math/big/rat.go\r\n> > +++ b/src/pkg/math/big/rat.go\r\n> > @@ -429,7 +429,7 @@\r\n> >    }\r\n> >\r\n> >    // check for a quotient\r\n> > -    sep := strings.Index(s, \"/\")\r\n> > +    sep := strings.IndexByte(s, '/')\r\n> >    if sep >= 0 {\r\n> >        if _, ok := z.a.SetString(s[0:sep], 10); !ok {\r\n> >            return nil, false\r\n> > @@ -443,7 +443,7 @@\r\n> >    }\r\n> >\r\n> >    // check for a decimal point\r\n> > -    sep = strings.Index(s, \".\")\r\n> > +    sep = strings.IndexByte(s, '.')\r\n> >    // check for an exponent\r\n> >    e := strings.IndexAny(s, \"eE\")\r\n> >    var exp Int\r\n> > Index: src/pkg/mime/mediatype.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/mime/mediatype.go\r\n> > +++ b/src/pkg/mime/mediatype.go\r\n> > @@ -18,7 +18,7 @@\r\n> > // When any of the arguments result in a standard violation then\r\n> > // FormatMediaType returns the empty string.\r\n> > func FormatMediaType(t string, param map[string]string) string {\r\n> > -    slash := strings.Index(t, \"/\")\r\n> > +    slash := strings.IndexByte(t, '/')\r\n> >    if slash == -1 {\r\n> >        return \"\"\r\n> >    }\r\n> > @@ -91,7 +91,7 @@\r\n> > // The returned map, params, maps from the lowercase\r\n> > // attribute to the attribute value with its case preserved.\r\n> > func ParseMediaType(v string) (mediatype string, params\r\n> map[string]string, err error) {\r\n> > -    i := strings.Index(v, \";\")\r\n> > +    i := strings.IndexByte(v, ';')\r\n> >    if i == -1 {\r\n> >        i = len(v)\r\n> >    }\r\n> > @@ -127,7 +127,7 @@\r\n> >        }\r\n> >\r\n> >        pmap := params\r\n> > -        if idx := strings.Index(key, \"*\"); idx != -1 {\r\n> > +        if idx := strings.IndexByte(key, '*'); idx != -1 {\r\n> >            baseName := key[:idx]\r\n> >            if continuation == nil {\r\n> >                continuation = make(map[string]map[string]string)\r\n> > Index: src/pkg/net/http/cgi/child.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/net/http/cgi/child.go\r\n> > +++ b/src/pkg/net/http/cgi/child.go\r\n> > @@ -40,7 +40,7 @@\r\n> > func envMap(env []string) map[string]string {\r\n> >    m := make(map[string]string)\r\n> >    for _, kv := range env {\r\n> > -        if idx := strings.Index(kv, \"=\"); idx != -1 {\r\n> > +        if idx := strings.IndexByte(kv, '='); idx != -1 {\r\n> >            m[kv[:idx]] = kv[idx+1:]\r\n> >        }\r\n> >    }\r\n> > Index: src/pkg/net/http/cookie.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/net/http/cookie.go\r\n> > +++ b/src/pkg/net/http/cookie.go\r\n> > @@ -47,7 +47,7 @@\r\n> >            continue\r\n> >        }\r\n> >        parts[0] = strings.TrimSpace(parts[0])\r\n> > -        j := strings.Index(parts[0], \"=\")\r\n> > +        j := strings.IndexByte(parts[0], '=')\r\n> >        if j < 0 {\r\n> >            continue\r\n> >        }\r\n> > @@ -71,7 +71,7 @@\r\n> >            }\r\n> >\r\n> >            attr, val := parts[i], \"\"\r\n> > -            if j := strings.Index(attr, \"=\"); j >= 0 {\r\n> > +            if j := strings.IndexByte(attr, '='); j >= 0 {\r\n> >                attr, val = attr[:j], attr[j+1:]\r\n> >            }\r\n> >            lowerAttr := strings.ToLower(attr)\r\n> > @@ -188,7 +188,7 @@\r\n> >                continue\r\n> >            }\r\n> >            name, val := parts[i], \"\"\r\n> > -            if j := strings.Index(name, \"=\"); j >= 0 {\r\n> > +            if j := strings.IndexByte(name, '='); j >= 0 {\r\n> >                name, val = name[:j], name[j+1:]\r\n> >            }\r\n> >            if !isCookieNameValid(name) {\r\n> > Index: src/pkg/net/http/fs.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/net/http/fs.go\r\n> > +++ b/src/pkg/net/http/fs.go\r\n> > @@ -467,7 +467,7 @@\r\n> >        if ra == \"\" {\r\n> >            continue\r\n> >        }\r\n> > -        i := strings.Index(ra, \"-\")\r\n> > +        i := strings.IndexByte(ra, '-')\r\n> >        if i < 0 {\r\n> >            return nil, errors.New(\"invalid range\")\r\n> >        }\r\n> > Index: src/pkg/net/http/request.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/net/http/request.go\r\n> > +++ b/src/pkg/net/http/request.go\r\n> > @@ -408,7 +408,7 @@\r\n> >    if !strings.HasPrefix(vers, \"HTTP/\") {\r\n> >        return 0, 0, false\r\n> >    }\r\n> > -    dot := strings.Index(vers, \".\")\r\n> > +    dot := strings.IndexByte(vers, '.')\r\n> >    if dot < 0 {\r\n> >        return 0, 0, false\r\n> >    }\r\n> > @@ -473,8 +473,8 @@\r\n> >\r\n> > // parseRequestLine parses \"GET /foo HTTP/1.1\" into its three parts.\r\n> > func parseRequestLine(line string) (method, requestURI, proto string, ok\r\n> bool) {\r\n> > -    s1 := strings.Index(line, \" \")\r\n> > -    s2 := strings.Index(line[s1+1:], \" \")\r\n> > +    s1 := strings.IndexByte(line, ' ')\r\n> > +    s2 := strings.IndexByte(line[s1+1:], ' ')\r\n> >    if s1 < 0 || s2 < 0 {\r\n> >        return\r\n> >    }\r\n> > Index: src/pkg/net/http/server.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/net/http/server.go\r\n> > +++ b/src/pkg/net/http/server.go\r\n> > @@ -1262,7 +1262,7 @@\r\n> >            }\r\n> >\r\n> >            var query string\r\n> > -            if i := strings.Index(urlStr, \"?\"); i != -1 {\r\n> > +            if i := strings.IndexByte(urlStr, '?'); i != -1 {\r\n> >                urlStr, query = urlStr[:i], urlStr[i:]\r\n> >            }\r\n> >\r\n> > @@ -1494,7 +1494,7 @@\r\n> >        if pattern[0] != '/' {\r\n> >            // In pattern, at least the last character is a '/', so\r\n> >            // strings.Index can't be -1.\r\n> > -            path = pattern[strings.Index(pattern, \"/\"):]\r\n> > +            path = pattern[strings.IndexByte(pattern, '/'):]\r\n> >        }\r\n> >        mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(path,\r\n> StatusMovedPermanently), pattern: pattern}\r\n> >    }\r\n> > Index: src/pkg/net/url/url.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/net/url/url.go\r\n> > +++ b/src/pkg/net/url/url.go\r\n> > @@ -421,7 +421,7 @@\r\n> >        return\r\n> >    }\r\n> >    userinfo, host := authority[:i], authority[i+1:]\r\n> > -    if strings.Index(userinfo, \":\") < 0 {\r\n> > +    if strings.IndexByte(userinfo, ':') < 0 {\r\n> >        if userinfo, err = unescape(userinfo, encodeUserPassword); err !=\r\n> nil {\r\n> >            return\r\n> >        }\r\n> > @@ -536,7 +536,7 @@\r\n> >            continue\r\n> >        }\r\n> >        value := \"\"\r\n> > -        if i := strings.Index(key, \"=\"); i >= 0 {\r\n> > +        if i := strings.IndexByte(key, '='); i >= 0 {\r\n> >            key, value = key[:i], key[i+1:]\r\n> >        }\r\n> >        key, err1 := QueryUnescape(key)\r\n> > Index: src/pkg/os/os_test.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/os/os_test.go\r\n> > +++ b/src/pkg/os/os_test.go\r\n> > @@ -890,7 +890,7 @@\r\n> >    }\r\n> >    want := run(t, []string{\"/bin/hostname\"})\r\n> >    if hostname != want {\r\n> > -        i := strings.Index(hostname, \".\")\r\n> > +        i := strings.IndexByte(hostname, '.')\r\n> >        if i < 0 || hostname[0:i] != want {\r\n> >            t.Errorf(\"Hostname() = %q, want %q\", hostname, want)\r\n> >        }\r\n> > Index: src/pkg/os/user/lookup_unix.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/os/user/lookup_unix.go\r\n> > +++ b/src/pkg/os/user/lookup_unix.go\r\n> > @@ -105,7 +105,7 @@\r\n> >    // say: \"It is expected to be a comma separated list of\r\n> >    // personal data where the first item is the full name of the\r\n> >    // user.\"\r\n> > -    if i := strings.Index(u.Name, \",\"); i >= 0 {\r\n> > +    if i := strings.IndexByte(u.Name, ','); i >= 0 {\r\n> >        u.Name = u.Name[:i]\r\n> >    }\r\n> >    return u, nil\r\n> > Index: src/pkg/path/match.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/path/match.go\r\n> > +++ b/src/pkg/path/match.go\r\n> > @@ -43,7 +43,7 @@\r\n> >        star, chunk, pattern = scanChunk(pattern)\r\n> >        if star && chunk == \"\" {\r\n> >            // Trailing * matches rest of string unless it has a /.\r\n> > -            return strings.Index(name, \"/\") < 0, nil\r\n> > +            return strings.IndexByte(name, '/') < 0, nil\r\n> >        }\r\n> >        // Look for match at current position.\r\n> >        t, ok, err := matchChunk(chunk, name)\r\n> > Index: src/pkg/regexp/exec_test.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/regexp/exec_test.go\r\n> > +++ b/src/pkg/regexp/exec_test.go\r\n> > @@ -293,7 +293,7 @@\r\n> >                out[n] = -1\r\n> >                out[n+1] = -1\r\n> >            } else {\r\n> > -                k := strings.Index(pair, \"-\")\r\n> > +                k := strings.IndexByte(pair, '-')\r\n> >                if k < 0 {\r\n> >                    t.Fatalf(\"%s:%d: invalid pair %s\", file, lineno, pair)\r\n> >                }\r\n> > @@ -456,7 +456,7 @@\r\n> >                continue Reading\r\n> >            }\r\n> >        case ':':\r\n> > -            i := strings.Index(flag[1:], \":\")\r\n> > +            i := strings.IndexByte(flag[1:], ':')\r\n> >            if i < 0 {\r\n> >                t.Logf(\"skip: %s\", line)\r\n> >                continue Reading\r\n> > Index: src/pkg/regexp/regexp.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/regexp/regexp.go\r\n> > +++ b/src/pkg/regexp/regexp.go\r\n> > @@ -429,7 +429,7 @@\r\n> > // in Expand, so for instance $1 represents the text of the first\r\n> submatch.\r\n> > func (re *Regexp) ReplaceAllString(src, repl string) string {\r\n> >    n := 2\r\n> > -    if strings.Index(repl, \"$\") >= 0 {\r\n> > +    if strings.IndexByte(repl, '$') >= 0 {\r\n> >        n = 2 * (re.numSubexp + 1)\r\n> >    }\r\n> >    b := re.replaceAll(nil, src, n, func(dst []byte, match []int) []byte {\r\n> > @@ -753,7 +753,7 @@\r\n> >\r\n> > func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src\r\n> string, match []int) []byte {\r\n> >    for len(template) > 0 {\r\n> > -        i := strings.Index(template, \"$\")\r\n> > +        i := strings.IndexByte(template, '$')\r\n> >        if i < 0 {\r\n> >            break\r\n> >        }\r\n> > Index: src/pkg/unicode/maketables.go\r\n> > ===================================================================\r\n> > --- a/src/pkg/unicode/maketables.go\r\n> > +++ b/src/pkg/unicode/maketables.go\r\n> > @@ -616,7 +616,7 @@\r\n> > }\r\n> >\r\n> > func parseScript(line string, scripts map[string][]Script) {\r\n> > -    comment := strings.Index(line, \"#\")\r\n> > +    comment := strings.IndexByte(line, '#')\r\n> >    if comment >= 0 {\r\n> >        line = line[0:comment]\r\n> >    }\r\n> >\r\n> >\r\n> > --\r\n> >\r\n> > ---You received this message because you are subscribed to the Google\r\n> Groups \"golang-dev\" group.\r\n> > To unsubscribe from this group and stop receiving emails from it, send\r\n> an email to golang-dev+unsubscribe@googlegroups.com.\r\n> > For more options, visit https://groups.google.com/groups/opt_out.\r\n> >\r\n> >\r\n>\r\n",
			"disapproval": false,
			"date": "2013-08-05 22:50:27.695380",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I still like strings.IndexByte for consistency, regardless of this CL.  If\r\nwe're going to have strings and bytes, the packages should feel the same.\r\n\r\nI agree this is longer, so could be considered uglier.  We can revert it.\r\n\r\nI disagree about \"not faster\".  I agree that it's not much faster, but this\r\ndoes avoid a function call.\r\n\r\nI was neutral on this CL, until I remembered when I first started adding\r\nAPIs to the standard library, I was told to update the tree to use new APIs\r\nwhen I added them.\r\n\r\n\r\n\r\n\r\nOn Mon, Aug 5, 2013 at 3:57 PM, Russ Cox <rsc@golang.org> wrote:\r\n\r\n> not lgtm\r\n>\r\n> This is exactly why strings.IndexByte didn't exist. This code is uglier\r\n> and not faster.\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-08-05 23:01:53.831090",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Aug 5, 2013 at 7:01 PM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n\r\n> I still like strings.IndexByte for consistency, regardless of this CL.  If\r\n> we're going to have strings and bytes, the packages should feel the same.\r\n>\r\n\r\nOK.\r\n\r\n\r\n> I agree this is longer, so could be considered uglier.  We can revert it.\r\n>\r\n> I disagree about \"not faster\".  I agree that it's not much faster, but\r\n> this does avoid a function call.\r\n>\r\n\r\nThat is true, but it is roughly the same. If you are calling Index or\r\nIndexByte enough times that that function call adds up, there is something\r\nbigger wrong with your program.\r\n\r\nI was neutral on this CL, until I remembered when I first started adding\r\n> APIs to the standard library, I was told to update the tree to use new APIs\r\n> when I added them.\r\n>\r\n\r\nIn general that is true. However, during the review you said the motivation\r\nwas for non-constant arguments. Feel free to use it to replace non-constant\r\nsingle-byte string arguments, but please revert the uses with constants.\r\n\r\nThanks.\r\nRuss\r\n",
			"disapproval": false,
			"date": "2013-08-05 23:05:51.112860",
			"approval": false
		}
	],
	"owner_email": "bradfitz@golang.org",
	"private": false,
	"base_url": "",
	"owner": "bradfitz",
	"subject": "code review 12486043: all: use strings.IndexByte instead of Index where possible",
	"created": "2013-08-05 22:36:53.380060",
	"patchsets": [
		1,
		3001,
		5001,
		9001
	],
	"modified": "2013-08-05 23:05:51.236190",
	"closed": true,
	"issue": 12486043
}