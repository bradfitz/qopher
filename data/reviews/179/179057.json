{
	"description": "A command to search for the source definition of\na Go identifier.\n\nThere are a few bits not entirely implemented (see the XXXs in the code),\nbut I'm already finding it very useful, and it's sufficiently\nGo-centric that I thought it could find a home in the main source tree.\n\nThis includes two knock on changes:\n1) add a []Decl case in ast/walk.go to enable it to cope\n\twith the array of declarations as found in a File node.\n\n2) add a \"ignoreerrors\" flag to ParsePackage so that it's\n\tpossible to read a package directory containing syntactically invalid\n\tGo source files if desired.",
	"cc": [
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"gri@golang.org"
	],
	"messages": [
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello gri, rsc, r (cc: golang-dev@googlegroups.com),\n\nI'd like you to review the following change.",
			"disapproval": false,
			"date": "2009-12-15 12:47:58.649168",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "I like it.  I've wanted something like this for a while.\nI have a bunch of small comments.\n\nA bigger comment is that the parser could\nlegitimately do the scoping at least in a single file,\nso that you could know, for any identifier, that either\nit refers to *this* declaration, or it refers to an unspecified\ntop-level declaration (either an import or a name outside\nthis file but in the same package).\n\nI think that would make sense in the long run,\nbut there's enough going on in parser world\nthat it's fine to keep the code here for now.\n\nhttp://codereview.appspot.com/179057/diff/2001/2004\nFile src/cmd/godef/acme/def.rc (right):\n\nhttp://codereview.appspot.com/179057/diff/2001/2004#newcode1\nsrc/cmd/godef/acme/def.rc:1: #!/bin/rc\n#!/usr/local/plan9/bin/rc please\n\nhttp://codereview.appspot.com/179057/diff/2001/2006\nFile src/cmd/godef/godef.go (right):\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode31\nsrc/cmd/godef/godef.go:31: var bflag = flag.Bool(\"b\", false, \"offset is specified in bytes\")\ns/bytes/bytes instead of code points/\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode34\nsrc/cmd/godef/godef.go:34: flag.Usage = func() {\nThis could equally well be done in main, and then\nit's next to the call to flag.Parse.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode68\nsrc/cmd/godef/godef.go:68: os.Exit(1);\nunexpected or usage errors should be Exit(2).\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode100\nsrc/cmd/godef/godef.go:100: ev = parseexpr(s, flag.Arg(1))\nshould be parseExpr\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode106\nsrc/cmd/godef/godef.go:106: ev = findidentifier(s, node, searchpos);\nfindIdentifier\nlookupExpr\nvisitGlobal\nparseLocalPackage\nruneToByte \nsearchPos\nvisitDecls\nlookupSelector\netc\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode111\nsrc/cmd/godef/godef.go:111: os.Exit(1);\nunexpected or usage errors should be Exit(2).\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode135\nsrc/cmd/godef/godef.go:135: // find an identifier, given an offset in the source file\n// findIdentifier looks for ... and returns ...\n\n(should be a complete sentence, and there's more detail that you could give)\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode240\nsrc/cmd/godef/godef.go:240: func fieldlookup(s Dict, fields []*ast.Field) lookupfn {\nlookupField etc\nyou switched halfway through the file.\ngo tends to put the verb first.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode379\nsrc/cmd/godef/godef.go:379: return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= 0x80 && unicode.IsLetter(ch)\nreturn ch == '_' || unicode.IsLetter(ch)\n\nwould be fine, or inline it at the call site.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode382\nsrc/cmd/godef/godef.go:382: func isDigit(ch int) bool {\nsimilarly, this is no more efficient than\ncalling unicode.IsDigit directly.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode421\nsrc/cmd/godef/godef.go:421: // unjustified assumption... but it makes it much faster!\nat least say what the assumption is\n\n// assume that last element of import path is package identifier.\n// unjustified, but makes it much faster.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode447\nsrc/cmd/godef/godef.go:447: declare(s.Outer, n.Name, typedeflookup(s, n.Name.Value, n.Type));\ns/typedeflookup/typeLookup/\n\nit's not a typedef.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode511\nsrc/cmd/godef/godef.go:511: // find the declaration we're looking for.\n// visitDecls looks for ... \n\nthis function definitely needs a comment but the\ncurrent one doesn't help me.  say what the arguments\nare and what gets returned.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode608\nsrc/cmd/godef/godef.go:608: func tuplemember(name string, n int) int {\nGo doesn't have tuples.\nNot sure what this is.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode620\nsrc/cmd/godef/godef.go:620: func optionaltuple(t *Ident) lookupfn {\nAgain, not sure what this is.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode734\nsrc/cmd/godef/godef.go:734: // XXX this is very basic, but probably sufficient for import strings.\nthere's a strconv.Unquote\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode821\nsrc/cmd/godef/godef.go:821: os.Exit(1);\nExit(2)\n\nhttp://codereview.appspot.com/179057/diff/2001/2007\nFile src/cmd/godef/scope.go (right):\n\nhttp://codereview.appspot.com/179057/diff/2001/2007#newcode18\nsrc/cmd/godef/scope.go:18: type Dict interface {\nIs there just one implementation of Dict\n(*Declarations)?  If so, no need for the interface.\n\nhttp://codereview.appspot.com/179057/diff/2001/2007#newcode113\nsrc/cmd/godef/scope.go:113: // TODO(gri) Uncomment once this code is needed.\ndelete this section\n\nhttp://codereview.appspot.com/179057/diff/2001/2012\nFile src/pkg/go/parser/interface.go (right):\n\nhttp://codereview.appspot.com/179057/diff/2001/2012#newcode169\nsrc/pkg/go/parser/interface.go:169: func ParsePackage(path string, filter func(*os.Dir) bool, mode uint, ignoreerrors bool) (*ast.Package, os.Error) {\nignoreerrors should be a bit in mode, not a separate flag.\n\nhttp://codereview.appspot.com/179057/diff/141/143\nFile src/cmd/godef/acme/acmedot.c (right):\n\nhttp://codereview.appspot.com/179057/diff/141/143#newcode1\nsrc/cmd/godef/acme/acmedot.c:1: #include <u.h>\nbelongs in misc/acme; add copyright header\n\nhttp://codereview.appspot.com/179057/diff/141/144\nFile src/cmd/godef/acme/def.rc (right):\n\nhttp://codereview.appspot.com/179057/diff/141/144#newcode1\nsrc/cmd/godef/acme/def.rc:1: #!/bin/rc\nbelongs in misc/acme; add copyright header\n\nhttp://codereview.appspot.com/179057/diff/141/148\nFile src/cmd/godef/testfile.go.txt (right):\n\nhttp://codereview.appspot.com/179057/diff/141/148#newcode1\nsrc/cmd/godef/testfile.go.txt:1: package main\ncopyright header",
			"disapproval": false,
			"date": "2009-12-15 18:03:49.086800",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/179057/diff/2001/2012\nFile src/pkg/go/parser/interface.go (right):\n\nhttp://codereview.appspot.com/179057/diff/2001/2012#newcode169\nsrc/pkg/go/parser/interface.go:169: func ParsePackage(path string, filter func(*os.Dir) bool, mode uint, ignoreerrors bool) (*ast.Package, os.Error) {\nOn 2009/12/15 18:22:58, gri wrote:\n> Introduce a new mode instead of adding a flag. That way, clients don't have to\n> change and the interface remains easily extensible.\n> \n\nyes to both. i don't know how i didn't think of that!",
			"disapproval": false,
			"date": "2009-12-16 12:07:19.503810",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Dec 16, 2009 at 5:38 AM, roger peppe <rogpeppe@gmail.com> wrote:\n\n> 2009/12/15  <gri@golang.org>:\n> > Introduce a new mode instead of adding a flag. That way, clients don't\n> > have to change and the interface remains easily extensible.\n>\n> BTW, why does ParsePkgFile ignore the flags that control partial\n> parsing? that means they have no effect when calling ParsePackage,\n> but it's actually quite useful to do a limited parse of a package\n> (for example to find out a package's identifier)\n>\n\nHistoric reasons. See http://codereview.appspot.com/180070 .\n- gri\n",
			"disapproval": false,
			"date": "2009-12-16 22:00:21.493823",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "thanks.  i haven't gotten a chance to read the\ncode carefully yet, but i'm going to do that either\ntoday or tomorrow.\n\nsorry for the delay.  i'm excited to have this tool.\n\nruss\n",
			"disapproval": false,
			"date": "2009-12-17 18:00:37.933363",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "2009/12/17 Russ Cox <rsc@golang.org>:\n> sorry for the delay. \u00a0i'm excited to have this tool.\n\nno problem. i'm quite excited to have made it.\n\ni have to say it's lovely to be able to point to\nany identifier in any go file in the source tree and\nsay \"take me to its definition\".\n\nparticularly in the presence of multiple chained :=\ndefinitions and unnamed members.\n",
			"disapproval": false,
			"date": "2009-12-17 18:25:26.239582",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "I took a closer look at this and I'm pretty lost.\nI think the code overuses closures: it should be possible\nto do a much simpler imperative traversal of the tree\ninstead of making everything a closure.\n\nFor the simple case of looking for the definition of \nthe name at a particular byte offset, you don't even\nneed to create an explicit scope.  A simple recursive\ntraversal of the ast can do something like\n\nfunc look(ast interface{}, pos int) (string, *Def) {\n    if ast overlaps pos {\n        return ast.name, nil\n    }\n    if ast declares some variables {\n        name, def := look(ast.body)\n        if name != \"\" && def == nil {\n            def = look for name in those variables\n        }\n        return name, def\n    }\n    for each kid k in ast {\n        if name, def := look(k, pos); name != \"\" {\n            return name, def\n        }\n    }\n    return \"\", nil\n}",
			"disapproval": false,
			"date": "2009-12-18 19:49:16.240216",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": " to put it more succinctly perhaps, when you see:\n\n    func typeLookupFn(s Dict, t interface{}) lookupfn {\n\nyou're seeing a function that, given type expression t\nand scope s, returns a function that can be used later\nto find out the submembers of that type.\n",
			"disapproval": false,
			"date": "2009-12-18 21:02:18.980510",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> this is essentially what it does do, but i didn't want\n> to recode the entire of ast.Walk, which is what i'd\n> have to do, because there's no generic way of getting\n> the kids of a node.\n\nfor this specific case,\nwhat if you just wrap ast.Walk (or write a separate function)\nto produce ast.Kids that returns []interface{} ?\n",
			"disapproval": false,
			"date": "2009-12-18 21:29:51.518343",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Some additional comments.\n\n- gri\n\nhttp://codereview.appspot.com/179057/diff/2001/2009\nFile src/cmd/godoc/godoc.go (right):\n\nhttp://codereview.appspot.com/179057/diff/2001/2009#newcode948\nsrc/cmd/godoc/godoc.go:948: pkg, err := parser.ParsePackage(dirname, filter, parser.ParseComments, false);\nthis won't need to change if you add an extra mode\n\nhttp://codereview.appspot.com/179057/diff/2001/2012\nFile src/pkg/go/parser/interface.go (right):\n\nhttp://codereview.appspot.com/179057/diff/2001/2012#newcode169\nsrc/pkg/go/parser/interface.go:169: func ParsePackage(path string, filter func(*os.Dir) bool, mode uint, ignoreerrors bool) (*ast.Package, os.Error) {\nIntroduce a new mode instead of adding a flag. That way, clients don't have to change and the interface remains easily extensible.\n\nhttp://codereview.appspot.com/179057/diff/2001/2013\nFile src/pkg/go/parser/parser_test.go (right):\n\nhttp://codereview.appspot.com/179057/diff/2001/2013#newcode81\nsrc/pkg/go/parser/parser_test.go:81: pkg, err := ParsePackage(path, dirFilter, 0, false);\nthis won't need to change if you add an extra mode",
			"disapproval": false,
			"date": "2009-12-15 18:22:58.016761",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Dec 15, 2009 at 10:03 AM, <rsc@golang.org> wrote:\n\n> I like it.  I've wanted something like this for a while.\n> I have a bunch of small comments.\n>\n> A bigger comment is that the parser could\n> legitimately do the scoping at least in a single file,\n> so that you could know, for any identifier, that either\n> it refers to *this* declaration, or it refers to an unspecified\n> top-level declaration (either an import or a name outside\n> this file but in the same package).\n>\n\nYes. However, please leave this as is for now. There's several other\ncleanups pending in the parser/ast world.\n- gri\n\n>\n> I think that would make sense in the long run,\n> but there's enough going on in parser world\n> that it's fine to keep the code here for now.\n>\n>\n>\n> http://codereview.appspot.com/179057/diff/2001/2004\n> File src/cmd/godef/acme/def.rc (right):\n>\n> http://codereview.appspot.com/179057/diff/2001/2004#newcode1\n> src/cmd/godef/acme/def.rc:1: #!/bin/rc\n> #!/usr/local/plan9/bin/rc please\n>\n> http://codereview.appspot.com/179057/diff/2001/2006\n> File src/cmd/godef/godef.go (right):\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode31\n> src/cmd/godef/godef.go:31: var bflag = flag.Bool(\"b\", false, \"offset is\n> specified in bytes\")\n> s/bytes/bytes instead of code points/\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode34\n> src/cmd/godef/godef.go:34: flag.Usage = func() {\n> This could equally well be done in main, and then\n> it's next to the call to flag.Parse.\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode68\n> src/cmd/godef/godef.go:68: os.Exit(1);\n> unexpected or usage errors should be Exit(2).\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode100\n> src/cmd/godef/godef.go:100: ev = parseexpr(s, flag.Arg(1))\n> should be parseExpr\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode106\n> src/cmd/godef/godef.go:106: ev = findidentifier(s, node, searchpos);\n> findIdentifier\n> lookupExpr\n> visitGlobal\n> parseLocalPackage\n> runeToByte\n> searchPos\n> visitDecls\n> lookupSelector\n> etc\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode111\n> src/cmd/godef/godef.go:111: os.Exit(1);\n> unexpected or usage errors should be Exit(2).\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode135\n> src/cmd/godef/godef.go:135: // find an identifier, given an offset in\n> the source file\n> // findIdentifier looks for ... and returns ...\n>\n> (should be a complete sentence, and there's more detail that you could\n> give)\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode240\n> src/cmd/godef/godef.go:240: func fieldlookup(s Dict, fields\n> []*ast.Field) lookupfn {\n> lookupField etc\n> you switched halfway through the file.\n> go tends to put the verb first.\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode379\n> src/cmd/godef/godef.go:379: return 'a' <= ch && ch <= 'z' || 'A' <= ch\n> && ch <= 'Z' || ch == '_' || ch >= 0x80 && unicode.IsLetter(ch)\n> return ch == '_' || unicode.IsLetter(ch)\n>\n> would be fine, or inline it at the call site.\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode382\n> src/cmd/godef/godef.go:382: func isDigit(ch int) bool {\n> similarly, this is no more efficient than\n> calling unicode.IsDigit directly.\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode421\n> src/cmd/godef/godef.go:421: // unjustified assumption... but it makes it\n> much faster!\n> at least say what the assumption is\n>\n> // assume that last element of import path is package identifier.\n> // unjustified, but makes it much faster.\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode447\n> src/cmd/godef/godef.go:447: declare(s.Outer, n.Name, typedeflookup(s,\n> n.Name.Value, n.Type));\n> s/typedeflookup/typeLookup/\n>\n> it's not a typedef.\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode511\n> src/cmd/godef/godef.go:511: // find the declaration we're looking for.\n> // visitDecls looks for ...\n>\n> this function definitely needs a comment but the\n> current one doesn't help me.  say what the arguments\n> are and what gets returned.\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode608\n> src/cmd/godef/godef.go:608: func tuplemember(name string, n int) int {\n> Go doesn't have tuples.\n> Not sure what this is.\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode620\n> src/cmd/godef/godef.go:620: func optionaltuple(t *Ident) lookupfn {\n> Again, not sure what this is.\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode734\n> src/cmd/godef/godef.go:734: // XXX this is very basic, but probably\n> sufficient for import strings.\n> there's a strconv.Unquote\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode821\n> src/cmd/godef/godef.go:821: os.Exit(1);\n> Exit(2)\n>\n> http://codereview.appspot.com/179057/diff/2001/2007\n> File src/cmd/godef/scope.go (right):\n>\n> http://codereview.appspot.com/179057/diff/2001/2007#newcode18\n> src/cmd/godef/scope.go:18: type Dict interface {\n> Is there just one implementation of Dict\n> (*Declarations)?  If so, no need for the interface.\n>\n> http://codereview.appspot.com/179057/diff/2001/2007#newcode113\n> src/cmd/godef/scope.go:113: // TODO(gri) Uncomment once this code is\n> needed.\n> delete this section\n>\n> http://codereview.appspot.com/179057/diff/2001/2012\n> File src/pkg/go/parser/interface.go (right):\n>\n> http://codereview.appspot.com/179057/diff/2001/2012#newcode169\n> src/pkg/go/parser/interface.go:169: func ParsePackage(path string,\n> filter func(*os.Dir) bool, mode uint, ignoreerrors bool) (*ast.Package,\n> os.Error) {\n> ignoreerrors should be a bit in mode, not a separate flag.\n>\n> http://codereview.appspot.com/179057/diff/141/143\n> File src/cmd/godef/acme/acmedot.c (right):\n>\n> http://codereview.appspot.com/179057/diff/141/143#newcode1\n> src/cmd/godef/acme/acmedot.c:1: #include <u.h>\n> belongs in misc/acme; add copyright header\n>\n> http://codereview.appspot.com/179057/diff/141/144\n> File src/cmd/godef/acme/def.rc (right):\n>\n> http://codereview.appspot.com/179057/diff/141/144#newcode1\n> src/cmd/godef/acme/def.rc:1: #!/bin/rc\n> belongs in misc/acme; add copyright header\n>\n> http://codereview.appspot.com/179057/diff/141/148\n> File src/cmd/godef/testfile.go.txt (right):\n>\n> http://codereview.appspot.com/179057/diff/141/148#newcode1\n> src/cmd/godef/testfile.go.txt:1: package main\n> copyright header\n>\n>\n> http://codereview.appspot.com/179057\n>\n",
			"disapproval": false,
			"date": "2009-12-15 18:37:42.203155",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/179057/diff/2001/2006\nFile src/cmd/godef/godef.go (right):\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode31\nsrc/cmd/godef/godef.go:31: var bflag = flag.Bool(\"b\", false, \"offset is specified in bytes\")\nOn 2009/12/15 18:03:49, rsc wrote:\n> s/bytes/bytes instead of code points/\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode34\nsrc/cmd/godef/godef.go:34: flag.Usage = func() {\nOn 2009/12/15 18:03:49, rsc wrote:\n> This could equally well be done in main, and then\n> it's next to the call to flag.Parse.\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode68\nsrc/cmd/godef/godef.go:68: os.Exit(1);\nOn 2009/12/15 18:03:49, rsc wrote:\n> unexpected or usage errors should be Exit(2).\n> \n\ni never knew that!\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode100\nsrc/cmd/godef/godef.go:100: ev = parseexpr(s, flag.Arg(1))\nOn 2009/12/15 18:03:49, rsc wrote:\n> should be parseExpr\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode106\nsrc/cmd/godef/godef.go:106: ev = findidentifier(s, node, searchpos);\nOn 2009/12/15 18:03:49, rsc wrote:\n> findIdentifier\n> lookupExpr\n> visitGlobal\n> parseLocalPackage\n> runeToByte \n> searchPos\n> visitDecls\n> lookupSelector\n> etc\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode111\nsrc/cmd/godef/godef.go:111: os.Exit(1);\nOn 2009/12/15 18:03:49, rsc wrote:\n> unexpected or usage errors should be Exit(2).\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode135\nsrc/cmd/godef/godef.go:135: // find an identifier, given an offset in the source file\nOn 2009/12/15 18:03:49, rsc wrote:\n> // findIdentifier looks for ... and returns ...\n> \n> (should be a complete sentence, and there's more detail that you could give)\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode240\nsrc/cmd/godef/godef.go:240: func fieldlookup(s Dict, fields []*ast.Field) lookupfn {\nOn 2009/12/15 18:03:49, rsc wrote:\n> lookupField etc\n> you switched halfway through the file.\n> go tends to put the verb first.\n\nmy convention is that i use lookup* when the action is done immediately, and *lookup when it returns a function that can perform the action later.\n\nmaybe i shouldn't try to distinguish.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode379\nsrc/cmd/godef/godef.go:379: return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= 0x80 && unicode.IsLetter(ch)\nOn 2009/12/15 18:03:49, rsc wrote:\n> return ch == '_' || unicode.IsLetter(ch)\n> \n> would be fine, or inline it at the call site.\n\nok. i took these functions verbatim from go/scanner...\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode382\nsrc/cmd/godef/godef.go:382: func isDigit(ch int) bool {\nOn 2009/12/15 18:03:49, rsc wrote:\n> similarly, this is no more efficient than\n> calling unicode.IsDigit directly.\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode421\nsrc/cmd/godef/godef.go:421: // unjustified assumption... but it makes it much faster!\nyes. the assumption is that as outlined in this\nthread: http://groups.google.com/group/golang-nuts/browse_thread/thread/8da0d20cdc50bbb6\n\n\ni've had no response, so i guess it's not going to happen.\ni should just take out the code.\n\nOn 2009/12/15 18:03:49, rsc wrote:\n> at least say what the assumption is\n> \n> // assume that last element of import path is package identifier.\n> // unjustified, but makes it much faster.\n>\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode447\nsrc/cmd/godef/godef.go:447: declare(s.Outer, n.Name, typedeflookup(s, n.Name.Value, n.Type));\nit's a type definition, isn't it?\nmaybe namedTypeLookup might be better. but that also implies other named types e.g. int32.\n\nbetter suggestion?\n\n\nOn 2009/12/15 18:03:49, rsc wrote:\n> s/typedeflookup/typeLookup/\n> \n> it's not a typedef.\n>\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode511\nsrc/cmd/godef/godef.go:511: // find the declaration we're looking for.\nOn 2009/12/15 18:03:49, rsc wrote:\n> // visitDecls looks for ... \n> \n> this function definitely needs a comment but the\n> current one doesn't help me.  say what the arguments\n> are and what gets returned.\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode608\nsrc/cmd/godef/godef.go:608: func tuplemember(name string, n int) int {\nit's a multiple return value.\n\ni called it a tuple as a shorthand.\n\nbetter name?\n\nOn 2009/12/15 18:03:49, rsc wrote:\n> Go doesn't have tuples.\n> Not sure what this is.\n>\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode734\nsrc/cmd/godef/godef.go:734: // XXX this is very basic, but probably sufficient for import strings.\nOn 2009/12/15 18:03:49, rsc wrote:\n> there's a strconv.Unquote\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2001/2006#newcode821\nsrc/cmd/godef/godef.go:821: os.Exit(1);\nOn 2009/12/15 18:03:49, rsc wrote:\n> Exit(2)\n> \n\nDone.",
			"disapproval": false,
			"date": "2009-12-15 18:52:48.737064",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": ">> you switched halfway through the file.\n>> go tends to put the verb first.\n>\n> my convention is that i use lookup* when the action is done immediately,\n> and *lookup when it returns a function that can perform the action\n> later.\n>\n> maybe i shouldn't try to distinguish.\n\nooh i see.  i missed that these were\nfunctions.  maybe typeLookupFunc?\n\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode379\n> src/cmd/godef/godef.go:379: return 'a' <= ch && ch <= 'z' || 'A' <= ch\n> && ch <= 'Z' || ch == '_' || ch >= 0x80 && unicode.IsLetter(ch)\n> On 2009/12/15 18:03:49, rsc wrote:\n>>\n>> return ch == '_' || unicode.IsLetter(ch)\n>\n>> would be fine, or inline it at the call site.\n>\n> ok. i took these functions verbatim from go/scanner...\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode382\n> src/cmd/godef/godef.go:382: func isDigit(ch int) bool {\n> On 2009/12/15 18:03:49, rsc wrote:\n>>\n>> similarly, this is no more efficient than\n>> calling unicode.IsDigit directly.\n>\n>\n> Done.\n>\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode421\n> src/cmd/godef/godef.go:421: // unjustified assumption... but it makes it\n> much faster!\n> yes. the assumption is that as outlined in this\n> thread:\n> http://groups.google.com/group/golang-nuts/browse_thread/thread/8da0d20cdc50bbb6\n>\n>\n> i've had no response, so i guess it's not going to happen.\n> i should just take out the code.\n\nit's probably fine to try first,\nbut i doubt it will happen as a hard and fast rule.\n\n> it's a type definition, isn't it?\n\nsure but typedef is a very C word.\nyou don't say vardef or constdef elsewhere.\n\n> http://codereview.appspot.com/179057/diff/2001/2006#newcode608\n> src/cmd/godef/godef.go:608: func tuplemember(name string, n int) int {\n> it's a multiple return value.\n>\n> i called it a tuple as a shorthand.\n>\n> better name?\n\nit's a return value.\ni'd like to avoid the world tuple just on the off chance\nthat a tuple type gets introduced later (seems\nunlikely but hey you never know).\n\nruss\n",
			"disapproval": false,
			"date": "2009-12-15 19:00:20.528396",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "2009/12/15 Russ Cox <rsc@golang.org>:\n> it's probably fine to try first,\n> but i doubt it will happen as a hard and fast rule.\n\nactually, it's not even fine to try first, because the\nimport identifier may shadow a name defined at\npackage scope in another file.\n\nhaving this rule (or something like it) makes things so\nmuch simpler. a tool can know without guessing\nat all which symbols are defined as part of the local\npackage, and which are defined externally.\n\ni think that's a very useful property (for humans and\nprograms), and i don't see that one loses anything at\nall by defining such a rule.\n\ni've commented out the relevant code for the time being,\nas it is strictly wrong. i live in hope!\n\n>> i called it a tuple as a shorthand.\n>>\n>> better name?\n>\n> it's a return value.\n> i'd like to avoid the world tuple just on the off chance\n> that a tuple type gets introduced later (seems\n> unlikely but hey you never know).\n\ni'm inclined to carry on calling it a tuple as long as the gc internals do.\nthere's no other decent name for a returned type with multiple values.\n",
			"disapproval": false,
			"date": "2009-12-16 10:38:21.322929",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "2009/12/15  <gri@golang.org>:\n> Introduce a new mode instead of adding a flag. That way, clients don't\n> have to change and the interface remains easily extensible.\n\nBTW, why does ParsePkgFile ignore the flags that control partial\nparsing? that means they have no effect when calling ParsePackage,\nbut it's actually quite useful to do a limited parse of a package\n(for example to find out a package's identifier)\n",
			"disapproval": false,
			"date": "2009-12-16 13:38:30.015717",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "i've updated the code to deal with range, casts, const, make & new amongst other fixes.\n\nit seems to deal ok with any code i've thrown at it, but i'm sure there are cases where it still gets it wrong! i haven't worked out a decent way of regression testing it yet - testfile.go.txt has a decent number of test cases, but it's not clear how to automate them...\n\nif you're inclined to, perhaps you could commit it, and then it would get some more testing on other peoples' code.",
			"disapproval": false,
			"date": "2009-12-17 12:25:50.930751",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "2009/12/18  <rsc@golang.org>:\n> I took a closer look at this and I'm pretty lost.\n> I think the code overuses closures: it should be possible\n> to do a much simpler imperative traversal of the tree\n> instead of making everything a closure.\n\nperhaps it does overuse closures, but i *think*\nit uses them to useful effect.\n\n> For the simple case of looking for the definition of\n> the name at a particular byte offset, you don't even\n> need to create an explicit scope. \u00a0A simple recursive\n> traversal of the ast can do something like\n[...]\n> \u00a0 \u00a0 \u00a0 \u00a0name, def := look(ast.body)\n[...]\n> \u00a0 \u00a0for each kid k in ast {\n\nthis is essentially what it does do, but i didn't want\nto recode the entire of ast.Walk, which is what i'd\nhave to do, because there's no generic way of getting\nthe kids of a node. if you use ast.Walk, you have to\nuse a closure (or a channel, which makes things more\ncomplicated - i tried)\n\nbut even if you do things that way, then you've still got to look up\nthe type of the expression once you've found the identifier\nyou're looking for.\n\none approach is to read through all the code, registering identifiers\nand their associated\ntypes or expressions, and then derive the type of the target\nidentifier from those.\n\nthis means you have to do a fair amount of work for each identifier,\nstoring whatever information is necessary in order to later derive the\ntype - you can't just store the ast node, because the type of an\nidentifier can be\nimplicitly derived from its context in the tree:\n\n e.g.\nswitch n := m.(type) { ... }\n\nthe type of n is different in each part of the tree, so n needs to be stored\nseparately in each branch.\n\nso what i do is whenever i encounter an identifier, i store it in the symbol\ntable alongside a function (closure) that allows me to access\ninformation about that\nidentifier *later* - i.e. it includes the sope of the identifier and\nthe ast node.\n\nso when i'm walking the tree, i'm doing almost no work, just creating a closure\nfor each identifier that i pass.\n\nthen i can later interrogate the identifiers for their information,\ngenerated on demand; so the closures have access to symbol table information\nthat i might pull in later (note the fact that i have several tries at\ngetting the info, each time parsing more external files)\ncurrently the only information that you can ask for is about a member;\nhence \"lookupfn\".\n\nbecause i'm not doing the work immediately, i have no problems with dubious\ncode - if there are bad statements or semantic errors that don't pertain\nto the identifier i'm looking at, then i never see them.\nthat's particularly useful in a tool that is designed to be used on code\nthat's being edited.\n\ni know, it's really an experiment in doing lazy functional programming in Go,\nbut i think it works quite well for this particular task.\n\ni think an imperative version would be considerably more complicated\n(and more likely more fragile too)\n\nsorry for the length.\n",
			"disapproval": false,
			"date": "2009-12-18 20:23:03.904406",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "2009/12/18 Russ Cox <rsc@golang.org>:\n>> this is essentially what it does do, but i didn't want\n>> to recode the entire of ast.Walk, which is what i'd\n>> have to do, because there's no generic way of getting\n>> the kids of a node.\n>\n> for this specific case,\n> what if you just wrap ast.Walk (or write a separate function)\n> to produce ast.Kids that returns []interface{} ?\n\nsure, you could do this.\nit'd be slower, but doable. probably not even too\nslow if you use a vector and just reset the length\neach time.\n\nit wouldn't affect anything outside nodeVisit\nand globalVisit though - everything else is also closure-ridden!\n",
			"disapproval": false,
			"date": "2009-12-18 21:40:02.941946",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "okay.  i'll read your message and take another look.\nthere should be more comments to take people\nthrough the code.  not inside functions necessarily\nbut each function and dta structure should say what\nis necessary to understand what's going on.\n\nruss\n",
			"disapproval": false,
			"date": "2009-12-18 21:51:08.611411",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "PTAL.\n\ni've added a bunch of comments, and updated the\nscope interface so it was easier to explain\n(and probably more sensible too).\n\ni'm sorry you find the code to be opaque - i always find it difficult\nto know what's going to be hard or easy for someone\nexternal to understand. FWIW, i do think that the\nunderlying model that it's using is really quite straightforward,\neven if it is perhaps obscured by rampant (but necessary) use of currying.\n\n  rog.\n\n2009/12/18 Russ Cox <rsc@golang.org>:\n> okay. \u00a0i'll read your message and take another look.\n> there should be more comments to take people\n> through the code. \u00a0not inside functions necessarily\n> but each function and dta structure should say what\n> is necessary to understand what's going on.\n>\n> russ\n>\n",
			"disapproval": false,
			"date": "2009-12-21 13:56:33.365342",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "The comments help.  Thanks.\n\nThere's already a \"godefs\" program, so either we\nhave to rename godefs or rename this program.\nI wonder if it makes sense to mix in the typical\ngodoc usage and call it gosrc, so that\n\ngosrc bytes Buffer\n\nsays where Buffer is defined, and \n\ngosrc src/pkg/xml/read.go 'NewParser().Skip'\n\nis just a more refined context and a more\ncomplicated query, equivalent to\n\ngosrc xml 'NewParser().Skip'\n\nor\n\ngosrc xml Parser.Skip\n\n(does that last one work?)\n\nWhat do you think?\n\nhttp://codereview.appspot.com/179057/diff/2201/2206\nFile src/cmd/godef/godef.go (right):\n\nhttp://codereview.appspot.com/179057/diff/2201/2206#newcode31\nsrc/cmd/godef/godef.go:31: var showTypes = flag.Bool(\"t\", false, \"show type nodes only\")\nLooks like a debugging flag.  If so, give it a longer\nname like \"types\"\n\nhttp://codereview.appspot.com/179057/diff/2201/2206#newcode34\nsrc/cmd/godef/godef.go:34: var debug = flag.Bool(\"d\", false, \"debug mode\")\ns/\"d\"/\"debug\"/\n\nhttp://codereview.appspot.com/179057/diff/2201/2206#newcode701\nsrc/cmd/godef/godef.go:701: // tupleMember returns N if name represents the\nThese are not tuples.\nPlease use a different name so that if tuples\nare added later there will not be any confusion.\n\nI suggest \"expression list\", because that's \nwhat they are.\n\nfunc listMember(name string, n int) int\nfunc optionalListFn\netc\n\nI also suggest using .l (list) instead of .t.\n\nhttp://codereview.appspot.com/179057/diff/2201/2206#newcode987\nsrc/cmd/godef/godef.go:987: func noMembers(_ string, _ bool, _ *list.List) *Ident {\nfunc noMembers(string, bool, *list.List) *Ident {",
			"disapproval": false,
			"date": "2009-12-21 20:03:31.223801",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "2009/12/21  <rsc@golang.org>:\n> There's already a \"godefs\" program, so either we\n> have to rename godefs or rename this program.\n> I wonder if it makes sense to mix in the typical\n> godoc usage and call it gosrc, so that\n>\n> gosrc bytes Buffer\n>\n> says where Buffer is defined, and\n>\n> gosrc src/pkg/xml/read.go 'NewParser().Skip'\n>\n> is just a more refined context and a more\n> complicated query, equivalent to\n>\n> gosrc xml 'NewParser().Skip'\n>\n> or\n>\n> gosrc xml Parser.Skip\n>\n> (does that last one work?)\n>\n> What do you think?\n\nthat seems totally reasonable. (yes the last example does work)\n\nthe only hesitation i have about the name gosrc, is that i can see that\nwith relatively little modification, i can make this program produce\nnot just the source location, but also the type and an enumeration of the\nmembers of a particular expression.\n\nthen gosrc might not seem quite so right.\ni had one suggestion for \"goto\" as a name, which i liked, but again,\nit's not quite right if it does more than just source location.\n\nwhatever. i don't mind too much.\n",
			"disapproval": false,
			"date": "2009-12-21 23:59:37.216458",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "\nOn Dec 22, 2009, at 10:59 AM, roger peppe wrote:\n\n> 2009/12/21  <rsc@golang.org>:\n>> There's already a \"godefs\" program, so either we\n>> have to rename godefs or rename this program.\n>> I wonder if it makes sense to mix in the typical\n>> godoc usage and call it gosrc, so that\n>>\n>> gosrc bytes Buffer\n>>\n>> says where Buffer is defined, and\n>>\n>> gosrc src/pkg/xml/read.go 'NewParser().Skip'\n>>\n>> is just a more refined context and a more\n>> complicated query, equivalent to\n>>\n>> gosrc xml 'NewParser().Skip'\n>>\n>> or\n>>\n>> gosrc xml Parser.Skip\n>>\n>> (does that last one work?)\n>>\n>> What do you think?\n>\n> that seems totally reasonable. (yes the last example does work)\n\ni wish godoc could handle this.  we should try to unify the interfaces  \nof godoc, godoc --http, godefs perhaps, and this tool.\n\n>\n> the only hesitation i have about the name gosrc, is that i can see  \n> that\n> with relatively little modification, i can make this program produce\n> not just the source location, but also the type and an enumeration  \n> of the\n> members of a particular expression.\n>\n> then gosrc might not seem quite so right.\n> i had one suggestion for \"goto\" as a name, which i liked, but again,\n> it's not quite right if it does more than just source location.\n>\n> whatever. i don't mind too much.\n\n",
			"disapproval": false,
			"date": "2009-12-22 05:52:36.411358",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Agreed. I think that the type information needs to be carried in the AST\nbecause then godoc could show much more, also on the webpages. This was\nalways the plan from the start. There's a bunch of AST cleanups I'd like to\ndo (related to how comments are represented) but perhaps I should move that\nback in the queue.\n\n- gri\n\nOn Mon, Dec 21, 2009 at 9:52 PM, Rob 'Commander' Pike <r@google.com> wrote:\n\n>\n> On Dec 22, 2009, at 10:59 AM, roger peppe wrote:\n>\n>  2009/12/21  <rsc@golang.org>:\n>>\n>>> There's already a \"godefs\" program, so either we\n>>> have to rename godefs or rename this program.\n>>> I wonder if it makes sense to mix in the typical\n>>> godoc usage and call it gosrc, so that\n>>>\n>>> gosrc bytes Buffer\n>>>\n>>> says where Buffer is defined, and\n>>>\n>>> gosrc src/pkg/xml/read.go 'NewParser().Skip'\n>>>\n>>> is just a more refined context and a more\n>>> complicated query, equivalent to\n>>>\n>>> gosrc xml 'NewParser().Skip'\n>>>\n>>> or\n>>>\n>>> gosrc xml Parser.Skip\n>>>\n>>> (does that last one work?)\n>>>\n>>> What do you think?\n>>>\n>>\n>> that seems totally reasonable. (yes the last example does work)\n>>\n>\n> i wish godoc could handle this.  we should try to unify the interfaces of\n> godoc, godoc --http, godefs perhaps, and this tool.\n>\n>\n>\n>> the only hesitation i have about the name gosrc, is that i can see that\n>> with relatively little modification, i can make this program produce\n>> not just the source location, but also the type and an enumeration of the\n>> members of a particular expression.\n>>\n>> then gosrc might not seem quite so right.\n>> i had one suggestion for \"goto\" as a name, which i liked, but again,\n>> it's not quite right if it does more than just source location.\n>>\n>> whatever. i don't mind too much.\n>>\n>\n>\n",
			"disapproval": false,
			"date": "2009-12-22 06:19:11.904239",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "So what's the plan?\n\nShould we check this in as gosrc and then cannibalize\nit from there?  Or somehow merge the code into go/ast\nand godoc?\n\nI don't want to drop this on the floor, but I am also\nunclear how to proceed.",
			"disapproval": false,
			"date": "2009-12-23 16:10:14.035688",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I suggest that for now it should be a separate tool. Also, I need to have a\ndetailed look at your sources again, but that may take some time due to the\nxmas season. I am technically on vacation and so are other team members.\n\n- gri\n\nOn Wed, Dec 23, 2009 at 8:10 AM, <rsc@golang.org> wrote:\n\n> So what's the plan?\n>\n> Should we check this in as gosrc and then cannibalize\n> it from there?  Or somehow merge the code into go/ast\n> and godoc?\n>\n> I don't want to drop this on the floor, but I am also\n> unclear how to proceed.\n>\n>\n> http://codereview.appspot.com/179057\n>\n",
			"disapproval": false,
			"date": "2009-12-23 21:05:30.085637",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "i'd go with the former option, as i won't be able to spend\nmuch time with the code over christmas & new year. at least\nif it's checked in then people will be able\nto use it and find bugs in it...\n\nmy vague plan for making the code available to godoc\nis to make most of the code into a package (or maybe two,\nas the scope and var declaration stuff really belongs in go/ast,\nbut i don't know what gri's plans are for that area)\n\ndoes it make sense to have the \"print info about the identifier\nat this offset in this file\" functionality in godoc?\ni've found it very useful for browsing source (in fact this\nfunctionality was my original motivation). has anyone\nhere tried out the acme \"def\" script - does it work for you?\n\n\n2009/12/23  <rsc@golang.org>:\n> So what's the plan?\n>\n> Should we check this in as gosrc and then cannibalize\n> it from there? \u00a0Or somehow merge the code into go/ast\n> and godoc?\n>\n> I don't want to drop this on the floor, but I am also\n> unclear how to proceed.\n>\n> http://codereview.appspot.com/179057\n>\n",
			"disapproval": false,
			"date": "2009-12-24 12:13:13.862879",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/179057/diff/2201/2206\nFile src/cmd/godef/godef.go (right):\n\nhttp://codereview.appspot.com/179057/diff/2201/2206#newcode31\nsrc/cmd/godef/godef.go:31: var showTypes = flag.Bool(\"t\", false, \"show type nodes only\")\nOn 2009/12/21 20:03:31, rsc wrote:\n> Looks like a debugging flag.  If so, give it a longer\n> name like \"types\"\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2201/2206#newcode34\nsrc/cmd/godef/godef.go:34: var debug = flag.Bool(\"d\", false, \"debug mode\")\nOn 2009/12/21 20:03:31, rsc wrote:\n> s/\"d\"/\"debug\"/\n> \n\nDone.\n\nhttp://codereview.appspot.com/179057/diff/2201/2206#newcode701\nsrc/cmd/godef/godef.go:701: // tupleMember returns N if name represents the\nOn 2009/12/21 20:03:31, rsc wrote:\n> These are not tuples.\n> Please use a different name so that if tuples\n> are added later there will not be any confusion.\n> \n> I suggest \"expression list\", because that's \n> what they are.\n\nok. i used \"elist\" and .e rather than \"list\" for the rather\nselfish reason that the \"l\" character has a rather\nambiguous appearance in the type face i use.\nalso because it makes it obvious that we're not\ntalking about the usual list data structure.\n\nhttp://codereview.appspot.com/179057/diff/2201/2206#newcode987\nsrc/cmd/godef/godef.go:987: func noMembers(_ string, _ bool, _ *list.List) *Ident {\nOn 2009/12/21 20:03:31, rsc wrote:\n> func noMembers(string, bool, *list.List) *Ident {\n> \n\nDone.",
			"disapproval": false,
			"date": "2009-12-24 13:41:15.229472",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "In the interest if making some progress, can you please split out the changes made to parser/ast into a separate CL? They look fine and I will approve them. Then we can concentrate on the rest which is really a separate issue.\n\nhttp://codereview.appspot.com/179057/diff/4001/4011\nFile src/pkg/go/parser/interface.go (right):\n\nhttp://codereview.appspot.com/179057/diff/4001/4011#newcode187\nsrc/pkg/go/parser/interface.go:187: if err != nil && (mode&SkipBadFiles) == 0 {\nSkipBadFiles is not defined in a file in this CL",
			"disapproval": false,
			"date": "2009-12-30 00:34:41.396593",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rogpeppe@gmail.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "",
			"disapproval": false,
			"date": "2010-01-15 22:00:40.027391",
			"approval": false
		}
	],
	"owner_email": "rogpeppe@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "rog",
	"subject": "code review 179057: A command to search for the source definition of",
	"created": "2009-12-15 12:41:44.397551",
	"patchsets": [
		1,
		26,
		1013,
		64,
		1027,
		1028,
		1053,
		102,
		116,
		1115,
		2001,
		141,
		171,
		196,
		208,
		2046,
		2067,
		2089,
		231,
		2111,
		2133,
		257,
		282,
		283,
		294,
		2201,
		309,
		4001,
		4027,
		3011
	],
	"modified": "2010-01-15 22:00:40.027391",
	"closed": false,
	"issue": 179057
}