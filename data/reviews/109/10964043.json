{
	"description": "go.text/transform: implementation of Writer, Chain, Nop and Discard.",
	"cc": [
		"nigeltao@golang.org",
		"r@golang.org",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10964043/diff/3001/transform/examples_test.go\nFile transform/examples_test.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/examples_test.go#newcode5\ntransform/examples_test.go:5: package transform\nI appreciate that these examples demonstrate the low-level details of the Transformer interface, but as package documentation, I'm not sure if this is useful.\n\nIf you want to *use* an existing Transformer, I'd direct you to using a Reader or a Writer instead of pumping the loop manually, and then you wouldn't normally care about ErrShortDst or ErrShortSrc. If you want to *implement* Transformer, then some example code might be nice, but that's not what's here.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/examples_test.go#newcode16\ntransform/examples_test.go:16: t := lowerCaseASCII{}\nShould the lowerCaseASCII type move from transform_test.go to example_test.go, to make the example self-contained?\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/examples_test.go#newcode18\ntransform/examples_test.go:18: if n1, _, err := t.Transform(dst, src, true); err == nil {\nUse nDst, nSrc instead of n1, n0.\n\nSimilarly below.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/examples_test.go#newcode33\ntransform/examples_test.go:33: {b(\"3a4\"), b(\"b\")},    // -> aaabbbb\nYou can drop the b function calls, since you can call copy(aByteSlice, aString).\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode175\ntransform/transform.go:175: // The user needs to call Close to flush unwritten bytes that may\nWas it a deliberate decision to omit a Flush method?\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode180\ntransform/transform.go:180: buf []byte\nWould it be more consistent (with Reader and Tranform) to rename buf and in to dst and src?\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode198\ntransform/transform.go:198: // Write implements the standard write interface.  If there are not enough\nOne space only after a full stop, please. I know that both styles are valid, and are used in the standard library, but please keep this file internally consistent.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode202\ntransform/transform.go:202: if w.n > 0 {\nThis might be easier as\nif start := w.n; start > 0 {\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode206\ntransform/transform.go:206: // If p >= start, we are consuming bytes from data. At this point, it is\nMove this comment a couple of lines down. I was confused for a while thinking how can p >= start be true when p is 0 and start is w.n, and w.n > 0 from the first line in this method.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode207\ntransform/transform.go:207: // safe to exit the loop and process bytes on data directly.\ns/on/of/ or just drop \"bytes on\" entirely?\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode211\ntransform/transform.go:211: nb, nd, err := w.t.Transform(w.buf, w.in[p:w.n], false)\nUse nDst and nSrc instead of nb and nd.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode218\ntransform/transform.go:218: break\nUnnecessary break, unless you mean to break the for instead of the switch.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode239\ntransform/transform.go:239: nb, nd, err := w.t.Transform(w.buf, data[n:], false)\nnDst, nSrc.\n\nSimilarly below.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode240\ntransform/transform.go:240: n += nd\nStrictly speaking, I'd put this after the w.w.Write call.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode256\ntransform/transform.go:256: func (w *Writer) Close() error {\nHow about this:\n\nfunc (w *Writer) Close() error {\n\tfor src := w.in[:w.n]; len(src) > 0; {\n\t\tnDst, nSrc, err := w.t.Transform(w.buf, src, true)\n\t\tif nDst == 0 {\n\t\t\treturn err\n\t\t}\n\t\tif _, werr := w.w.Write(w.buf[:nDst]); werr != nil {\n\t\t\treturn werr\n\t\t}\n\t\tif err != ErrShortDst {\n\t\t\treturn err\n\t\t}\n\t\tsrc = src[nSrc:]\n\t}\n\treturn nil\n}\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode259\ntransform/transform.go:259: nb, ni, err = w.t.Transform(w.buf[:], w.in[p:w.n], true)\nDrop the [:].\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode285\ntransform/transform.go:285: type devNull struct{}\ns/devNull/discard/ ?\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode300\ntransform/transform.go:300: // chainedTransformer applies a list of Transformers in sequence.\ns/chainedTransformer/chained/\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode327\ntransform/transform.go:327: if r, ok := c.link[i].t.(Resetter); ok {\nWhy isn't c.link[0].t reset?\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode361\ntransform/transform.go:361: // k is the lowest int for which c.link[k] may still produce bytes.\ns/int/index/?\n\nI'm finding this loop very hard to understand in general. What is i? It sometimes goes up, it sometimes goes down. What's the general approach? Do we walk the chain as soon as there is some data to push, no matter how little data, or do we try and fill up one link's buffer before moving on to the next one? This really needs more commentary.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform_test.go\nFile transform/transform_test.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform_test.go#newcode157\ntransform/transform_test.go:157: var testCases = []testCase{\nLet me send you a rubber-stamp CL to move these test cases out.",
			"disapproval": false,
			"date": "2013-07-09 07:56:09.586400",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, r@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-07-09 13:30:59.487130",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10964043/diff/9002/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/9002/transform/transform.go#newcode177\ntransform/transform.go:177: // in[:n] contains bytes that have not yet passed through t.\ns/in/src/\n\nhttps://codereview.appspot.com/10964043/diff/9002/transform/transform.go#newcode193\ntransform/transform.go:193: // Write implements the standard write interface. If there are not enough\ns/standard write/io.Writer/\n\nhttps://codereview.appspot.com/10964043/diff/9002/transform/transform.go#newcode218\ntransform/transform.go:218: break\nIt doesn't matter in practice, but you mean \"break loop\", right?\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode207\ntransform/transform.go:207: nDst, nSrc, err := w.t.Transform(w.dst, w.src[p:w.n], false)\nIt's kind of unfortunate that you need two similar loops that each call w.t.Transform. I wonder if there's a nice way to reduce the copy/pasting...\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode300\ntransform/transform.go:300: type chained struct {\nI'd drop the \"ed\", and also drop the \"struct\":\n\n// chain is a sequence of links. A chain with N Transformers has N+1 links and\n// N+1 buffers. Of those N+1 buffers, the first and last are the src and dst\n// buffers given to chain.Transform and the middle N-1 buffers are intermediate\n// buffers owned by the chain. The i'th link transforms bytes from the i'th\n// buffer chain[i].b at read offset chain[i].p to the i+1'th buffer\n// chain[i+1].b at write offset chain[i+1].n, for i in [0, N).\ntype chain []link\n\ntype link struct {\n\tt Transformer\n\t// b[p:n] holds the bytes to be transformed by t.\n\tb []byte\n\tp int\n\tn int\n}\n\nfunc (l *link) dst() []byte {\n\treturn l.b[l.n:]\n}\n\nfunc (l *link) src() []byte {\n\treturn l.b[l.p:l.n]\n}\n\n// Chain returns a StatefulTransformer that applies t in sequence.\nfunc Chain(t ...Transformer) StatefulTransformer {\n\tif len(t) == 0 {\n\t\treturn nop{}\n\t}\n\tc := make(chain, len(t)+1)\n\tfor i, tt := range t {\n\t\tc[i].t = tt\n\t}\n\t// Allocate intermediate buffers.\n\tb := make([][defaultBufSize]byte, len(t)-1)\n\tfor i := range b {\n\t\tc[i+1].b = b[i][:]\n\t}\n\treturn c\n}\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode350\ntransform/transform.go:350: last := len(c.link) - 2 // index of last Transformer\nIt's confusing how the \"last\" here means something different than the \"last\" in \"lastFull\". How about renaming this one to \"high\" and k to \"low\"? The for loop below would begin with:\n\n// i is the index of the next Transformer to apply, for i in [low, high].\n// low is the lowest index for which c[low] may still produce bytes.\n// high is the highest index for which c[high] has a Transformer.\n// The error returned by Transform determines whether to increase or\n// decrease i. We try to completely fill a buffer before processing it.\nfor low, i, high := 0, 0, len(c)-2; low <= i && i <= high; {\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode365\ntransform/transform.go:365: n1, n0, err0 := in.t.Transform(out.dst(), in.src(), atEOF && k == i)\nnDst, nSrc.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode378\ntransform/transform.go:378: } else if out.n == 0 {\nGo style is to drop the \"else\" in an \"else if\" after a \"return\". How about:\n\n// Process the destination buffer next. Return if we are already\n// at the high index.\nif i == high {\n\treturn dstL.n, srcL.p, ErrShortDst\n}\nif out.n != 0 {\n\ti++\n\t// If the Transformer at the next index is not able to process any\n\t// source bytes there is nothing that can be done to make progress\n\t// and the bytes will remain unprocessed. lastFull is used to\n\t// detect this and break out of the loop with a fatal error.\n\tlastFull = true\n\tcontinue\n}\n// The destination buffer was too small, but is completely empty.\n// Return a fatal error as this transformation can never complete.\nerr0 = errShortInternal\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode392\ntransform/transform.go:392: // Source bytes were depleted before fillin up the destination buffer.\nTypo in \"filling\".\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode406\ntransform/transform.go:406: // if i == k, we have depleted the bytes at index i or any previous levels.\ns/previous/lower/ ? Previous might mean higher if we just did i--.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go\nFile transform/transform_test.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode357\ntransform/transform_test.go:357: r := NewReader(strings.NewReader(tc.src), tc.t)\nCall\nreset(tc.t)\nabove this line?\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode393\ntransform/transform_test.go:393: for b := []byte(tc.src); len(b) > 0 && err == nil; {\nYou can drop the \"[]byte\", since you can copy(aByteSlice, aString).\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode423\ntransform/transform_test.go:423: n1, n0, err := Nop.Transform(dst, []byte(tc.str), true)\nnDst, nSrc.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode428\ntransform/transform_test.go:428: if res := string(dst[:n1]); res != want || err != tc.err || n0 != n1 {\ns/res/got/\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode445\ntransform/transform_test.go:445: n1, n0, err := Discard.Transform(make([]byte, tc.dstSize), []byte(tc.str), true)\nnDst, nSrc.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode625\ntransform/transform_test.go:625: func doTransform(t *testing.T, tc testCase) (res string, n, i int, err error) {\nIt looks like you don't care about t or n.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode633\ntransform/transform_test.go:633: for i < tc.wantIter || tc.wantIter == 0 {\nMaybe this function should return the number of iterations taken instead of enforcing the cap here?? It would return (string, int error) that is symmetric with the testCase's fields: wantStr, wantIter, wantErr:\n\nfunc (tc testCase) run() (str string, iter int, err error) {\n\treset(tc.t)\n\tdst := make([]byte, tc.dstSize)\n\tout, in := make([]byte, 0, 2*len(tc.src)), []byte(tc.src)\n\tfor {\n\t\titer++\n\t\tsrc, atEOF := in, true\n\t\tif len(src) > tc.srcSize {\n\t\t\tsrc, atEOF = src[:tc.srcSize], false\n\t\t}\n\t\tnDst, nSrc, err := tc.t.Transform(dst, src, atEOF)\n\t\tout = append(out, dst[:nDst]...)\n\t\tin = in[nSrc:]\n\n\t\tswitch {\n\t\tcase err == nil && len(in) != 0:\n\t\tcase err == ErrShortDst && nDst > 0:\n\t\tcase err == ErrShortSrc && nSrc > 0:\n\t\tdefault:\n\t\t\treturn string(out), iter, err\n\t\t}\n\t}\n}\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode636\ntransform/transform_test.go:636: n1, n0, err = tc.t.Transform(dst, src[:m], len(input) == m+n)\nnDst, nSrc.",
			"disapproval": false,
			"date": "2013-07-11 08:41:32.791770",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "good suggestions!\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/examples_test.go\nFile transform/examples_test.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/examples_test.go#newcode5\ntransform/examples_test.go:5: package transform\nFair enough. Admittedly I wrote these partly to get a good feel of which API would work.  I agree it would be more useful to include examples writing a transformer.\n\n I will remove these examples altogether.\n\n\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> I appreciate that these examples demonstrate the low-level details of the\n> Transformer interface, but as package documentation, I'm not sure if this is\n> useful.\n> \n> If you want to *use* an existing Transformer, I'd direct you to using a Reader\n> or a Writer instead of pumping the loop manually, and then you wouldn't normally\n> care about ErrShortDst or ErrShortSrc. If you want to *implement* Transformer,\n> then some example code might be nice, but that's not what's here.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/examples_test.go#newcode16\ntransform/examples_test.go:16: t := lowerCaseASCII{}\nThese could indeed make good examples on how to write a Transformer.  Best to do in a separate CL.\n\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> Should the lowerCaseASCII type move from transform_test.go to example_test.go,\n> to make the example self-contained?\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode175\ntransform/transform.go:175: // The user needs to call Close to flush unwritten bytes that may\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> Was it a deliberate decision to omit a Flush method?\n\nWrite already writes all bytes that are transformed before continuing.  So Flush would be a no-op at this point.  I didn't see the merit of adding it yet and figured it could always be added later if needed.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode180\ntransform/transform.go:180: buf []byte\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> Would it be more consistent (with Reader and Tranform) to rename buf and in to\n> dst and src?\n\"in\" is not used the same as \"src\" in reader, but close enough, I guess.  Changed.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode198\ntransform/transform.go:198: // Write implements the standard write interface.  If there are not enough\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> One space only after a full stop, please. I know that both styles are valid, and\n> are used in the standard library, but please keep this file internally\n> consistent.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode202\ntransform/transform.go:202: if w.n > 0 {\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> This might be easier as\n> if start := w.n; start > 0 {\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode206\ntransform/transform.go:206: // If p >= start, we are consuming bytes from data. At this point, it is\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> Move this comment a couple of lines down. I was confused for a while thinking\n> how can p >= start be true when p is 0 and start is w.n, and w.n > 0 from the\n> first line in this method.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode207\ntransform/transform.go:207: // safe to exit the loop and process bytes on data directly.\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> s/on/of/ or just drop \"bytes on\" entirely?\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode211\ntransform/transform.go:211: nb, nd, err := w.t.Transform(w.buf, w.in[p:w.n], false)\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> Use nDst and nSrc instead of nb and nd.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode218\ntransform/transform.go:218: break\nIt is not strictly necessary to break the loop here, but I do so anyway as I think it is somewhat clearer.\n\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> Unnecessary break, unless you mean to break the for instead of the switch.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode239\ntransform/transform.go:239: nb, nd, err := w.t.Transform(w.buf, data[n:], false)\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> nDst, nSrc.\n> \n> Similarly below.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode240\ntransform/transform.go:240: n += nd\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> Strictly speaking, I'd put this after the w.w.Write call.\n\nGood point. Done.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode256\ntransform/transform.go:256: func (w *Writer) Close() error {\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> How about this:\n> \n> func (w *Writer) Close() error {\n> \tfor src := w.in[:w.n]; len(src) > 0; {\n> \t\tnDst, nSrc, err := w.t.Transform(w.buf, src, true)\n> \t\tif nDst == 0 {\n> \t\t\treturn err\n> \t\t}\n> \t\tif _, werr := w.w.Write(w.buf[:nDst]); werr != nil {\n> \t\t\treturn werr\n> \t\t}\n> \t\tif err != ErrShortDst {\n> \t\t\treturn err\n> \t\t}\n> \t\tsrc = src[nSrc:]\n> \t}\n> \treturn nil\n> }\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode259\ntransform/transform.go:259: nb, ni, err = w.t.Transform(w.buf[:], w.in[p:w.n], true)\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> Drop the [:].\n\nDone. :)\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode285\ntransform/transform.go:285: type devNull struct{}\nWas trying to be consistent with the ioutil naming, but I think this makes more sense indeed. Changed.\n\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> s/devNull/discard/ ?\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode300\ntransform/transform.go:300: // chainedTransformer applies a list of Transformers in sequence.\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> s/chainedTransformer/chained/\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode327\ntransform/transform.go:327: if r, ok := c.link[i].t.(Resetter); ok {\nBug. Good catch.  p and n don't need to be reset, but transformer clearly does.  Added test for this case.\n\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> Why isn't c.link[0].t reset?\n\nhttps://codereview.appspot.com/10964043/diff/3001/transform/transform.go#newcode361\ntransform/transform.go:361: // k is the lowest int for which c.link[k] may still produce bytes.\nOn 2013/07/09 07:56:09, nigeltao wrote:\n> s/int/index/?\nDone.\n\n> I'm finding this loop very hard to understand in general. What is i? It\n> sometimes goes up, it sometimes goes down. What's the general approach? Do we\n> walk the chain as soon as there is some data to push, no matter how little data,\n> or do we try and fill up one link's buffer before moving on to the next one?\n> This really needs more commentary.\nAdded a bunch of comments.\n\nhttps://codereview.appspot.com/10964043/diff/9002/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/9002/transform/transform.go#newcode177\ntransform/transform.go:177: // in[:n] contains bytes that have not yet passed through t.\noops. Done.\n\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> s/in/src/\n\nhttps://codereview.appspot.com/10964043/diff/9002/transform/transform.go#newcode193\ntransform/transform.go:193: // Write implements the standard write interface. If there are not enough\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> s/standard write/io.Writer/\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/9002/transform/transform.go#newcode218\ntransform/transform.go:218: break\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> It doesn't matter in practice, but you mean \"break loop\", right?\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/9002/transform/transform.go#newcode218\ntransform/transform.go:218: break\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> It doesn't matter in practice, but you mean \"break loop\", right?\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode207\ntransform/transform.go:207: nDst, nSrc, err := w.t.Transform(w.dst, w.src[p:w.n], false)\nI updated the code to have a single loop. It looks cleaner and smaller, although it is slightly more tricky as now you have to understand two loops at once.  Let me know what you think.  I saved the old code in case you prefer that.\n\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> It's kind of unfortunate that you need two similar loops that each call\n> w.t.Transform. I wonder if there's a nice way to reduce the copy/pasting...\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode300\ntransform/transform.go:300: type chained struct {\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> I'd drop the \"ed\", and also drop the \"struct\":\n> \n> // chain is a sequence of links. A chain with N Transformers has N+1 links and\n> // N+1 buffers. Of those N+1 buffers, the first and last are the src and dst\n> // buffers given to chain.Transform and the middle N-1 buffers are intermediate\n> // buffers owned by the chain. The i'th link transforms bytes from the i'th\n> // buffer chain[i].b at read offset chain[i].p to the i+1'th buffer\n> // chain[i+1].b at write offset chain[i+1].n, for i in [0, N).\n> type chain []link\n> \n> type link struct {\n> \tt Transformer\n> \t// b[p:n] holds the bytes to be transformed by t.\n> \tb []byte\n> \tp int\n> \tn int\n> }\n> \n> func (l *link) dst() []byte {\n> \treturn l.b[l.n:]\n> }\n> \n> func (l *link) src() []byte {\n> \treturn l.b[l.p:l.n]\n> }\n> \n> // Chain returns a StatefulTransformer that applies t in sequence.\n> func Chain(t ...Transformer) StatefulTransformer {\n> \tif len(t) == 0 {\n> \t\treturn nop{}\n> \t}\n> \tc := make(chain, len(t)+1)\n> \tfor i, tt := range t {\n> \t\tc[i].t = tt\n> \t}\n> \t// Allocate intermediate buffers.\n> \tb := make([][defaultBufSize]byte, len(t)-1)\n> \tfor i := range b {\n> \t\tc[i+1].b = b[i][:]\n> \t}\n> \treturn c\n> }\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode350\ntransform/transform.go:350: last := len(c.link) - 2 // index of last Transformer\nThat is indeed much nicer.\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> It's confusing how the \"last\" here means something different than the \"last\" in\n> \"lastFull\". How about renaming this one to \"high\" and k to \"low\"? The for loop\n> below would begin with:\n> \n> // i is the index of the next Transformer to apply, for i in [low, high].\n> // low is the lowest index for which c[low] may still produce bytes.\n> // high is the highest index for which c[high] has a Transformer.\n> // The error returned by Transform determines whether to increase or\n> // decrease i. We try to completely fill a buffer before processing it.\n> for low, i, high := 0, 0, len(c)-2; low <= i && i <= high; {\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode365\ntransform/transform.go:365: n1, n0, err0 := in.t.Transform(out.dst(), in.src(), atEOF && k == i)\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> nDst, nSrc.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode365\ntransform/transform.go:365: n1, n0, err0 := in.t.Transform(out.dst(), in.src(), atEOF && k == i)\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> nDst, nSrc.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode378\ntransform/transform.go:378: } else if out.n == 0 {\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> Go style is to drop the \"else\" in an \"else if\" after a \"return\". How about:\n> \n> // Process the destination buffer next. Return if we are already\n> // at the high index.\n> if i == high {\n> \treturn dstL.n, srcL.p, ErrShortDst\n> }\n> if out.n != 0 {\n> \ti++\n> \t// If the Transformer at the next index is not able to process any\n> \t// source bytes there is nothing that can be done to make progress\n> \t// and the bytes will remain unprocessed. lastFull is used to\n> \t// detect this and break out of the loop with a fatal error.\n> \tlastFull = true\n> \tcontinue\n> }\n> // The destination buffer was too small, but is completely empty.\n> // Return a fatal error as this transformation can never complete.\n> err0 = errShortInternal\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode378\ntransform/transform.go:378: } else if out.n == 0 {\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> Go style is to drop the \"else\" in an \"else if\" after a \"return\". How about:\n> \n> // Process the destination buffer next. Return if we are already\n> // at the high index.\n> if i == high {\n> \treturn dstL.n, srcL.p, ErrShortDst\n> }\n> if out.n != 0 {\n> \ti++\n> \t// If the Transformer at the next index is not able to process any\n> \t// source bytes there is nothing that can be done to make progress\n> \t// and the bytes will remain unprocessed. lastFull is used to\n> \t// detect this and break out of the loop with a fatal error.\n> \tlastFull = true\n> \tcontinue\n> }\n> // The destination buffer was too small, but is completely empty.\n> // Return a fatal error as this transformation can never complete.\n> err0 = errShortInternal\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode392\ntransform/transform.go:392: // Source bytes were depleted before fillin up the destination buffer.\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> Typo in \"filling\".\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode392\ntransform/transform.go:392: // Source bytes were depleted before fillin up the destination buffer.\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> Typo in \"filling\".\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform.go#newcode406\ntransform/transform.go:406: // if i == k, we have depleted the bytes at index i or any previous levels.\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> s/previous/lower/ ? Previous might mean higher if we just did i--.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go\nFile transform/transform_test.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode357\ntransform/transform_test.go:357: r := NewReader(strings.NewReader(tc.src), tc.t)\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> Call\n> reset(tc.t)\n> above this line?\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode393\ntransform/transform_test.go:393: for b := []byte(tc.src); len(b) > 0 && err == nil; {\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> You can drop the \"[]byte\", since you can copy(aByteSlice, aString).\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode423\ntransform/transform_test.go:423: n1, n0, err := Nop.Transform(dst, []byte(tc.str), true)\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> nDst, nSrc.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode428\ntransform/transform_test.go:428: if res := string(dst[:n1]); res != want || err != tc.err || n0 != n1 {\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> s/res/got/\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode445\ntransform/transform_test.go:445: n1, n0, err := Discard.Transform(make([]byte, tc.dstSize), []byte(tc.str), true)\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> nDst, nSrc.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode625\ntransform/transform_test.go:625: func doTransform(t *testing.T, tc testCase) (res string, n, i int, err error) {\nGood point, taken your approach below.\n\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> It looks like you don't care about t or n.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode633\ntransform/transform_test.go:633: for i < tc.wantIter || tc.wantIter == 0 {\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> Maybe this function should return the number of iterations taken instead of\n> enforcing the cap here?? It would return (string, int error) that is symmetric\n> with the testCase's fields: wantStr, wantIter, wantErr:\n> \n> func (tc testCase) run() (str string, iter int, err error) {\n> \treset(tc.t)\n> \tdst := make([]byte, tc.dstSize)\n> \tout, in := make([]byte, 0, 2*len(tc.src)), []byte(tc.src)\n> \tfor {\n> \t\titer++\n> \t\tsrc, atEOF := in, true\n> \t\tif len(src) > tc.srcSize {\n> \t\t\tsrc, atEOF = src[:tc.srcSize], false\n> \t\t}\n> \t\tnDst, nSrc, err := tc.t.Transform(dst, src, atEOF)\n> \t\tout = append(out, dst[:nDst]...)\n> \t\tin = in[nSrc:]\n> \n> \t\tswitch {\n> \t\tcase err == nil && len(in) != 0:\n> \t\tcase err == ErrShortDst && nDst > 0:\n> \t\tcase err == ErrShortSrc && nSrc > 0:\n> \t\tdefault:\n> \t\t\treturn string(out), iter, err\n> \t\t}\n> \t}\n> }\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/19001/transform/transform_test.go#newcode636\ntransform/transform_test.go:636: n1, n0, err = tc.t.Transform(dst, src[:m], len(input) == m+n)\nOn 2013/07/11 08:41:33, nigeltao wrote:\n> nDst, nSrc.\n\nDone.",
			"disapproval": false,
			"date": "2013-07-11 17:55:58.233690",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, r@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-07-11 17:54:31.132880",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This is getting pretty close. Rob, can you take a look?\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform.go#newcode213\ntransform/transform.go:213: // to data instead to reduce the need copying.\nreduce the need for copying.\n\nor just\n\nreduce the copying.\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform.go#newcode352\ntransform/transform.go:352: // decrease i. We try to completely fill a buffer before processing it.\ns/processing/reading/ ?\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform.go#newcode404\ntransform/transform.go:404: // Exhausted level k or fatal error: increase k and continue\ns/k/low/g\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go\nFile transform/transform_test.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode125\ntransform/transform_test.go:125: wantIter int\nAdd that wantIter == 0 means that we don't care about the number of iterations taken?\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode474\ntransform/transform_test.go:474: t:        mkChain(rleEncode{}, 100, Nop),\nThis might be a more interesting test if Nop was lowerCaseASCII{} and src was \"ABB\".\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode599\ntransform/transform_test.go:599: t:       mkChain(dontMentionX{}, 8, rleDecode{}, 4, Nop),\nCan I get another similar test, with larger intermediate buffers, that transforming \"3a4b5eX\" results in \"aaabbbbeeeee\" and errYouMentionedX?\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode743\ntransform/transform_test.go:743: str, i, err := doTransform(tc)\nI would rename i to iter, for symmetry with wantIter.\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode744\ntransform/transform_test.go:744: mi := tc.wantIter != i\nmi := tc.wantIter != 0 && tc.wantIter != i",
			"disapproval": false,
			"date": "2013-07-12 08:29:21.450460",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10964043/diff/25001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform.go#newcode213\ntransform/transform.go:213: // to data instead to reduce the need copying.\nOn 2013/07/12 08:29:21, nigeltao wrote:\n> reduce the need for copying.\n> \n> or just\n> \n> reduce the copying.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform.go#newcode352\ntransform/transform.go:352: // decrease i. We try to completely fill a buffer before processing it.\nConverting?\n\nOn 2013/07/12 08:29:21, nigeltao wrote:\n> s/processing/reading/ ?\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform.go#newcode404\ntransform/transform.go:404: // Exhausted level k or fatal error: increase k and continue\nOn 2013/07/12 08:29:21, nigeltao wrote:\n> s/k/low/g\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go\nFile transform/transform_test.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode125\ntransform/transform_test.go:125: wantIter int\nOn 2013/07/12 08:29:21, nigeltao wrote:\n> Add that wantIter == 0 means that we don't care about the number of iterations\n> taken?\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode125\ntransform/transform_test.go:125: wantIter int\nOn 2013/07/12 08:29:21, nigeltao wrote:\n> Add that wantIter == 0 means that we don't care about the number of iterations\n> taken?\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode474\ntransform/transform_test.go:474: t:        mkChain(rleEncode{}, 100, Nop),\nOn 2013/07/12 08:29:21, nigeltao wrote:\n> This might be a more interesting test if Nop was lowerCaseASCII{} and src was\n> \"ABB\".\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode599\ntransform/transform_test.go:599: t:       mkChain(dontMentionX{}, 8, rleDecode{}, 4, Nop),\nOn 2013/07/12 08:29:21, nigeltao wrote:\n> Can I get another similar test, with larger intermediate buffers, that\n> transforming \"3a4b5eX\" results in \"aaabbbbeeeee\" and errYouMentionedX?\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode743\ntransform/transform_test.go:743: str, i, err := doTransform(tc)\nOn 2013/07/12 08:29:21, nigeltao wrote:\n> I would rename i to iter, for symmetry with wantIter.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode744\ntransform/transform_test.go:744: mi := tc.wantIter != i\nOn 2013/07/12 08:29:21, nigeltao wrote:\n> mi := tc.wantIter != 0 && tc.wantIter != i\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/25001/transform/transform_test.go#newcode744\ntransform/transform_test.go:744: mi := tc.wantIter != i\nOn 2013/07/12 08:29:21, nigeltao wrote:\n> mi := tc.wantIter != 0 && tc.wantIter != i\n\nDone.",
			"disapproval": false,
			"date": "2013-07-12 09:15:33.154680",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, r@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-07-12 09:15:53.548120",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10964043/diff/36001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform.go#newcode29\ntransform/transform.go:29: // to progress and the Transform has to be aborted.\n// to make progress and the Transform operation must be aborted.\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform.go#newcode67\ntransform/transform.go:67: // StatefulTransformer implements a Transformer and Resetter interface.\nthat is a truly horrible name and a weak concept.\ncan't you just get rid of the reset idea? it seems possible to me.\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform.go#newcode171\ntransform/transform.go:171: // be buffered.\nwhen?\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform.go#newcode195\ntransform/transform.go:195: // for the next write. Call Close to flush remaining bytes.\nwhen n==0? when err==io.EOF?\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform.go#newcode339\ntransform/transform.go:339: // Transform applies the c.t in sequence.\n\"the c.t\" is poor explanation",
			"disapproval": false,
			"date": "2013-07-15 03:07:20.947060",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I don't believe that the efficiency considerations that led to the Reset idea are necessary, and they are certainly not important at this stage of development. If they turn out to be important down the road, we can, based on the experience we have, find the right design.\n\nOne problem with Reset as concept is that it's not part of the current operation. It means, \"clean up from before\", which is a lousy interface. Better would be to require a Close, so the operations  are Transform, Close, as in \"process; OK now I'm done.\"\n\nBut it's not necessary to worry about this at all, perhaps forever and for sure not now.",
			"disapproval": false,
			"date": "2013-07-15 03:28:02.939660",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Jul 15, 2013 at 1:28 PM,  <r@golang.org> wrote:\r\n> One problem with Reset as concept is that it's not part of the current\r\n> operation. It means, \"clean up from before\", which is a lousy interface.\r\n> Better would be to require a Close, so the operations  are Transform,\r\n> Close, as in \"process; OK now I'm done.\"\r\n\r\nOn the other hand, if a Transformer is supposed to be re-usable, it\r\nseems odd to use something after you 'Close' it.\r\n\r\nTangentially, I'm not sure if \"I'm done\" can be implied by (stateful)\r\nTransformer implementations. Callers can call Transform multiple times\r\nwith atEOF = true, if they're flushing the Transformer's buffers. If\r\natEOF is false and a Transformer returns ErrShortDst, then the caller\r\nmay or may not do something more with the Transformer. I think that\r\nany Reset or Close has to be explicit.\r\n\r\n\r\n> But it's not necessary to worry about this at all, perhaps forever and\r\n> for sure not now.\r\n\r\nI'm also not sure if it's necessary to worry about this at all, but\r\nMarcel seems to think it is important:\r\nhttps://groups.google.com/d/msg/golang-dev/BvNYKGU_XRY/y92e6zvF3lwJ\r\n",
			"disapproval": false,
			"date": "2013-07-15 05:57:07.187960",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10964043/diff/36001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform.go#newcode29\ntransform/transform.go:29: // to progress and the Transform has to be aborted.\nOn 2013/07/15 03:07:21, r wrote:\n> // to make progress and the Transform operation must be aborted.\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform.go#newcode67\ntransform/transform.go:67: // StatefulTransformer implements a Transformer and Resetter interface.\nI'm not a big fan either, so I'll remove it.\nI removed it.  Let's revisit later. There are certain conditions where it makes sense, as Nigel points out, but for now the user will have to flush manually using Transform(dst, nil, true).  This is now possible for Chain as well.  I modified chain so that it flushes buffers when a fatal error is encountered.  The new code has the property that downstream fatal errors take precedence over upstream (which makes sense, as it implies it is an error occurring earlier in the character stream).  It also make it impossible now for the caller to get in an infinite if the fatal error is not properly handled.\n\nOn 2013/07/15 03:07:21, r wrote:\n> that is a truly horrible name and a weak concept.\n> can't you just get rid of the reset idea? it seems possible to me.\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform.go#newcode171\ntransform/transform.go:171: // be buffered.\nOn 2013/07/15 03:07:21, r wrote:\n> when?\n\nChain buffers bytes, for example.  It has to.  It cannot always know which input bytes were responsible for the bytes that were converted at the end of the chain.  There is probably a way around this if the transformer can give boundary information (as is implemented in unicode/norm).\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform.go#newcode195\ntransform/transform.go:195: // for the next write. Call Close to flush remaining bytes.\nChanged it slightly.  I'm not entirely sure what was unclear, so I hope this clarifies it.\n\nOn 2013/07/15 03:07:21, r wrote:\n> when n==0? when err==io.EOF?\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform.go#newcode339\ntransform/transform.go:339: // Transform applies the c.t in sequence.\nOn 2013/07/15 03:07:21, r wrote:\n> \"the c.t\" is poor explanation\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform_test.go\nFile transform/transform_test.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/36001/transform/transform_test.go#newcode471\ntransform/transform_test.go:471: var chainTests = []testCase{\nChains are reusable but not reentrant.  Making this a function to allow for parallel tests.",
			"disapproval": false,
			"date": "2013-07-15 14:41:31.425550",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, r@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-07-15 14:43:04.429640",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "looking good. please update the CL description.\n\nhttps://codereview.appspot.com/10964043/diff/49001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/49001/transform/transform.go#newcode181\ntransform/transform.go:181: // bytes are available to complete a Transform, the bytes will be buffered\ns/are //\n\nhttps://codereview.appspot.com/10964043/diff/49001/transform/transform.go#newcode183\ntransform/transform.go:183: // with atEOF == true.\nwhat's this line? or is it just out of place? anyway please clarify.",
			"disapproval": false,
			"date": "2013-07-18 10:22:17.429950",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=1aab38f578b8&repo=text ***\n\ngo.text/transform: implementation of Writer, Chain, Nop and Discard.\n\nR=nigeltao, r\nCC=golang-dev\nhttps://codereview.appspot.com/10964043\n\nhttps://codereview.appspot.com/10964043/diff/49001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10964043/diff/49001/transform/transform.go#newcode181\ntransform/transform.go:181: // bytes are available to complete a Transform, the bytes will be buffered\nOn 2013/07/18 10:22:18, r wrote:\n> s/are //\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/49001/transform/transform.go#newcode181\ntransform/transform.go:181: // bytes are available to complete a Transform, the bytes will be buffered\nOn 2013/07/18 10:22:18, r wrote:\n> s/are //\n\nDone.\n\nhttps://codereview.appspot.com/10964043/diff/49001/transform/transform.go#newcode183\ntransform/transform.go:183: // with atEOF == true.\nIt is a redundant addition.  Removing it seems to make things clearer.\n\nOn 2013/07/18 10:22:18, r wrote:\n> what's this line? or is it just out of place? anyway please clarify.",
			"disapproval": false,
			"date": "2013-07-24 14:26:08.699310",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"mpvl@golang.org",
				"nigeltao@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, r@golang.org (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://code.google.com/p/go.text/",
			"disapproval": false,
			"date": "2013-07-05 15:44:47.773540",
			"approval": false
		}
	],
	"owner_email": "mpvl@golang.org",
	"private": false,
	"base_url": "",
	"owner": "mpvl",
	"subject": "code review 10964043: go.text/transform: implementation of Writer, Chain, Nop...",
	"created": "2013-07-05 15:43:57.754990",
	"patchsets": [
		1,
		3001,
		11001,
		9002,
		19001,
		25001,
		33001,
		36001,
		44001,
		49001,
		52001
	],
	"modified": "2013-07-24 14:26:10.482390",
	"closed": true,
	"issue": 10964043
}