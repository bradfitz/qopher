{
	"description": "goauth2: adding a jwt package to support server to server applications.\n\nThe jwt package allows the user to define a jwt.Token containing the\nrequired and optional fields for constructing the serialized and encoded\nJWT to be used for requesting an access_token.  Integrating this package\ninto oauth/oauth.go will require some redesign of the parent package.\nThese changes have been postponed for a later CL.\n\nThe descriptions of the standards this change implements can be found on\nthe following web page.\n\nhttps://developers.google.com/accounts/docs/OAuth2ServiceAccount\n\nThis addition to the library will allow for example a GAE instance to\nmake requests to service like BigQuery.",
	"cc": [
		"bradfitz@google.com",
		"golang-dev@googlegroups.com",
		"tiziana@google.com"
	],
	"reviewers": [
		"adg@google.com",
		"adg@golang.org",
		"jcgregorio@google.com",
		"iant@google.com",
		"gavaletz@gmail.com"
	],
	"messages": [
		{
			"sender": "adg@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "In its current state, we might as well put a function in the jwt\r\npackage that returns an *oauth.Token and leave the oauth package\r\nalone.\r\n\r\nI think that's probably the only reasonable way to proceed without\r\nredesigning the oauth package, which is something I'd like to do but\r\nnot now.\r\n\r\nPlease do that. More review comments to follow.\r\n\r\nAndrew\r\n",
			"disapproval": false,
			"date": "2012-08-01 07:43:17.190420",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"jcgregorio@google.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go\nFile oauth/jwt/jwt.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode48\noauth/jwt/jwt.go:48: type Segment interface {\nThis doesn't seem to be used anywhere.\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode161\noauth/jwt/jwt.go:161: func (t *Token) Assertion() (string, error) {\nmake this Encode, as it was before\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode225\noauth/jwt/jwt.go:225: func (t *Token) BuildRequest() (*http.Request, error) {\nLet's combine this with HandleResponse and rename it to \n\nfunc (*Token) Assert() (*oauth.Token, error)",
			"disapproval": false,
			"date": "2012-08-01 07:45:19.797150",
			"approval": false
		},
		{
			"sender": "jcgregorio@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6452058/diff/7004/oauth/jwt/jwt.go\nFile oauth/jwt/jwt.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/7004/oauth/jwt/jwt.go#newcode100\noauth/jwt/jwt.go:100: // one hour from then (or the time in the request)?\nThe exp time is the time that this assertion will expire. It has no bearing on the lifetime of the access_token you receive.\n\nYes, you could encode an assertion and sit on it and then send it to the server, as long as you send it before the 'exp' time is reached it will still work.",
			"disapproval": false,
			"date": "2012-08-02 18:41:22.405450",
			"approval": false
		},
		{
			"sender": "jcgregorio@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6452058/diff/7004/oauth/jwt/jwt.go\nFile oauth/jwt/jwt.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/7004/oauth/jwt/jwt.go#newcode100\noauth/jwt/jwt.go:100: // one hour from then (or the time in the request)?\nAgreed, do not try to reuse a JWT.\n\nOn 2012/08/02 19:09:37, gavaletz_google wrote:\n> On 2012/08/02 18:41:22, jcgregorio_google wrote:\n> > The exp time is the time that this assertion will expire. It has no bearing on\n> > the lifetime of the access_token you receive.\n> > \n> > Yes, you could encode an assertion and sit on it and then send it to the\n> server,\n> > as long as you send it before the 'exp' time is reached it will still work.\n> \n> Ok, so that means that the encoded JWT can be used to request an access_token\n> for up to one hour from the time it was encoded.  If the access_token were to\n> expire before the expiration of the JWT then we could use the same JWT to\n> request a fresh access_token.  That said, since the access_token expires in an\n> hour it effectively makes the encoded JWT disposable.\n> \n> Unless there is a common circumstance where a access_token would expire in less\n> than an hour I don't think it makes sense to try to re-use a JWT for a corner\n> case.\n> \n> Do you agree?\n>",
			"disapproval": false,
			"date": "2012-08-02 19:20:58.778180",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"jcgregorio@google.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello adg@google.com (cc: bradfitz@google.com, golang-dev@googlegroups.com, jcgregorio@google.com, tiziana@google.com),\n\nI'd like you to review this change to\nhttps://code.google.com/p/goauth2/",
			"disapproval": false,
			"date": "2012-07-27 21:05:56.020360",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6452058/diff/7004/oauth/jwt/jwt.go\nFile oauth/jwt/jwt.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/7004/oauth/jwt/jwt.go#newcode100\noauth/jwt/jwt.go:100: // one hour from then (or the time in the request)?\nOn 2012/08/02 18:41:22, jcgregorio_google wrote:\n> The exp time is the time that this assertion will expire. It has no bearing on\n> the lifetime of the access_token you receive.\n> \n> Yes, you could encode an assertion and sit on it and then send it to the server,\n> as long as you send it before the 'exp' time is reached it will still work.\n\nOk, so that means that the encoded JWT can be used to request an access_token for up to one hour from the time it was encoded.  If the access_token were to expire before the expiration of the JWT then we could use the same JWT to request a fresh access_token.  That said, since the access_token expires in an hour it effectively makes the encoded JWT disposable.\n\nUnless there is a common circumstance where a access_token would expire in less than an hour I don't think it makes sense to try to re-use a JWT for a corner case.\n\nDo you agree?",
			"disapproval": false,
			"date": "2012-08-02 19:09:37.551000",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello adg@google.com, adg@golang.org, jcgregorio@google.com (cc: bradfitz@google.com, golang-dev@googlegroups.com, tiziana@google.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-08-02 19:44:36.107400",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"jcgregorio@google.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I am still thinking about how to integrate. I think this approach is wrong.\n\nOne thing we don't want to lose is the ability to refresh the token. That transparent refresh is one of the only things that the oauth package buys us - otherwise we might as well just write a separate jwt package.\n\nMaybe there's an argument for a \n\ntype TokenUpdater interface {\n    UpdateToken(*Token, v url.Values) error\n}\n\nAnd then we can have a TokenUpdater field in oauth.Config, which, if nil, uses the default implementaiton. Then our jwt.Token can implement UpdateToken.\n\nHow does that feel to you?\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go\nFile oauth/jwt/jwt.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode8\noauth/jwt/jwt.go:8: \"../../oauth\"\ncode.google.com/p/goauth2/oauth",
			"disapproval": false,
			"date": "2012-07-30 09:24:26.385110",
			"approval": false
		},
		{
			"sender": "jcgregorio@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Jul 30, 2012 at 11:59 AM, Eric Gavaletz <gavaletz@google.com> wrote:\r\n> I just need to know that we are all on the same page, and that I am reading\r\n> the documentation the same way everyone else is.\r\n>\r\n> When you say \"this approach\" are you referring to the way that things are\r\n> implemented now, or the way I suggested in our original thread (copied here\r\n> for clarity).  This proposal does not lose the ability to refresh the token\r\n> for the client login, but since there is no refresh support for service\r\n> accounts it makes sense to just alias it to re-encode and sign a new JWT and\r\n> use it to request a new access token.\r\n\r\nIn the Python client library I broke apart things into Flows and\r\nCredentials. The Credentials\r\nare what does the auth, and the Flows represent the oauth dance you\r\nhave to go through\r\nto get a Credential. Usually you go through the dance to get a\r\nCredentials, but there\r\nare cases, like the SignedJwtAssertionCredentials, where you can just\r\nconstruct one and use it\r\ndirectly. See this page for more details:\r\n\r\n  https://developers.google.com/api-client-library/python/guide/aaa_oauth\r\n\r\nI think this would map to goauth as Transport taking in a Credentials\r\nobject, Credentials objects\r\nthat know how to refresh themselves, and many of the operations on\r\nTransport being moved\r\ninto a Flow object, but I'm not sure how idiomatic that is in Go.\r\n\r\n>\r\n> I think that this post by one of the oauth2.0 specification authors brings\r\n> important context to this discussion.  In particular It seems that the\r\n> specification has so much extensibility and flexibility that pretty much\r\n> anything goes (and it shows).  The fact that there are many different ways\r\n> to authenticate (and that they are covered under the OAuth 2.0 umbrella)\r\n> does not mean that they operate the same.\r\n\r\nI don't quite agree with Eran's position, here's my public thoughts on\r\nthe subject:\r\n\r\n  https://plus.google.com/u/0/118148240205592032989/posts/Qudedrg7JqJ\r\n\r\n  -joe\r\n\r\n\r\n>\r\n> Oauth 2.0 user login and service accounts are very different, but should be\r\n> included in the same package as long as we pretend that this is one\r\n> specification - protocol sic.\r\n>\r\n> BEGIN\r\n> PASTE============================================================================\r\n>\r\n> I have implemented what we talked about (CL 6452058), but I think that after\r\n> looking at it with fresh eyes that something is off.\r\n>\r\n> The first thing is that the oauth.Config is an Assertion of sorts and it\r\n> feels weird to be using it this way.  For instance there is nothing used\r\n> from the oauth.Config in the\r\n>\r\n> func (*Config) Assert(Assertion) (*Token, error)\r\n>\r\n> function.  What I see the practical interface for the Assertions being is\r\n> something like this:\r\n>\r\n> type Assertion interface {\r\n>         BuildRequest() (*http.Request, error)\r\n>         BuildRefreshRequest() (*http.Request, error) // In the case of JWT\r\n> this would alias BuildRequest.\r\n>         HandleResponse(*http.Response) (*Token, error)\r\n> }\r\n>\r\n> Then we could have:\r\n>\r\n> type Transport struct {\r\n>         *Assertion\r\n>         *Token\r\n>         Transport http.RoundTripper\r\n> }\r\n>\r\n> Where Config implements the Assertion interface.  The interface we talked\r\n> about last night means that the Assert function could get complicated and\r\n> need to handle funky corner cases (the Oauth2 site lists 6 different cases\r\n> for authentication!).\r\n>\r\n> Withing Transport we could have something as simple as:\r\n>\r\n> func (t *Transport) Exchange() error {\r\n>         req, err := t.Assertion.BuildRequest()\r\n>         if err != nil {\r\n>                 return err\r\n>         }\r\n>         c := &http.Client{}\r\n>         resp, err := c.Do(req)\r\n>         if err != nil {\r\n>                 return err\r\n>         }\r\n>         t.Token, err = t.Assertion.HandleResponse(resp)\r\n>         return err\r\n> }\r\n>\r\n> // The refresh function would be almost the same except it would use a\r\n> BuildRefreshRequest.\r\n>\r\n> t := &Transport{\r\n>         Assertion: jwt, // Or a config\r\n> }\r\n>\r\n> err := t.Exchange()\r\n> ...\r\n> err := t.Refresh()\r\n>\r\n> END\r\n> PASTE==============================================================================\r\n>\r\n>\r\n> On Mon, Jul 30, 2012 at 2:24 AM, <adg@golang.org> wrote:\r\n>>\r\n>> I am still thinking about how to integrate. I think this approach is\r\n>> wrong.\r\n>>\r\n>> One thing we don't want to lose is the ability to refresh the token.\r\n>> That transparent refresh is one of the only things that the oauth\r\n>> package buys us - otherwise we might as well just write a separate jwt\r\n>> package.\r\n>>\r\n>> Maybe there's an argument for a\r\n>>\r\n>> type TokenUpdater interface {\r\n>>     UpdateToken(*Token, v url.Values) error\r\n>> }\r\n>>\r\n>> And then we can have a TokenUpdater field in oauth.Config, which, if\r\n>> nil, uses the default implementaiton. Then our jwt.Token can implement\r\n>> UpdateToken.\r\n>>\r\n>> How does that feel to you?\r\n>>\r\n>>\r\n>> http://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go\r\n>> File oauth/jwt/jwt.go (right):\r\n>>\r\n>> http://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode8\r\n>> oauth/jwt/jwt.go:8: \"../../oauth\"\r\n>> code.google.com/p/goauth2/oauth\r\n>>\r\n>> http://codereview.appspot.com/6452058/\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2012-07-30 16:50:05.827490",
			"approval": false
		},
		{
			"sender": "adg@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 8 August 2012 10:50, Eric Gavaletz <gavaletz@google.com> wrote:\r\n> Yes, and given the feedback that Joe has gotten on the issue with the .p12\r\n> file I think I am going to have to include commentary about unpacking the\r\n> key using openssl.  My GSoC student also highlighted that there was an issue\r\n> with having an assert method that makes use of the default http client.\r\n> When running on GAE we need to be able to use the url fetch.  So I am going\r\n> to have to take another look at that too.\r\n>\r\n> For something that should have been a simple fix it is taking a lot of time\r\n> and effort.  I appreciate your patience and will have an updated CL to you\r\n> soon.\r\n\r\nI appreciate your hard work more :-)\r\n\r\nThanks.\r\n",
			"disapproval": false,
			"date": "2012-08-08 00:51:44.119310",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I just need to know that we are all on the same page, and that I am reading\r\nthe documentation the same way everyone else is.\r\n\r\nWhen you say \"this approach\" are you referring to the way that things are\r\nimplemented now, or the way I suggested in our original thread (copied here\r\nfor clarity).  This proposal does not lose the ability to refresh the token\r\nfor the client login, but since there is no refresh support for service\r\naccounts it makes sense to just alias it to re-encode and sign a new JWT\r\nand use it to request a new access token.\r\n\r\nI think that this\r\npost<http://hueniverse.com/2012/07/oauth-2-0-and-the-road-to-hell/>by\r\none of the oauth2.0 specification authors brings important context to\r\nthis discussion.  In particular It seems that the specification has so\r\nmuch extensibility and flexibility that pretty much anything goes (and it\r\nshows).  The fact that there are many different ways to authenticate (and\r\nthat they are covered under the OAuth 2.0 umbrella) does not mean that they\r\noperate the same.\r\n\r\nOauth 2.0 user login and service accounts are very different, but should be\r\nincluded in the same package as long as we pretend that this is one\r\nspecification - protocol sic.\r\n\r\nBEGIN\r\nPASTE============================================================================\r\n\r\nI have implemented what we talked about (CL 6452058), but I think that\r\nafter looking at it with fresh eyes that something is off.\r\n\r\nThe first thing is that the oauth.Config is an Assertion of sorts and it\r\nfeels weird to be using it this way.  For instance there is nothing used\r\nfrom the oauth.Config in the\r\n\r\nfunc (*Config) Assert(Assertion) (*Token, error)\r\n\r\nfunction.  What I see the practical interface for the Assertions being is\r\nsomething like this:\r\n\r\ntype Assertion interface {\r\n        BuildRequest() (*http.Request, error)\r\n        BuildRefreshRequest() (*http.Request, error) // In the case of JWT\r\nthis would alias BuildRequest.\r\n        HandleResponse(*http.Response) (*Token, error)\r\n}\r\n\r\nThen we could have:\r\n\r\ntype Transport struct {\r\n\r\n        *Assertion\r\n        *Token\r\n        Transport http.RoundTripper\r\n}\r\n\r\nWhere Config implements the Assertion interface.  The interface we talked\r\nabout last night means that the Assert function could get complicated and\r\nneed to handle funky corner cases (the Oauth2 site lists 6 different cases\r\nfor authentication!).\r\n\r\nWithing Transport we could have something as simple as:\r\n\r\nfunc (t *Transport) Exchange() error {\r\n\r\n        req, err := t.Assertion.BuildRequest()\r\n\r\n        if err != nil {\r\n\r\n                return err\r\n\r\n        }\r\n\r\n        c := &http.Client{}\r\n\r\n        resp, err := c.Do(req)\r\n\r\n        if err != nil {\r\n\r\n                return err\r\n\r\n        }\r\n\r\n        t.Token, err = t.Assertion.HandleResponse(resp)\r\n\r\n        return err\r\n}\r\n\r\n// The refresh function would be almost the same except it would use a\r\nBuildRefreshRequest.\r\n\r\nt := &Transport{\r\n        Assertion: jwt, // Or a config\r\n}\r\n\r\nerr := t.Exchange()\r\n...\r\nerr := t.Refresh()\r\n\r\nEND\r\nPASTE==============================================================================\r\n\r\n\r\nOn Mon, Jul 30, 2012 at 2:24 AM, <adg@golang.org> wrote:\r\n\r\n> I am still thinking about how to integrate. I think this approach is\r\n> wrong.\r\n>\r\n> One thing we don't want to lose is the ability to refresh the token.\r\n> That transparent refresh is one of the only things that the oauth\r\n> package buys us - otherwise we might as well just write a separate jwt\r\n> package.\r\n>\r\n> Maybe there's an argument for a\r\n>\r\n> type TokenUpdater interface {\r\n>     UpdateToken(*Token, v url.Values) error\r\n> }\r\n>\r\n> And then we can have a TokenUpdater field in oauth.Config, which, if\r\n> nil, uses the default implementaiton. Then our jwt.Token can implement\r\n> UpdateToken.\r\n>\r\n> How does that feel to you?\r\n>\r\n>\r\n> http://codereview.appspot.com/**6452058/diff/1001/oauth/jwt/**jwt.go<http://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go>\r\n> File oauth/jwt/jwt.go (right):\r\n>\r\n> http://codereview.appspot.com/**6452058/diff/1001/oauth/jwt/**\r\n> jwt.go#newcode8<http://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode8>\r\n> oauth/jwt/jwt.go:8: \"../../oauth\"\r\n> code.google.com/p/goauth2/**oauth <http://code.google.com/p/goauth2/oauth>\r\n>\r\n> http://codereview.appspot.com/**6452058/<http://codereview.appspot.com/6452058/>\r\n>\r\n",
			"disapproval": false,
			"date": "2012-07-30 16:00:20.015790",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Borrowing from your public thoughts on the subject:\r\n\r\n\"Breaking the protocol apart into separate flows for different situations\r\nallows each of those flows to be easier to understand and implement\r\ncorrectly.\"\r\n\r\nWhen Andrew and I were first discussing how integrate JWT into the existing\r\nlibrary, the idea of adding another level of abstraction didn't sound  good\r\nto Andrew.  Being very new to Go I was easily convinced, but now I am not\r\nso sure.  To borrow Joe's analogy of a dance, it isn't just enough to do\r\nthe same dance (flow) with a different partner (authorization code/JWT),\r\nbut based on the type of credentials you have (and the desired result)\r\nthere is a different dance altogether.\r\n\r\nAlso taking from the Google\r\ndocumentation<https://developers.google.com/accounts/docs/OAuth2Login>\r\n:\r\n\r\n\"Given the security implications of getting the implementation correct, we *\r\nstrongly* encourage developers to use OAuth 2.0 libraries when interacting\r\nwith Google's OAuth 2.0 endpoints (see Client\r\nlibraries<https://developers.google.com/accounts/docs/OAuth2#libraries>\r\nfor\r\nmore information). \"\r\n\r\nI think that given the complexity and the various dances based on input\r\nthat we should make this easier on the developer depending on the library.\r\n I think having a Credentials->(OpenIdConnectConfig/JWT) that is used by a\r\nTransport to initiate/refresh an authenticated connection seems like the\r\nway to go.  This level of abstraction will probably be useful in the future\r\nas this specification is a moving target and again according to the\r\nGoogle documentation \"these Google endpoints will update as the\r\nspecification matures.\"\r\n\r\nWith that in mind the interface for the Assertion (Credentials in Joe's\r\nresponse) may still not be generic enough to handle the various dances that\r\noauth requires (or will require).\r\n\r\ntype Assertion interface {\r\n        BuildRequest() (*http.Request, error)\r\n        BuildRefreshRequest() (*http.Request, error) // In the case of JWT\r\nthis would alias BuildRequest.\r\n        HandleResponse(*http.Response) (*Token, error)\r\n}\r\n\r\nThis case does not handle the SignedJwtAssertionCredentials type flow/dance\r\nand would mean that we would again have to take on this pain again in the\r\nfuture.\r\n\r\n~Eric\r\n\r\n\r\nOn Mon, Jul 30, 2012 at 9:50 AM, Joe Gregorio <jcgregorio@google.com> wrote:\r\n\r\n> On Mon, Jul 30, 2012 at 11:59 AM, Eric Gavaletz <gavaletz@google.com>\r\n> wrote:\r\n> > I just need to know that we are all on the same page, and that I am\r\n> reading\r\n> > the documentation the same way everyone else is.\r\n> >\r\n> > When you say \"this approach\" are you referring to the way that things are\r\n> > implemented now, or the way I suggested in our original thread (copied\r\n> here\r\n> > for clarity).  This proposal does not lose the ability to refresh the\r\n> token\r\n> > for the client login, but since there is no refresh support for service\r\n> > accounts it makes sense to just alias it to re-encode and sign a new JWT\r\n> and\r\n> > use it to request a new access token.\r\n>\r\n> In the Python client library I broke apart things into Flows and\r\n> Credentials. The Credentials\r\n> are what does the auth, and the Flows represent the oauth dance you\r\n> have to go through\r\n> to get a Credential. Usually you go through the dance to get a\r\n> Credentials, but there\r\n> are cases, like the SignedJwtAssertionCredentials, where you can just\r\n> construct one and use it\r\n> directly. See this page for more details:\r\n>\r\n>   https://developers.google.com/api-client-library/python/guide/aaa_oauth\r\n>\r\n> I think this would map to goauth as Transport taking in a Credentials\r\n> object, Credentials objects\r\n> that know how to refresh themselves, and many of the operations on\r\n> Transport being moved\r\n> into a Flow object, but I'm not sure how idiomatic that is in Go.\r\n>\r\n> >\r\n> > I think that this post by one of the oauth2.0 specification authors\r\n> brings\r\n> > important context to this discussion.  In particular It seems that the\r\n> > specification has so much extensibility and flexibility that pretty much\r\n> > anything goes (and it shows).  The fact that there are many different\r\n> ways\r\n> > to authenticate (and that they are covered under the OAuth 2.0 umbrella)\r\n> > does not mean that they operate the same.\r\n>\r\n> I don't quite agree with Eran's position, here's my public thoughts on\r\n> the subject:\r\n>\r\n>   https://plus.google.com/u/0/118148240205592032989/posts/Qudedrg7JqJ\r\n>\r\n>   -joe\r\n>\r\n>\r\n> >\r\n> > Oauth 2.0 user login and service accounts are very different, but should\r\n> be\r\n> > included in the same package as long as we pretend that this is one\r\n> > specification - protocol sic.\r\n> >\r\n> > BEGIN\r\n> >\r\n> PASTE============================================================================\r\n> >\r\n> > I have implemented what we talked about (CL 6452058), but I think that\r\n> after\r\n> > looking at it with fresh eyes that something is off.\r\n> >\r\n> > The first thing is that the oauth.Config is an Assertion of sorts and it\r\n> > feels weird to be using it this way.  For instance there is nothing used\r\n> > from the oauth.Config in the\r\n> >\r\n> > func (*Config) Assert(Assertion) (*Token, error)\r\n> >\r\n> > function.  What I see the practical interface for the Assertions being is\r\n> > something like this:\r\n> >\r\n> > type Assertion interface {\r\n> >         BuildRequest() (*http.Request, error)\r\n> >         BuildRefreshRequest() (*http.Request, error) // In the case of\r\n> JWT\r\n> > this would alias BuildRequest.\r\n> >         HandleResponse(*http.Response) (*Token, error)\r\n> > }\r\n> >\r\n> > Then we could have:\r\n> >\r\n> > type Transport struct {\r\n> >         *Assertion\r\n> >         *Token\r\n> >         Transport http.RoundTripper\r\n> > }\r\n> >\r\n> > Where Config implements the Assertion interface.  The interface we talked\r\n> > about last night means that the Assert function could get complicated and\r\n> > need to handle funky corner cases (the Oauth2 site lists 6 different\r\n> cases\r\n> > for authentication!).\r\n> >\r\n> > Withing Transport we could have something as simple as:\r\n> >\r\n> > func (t *Transport) Exchange() error {\r\n> >         req, err := t.Assertion.BuildRequest()\r\n> >         if err != nil {\r\n> >                 return err\r\n> >         }\r\n> >         c := &http.Client{}\r\n> >         resp, err := c.Do(req)\r\n> >         if err != nil {\r\n> >                 return err\r\n> >         }\r\n> >         t.Token, err = t.Assertion.HandleResponse(resp)\r\n> >         return err\r\n> > }\r\n> >\r\n> > // The refresh function would be almost the same except it would use a\r\n> > BuildRefreshRequest.\r\n> >\r\n> > t := &Transport{\r\n> >         Assertion: jwt, // Or a config\r\n> > }\r\n> >\r\n> > err := t.Exchange()\r\n> > ...\r\n> > err := t.Refresh()\r\n> >\r\n> > END\r\n> >\r\n> PASTE==============================================================================\r\n> >\r\n> >\r\n> > On Mon, Jul 30, 2012 at 2:24 AM, <adg@golang.org> wrote:\r\n> >>\r\n> >> I am still thinking about how to integrate. I think this approach is\r\n> >> wrong.\r\n> >>\r\n> >> One thing we don't want to lose is the ability to refresh the token.\r\n> >> That transparent refresh is one of the only things that the oauth\r\n> >> package buys us - otherwise we might as well just write a separate jwt\r\n> >> package.\r\n> >>\r\n> >> Maybe there's an argument for a\r\n> >>\r\n> >> type TokenUpdater interface {\r\n> >>     UpdateToken(*Token, v url.Values) error\r\n> >> }\r\n> >>\r\n> >> And then we can have a TokenUpdater field in oauth.Config, which, if\r\n> >> nil, uses the default implementaiton. Then our jwt.Token can implement\r\n> >> UpdateToken.\r\n> >>\r\n> >> How does that feel to you?\r\n> >>\r\n> >>\r\n> >> http://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go\r\n> >> File oauth/jwt/jwt.go (right):\r\n> >>\r\n> >>\r\n> http://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode8\r\n> >> oauth/jwt/jwt.go:8: \"../../oauth\"\r\n> >> code.google.com/p/goauth2/oauth\r\n> >>\r\n> >> http://codereview.appspot.com/6452058/\r\n> >\r\n> >\r\n>\r\n",
			"disapproval": false,
			"date": "2012-07-30 17:45:29.172130",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"jcgregorio@google.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Responding to feedback.\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go\nFile oauth/jwt/jwt.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode8\noauth/jwt/jwt.go:8: \"../../oauth\"\nOn 2012/07/30 09:24:26, adg wrote:\n> code.google.com/p/goauth2/oauth\n\nThis change has been made; however, I am having trouble getting my tests to run now.  To begin working on the project I checked out the code with \"hg clone https://code.google.com/p/goauth2/\", but should I have used \"go get code.google.com/p/goauth2/oauth\"?  Would that have given me a fully functional hg client?\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode48\noauth/jwt/jwt.go:48: type Segment interface {\nOn 2012/08/01 07:45:19, adg wrote:\n> This doesn't seem to be used anywhere.\n\nRemoved.\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode161\noauth/jwt/jwt.go:161: func (t *Token) Assertion() (string, error) {\nOn 2012/08/01 07:45:19, adg wrote:\n> make this Encode, as it was before\n\nDone.\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/jwt/jwt.go#newcode225\noauth/jwt/jwt.go:225: func (t *Token) BuildRequest() (*http.Request, error) {\nOn 2012/08/01 07:45:19, adg wrote:\n> Let's combine this with HandleResponse and rename it to \n> \n> func (*Token) Assert() (*oauth.Token, error)\n\nI left these two functions in place and moved the Assert function that was in oauth/oauth.go here (with a few edits).\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/oauth.go\nFile oauth/oauth.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/oauth.go#newcode82\noauth/oauth.go:82: type Assertion interface {\nRemoved for now.\n\nhttp://codereview.appspot.com/6452058/diff/1001/oauth/oauth.go#newcode102\noauth/oauth.go:102: func (c *Config) Assert(a Assertion) (*Token, error) {\nMoved to oauth/jwt/jwt.go as:\nfunc (t *Token) Assert() (*oauth.Token, error)",
			"disapproval": false,
			"date": "2012-08-01 18:54:04.204410",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6452058/diff/7004/oauth/jwt/jwt.go\nFile oauth/jwt/jwt.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/7004/oauth/jwt/jwt.go#newcode100\noauth/jwt/jwt.go:100: // one hour from then (or the time in the request)?\nOn 2012/08/02 19:20:59, jcgregorio_google wrote:\n> Agreed, do not try to reuse a JWT.\n> \n> On 2012/08/02 19:09:37, gavaletz_google wrote:\n> > On 2012/08/02 18:41:22, jcgregorio_google wrote:\n> > > The exp time is the time that this assertion will expire. It has no bearing\n> on\n> > > the lifetime of the access_token you receive.\n> > > \n> > > Yes, you could encode an assertion and sit on it and then send it to the\n> > server,\n> > > as long as you send it before the 'exp' time is reached it will still work.\n> > \n> > Ok, so that means that the encoded JWT can be used to request an access_token\n> > for up to one hour from the time it was encoded.  If the access_token were to\n> > expire before the expiration of the JWT then we could use the same JWT to\n> > request a fresh access_token.  That said, since the access_token expires in an\n> > hour it effectively makes the encoded JWT disposable.\n> > \n> > Unless there is a common circumstance where a access_token would expire in\n> less\n> > than an hour I don't think it makes sense to try to re-use a JWT for a corner\n> > case.\n> > \n> > Do you agree?\n> > \n> \n\nCommentary updated to reflect this new understanding.",
			"disapproval": false,
			"date": "2012-08-02 19:45:36.331400",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"jcgregorio@google.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello adg@google.com, adg@golang.org (cc: bradfitz@google.com, golang-dev@googlegroups.com, jcgregorio@google.com, tiziana@google.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-08-01 19:00:09.544740",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go\nFile oauth/jwt/jwt.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode35\noauth/jwt/jwt.go:35: StdAlgorithm     = \"RS256\"\nthese should be unexported\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode42\noauth/jwt/jwt.go:42: ErrInvKey = errors.New(\"Invalid Key\")\nErrInvalidKey\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode63\noauth/jwt/jwt.go:63: type Header struct {\nI'm not sure we should expose this or Signature. The user just constructs the ClaimSet, right, and the rest is all derived from that?\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode229\noauth/jwt/jwt.go:229: // Assert returns an *oauth.Token that can be used to make future requests.  The\nSay what it does. It's obvious that it returns an *oauth.Token. Say that it gets a token by exchanging these credentials.\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode252\noauth/jwt/jwt.go:252: // Most users should simply use the Assert method.\nI would prefer to expose as little as possible in the public API. This makes it easier for us to make changes later on. Let's hide this and the HandleResponse method, for now.",
			"disapproval": false,
			"date": "2012-08-06 02:01:03.606870",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello adg@google.com, adg@golang.org, jcgregorio@google.com (cc: bradfitz@google.com, golang-dev@googlegroups.com, tiziana@google.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-08-06 16:32:51.343570",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello adg@google.com, adg@golang.org, jcgregorio@google.com (cc: bradfitz@google.com, golang-dev@googlegroups.com, tiziana@google.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-08-10 20:26:59.209520",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Sending update to CL 6452058.\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go\nFile oauth/jwt/jwt.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode35\noauth/jwt/jwt.go:35: StdAlgorithm     = \"RS256\"\nOn 2012/08/06 02:01:03, adg wrote:\n> these should be unexported\n\nDone.\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode42\noauth/jwt/jwt.go:42: ErrInvKey = errors.New(\"Invalid Key\")\nOn 2012/08/06 02:01:03, adg wrote:\n> ErrInvalidKey\n\nDone.\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode63\noauth/jwt/jwt.go:63: type Header struct {\nOn 2012/08/06 02:01:03, adg wrote:\n> I'm not sure we should expose this or Signature. The user just constructs the\n> ClaimSet, right, and the rest is all derived from that?\nTo make this work with Google's servers all you would need to fill in is the claim set.  That said even if someone put the necessary values in here to satisfy another server's requirements, it would not change the fact that the signature methods would continue to use RS256.  So I agree that we could hide everything but the claim set for now and always use the StdHeader.\n\nIf that is the case you could simply have the encoded form of the header stored as a constant sting (see const HeaderEnc in jwt_test.go).\n\nSince this would be a significant change I will wait for your response to this comment before making that update.  See more comments on line 139.\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode139\noauth/jwt/jwt.go:139: type Token struct {\nIf we want hide things and making this library so that it only works with Google servers, then we could reduce this down to a union of the ClaimSet and the Key (call it a Config) and just have the \n\nfunc (c *Config) Assert() (*oauth.Token, error) \n\nfunction.\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode229\noauth/jwt/jwt.go:229: // Assert returns an *oauth.Token that can be used to make future requests.  The\nOn 2012/08/06 02:01:03, adg wrote:\n> Say what it does. It's obvious that it returns an *oauth.Token. Say that it gets\n> a token by exchanging these credentials.\n\nPTAL\n\nhttp://codereview.appspot.com/6452058/diff/7005/oauth/jwt/jwt.go#newcode252\noauth/jwt/jwt.go:252: // Most users should simply use the Assert method.\nOn 2012/08/06 02:01:03, adg wrote:\n> I would prefer to expose as little as possible in the public API. This makes it\n> easier for us to make changes later on. Let's hide this and the HandleResponse\n> method, for now.\n\nDone.",
			"disapproval": false,
			"date": "2012-08-06 16:30:52.505430",
			"approval": false
		},
		{
			"sender": "iant@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Aug 10, 2012 at 1:32 PM, Eric Gavaletz <gavaletz@google.com> wrote:\r\n> Today is my last day at Google (at least for the next year).  I would like\r\n> to get this submitted before I have to leave, but if there are issues that\r\n> will prevent that how should I handle this using my external email/account\r\n> (gavaletz@gmail.com).\r\n\r\nUnfortunately I think both adg and bradfitz are out today.\r\n\r\nAnybody else feel up on goauth2?\r\n\r\nIan\r\n\r\n> On Fri, Aug 10, 2012 at 1:28 PM, <gavaletz@google.com> wrote:\r\n>>\r\n>> Hello adg@google.com, adg@golang.org, jcgregorio@google.com (cc:\r\n>> bradfitz@google.com, golang-dev@googlegroups.com, tiziana@google.com),\r\n>>\r\n>> Please take another look.\r\n>>\r\n>>\r\n>> http://codereview.appspot.com/6452058/\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2012-08-10 20:58:19.176370",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Yes, and given the feedback that Joe has gotten on the issue with the .p12\r\nfile I think I am going to have to include commentary about unpacking the\r\nkey using openssl.  My GSoC student also highlighted that there was an\r\nissue with having an assert method that makes use of the default http\r\nclient.  When running on GAE we need to be able to use the url fetch.  So I\r\nam going to have to take another look at that too.\r\n\r\nFor something that should have been a simple fix it is taking a lot of time\r\nand effort.  I appreciate your patience and will have an updated CL to you\r\nsoon.\r\n\r\n~Eric\r\n\r\n\r\nOn Tue, Aug 7, 2012 at 5:43 PM, <adg@golang.org> wrote:\r\n\r\n> Am I still waiting on an additional change from you?\r\n>\r\n> http://codereview.appspot.com/**6452058/<http://codereview.appspot.com/6452058/>\r\n>\r\n",
			"disapproval": false,
			"date": "2012-08-08 00:50:36.205170",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello adg@google.com, adg@golang.org, jcgregorio@google.com (cc: bradfitz@google.com, golang-dev@googlegroups.com, tiziana@google.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-08-10 20:28:59.103870",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Since this CL has a fair amount of history I guess the better question\r\nwould be how to continue working on this CL with my gmail account.  I am\r\nnew to this review system and mercurial.  Would it be sufficient to tar the\r\ndirectory and login to the review system with my gmail address?\r\n\r\n~Eric\r\n\r\n\r\nOn Fri, Aug 10, 2012 at 1:58 PM, Ian Lance Taylor <iant@google.com> wrote:\r\n\r\n> On Fri, Aug 10, 2012 at 1:32 PM, Eric Gavaletz <gavaletz@google.com>\r\n> wrote:\r\n> > Today is my last day at Google (at least for the next year).  I would\r\n> like\r\n> > to get this submitted before I have to leave, but if there are issues\r\n> that\r\n> > will prevent that how should I handle this using my external\r\n> email/account\r\n> > (gavaletz@gmail.com).\r\n>\r\n> Unfortunately I think both adg and bradfitz are out today.\r\n>\r\n> Anybody else feel up on goauth2?\r\n>\r\n> Ian\r\n>\r\n> > On Fri, Aug 10, 2012 at 1:28 PM, <gavaletz@google.com> wrote:\r\n> >>\r\n> >> Hello adg@google.com, adg@golang.org, jcgregorio@google.com (cc:\r\n> >> bradfitz@google.com, golang-dev@googlegroups.com, tiziana@google.com),\r\n> >>\r\n> >> Please take another look.\r\n> >>\r\n> >>\r\n> >> http://codereview.appspot.com/6452058/\r\n> >\r\n> >\r\n>\r\n",
			"disapproval": false,
			"date": "2012-08-10 21:02:12.290340",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Possible issue making use of the .p12 file that Google API console gives us when we expected a un-encrypted .pem file.\n\nhttp://codereview.appspot.com/6452058/diff/11001/oauth/jwt/jwt.go\nFile oauth/jwt/jwt.go (right):\n\nhttp://codereview.appspot.com/6452058/diff/11001/oauth/jwt/jwt.go#newcode142\noauth/jwt/jwt.go:142: Key       []byte\nDue to an upcoming deadline I had to give an \"advanced copy\" of this to my GSoC student to get started.  He did run into a problem with the type of key that the API console gave him.  The key is encrypted using the \"notasecret\" password, and to get a pem file I used openssl like this:\n\nopenssl pkcs12 -in <privatekey.p12> -nocerts -passin pass:notasecret -nodes -out <privatekey.pem>\n\nObviously we would like to be able to use the key provided by Google directly.  The answer in the pyhton lib can be found in the oauth2client/crypt.py file on line 124:\n\npkey = crypto.load_pkcs12(key, password).get_privatekey()\n\nWhere crypto comes from OpenSSL.  I looked but did not find a way to do this using a std go pkg.  Do you know of a way to avoid putting this in the comments?",
			"disapproval": false,
			"date": "2012-08-06 17:44:47.215210",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Am I still waiting on an additional change from you?",
			"disapproval": false,
			"date": "2012-08-08 00:43:15.505870",
			"approval": false
		},
		{
			"sender": "iant@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Aug 10, 2012 at 2:01 PM, Eric Gavaletz <gavaletz@google.com> wrote:\r\n> Since this CL has a fair amount of history I guess the better question would\r\n> be how to continue working on this CL with my gmail account.  I am new to\r\n> this review system and mercurial.  Would it be sufficient to tar the\r\n> directory and login to the review system with my gmail address?\r\n\r\nI honestly don't know, but worst case you can \"hg clpatch 6452058; hg\r\nchange -D 6452058\" and then start a new CL with your non-Google\r\naccount.\r\n\r\nIan\r\n\r\n\r\n> On Fri, Aug 10, 2012 at 1:58 PM, Ian Lance Taylor <iant@google.com> wrote:\r\n>>\r\n>> On Fri, Aug 10, 2012 at 1:32 PM, Eric Gavaletz <gavaletz@google.com>\r\n>> wrote:\r\n>> > Today is my last day at Google (at least for the next year).  I would\r\n>> > like\r\n>> > to get this submitted before I have to leave, but if there are issues\r\n>> > that\r\n>> > will prevent that how should I handle this using my external\r\n>> > email/account\r\n>> > (gavaletz@gmail.com).\r\n>>\r\n>> Unfortunately I think both adg and bradfitz are out today.\r\n>>\r\n>> Anybody else feel up on goauth2?\r\n>>\r\n>> Ian\r\n>>\r\n>> > On Fri, Aug 10, 2012 at 1:28 PM, <gavaletz@google.com> wrote:\r\n>> >>\r\n>> >> Hello adg@google.com, adg@golang.org, jcgregorio@google.com (cc:\r\n>> >> bradfitz@google.com, golang-dev@googlegroups.com, tiziana@google.com),\r\n>> >>\r\n>> >> Please take another look.\r\n>> >>\r\n>> >>\r\n>> >> http://codereview.appspot.com/6452058/\r\n>> >\r\n>> >\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2012-08-10 21:14:54.920560",
			"approval": false
		},
		{
			"sender": "gavaletz@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Today is my last day at Google (at least for the next year).  I would like\r\nto get this submitted before I have to leave, but if there are issues that\r\nwill prevent that how should I handle this using my external email/account (\r\ngavaletz@gmail.com).\r\n\r\n~Eric\r\n\r\n\r\nOn Fri, Aug 10, 2012 at 1:28 PM, <gavaletz@google.com> wrote:\r\n\r\n> Hello adg@google.com, adg@golang.org, jcgregorio@google.com (cc:\r\n> bradfitz@google.com, golang-dev@googlegroups.com, tiziana@google.com),\r\n>\r\n> Please take another look.\r\n>\r\n>\r\n> http://codereview.appspot.com/**6452058/<http://codereview.appspot.com/6452058/>\r\n>\r\n",
			"disapproval": false,
			"date": "2012-08-10 20:32:24.412760",
			"approval": false
		},
		{
			"sender": "gavaletz@gmail.com",
			"recipients": [
				"gavaletz@google.com",
				"adg@google.com",
				"adg@golang.org",
				"jcgregorio@google.com",
				"iant@google.com",
				"gavaletz@gmail.com",
				"bradfitz@google.com",
				"golang-dev@googlegroups.com",
				"tiziana@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I am getting back to work at my university and was wondering what further feedback you have for this.  My personal needs are for the authentication to work for Google services, and with that in mind you can \"hide\" a lot of the details that remain constant for Google services.  This makes the code easier to maintain, but we may want to think about the open issues that relate to other services (Facebook and Microsoft for example) and how we may need to re-think the API.  I think that this JWT implementation would be a good addition to the existing library, but maybe we want to do a major upgrade in the future that addresses the compatibility issues.\n\nHaving to go back and consider all the different OAuth2 mechanisms, use cases and services may call for a design change that breaks the existing API.  I personally don't use Facebook or Microsoft, and adding the ability to work with those services would increase the size and complexity of the library.  There is a growing list of open issues, but given the trouble that we have had with JWT on Google servers I am not excited about the prospects of testing for Facebook, Microsoft, and what ever comes next.\n\n~Eric Gavaletz",
			"disapproval": false,
			"date": "2012-08-21 19:41:49.999730",
			"approval": false
		},
		{
			"sender": "adg@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 22 August 2012 05:41,  <gavaletz@gmail.com> wrote:\r\n> I am getting back to work at my university and was wondering what\r\n> further feedback you have for this.  My personal needs are for the\r\n> authentication to work for Google services, and with that in mind you\r\n> can \"hide\" a lot of the details that remain constant for Google\r\n> services.  This makes the code easier to maintain, but we may want to\r\n> think about the open issues that relate to other services (Facebook and\r\n> Microsoft for example) and how we may need to re-think the API.  I think\r\n> that this JWT implementation would be a good addition to the existing\r\n> library, but maybe we want to do a major upgrade in the future that\r\n> addresses the compatibility issues.\r\n\r\nIt looks fine to me, too. Could you please re-create this CL from your\r\ngmail account so we can polish it up for submission? Thanks.\r\n\r\n> Having to go back and consider all the different OAuth2 mechanisms, use\r\n> cases and services may call for a design change that breaks the existing\r\n> API.  I personally don't use Facebook or Microsoft, and adding the\r\n> ability to work with those services would increase the size and\r\n> complexity of the library.  There is a growing list of open issues, but\r\n> given the trouble that we have had with JWT on Google servers I am not\r\n> excited about the prospects of testing for Facebook, Microsoft, and what\r\n> ever comes next.\r\n\r\nBoth FB and MS's oauth implementations go against the spec, so I'm not\r\ngoing to bend over to support them either. Other contributors have\r\nstepped in to do so in the past, and I'm prepared to let them do it\r\nagain with JWT if necessary.\r\n\r\nAndrew\r\n",
			"disapproval": false,
			"date": "2012-08-22 01:50:02.414260",
			"approval": false
		},
		{
			"sender": "adg@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "You can't. You must start a new one.\r\n\r\nThe history is still there. Just cite the old review URL in the new CL\r\ndescription.\r\n\r\nThanks!\r\n\r\nOn 11 August 2012 07:01, Eric Gavaletz <gavaletz@google.com> wrote:\r\n> Since this CL has a fair amount of history I guess the better question would\r\n> be how to continue working on this CL with my gmail account.  I am new to\r\n> this review system and mercurial.  Would it be sufficient to tar the\r\n> directory and login to the review system with my gmail address?\r\n>\r\n> ~Eric\r\n>\r\n>\r\n> On Fri, Aug 10, 2012 at 1:58 PM, Ian Lance Taylor <iant@google.com> wrote:\r\n>>\r\n>> On Fri, Aug 10, 2012 at 1:32 PM, Eric Gavaletz <gavaletz@google.com>\r\n>> wrote:\r\n>> > Today is my last day at Google (at least for the next year).  I would\r\n>> > like\r\n>> > to get this submitted before I have to leave, but if there are issues\r\n>> > that\r\n>> > will prevent that how should I handle this using my external\r\n>> > email/account\r\n>> > (gavaletz@gmail.com).\r\n>>\r\n>> Unfortunately I think both adg and bradfitz are out today.\r\n>>\r\n>> Anybody else feel up on goauth2?\r\n>>\r\n>> Ian\r\n>>\r\n>> > On Fri, Aug 10, 2012 at 1:28 PM, <gavaletz@google.com> wrote:\r\n>> >>\r\n>> >> Hello adg@google.com, adg@golang.org, jcgregorio@google.com (cc:\r\n>> >> bradfitz@google.com, golang-dev@googlegroups.com, tiziana@google.com),\r\n>> >>\r\n>> >> Please take another look.\r\n>> >>\r\n>> >>\r\n>> >> http://codereview.appspot.com/6452058/\r\n>> >\r\n>> >\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2012-08-22 12:14:01.949670",
			"approval": false
		}
	],
	"owner_email": "gavaletz@google.com",
	"private": false,
	"base_url": "",
	"owner": "gavaletz_google",
	"subject": "code review 6452058: goauth2: adding a jwt package to support server to serv...",
	"created": "2012-07-27 21:02:29.187420",
	"patchsets": [
		1,
		1001,
		7004,
		7005,
		11001,
		6007,
		1007
	],
	"modified": "2012-08-22 12:14:01.949670",
	"closed": false,
	"issue": 6452058
}