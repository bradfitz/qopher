{
	"description": "go.tools/go.types/typemap: a map whose keys are types.\n\ngo/types.Type has an equivalence relation (IsIdentical) that\nis not consistent with the equivalence relation implemented by\nGo's == operator for Types.  Therefore extra work is required\nto build a map whose keys are types.  This package does that\nwork.\n\nHas simple unit test.  More tests might be good.",
	"cc": [
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"gri@golang.org",
		"axwalk@gmail.com"
	],
	"messages": [
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello gri@golang.org (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://code.google.com/p/go.tools",
			"disapproval": false,
			"date": "2013-05-29 18:45:01.093380",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Some initial feedback. More to come.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode2\ngo/types/typemap/typemap.go:2: // types (go/types.Type) to arbitrary values.  Because the equivalence\nAlmost never does some user-defined equivalence relation match a language operator's == relation. Rephrase a bit.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode19\ngo/types/typemap/typemap.go:19: type Entry struct {\nneeds to be exported?\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode182\ngo/types/typemap/typemap.go:182: type Hasher map[types.Type]int\nperhaps not export the internals?\n\ntype Hasher struct {\n   m map...\n}\n\nThis would also be where a Mutex would go if one were to make this thread-safe.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode184\ngo/types/typemap/typemap.go:184: // Hash returns a hash, a function of t such that IsIdentical(x, y) =>\n// Hash computes a hash value for the given type t such that IsIdentical(t, t') => Hash(t) == Hash(t').\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode187\ngo/types/typemap/typemap.go:187: // Since a good hash function must necessarily traverse the entire\nImplementation detail. Shouldn't be in the API.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode193\ngo/types/typemap/typemap.go:193: func (h Hasher) Hash(t types.Type) int {\nresult uint32?\n\nget reproducible results?\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode202\ngo/types/typemap/typemap.go:202: // hashString computes the FNV hash of s.\nhashString computes the Fowler\u2013Noll\u2013Vo (FNV) hash of s.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode203\ngo/types/typemap/typemap.go:203: func hashString(s string) int {\nshouldn't this be a uint32 result always?\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode213\ngo/types/typemap/typemap.go:213: func (h Hasher) hashImpl(t types.Type) int {\ns/hashImpl/hashFor/ ?\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode213\ngo/types/typemap/typemap.go:213: func (h Hasher) hashImpl(t types.Type) int {\ns/int/int32/\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode220\ngo/types/typemap/typemap.go:220: return 9043 + 2*int(t.Len()) + 3*h.Hash(t.Elem())\nwhy + and not ^ ?",
			"disapproval": false,
			"date": "2013-07-09 18:31:49.992540",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Some more comments.\n\nOverall I think it's fine but:\n\n- I think the API can be simplified.\n- You document internals in the API - leave away.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode1\ngo/types/typemap/typemap.go:1: // Package typemap defines type T, a hash-table-based mapping from\nThis package also implements a hash function on types.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode39\ngo/types/typemap/typemap.go:39: hasher Hasher // shared by many typemap.Ts.\nCan this just be a function? That way the implementation is truly flexible.\n\nhash func(Type)int32\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode70\ngo/types/typemap/typemap.go:70: // It returns true if the map shrunk.\nwhat is the return value used for? If somebody is interested, they can just call Len() twice.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode74\ngo/types/typemap/typemap.go:74: hash := m.hasher.Hash(k)\nthis would become\n\nh := m.hash(k)\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode92\ngo/types/typemap/typemap.go:92: if m != nil && m.table != nil {\nThis initial portion is shared among several functions. Factor out an index(k Type) int function providing the index.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode122\ngo/types/typemap/typemap.go:122: // Len returns the number of key/value associations in the map.\nLen returns the number of map entries.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode132\ngo/types/typemap/typemap.go:132: func (m *T) AppendEntries(e []Entry) []Entry {\nwhy exported?",
			"disapproval": false,
			"date": "2013-07-09 19:52:27.502700",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode1\ngo/types/typemap/typemap.go:1: // Package typemap defines type T, a hash-table-based mapping from\nOn 2013/07/09 19:52:27, gri wrote:\n> This package also implements a hash function on types.\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode2\ngo/types/typemap/typemap.go:2: // types (go/types.Type) to arbitrary values.  Because the equivalence\nOn 2013/07/09 18:31:50, gri wrote:\n> Almost never does some user-defined equivalence relation match a language\n> operator's == relation. \n\nThat's not quite true.  It's not uncommon to design a datatype with its equivalence relation in mind, e.g. ssa.Id.\n\n> Rephrase a bit.\n\n// The concrete types that implement the Type interface are pointers,\n// but they are not canonical, so the equivalence relation implemented\n// by Go's == operator (and used internally by maps) is not the proper\n// equivalence relation for types.  Additional work is required to\n// build a map whose keys are types.  This package does that work.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode19\ngo/types/typemap/typemap.go:19: type Entry struct {\nOn 2013/07/09 18:31:50, gri wrote:\n> needs to be exported?\n\nYes; see AppendEntries.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode39\ngo/types/typemap/typemap.go:39: hasher Hasher // shared by many typemap.Ts.\nOn 2013/07/09 19:52:27, gri wrote:\n> Can this just be a function? That way the implementation is truly flexible.\n> \n> hash func(Type)int32\n\nIt could be a function, but an interface with a single method is more flexible since it allows you to define String() which makes it less opaque when debugging.  Done.\n\nI don't expect anyone to supply a different implementation of the Hasher interface, only a different instance, though I suppose locking vs nonlocking implementations might be interesting.  What do you think?\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode70\ngo/types/typemap/typemap.go:70: // It returns true if the map shrunk.\nOn 2013/07/09 19:52:27, gri wrote:\n> what is the return value used for? If somebody is interested, they can just call\n> Len() twice.\n\nMany Insert/Delete methods in collections APIs return a boolean indicating \"changed\" as this information always comes for free and it's very convenient for users.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode74\ngo/types/typemap/typemap.go:74: hash := m.hasher.Hash(k)\nOn 2013/07/09 19:52:27, gri wrote:\n> this would become\n> \n> h := m.hash(k)\n\nWith an interface, it remains the same.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode122\ngo/types/typemap/typemap.go:122: // Len returns the number of key/value associations in the map.\nOn 2013/07/09 19:52:27, gri wrote:\n> Len returns the number of map entries.\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode132\ngo/types/typemap/typemap.go:132: func (m *T) AppendEntries(e []Entry) []Entry {\nOn 2013/07/09 19:52:27, gri wrote:\n> why exported?\n\nThis is the only way clients can iterate over the map.\n\nI considered instead an API equivalent to this:\n\n  func (m *T) Entries() []Entry {\n      return m.AppendEntries(nil)\n  }\n\nbut I figured users might want to avoid the allocation by providing their own slice.  Which do you prefer?\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode182\ngo/types/typemap/typemap.go:182: type Hasher map[types.Type]int\nOn 2013/07/09 18:31:50, gri wrote:\n> perhaps not export the internals?\n> \n> type Hasher struct {\n>    m map...\n> }\n> \n> This would also be where a Mutex would go if one were to make this thread-safe.\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode187\ngo/types/typemap/typemap.go:187: // Since a good hash function must necessarily traverse the entire\nOn 2013/07/09 18:31:50, gri wrote:\n> Implementation detail. Shouldn't be in the API.\n\nIt's quite an important detail because it means that if you (say) accept user input in a long running server, and use a global hasher to hash types, it will grow without bound because it holds references to types from all previous requests.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode193\ngo/types/typemap/typemap.go:193: func (h Hasher) Hash(t types.Type) int {\nOn 2013/07/09 18:31:50, gri wrote:\n> result uint32?\n> \n> get reproducible results?\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode202\ngo/types/typemap/typemap.go:202: // hashString computes the FNV hash of s.\nOn 2013/07/09 18:31:50, gri wrote:\n> hashString computes the Fowler\u2013Noll\u2013Vo (FNV) hash of s.\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode203\ngo/types/typemap/typemap.go:203: func hashString(s string) int {\nOn 2013/07/09 18:31:50, gri wrote:\n> shouldn't this be a uint32 result always?\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode213\ngo/types/typemap/typemap.go:213: func (h Hasher) hashImpl(t types.Type) int {\nOn 2013/07/09 18:31:50, gri wrote:\n> s/hashImpl/hashFor/ ?\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode213\ngo/types/typemap/typemap.go:213: func (h Hasher) hashImpl(t types.Type) int {\nOn 2013/07/09 18:31:50, gri wrote:\n> s/int/int32/\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode220\ngo/types/typemap/typemap.go:220: return 9043 + 2*int(t.Len()) + 3*h.Hash(t.Elem())\nOn 2013/07/09 18:31:50, gri wrote:\n> why + and not ^ ?\n\nDoes it matter from an entropy perspective?",
			"disapproval": false,
			"date": "2013-07-09 22:10:35.990940",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/11001/go/types/typemap/typemap.go#newcode92\ngo/types/typemap/typemap.go:92: if m != nil && m.table != nil {\nOn 2013/07/09 19:52:27, gri wrote:\n> This initial portion is shared among several functions. Factor out an index(k\n> Type) int function providing the index.\n\nThere's no good abstraction here since all the intermediate results are also wanted by each caller.",
			"disapproval": false,
			"date": "2013-07-09 22:12:26.814690",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "still more questions\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode23\ngo/types/typemap/typemap.go:23: type Entry struct {\nI'm still not convinced that this is needed. Why can't a client iterate via, say:\n\nfunc (m T) Iterate(func(typ Type, val interface{}))\n\nseems very easy to use\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode47\ngo/types/typemap/typemap.go:47: type T struct {\ns/T/M/ ?\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode53\ngo/types/typemap/typemap.go:53: // Init initializes the hasher of an empty typemap.T.\nI'm not sure the availability of String() is worth the complication of the API. Realistically, nobody (but you, perhaps me) will redefine the hasher.\n\nI think this is an important API, I think it should be as simple and easy to use as possible.\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode102\ngo/types/typemap/typemap.go:102: if m != nil && len(m.table) > 0 {\nif m != nil should suffice\nrange over nil map will do the right thing\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode114\ngo/types/typemap/typemap.go:114: func (m *T) Insert(k types.Type, v interface{}) (prev interface{}) {\nuse typ, val instead of k, v ?\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode225\ngo/types/typemap/typemap.go:225: func MakeHasher() Hasher {\nDefaultHasher()\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode229\ngo/types/typemap/typemap.go:229: type hasher map[types.Type]int32\nwhy not uint32 ? that's what Fowler\u2013Noll\u2013Vo uses. there's no reason to use a signed value.",
			"disapproval": false,
			"date": "2013-07-09 22:55:05.089620",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode23\ngo/types/typemap/typemap.go:23: type Entry struct {\nOn 2013/07/09 22:55:05, gri wrote:\n> I'm still not convinced that this is needed. Why can't a client iterate via,\n> say:\n> \n> func (m T) Iterate(func(typ Type, val interface{}))\n> \n> seems very easy to use\n\nIt seems easy but in fact it's much harder to specify and to implement, and it's probably less efficient.\nWhat is the expected behaviour of the iterator if the user-supplied callback mutates the map?\n\nI've added Entries and Keys methods that are equivalent to AppendX(nil), since this is the common case.  I'd be happy to un-export the Append methods if you think they are confusing.\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode47\ngo/types/typemap/typemap.go:47: type T struct {\nOn 2013/07/09 22:55:05, gri wrote:\n> s/T/M/ ?\n\nI did a little grepping and found only testing.{T,B} as precedents.  I'd always assumed that T meant \"type\" as in \"the primary type of this package\", but perhaps it meant \"test\".  So M for \"map\" seems good.\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode53\ngo/types/typemap/typemap.go:53: // Init initializes the hasher of an empty typemap.T.\nOn 2013/07/09 22:55:05, gri wrote:\n> I'm not sure the availability of String() is worth the complication of the API.\n> Realistically, nobody (but you, perhaps me) will redefine the hasher.\n> \n> I think this is an important API, I think it should be as simple and easy to use\n> as possible.\n\nIt's possible there's a misunderstanding here.  The Hasher interface (or indeed an equivalent function closure) provides two different features:\n\n(1) a hook allowing customization the hash function used by the map; and \n(2) a place to hold the state used by the hash function, e.g. for memoization.\n\nLet me be clear: feature #1 is completely unimportant to me and I would be happy to do away with it.  I cannot conceive of a good reason why you would want to change the hash function, since it has to be consistent with IsIdentical that essentially dictates its entire implementation. Clients implementing their own hash function are likely to get it wrong and have very subtle bugs.\n\nFeature #2 is the sole reason the hasher is exposed.  Hashers need to be stateful, for performance, so they can memoize values already seen.  This makes them not thread-safe.  Clients need to be able to control which M instances collaborate over the same set of types and would therefore benefit by sharing a hasher; and they need to be able to control hasher lifetimes to manage their memory footprint.\n\nThis suggests an alternative approach: make the Hasher type completely opaque.  That's what I've just done.\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode102\ngo/types/typemap/typemap.go:102: if m != nil && len(m.table) > 0 {\nOn 2013/07/09 22:55:05, gri wrote:\n> if m != nil should suffice\n> range over nil map will do the right thing\n\nYes, but this cheap little check saves you from hashing a type in the common case where the map is empty.\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode114\ngo/types/typemap/typemap.go:114: func (m *T) Insert(k types.Type, v interface{}) (prev interface{}) {\nOn 2013/07/09 22:55:05, gri wrote:\n> use typ, val instead of k, v ?\n\nI've changed it to key, val, since that clarifies their role w.r.t. the map abstraction.  That the key is a Type is clear from its type.\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode225\ngo/types/typemap/typemap.go:225: func MakeHasher() Hasher {\nOn 2013/07/09 22:55:05, gri wrote:\n> DefaultHasher()\n\nDefaultHasher() suggests to me that it returns a default, shared *instance* of a hasher, whereas this returns a new, unaliased instance.\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode229\ngo/types/typemap/typemap.go:229: type hasher map[types.Type]int32\nOn 2013/07/09 22:55:05, gri wrote:\n> why not uint32 ? that's what Fowler\u2013Noll\u2013Vo uses. there's no reason to use a\n> signed value.\n\nDone.",
			"disapproval": false,
			"date": "2013-07-10 02:28:12.132810",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "some more comments\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode23\ngo/types/typemap/typemap.go:23: type Entry struct {\nOn 2013/07/10 02:28:12, adonovan wrote:\n> On 2013/07/09 22:55:05, gri wrote:\n> > I'm still not convinced that this is needed. Why can't a client iterate via,\n> > say:\n> > \n> > func (m T) Iterate(func(typ Type, val interface{}))\n> > \n> > seems very easy to use\n> \n> It seems easy but in fact it's much harder to specify and to implement, and it's\n> probably less efficient.\n> What is the expected behaviour of the iterator if the user-supplied callback\n> mutates the map?\n\nExactly the same as for Go maps.\n\n> \n> I've added Entries and Keys methods that are equivalent to AppendX(nil), since\n> this is the common case.  I'd be happy to un-export the Append methods if you\n> think they are confusing.\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode53\ngo/types/typemap/typemap.go:53: // Init initializes the hasher of an empty typemap.T.\nOn 2013/07/10 02:28:12, adonovan wrote:\n> On 2013/07/09 22:55:05, gri wrote:\n> > I'm not sure the availability of String() is worth the complication of the\n> API.\n> > Realistically, nobody (but you, perhaps me) will redefine the hasher.\n> > \n> > I think this is an important API, I think it should be as simple and easy to\n> use\n> > as possible.\n> \n> It's possible there's a misunderstanding here.  The Hasher interface (or indeed\n> an equivalent function closure) provides two different features:\n> \n> (1) a hook allowing customization the hash function used by the map; and \n> (2) a place to hold the state used by the hash function, e.g. for memoization.\n> \n> Let me be clear: feature #1 is completely unimportant to me and I would be happy\n> to do away with it.  I cannot conceive of a good reason why you would want to\n> change the hash function, since it has to be consistent with IsIdentical that\n> essentially dictates its entire implementation. Clients implementing their own\n> hash function are likely to get it wrong and have very subtle bugs.\n> \n> Feature #2 is the sole reason the hasher is exposed.  Hashers need to be\n> stateful, for performance, so they can memoize values already seen.  This makes\n> them not thread-safe.  Clients need to be able to control which M instances\n> collaborate over the same set of types and would therefore benefit by sharing a\n> hasher; and they need to be able to control hasher lifetimes to manage their\n> memory footprint.\n> \n> This suggests an alternative approach: make the Hasher type completely opaque. \n> That's what I've just done.\n\nA single-method interface is equivalent to a closure.\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode102\ngo/types/typemap/typemap.go:102: if m != nil && len(m.table) > 0 {\nOn 2013/07/10 02:28:12, adonovan wrote:\n> On 2013/07/09 22:55:05, gri wrote:\n> > if m != nil should suffice\n> > range over nil map will do the right thing\n> \n> Yes, but this cheap little check saves you from hashing a type in the common\n> case where the map is empty.\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/32001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/32001/go/types/typemap/typemap.go#newcode17\ngo/types/typemap/typemap.go:17: \"code.google.com/p/go.tools/go/types\"\nput this on a separate line, separated by a blank line, at the bottom",
			"disapproval": false,
			"date": "2013-07-10 05:42:35.105300",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode23\ngo/types/typemap/typemap.go:23: type Entry struct {\nOn 2013/07/10 05:42:35, gri wrote:\n> On 2013/07/10 02:28:12, adonovan wrote:\n> > On 2013/07/09 22:55:05, gri wrote:\n> > > I'm still not convinced that this is needed. Why can't a client iterate via,\n> > > say:\n> > > \n> > > func (m T) Iterate(func(typ Type, val interface{}))\n> > > \n> > > seems very easy to use\n> > \n> > It seems easy but in fact it's much harder to specify and to implement, and\n> it's\n> > probably less efficient.\n> > What is the expected behaviour of the iterator if the user-supplied callback\n> > mutates the map?\n> \n> Exactly the same as for Go maps.\n\nBut this is a two level map, and there's a non-trivial amount of iterator machinery built in to the Go runtime that would need to be partially reproduced.  Ranging over the map buckets is the easy part.  Newly added buckets may or may not be visited.  But deletions are more problematic, since they mutate the bucket slice's underlying array by moving the last element to the deleted slot and shrinking the slice by one:  this could cause values to be skipped (if the iterator is between the deleted and final slot) or deleted values to be reported (if the slice held by the iterator is longer than the slice in the map).\n\nI'm not saying it's impossible.  I'm just saying it's much harder, and I haven't yet encountered a compelling need for it.\n\nhttps://codereview.appspot.com/9649044/diff/24001/go/types/typemap/typemap.go#newcode53\ngo/types/typemap/typemap.go:53: // Init initializes the hasher of an empty typemap.T.\nOn 2013/07/10 05:42:35, gri wrote:\n> On 2013/07/10 02:28:12, adonovan wrote:\n> > On 2013/07/09 22:55:05, gri wrote:\n> > > I'm not sure the availability of String() is worth the complication of the\n> > API.\n> > > Realistically, nobody (but you, perhaps me) will redefine the hasher.\n> > > \n> > > I think this is an important API, I think it should be as simple and easy to\n> > use\n> > > as possible.\n> > \n> > It's possible there's a misunderstanding here.  The Hasher interface (or\n> indeed\n> > an equivalent function closure) provides two different features:\n> > \n> > (1) a hook allowing customization the hash function used by the map; and \n> > (2) a place to hold the state used by the hash function, e.g. for memoization.\n> > \n> > Let me be clear: feature #1 is completely unimportant to me and I would be\n> happy\n> > to do away with it.  I cannot conceive of a good reason why you would want to\n> > change the hash function, since it has to be consistent with IsIdentical that\n> > essentially dictates its entire implementation. Clients implementing their own\n> > hash function are likely to get it wrong and have very subtle bugs.\n> > \n> > Feature #2 is the sole reason the hasher is exposed.  Hashers need to be\n> > stateful, for performance, so they can memoize values already seen.  This\n> makes\n> > them not thread-safe.  Clients need to be able to control which M instances\n> > collaborate over the same set of types and would therefore benefit by sharing\n> a\n> > hasher; and they need to be able to control hasher lifetimes to manage their\n> > memory footprint.\n> > \n> > This suggests an alternative approach: make the Hasher type completely opaque.\n> \n> > That's what I've just done.\n> \n> A single-method interface is equivalent to a closure.\n\nYes, but I'm not sure how this relates to the foregoing text.  The current code has neither interface nor closure but an opaque concrete type.",
			"disapproval": false,
			"date": "2013-07-10 13:01:11.033350",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9649044/diff/32001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/32001/go/types/typemap/typemap.go#newcode17\ngo/types/typemap/typemap.go:17: \"code.google.com/p/go.tools/go/types\"\nOn 2013/07/10 05:42:35, gri wrote:\n> put this on a separate line, separated by a blank line, at the bottom\n\nDone.",
			"disapproval": false,
			"date": "2013-07-10 14:31:29.517190",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9649044/diff/37001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/37001/go/types/typemap/typemap.go#newcode48\ngo/types/typemap/typemap.go:48: hasher Hasher // shared by many typemap.Ts.\nno . at end - this is not a sentence\n\nhttps://codereview.appspot.com/9649044/diff/37001/go/types/typemap/typemap.go#newcode49\ngo/types/typemap/typemap.go:49: table  map[uint32][]Entry\nadd a comment\n\n// hash -> bucket mapping\n\nhttps://codereview.appspot.com/9649044/diff/37001/go/types/typemap/typemap.go#newcode50\ngo/types/typemap/typemap.go:50: length int\n// number of map entries\n\nhttps://codereview.appspot.com/9649044/diff/37001/go/types/typemap/typemap.go#newcode71\ngo/types/typemap/typemap.go:71: func (m *M) Init(hasher Hasher) {\nHow about MakeMap(hasher Hasher) M ?\n\nAlternatively, it this is Init, shouldn't it empty the table?\n\nhttps://codereview.appspot.com/9649044/diff/37001/go/types/typemap/typemap.go#newcode87\ngo/types/typemap/typemap.go:87: last := len(bucket) - 1\nAnother way of deleting an entry would be to nil it (tbd if key or value should be nil-ed out, or both). That way, the Go map iteration semantics should be not too hard to obtain.\n\nhttps://codereview.appspot.com/9649044/diff/37001/go/types/typemap/typemap.go#newcode104\ngo/types/typemap/typemap.go:104: if types.IsIdentical(key, e.key) {\nIf Delete nils out the value, this will just work.\n\nhttps://codereview.appspot.com/9649044/diff/37001/go/types/typemap/typemap.go#newcode118\ngo/types/typemap/typemap.go:118: if types.IsIdentical(key, e.key) {\nIf Delete nils out the value, this will just work. Need to be a bit careful with the length, though.\n\nhttps://codereview.appspot.com/9649044/diff/37001/go/types/typemap/typemap.go#newcode313\ngo/types/typemap/typemap.go:313: return uint32(uintptr(unsafe.Pointer(t.Obj())))\ninstead use the hash of the qualified type name\n\nthat said, named types are identical if they are == (if that's not true now, it shouldn't be hard to make true)",
			"disapproval": false,
			"date": "2013-07-10 16:24:15.423930",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nminor knits\n\nlets chat about the Hasher (and perhaps separate CL).\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go#newcode6\ngo/types/typemap/typemap.go:6: // Since they are not canonicalized, == cnnote be used to check for\ns/cnnote/cannot/\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go#newcode15\ngo/types/typemap/typemap.go:15: \"code.google.com/p/go.tools/go/types\"\nthis slipped up again - gofmt trouble?\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go#newcode20\ngo/types/typemap/typemap.go:20: // typemap.M is a hash-table-based mapping from types.Type to\ns/hash-table-based//\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go#newcode27\ngo/types/typemap/typemap.go:27: table  map[uint32][]entry // maps hash to bucket.  An empty entry{} => deleted\n// maps hash to bucket; if entry.key == nil, the entry is unused\n\nIt just happens that those holes only come about though deletion, for now.\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go#newcode86\ngo/types/typemap/typemap.go:86: func (m *M) Get(key types.Type) interface{} {\nAt seems more commonly used the Get for cases like this. Leaving up to you.",
			"disapproval": false,
			"date": "2013-07-10 19:54:29.870780",
			"approval": true
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Looking good, but I think it can be simplified more.\n\nBtw., the advantage of using\n\ntype Hasher func(typ Type) uint32\n\n(with still opaque implementation) would be that 1) you can easily test the map with a hash function that always returns a constant value, and 2) that one has a hash function for types available that might be useful in other contexts.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode6\ngo/types/typemap/typemap.go:6: // but they are not canonical, so the equivalence relation implemented\ncan we just shorten this to:\n\nThe concrete types that implement the Type interface are pointers. Since they are not canonicalized, == cannot be used to check for identity, and thus we cannot simply use a Go map instead.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode28\ngo/types/typemap/typemap.go:28: // Key returns the key (i.e. type) of the association e.\nthis comment is not really needed\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode29\ngo/types/typemap/typemap.go:29: func (e entry) Key() types.Type {\nwhy are these exported?\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode33\ngo/types/typemap/typemap.go:33: // Value returns the value of the association e.\nnot really necessary comment\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode34\ngo/types/typemap/typemap.go:34: func (e entry) Value() interface{} {\nditto\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode43\ngo/types/typemap/typemap.go:43: // typemap.M may be used as a set of types; just use bool or struct{}\nI'm not sure this is necessary to mention. If one sticks in nil, of course one will get out nil all the time.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode48\ngo/types/typemap/typemap.go:48: hasher Hasher             // shared by many typemap.Ms.\nno . needed at end of comment - not a sentence\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode73\ngo/types/typemap/typemap.go:73: // hasher at the first call to Insert.\nShould it be ok to call SetHasher anytime, or only at initialization time?\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode79\ngo/types/typemap/typemap.go:79: // Delete removes the association for type key, if any.\n// Delete removes the entry with the given key, if any.\n\n(let's us map _entry_ - simpler)\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode80\ngo/types/typemap/typemap.go:80: // It returns true if the map shrunk.\nshrunk could be interpreted as referring to memory use.\n\nIt returns true if the entry was found. ?\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode99\ngo/types/typemap/typemap.go:99: // Lookup returns the value associated with key key, if present, or nil\n// At returns the map entry for the given key.\n// The result is nil if the entry is not present.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode102\ngo/types/typemap/typemap.go:102: func (m *M) Lookup(key types.Type) interface{} {\ns/Lookup/At/ ?\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode113\ngo/types/typemap/typemap.go:113: // Insert updates the map to associate key key with value val, and\n// Set sets the map entry for key to val ... (?)\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode115\ngo/types/typemap/typemap.go:115: func (m *M) Insert(key types.Type, value interface{}) (prev interface{}) {\ns/Insert/Set/ ?\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode119\ngo/types/typemap/typemap.go:119: var deleted *entry\ns/deleted/hole/ ?\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode158\ngo/types/typemap/typemap.go:158: // built-in maps, namely: if f deletes a map entry that Iterate has\ns/built-in/Go/\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode158\ngo/types/typemap/typemap.go:158: // built-in maps, namely: if f deletes a map entry that Iterate has\ns/, namely//\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode175\ngo/types/typemap/typemap.go:175: // Keys returns a new slice containing the set of map keys.\nnot clear to me that this is needed\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode222\ngo/types/typemap/typemap.go:222: // A Hasher maps each type to its hash value.\nA Hasher maps each type to its hash value.\nFor efficiency, a hasher uses memoization; thus its memory footprint grows monotonically over time.\n\n(r would use \"memorization\")\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode223\ngo/types/typemap/typemap.go:223: // Hashers are opaque to clients.\nleave away - the code already does this for you\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode232\ngo/types/typemap/typemap.go:232: // graph rooted at t, the hasher memoizes the results of each\nthere's no t anywhere here - confusing comment\n\nleave away in favor of expanded comment above",
			"disapproval": false,
			"date": "2013-07-10 18:58:01.896280",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode6\ngo/types/typemap/typemap.go:6: // but they are not canonical, so the equivalence relation implemented\nOn 2013/07/10 18:58:02, gri wrote:\n> can we just shorten this to:\n> \n> The concrete types that implement the Type interface are pointers. Since they\n> are not canonicalized, == cannot be used to check for identity, and thus we\n> cannot simply use a Go map instead.\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode28\ngo/types/typemap/typemap.go:28: // Key returns the key (i.e. type) of the association e.\nOn 2013/07/10 18:58:02, gri wrote:\n> this comment is not really needed\n\nOops: a relic of when it was exported. Gone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode29\ngo/types/typemap/typemap.go:29: func (e entry) Key() types.Type {\nOn 2013/07/10 18:58:02, gri wrote:\n> why are these exported?\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode33\ngo/types/typemap/typemap.go:33: // Value returns the value of the association e.\nOn 2013/07/10 18:58:02, gri wrote:\n> not really necessary comment\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode34\ngo/types/typemap/typemap.go:34: func (e entry) Value() interface{} {\nOn 2013/07/10 18:58:02, gri wrote:\n> ditto\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode43\ngo/types/typemap/typemap.go:43: // typemap.M may be used as a set of types; just use bool or struct{}\nOn 2013/07/10 18:58:02, gri wrote:\n> I'm not sure this is necessary to mention. If one sticks in nil, of course one\n> will get out nil all the time.\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode48\ngo/types/typemap/typemap.go:48: hasher Hasher             // shared by many typemap.Ms.\nOn 2013/07/10 18:58:02, gri wrote:\n> no . needed at end of comment - not a sentence\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode73\ngo/types/typemap/typemap.go:73: // hasher at the first call to Insert.\nOn 2013/07/10 18:58:02, gri wrote:\n> Should it be ok to call SetHasher anytime, or only at initialization time?\n\nAs it was before, it just worked, as a consequence of this:\n\n  All Hashers are functionally equivalent but contain internal state\n  used to cache the results of hashing previously seen types.\n\nbut now that we've exposed the function-ness of hashers, users can implement their own hash function such that SetHasher will now cause inconsistency.  They can also get the hash function wrong.\n\nPermission to revert a Hasher back to an opaque struct?\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode79\ngo/types/typemap/typemap.go:79: // Delete removes the association for type key, if any.\nOn 2013/07/10 18:58:02, gri wrote:\n> // Delete removes the entry with the given key, if any.\n> \n> (let's us map _entry_ - simpler)\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode80\ngo/types/typemap/typemap.go:80: // It returns true if the map shrunk.\nOn 2013/07/10 18:58:02, gri wrote:\n> shrunk could be interpreted as referring to memory use.\n> \n> It returns true if the entry was found. ?\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode99\ngo/types/typemap/typemap.go:99: // Lookup returns the value associated with key key, if present, or nil\nOn 2013/07/10 18:58:02, gri wrote:\n> // At returns the map entry for the given key.\n> // The result is nil if the entry is not present.\n\nAt suggests indexing.  I've used Get, by analogy with Set.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode102\ngo/types/typemap/typemap.go:102: func (m *M) Lookup(key types.Type) interface{} {\nOn 2013/07/10 18:58:02, gri wrote:\n> s/Lookup/At/ ?\n> \n\nGet.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode113\ngo/types/typemap/typemap.go:113: // Insert updates the map to associate key key with value val, and\nOn 2013/07/10 18:58:02, gri wrote:\n> // Set sets the map entry for key to val ... (?)\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode115\ngo/types/typemap/typemap.go:115: func (m *M) Insert(key types.Type, value interface{}) (prev interface{}) {\nOn 2013/07/10 18:58:02, gri wrote:\n> s/Insert/Set/ ?\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode119\ngo/types/typemap/typemap.go:119: var deleted *entry\nOn 2013/07/10 18:58:02, gri wrote:\n> s/deleted/hole/ ?\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode158\ngo/types/typemap/typemap.go:158: // built-in maps, namely: if f deletes a map entry that Iterate has\nOn 2013/07/10 18:58:02, gri wrote:\n> s/built-in/Go/\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode158\ngo/types/typemap/typemap.go:158: // built-in maps, namely: if f deletes a map entry that Iterate has\nOn 2013/07/10 18:58:02, gri wrote:\n> s/, namely//\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode175\ngo/types/typemap/typemap.go:175: // Keys returns a new slice containing the set of map keys.\nOn 2013/07/10 18:58:02, gri wrote:\n> not clear to me that this is needed\n\nClearly it can be implemented atop the API, but it's proven very useful to me.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode222\ngo/types/typemap/typemap.go:222: // A Hasher maps each type to its hash value.\nOn 2013/07/10 18:58:02, gri wrote:\n> A Hasher maps each type to its hash value.\n> For efficiency, a hasher uses memoization; thus its memory footprint grows\n> monotonically over time.\n\nDone.\n\n> (r would use \"memorization\")\n\nYeah, memoization is awkward, but its use goes back to at least the 60s, and it's even used in the UK where we prefer our words longer. :)\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode223\ngo/types/typemap/typemap.go:223: // Hashers are opaque to clients.\nOn 2013/07/10 18:58:02, gri wrote:\n> leave away - the code already does this for you\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/43001/go/types/typemap/typemap.go#newcode232\ngo/types/typemap/typemap.go:232: // graph rooted at t, the hasher memoizes the results of each\nOn 2013/07/10 18:58:02, gri wrote:\n> there's no t anywhere here - confusing comment\n> \n> leave away in favor of expanded comment above\n\nDone.",
			"disapproval": false,
			"date": "2013-07-10 19:41:10.422730",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "All done.\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go\nFile go/types/typemap/typemap.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go#newcode6\ngo/types/typemap/typemap.go:6: // Since they are not canonicalized, == cnnote be used to check for\nOn 2013/07/10 19:54:30, gri wrote:\n> s/cnnote/cannot/\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go#newcode15\ngo/types/typemap/typemap.go:15: \"code.google.com/p/go.tools/go/types\"\nOn 2013/07/10 19:54:30, gri wrote:\n> this slipped up again - gofmt trouble?\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go#newcode20\ngo/types/typemap/typemap.go:20: // typemap.M is a hash-table-based mapping from types.Type to\nOn 2013/07/10 19:54:30, gri wrote:\n> s/hash-table-based//\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go#newcode27\ngo/types/typemap/typemap.go:27: table  map[uint32][]entry // maps hash to bucket.  An empty entry{} => deleted\nOn 2013/07/10 19:54:30, gri wrote:\n> // maps hash to bucket; if entry.key == nil, the entry is unused\n> \n> It just happens that those holes only come about though deletion, for now.\n\nDone.\n\nhttps://codereview.appspot.com/9649044/diff/48001/go/types/typemap/typemap.go#newcode86\ngo/types/typemap/typemap.go:86: func (m *M) Get(key types.Type) interface{} {\nOn 2013/07/10 19:54:30, gri wrote:\n> At seems more commonly used the Get for cases like this. Leaving up to you.\n\nOk, done.",
			"disapproval": false,
			"date": "2013-07-10 21:56:19.314750",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=6185c3a5abea&repo=tools ***\n\ngo.tools/go.types/typemap: a map whose keys are types.\n\ngo/types.Type has an equivalence relation (IsIdentical) that\nis not consistent with the equivalence relation implemented by\nGo's == operator for Types.  Therefore extra work is required\nto build a map whose keys are types.  This package does that\nwork.\n\nHas simple unit test.  More tests might be good.\n\nR=gri\nCC=golang-dev\nhttps://codereview.appspot.com/9649044",
			"disapproval": false,
			"date": "2013-07-10 21:57:11.002270",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nhttps://codereview.appspot.com/9649044/diff/58001/go/types/typemap/typemap_test.go\nFile go/types/typemap/typemap_test.go (right):\n\nhttps://codereview.appspot.com/9649044/diff/58001/go/types/typemap/typemap_test.go#newcode9\ngo/types/typemap/typemap_test.go:9: \"code.google.com/p/go.tools/go/types\"\nseparate these into a 2nd group",
			"disapproval": false,
			"date": "2013-07-10 21:57:56.617430",
			"approval": true
		},
		{
			"sender": "axwalk@gmail.com",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"axwalk@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/07/10 21:57:11, adonovan wrote:\n> *** Submitted as\n> https://code.google.com/p/go/source/detail?r=6185c3a5abea&repo=tools ***\n> \n> go.tools/go.types/typemap: a map whose keys are types.\n> \n> go/types.Type has an equivalence relation (IsIdentical) that\n> is not consistent with the equivalence relation implemented by\n> Go's == operator for Types.  Therefore extra work is required\n> to build a map whose keys are types.  This package does that\n> work.\n> \n> Has simple unit test.  More tests might be good.\n> \n> R=gri\n> CC=golang-dev\n> https://codereview.appspot.com/9649044\n\nI just saw this went in, and thought I'd take a look at using it in llgo.\nThere are currently two typemaps in llgo (I guess this is standard stuff):\none for generating/caching the LLVM types from types.Types, and one for\ngenerating/caching runtime type structures.\n\nThe first problem I've come across is that the receiver of signatures\nis entirely ignored in hashing, and I see this is the same in\ntypes.IsIdentical. Is there a reason why this should not be added?\n\nCheers,\nAndrew",
			"disapproval": false,
			"date": "2013-07-11 12:38:25.775520",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> The first problem I've come across is that the receiver of signatures\r\n> is entirely ignored in hashing, and I see this is the same in\r\n> types.IsIdentical. Is there a reason why this should not be added?\r\n\r\nThis confused me too.  At some point I convinced myself that it's correct,\r\nat least within the typechecker, because of higher-level invariants:\r\n- the signature of a concrete method (T)func(X) when used as a value is\r\nconverted to a simple func(T, X), with recv=nil.\r\n- lookup.go exploits the lack of receiver checking when matching interface\r\nmethods (recv=nil) against concrete methods (recv!=nil).\r\n- identicalMethods performs pairwise comparisons only of interface methods\r\n(recv==nil)\r\n\r\nBut it's certainly confusing and deserves some commentary and perhaps\r\nauditing.\r\n\r\n\r\nOn 11 July 2013 08:38, <axwalk@gmail.com> wrote:\r\n\r\n> On 2013/07/10 21:57:11, adonovan wrote:\r\n>\r\n>> *** Submitted as\r\n>> https://code.google.com/p/go/**source/detail?r=6185c3a5abea&**repo=tools<https://code.google.com/p/go/source/detail?r=6185c3a5abea&repo=tools>\r\n>>\r\n> ***\r\n>\r\n>  go.tools/go.types/typemap: a map whose keys are types.\r\n>>\r\n>\r\n>  go/types.Type has an equivalence relation (IsIdentical) that\r\n>> is not consistent with the equivalence relation implemented by\r\n>> Go's == operator for Types.  Therefore extra work is required\r\n>> to build a map whose keys are types.  This package does that\r\n>> work.\r\n>>\r\n>\r\n>  Has simple unit test.  More tests might be good.\r\n>>\r\n>\r\n>  R=gri\r\n>> CC=golang-dev\r\n>> https://codereview.appspot.**com/9649044<https://codereview.appspot.com/9649044>\r\n>>\r\n>\r\n> I just saw this went in, and thought I'd take a look at using it in\r\n> llgo.\r\n> There are currently two typemaps in llgo (I guess this is standard\r\n> stuff):\r\n> one for generating/caching the LLVM types from types.Types, and one for\r\n> generating/caching runtime type structures.\r\n>\r\n> The first problem I've come across is that the receiver of signatures\r\n> is entirely ignored in hashing, and I see this is the same in\r\n> types.IsIdentical. Is there a reason why this should not be added?\r\n>\r\n> Cheers,\r\n> Andrew\r\n>\r\n> https://codereview.appspot.**com/9649044/<https://codereview.appspot.com/9649044/>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-07-11 14:22:10.587830",
			"approval": false
		}
	],
	"owner_email": "adonovan@google.com",
	"private": false,
	"base_url": "",
	"owner": "adonovan",
	"subject": "code review 9649044: go.tools/go.types/typemap: a map whose keys are types.",
	"created": "2013-05-29 18:44:21.405810",
	"patchsets": [
		1,
		2001,
		4001,
		8001,
		11001,
		19001,
		22001,
		24001,
		29001,
		32001,
		37001,
		43001,
		48001,
		53001,
		55001,
		58001,
		62001
	],
	"modified": "2013-07-11 14:22:10.913830",
	"closed": true,
	"issue": 9649044
}