{
	"description": "image/gif: add writer implementation",
	"cc": [
		"r@golang.org",
		"nigeltao@golang.org",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Sun, Jul 7, 2013 at 10:35 PM, Nigel Tao <nigeltao@golang.org> wrote:\r\n> On Thu, Jul 4, 2013 at 5:30 PM,  <nigeltao@golang.org> wrote:\r\n>> Encoding full-color image as a GIF involves several steps:\r\n>> 1. calculating an appropriate palette,\r\n>> 2. converting the source image to that palette,\r\n>> 3. writing the paletted image in GIF-specific format (headers, LZW\r\n>> compression, blocks, etc.)\r\n>\r\n> I've had a go at implementing step 2. Please take a look at\r\n> https://codereview.appspot.com/10977043\r\n\r\nStep 2 has been submitted. Step 1 should be covered by\r\nhttps://codereview.appspot.com/11148043/ which adds a draw.Quantizer\r\ninterface:\r\n\r\n// Quantizer produces a palette for an image.\r\ntype Quantizer interface {\r\n        // Quantize appends up to cap(p) - len(p) colors to p and returns the\r\n        // updated palette suitable for converting m to a paletted image.\r\n        Quantize(p color.Palette, m image.Image) color.Palette\r\n}\r\n\r\nI think that this CL should focus on step 3, and Options should be\r\n\r\ntype Options struct {\r\n       NumColors int\r\n       Quantizer draw.Quantizer\r\n       Drawer draw.Drawer\r\n}\r\n\r\nIf NumColors is zero then use 256. If Quantizer is zero (nil), then\r\njust use color.Plan9Palette as a standard palette. If Drawer is zero\r\nthen use draw.FloydSteinberg.\r\n\r\nMedianCut will implement Quantizer but I don't think that it belongs\r\nin the standard library yet. You are of course free to host it on\r\ngithub, code.google.com, etc.\r\n",
			"disapproval": false,
			"date": "2013-07-11 04:49:54.252860",
			"approval": false
		},
		{
			"sender": "andybons@chromium.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "ptal\n\nRemoved mediancut.go.\n\nWhat is the purpose of returning a color.Palette from Quantize in addition to potentially altering the one passed in? Would there be a difference between the two at return time?",
			"disapproval": false,
			"date": "2013-07-11 18:37:21.637780",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Jul 12, 2013 at 4:37 AM,  <andybons@chromium.org> wrote:\r\n> What is the purpose of returning a color.Palette from Quantize in\r\n> addition to potentially altering the one passed in? Would there be a\r\n> difference between the two at return time?\r\n\r\nCall the argument palette p and the returned one q. len(p) should be\r\nless than cap(p), and len(q) should be greater than len(p).\r\n\r\n// Quantize appends up to cap(p) - len(p) colors to p and returns the\r\n// updated palette suitable for converting m to a paletted image.\r\nQuantize(p color.Palette, m image.Image) color.Palette\r\n",
			"disapproval": false,
			"date": "2013-07-11 22:29:16.318640",
			"approval": false
		},
		{
			"sender": "andybons@chromium.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/07/11 22:29:16, nigeltao wrote:\n> On Fri, Jul 12, 2013 at 4:37 AM,  <mailto:andybons@chromium.org> wrote:\n> > What is the purpose of returning a color.Palette from Quantize in\n> > addition to potentially altering the one passed in? Would there be a\n> > difference between the two at return time?\n> \n> Call the argument palette p and the returned one q. len(p) should be\n> less than cap(p), and len(q) should be greater than len(p).\n\nGot it. I believe I\u2019m doing what I should be, then. Let me know if that\u2019s not the case.",
			"disapproval": false,
			"date": "2013-07-11 23:15:15.612680",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go\nFile src/pkg/image/gif/writer.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode25\nsrc/pkg/image/gif/writer.go:25: func log2Int256(x int) int {\nJust call the function log2.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode129\nsrc/pkg/image/gif/writer.go:129: // TODO: GIF87a could be valid depending on the features that\nI wouldn't bother. Just assume GIF89a.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode179\nsrc/pkg/image/gif/writer.go:179: e.buf[3*i] = uint8(r >> 8)\nI'd add a +0 for symmetry. The compiler should take it back out.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode203\nsrc/pkg/image/gif/writer.go:203: if b.Dx() >= 1<<16 || b.Dy() >= 1<<16 || b.Min.X >= 1<<16 || b.Min.Y >= 1<<16 {\nYou should also check b.Min.X < 0 and likewise for Y.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode256\nsrc/pkg/image/gif/writer.go:256: bw := &blockWriter{w: e.w}\nYou shouldn't need to allocate a blockWriter for each call to writeImageBlock. In fact, you could probably re-use the encoder's tmp buffer:\n\ntype blockWriter struct {\n  e *encoder\n}\n\nfunc (b blockWriter) Write(data []byte) (int, error) {\n  if b.e.err != nil {\n    return 0, b.e.err\n  }\n  etc\n}\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode268\nsrc/pkg/image/gif/writer.go:268: const DefaultNumColors = 256\nI'm not sure that this constant is worth exporting, or even defining.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode299\nsrc/pkg/image/gif/writer.go:299: e := newEncoder(w)\nIt doesn't seem worth defining a newEncoder function. Just inline it:\n\ne := encoder{ g: g }\nif ww, ok := w.(writer); ok {\n  e.w = ww\n} else {\n  e.w = bufio.NewWriter(w)\n}\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode322\nsrc/pkg/image/gif/writer.go:322: o.NumColors = DefaultNumColors\nI'd prefer not to modify the o argument's fields. Instead:\n\nopts := *o\nif opts.NumColors <= 0 || 256 < opts.NumColors {\n  opts.NumColors = 256\n}\netc.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode330\nsrc/pkg/image/gif/writer.go:330: pm = image.NewPaletted(b, color.Plan9Palette)\nStrictly speaking, I think that\ncolor.Plan9Palette\nshould be\ncolor.Plan9Palette[:opts.NumColors]\nand add a TODO to pick a better sub-sample of the Plan 9 palette.",
			"disapproval": false,
			"date": "2013-07-12 00:47:17.075170",
			"approval": false
		},
		{
			"sender": "andybons@chromium.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go\nFile src/pkg/image/gif/writer.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode25\nsrc/pkg/image/gif/writer.go:25: func log2Int256(x int) int {\nOn 2013/07/12 00:47:17, nigeltao wrote:\n> Just call the function log2.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode129\nsrc/pkg/image/gif/writer.go:129: // TODO: GIF87a could be valid depending on the features that\nOn 2013/07/12 00:47:17, nigeltao wrote:\n> I wouldn't bother. Just assume GIF89a.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode179\nsrc/pkg/image/gif/writer.go:179: e.buf[3*i] = uint8(r >> 8)\nOn 2013/07/12 00:47:17, nigeltao wrote:\n> I'd add a +0 for symmetry. The compiler should take it back out.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode203\nsrc/pkg/image/gif/writer.go:203: if b.Dx() >= 1<<16 || b.Dy() >= 1<<16 || b.Min.X >= 1<<16 || b.Min.Y >= 1<<16 {\nOn 2013/07/12 00:47:17, nigeltao wrote:\n> You should also check b.Min.X < 0 and likewise for Y.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode256\nsrc/pkg/image/gif/writer.go:256: bw := &blockWriter{w: e.w}\nOn 2013/07/12 00:47:17, nigeltao wrote:\n> You shouldn't need to allocate a blockWriter for each call to writeImageBlock.\n> In fact, you could probably re-use the encoder's tmp buffer:\n> \n> type blockWriter struct {\n>   e *encoder\n> }\n> \n> func (b blockWriter) Write(data []byte) (int, error) {\n>   if b.e.err != nil {\n>     return 0, b.e.err\n>   }\n>   etc\n> }\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode268\nsrc/pkg/image/gif/writer.go:268: const DefaultNumColors = 256\nOn 2013/07/12 00:47:17, nigeltao wrote:\n> I'm not sure that this constant is worth exporting, or even defining.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode299\nsrc/pkg/image/gif/writer.go:299: e := newEncoder(w)\nOn 2013/07/12 00:47:17, nigeltao wrote:\n> It doesn't seem worth defining a newEncoder function. Just inline it:\n> \n> e := encoder{ g: g }\n> if ww, ok := w.(writer); ok {\n>   e.w = ww\n> } else {\n>   e.w = bufio.NewWriter(w)\n> }\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode322\nsrc/pkg/image/gif/writer.go:322: o.NumColors = DefaultNumColors\nOn 2013/07/12 00:47:17, nigeltao wrote:\n> I'd prefer not to modify the o argument's fields. Instead:\n> \n> opts := *o\n> if opts.NumColors <= 0 || 256 < opts.NumColors {\n>   opts.NumColors = 256\n> }\n> etc.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/55003/src/pkg/image/gif/writer.go#newcode330\nsrc/pkg/image/gif/writer.go:330: pm = image.NewPaletted(b, color.Plan9Palette)\nOn 2013/07/12 00:47:17, nigeltao wrote:\n> Strictly speaking, I think that\n> color.Plan9Palette\n> should be\n> color.Plan9Palette[:opts.NumColors]\n> and add a TODO to pick a better sub-sample of the Plan 9 palette.\n\nDone.",
			"disapproval": false,
			"date": "2013-07-12 01:55:05.416510",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM.\n\nI'll make the minor edits and submit.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go\nFile src/pkg/image/gif/writer.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go#newcode70\nsrc/pkg/image/gif/writer.go:70: func (b *blockWriter) Write(data []byte) (int, error) {\nDrop the *.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go#newcode125\nsrc/pkg/image/gif/writer.go:125: writeUint16(e.buf[:2], uint16(pm.Bounds().Dx()))\nI'd change :2 to 0:2, for symmetry.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go#newcode169\nsrc/pkg/image/gif/writer.go:169: e.buf[3*i] = 0x00\n+0.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go#newcode241\nsrc/pkg/image/gif/writer.go:241: bw := &blockWriter{e: e}\nDrop the &, and just inline this variable into the next line.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go#newcode305\nsrc/pkg/image/gif/writer.go:305: if o == nil {\nAh, there's no need to allocate here. Instead:\n\nopts := Options{}\nif o != nil {\n  opts = *o\n}\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer_test.go\nFile src/pkg/image/gif/writer_test.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer_test.go#newcode78\nsrc/pkg/image/gif/writer_test.go:78: t.Error(tc.filename, err)\nAdd\ncontinue\nafter this.\n\nSimilarly below.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer_test.go#newcode121\nsrc/pkg/image/gif/writer_test.go:121: t.Error(\"EncodeAll:\", err)\nChange Error to Fatal, as there's not much point continuing if the EncodeAll fails.",
			"disapproval": false,
			"date": "2013-07-12 04:51:04.202690",
			"approval": true
		},
		{
			"sender": "andybons@chromium.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go\nFile src/pkg/image/gif/writer.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go#newcode70\nsrc/pkg/image/gif/writer.go:70: func (b *blockWriter) Write(data []byte) (int, error) {\nOn 2013/07/12 04:51:04, nigeltao wrote:\n> Drop the *.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go#newcode125\nsrc/pkg/image/gif/writer.go:125: writeUint16(e.buf[:2], uint16(pm.Bounds().Dx()))\nOn 2013/07/12 04:51:04, nigeltao wrote:\n> I'd change :2 to 0:2, for symmetry.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go#newcode169\nsrc/pkg/image/gif/writer.go:169: e.buf[3*i] = 0x00\nOn 2013/07/12 04:51:04, nigeltao wrote:\n> +0.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go#newcode241\nsrc/pkg/image/gif/writer.go:241: bw := &blockWriter{e: e}\nOn 2013/07/12 04:51:04, nigeltao wrote:\n> Drop the &, and just inline this variable into the next line.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer.go#newcode305\nsrc/pkg/image/gif/writer.go:305: if o == nil {\nOn 2013/07/12 04:51:04, nigeltao wrote:\n> Ah, there's no need to allocate here. Instead:\n> \n> opts := Options{}\n> if o != nil {\n>   opts = *o\n> }\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer_test.go\nFile src/pkg/image/gif/writer_test.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer_test.go#newcode78\nsrc/pkg/image/gif/writer_test.go:78: t.Error(tc.filename, err)\nOn 2013/07/12 04:51:04, nigeltao wrote:\n> Add\n> continue\n> after this.\n> \n> Similarly below.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/74001/src/pkg/image/gif/writer_test.go#newcode121\nsrc/pkg/image/gif/writer_test.go:121: t.Error(\"EncodeAll:\", err)\nOn 2013/07/12 04:51:04, nigeltao wrote:\n> Change Error to Fatal, as there's not much point continuing if the EncodeAll\n> fails.\n\nDone.",
			"disapproval": false,
			"date": "2013-07-12 14:25:54.657140",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=58ee92a528da ***\n\nimage/gif: add writer implementation\n\nR=r, nigeltao\nCC=golang-dev\nhttps://codereview.appspot.com/10896043\n\nCommitter: Nigel Tao <nigeltao@golang.org>",
			"disapproval": false,
			"date": "2013-07-15 00:57:13.170390",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Also, please complete a Contributor License Agreement if you haven't already done so:\n\nhttp://golang.org/doc/contribute.html#copyright",
			"disapproval": false,
			"date": "2013-07-03 03:31:55.534920",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "It looks like the median cut algorithm isn't cheap. For a 1000x1000 pixel image, you're allocating a million points (even if the image only contains e.g. 300 distinct colors) and repeatedly sorting them.\n\nEncoding full-color image as a GIF involves several steps:\n1. calculating an appropriate palette,\n2. converting the source image to that palette,\n3. writing the paletted image in GIF-specific format (headers, LZW compression, blocks, etc.)\n\nSo far, I think we've treated 1 and 2 as a monolithic processs. On second thoughts, it may be better to separate them out.\n\nSpecifically, step 1 isn't cheap, and step 1 can be avoided if you use a pre-defined palette. The Netscape Color Cube is one such palette. The Plan 9 palette (http://plan9.bell-labs.com/magic/man2html/6/color) is another one, with the nice property that it contains 16 shades of gray, so grayscale or mostly-grayscale images look pretty reasonable.\n\nIt may be better for package gif's default encoding method to use a standard palette, while keeping the option to specify a custom quantizer such as one that implements median-cut.\n\nRob and I need to do some more thinking about this, but I'm pretty busy for the next few days. Can you hold off on this one for a bit?",
			"disapproval": false,
			"date": "2013-07-04 07:30:39.571850",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go\nFile src/pkg/image/gif/mediancut.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode150\nsrc/pkg/image/gif/mediancut.go:150: Quantize(m image.Image) (*image.Paletted, error)\nOn 2013/07/03 17:19:35, Andrew Bonventre wrote:\n> In the above API, what do r and sp specify exactly? Is r the bounds of the src\n> image that the palette should be quantized from? What is sp?\n\nThey have the same meaning as the image/draw package.\nhttp://golang.org/pkg/image/draw/\nand\nhttp://golang.org/doc/articles/image_draw.html\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode243\nsrc/pkg/image/gif/mediancut.go:243: pm.Stride = m.Bounds().Dx()\nOn 2013/07/03 17:19:35, Andrew Bonventre wrote:\n> Apologies if I\u2019m missing something...?\n\nimage.NewPaletted already sets the stride to the correct value. You shouldn't have to override it, and if you do, you're possibly setting it to the wrong value. The stride is not necessarily the width of the image rectangle, if the pixel buffer is part of a larger (wider) buffer. But NewPaletted takes care of all of that.\n\nhttp://play.golang.org/p/N0EA91shi_",
			"disapproval": false,
			"date": "2013-07-03 23:48:04.616950",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Jul 4, 2013 at 5:30 PM,  <nigeltao@golang.org> wrote:\r\n> Encoding full-color image as a GIF involves several steps:\r\n> 1. calculating an appropriate palette,\r\n> 2. converting the source image to that palette,\r\n> 3. writing the paletted image in GIF-specific format (headers, LZW\r\n> compression, blocks, etc.)\r\n\r\nI've had a go at implementing step 2. Please take a look at\r\nhttps://codereview.appspot.com/10977043\r\n",
			"disapproval": false,
			"date": "2013-07-07 12:35:04.038300",
			"approval": false
		},
		{
			"sender": "andybons@chromium.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> Rob and I need to do some more thinking about this, but I'm pretty busy for the\n> next few days. Can you hold off on this one for a bit?\n\nSure. No worries.",
			"disapproval": false,
			"date": "2013-07-04 11:56:26.844710",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go\nFile src/pkg/image/gif/mediancut.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode32\nsrc/pkg/image/gif/mediancut.go:32: type point struct {\nOr just\n\ntype point [numDimensions]uint32\n\nAlso, int would seem easier to work with than uint32.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode44\nsrc/pkg/image/gif/mediancut.go:44: b := &block{points: p}\nreturn &block{\n  minCorner: point{0x00, 0x00, 0x00},\n  maxCorner: point{0xFF, 0xFF, 0xFF},\n  points: p,\n}\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode83\nsrc/pkg/image/gif/mediancut.go:83: type By func(p1, p2 *point) bool\nWhy is this type exported?\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode85\nsrc/pkg/image/gif/mediancut.go:85: func (by By) Sort(points []point) {\nWhy is this method exported? We usually don't export methods unless we have to, and we don't have to.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode86\nsrc/pkg/image/gif/mediancut.go:86: ps := &pointSorter{\nYou can inline this into the next line:\n\nsort.Sort(&pointSorter{\n  points: points,\n  by:     by,\n})\n\nOr just inline the whole method in the one place it gets called below. Then you wouldn't need to define a By type.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode98\nsrc/pkg/image/gif/mediancut.go:98: func (ps *pointSorter) Len() int {\nI'd change ps to just s.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode111\nsrc/pkg/image/gif/mediancut.go:111: type PriorityQueue []*block\nWhy is this type exported?\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode137\nsrc/pkg/image/gif/mediancut.go:137: *pq = old[0 : n-1]\nDrop the 0.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode149\nsrc/pkg/image/gif/mediancut.go:149: type Quantizer interface {\nThis needs documentation comments.\n\nI'd also move it to writer.go, near where the Options type is defined.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode150\nsrc/pkg/image/gif/mediancut.go:150: Quantize(m image.Image) (*image.Paletted, error)\nWas this the API that we agreed on??\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode153\nsrc/pkg/image/gif/mediancut.go:153: type MedianCutQuantizer struct {\nThis needs documentation comments.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode178\nsrc/pkg/image/gif/mediancut.go:178: block1 := newBlock(points[0:median])\nDrop the 0.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode190\nsrc/pkg/image/gif/mediancut.go:190: sum := make([]uint32, numDimensions)\nnumDimensions is constant, use a (stack-allocated) array instead of a slice.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode201\nsrc/pkg/image/gif/mediancut.go:201: R: uint16(avgPoint.x[0]),\nI wouldn't bother with an avgPoint variable, and just use\nsum[0] / len(block.points)\ndirectly here.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode215\nsrc/pkg/image/gif/mediancut.go:215: colorSet := make(map[color.Color]bool, q.NumColor)\nThe color.Color implementation could be a func, which is not a valid map key type.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode242\nsrc/pkg/image/gif/mediancut.go:242: pm := image.NewPaletted(m.Bounds(), palette)\nm.Bounds() could be just bounds.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode243\nsrc/pkg/image/gif/mediancut.go:243: pm.Stride = m.Bounds().Dx()\nHuh?\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode246\nsrc/pkg/image/gif/mediancut.go:246: pm.Set(x, y, m.At(x, y))\nAdd a TODO to do this more efficiently.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go\nFile src/pkg/image/gif/writer.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode41\nsrc/pkg/image/gif/writer.go:41: io.ByteWriter\nDo you call writer.WriteByte anywhere? You probably should, as it should be more efficient that calling Write with 1-byte slices.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode78\nsrc/pkg/image/gif/writer.go:78: b.slice = b.tmp[1:256]\nWhy is b.slice a field? Just use b.tmp[1:256] on the next line.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode128\nsrc/pkg/image/gif/writer.go:128: e.buf[0] = 0x21 // Extention Introducer.\nTypo in \"Extension\".\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode129\nsrc/pkg/image/gif/writer.go:129: e.buf[1] = 0xff // Aplication Label.\nTypo in \"Application\".\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode161\nsrc/pkg/image/gif/writer.go:161: e.write(e.buf[:3])\nMaking 1 write of 768 bytes will be more efficient than 256 writes of 3 bytes.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode199\nsrc/pkg/image/gif/writer.go:199: writeUint16(e.buf[1:3], uint16(pm.Bounds().Min.X))\nYou should probably return an error if any of these bounds overflow a uint16.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode205\nsrc/pkg/image/gif/writer.go:205: if len(pm.Palette) > 0 {\nI'd just return an error if pm has an empty palette.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode265\nsrc/pkg/image/gif/writer.go:265: return e.err\nIf e.w was created above by bufio.NewWriter, then you may have unflushed bytes here.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode282\nsrc/pkg/image/gif/writer.go:282: pm, e.err = o.Quantizer.Quantize(m)\nQuantization is unnecessary work if m is already an *image.Paletted:\n\npm, ok := m.(*image.Paletted)\nif !ok {\n  // Quantize.\n}\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode286\nsrc/pkg/image/gif/writer.go:286: e.g = &GIF{Image: []*image.Paletted{pm}}\nAll this below should just be a call to EncodeAll.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer_test.go\nFile src/pkg/image/gif/writer_test.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer_test.go#newcode28\nsrc/pkg/image/gif/writer_test.go:28: func readGif(filename string) (*GIF, error) {\nreadGif should be readGIF.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer_test.go#newcode109\nsrc/pkg/image/gif/writer_test.go:109: Delay:     make([]int, len(frames), 5),\nWhy the \", 5\"?\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer_test.go#newcode156\nsrc/pkg/image/gif/writer_test.go:156: // Restrict to a 256-color palette to avoid quantization path.\nI'd also like a benchmark for the quantization path. Your current implementation seems very allocation-heavy.",
			"disapproval": false,
			"date": "2013-07-03 03:27:24.723050",
			"approval": false
		},
		{
			"sender": "andybons@chromium.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I\u2019ve noticed some hot spots when I benchmarked that I plan to address. The two notable ones are both within the Quantizer.\n\nlines 172 and 246 are the most obvious areas where performance should be improved before submission.",
			"disapproval": false,
			"date": "2013-07-02 23:26:52.938610",
			"approval": false
		},
		{
			"sender": "andybons@chromium.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "ptal\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go\nFile src/pkg/image/gif/mediancut.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode150\nsrc/pkg/image/gif/mediancut.go:150: Quantize(m image.Image) (*image.Paletted, error)\nOn 2013/07/03 23:48:04, nigeltao wrote:\n> On 2013/07/03 17:19:35, Andrew Bonventre wrote:\n> > In the above API, what do r and sp specify exactly? Is r the bounds of the src\n> > image that the palette should be quantized from? What is sp?\n> \n> They have the same meaning as the image/draw package.\n> http://golang.org/pkg/image/draw/\n> and\n> http://golang.org/doc/articles/image_draw.html\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode243\nsrc/pkg/image/gif/mediancut.go:243: pm.Stride = m.Bounds().Dx()\nOn 2013/07/03 23:48:04, nigeltao wrote:\n> On 2013/07/03 17:19:35, Andrew Bonventre wrote:\n> > Apologies if I\u2019m missing something...?\n> \n> image.NewPaletted already sets the stride to the correct value. You shouldn't\n> have to override it, and if you do, you're possibly setting it to the wrong\n> value. The stride is not necessarily the width of the image rectangle, if the\n> pixel buffer is part of a larger (wider) buffer. But NewPaletted takes care of\n> all of that.\n> \n> http://play.golang.org/p/N0EA91shi_\n\nDone.",
			"disapproval": false,
			"date": "2013-07-04 04:31:30.733520",
			"approval": false
		},
		{
			"sender": "andybons@chromium.org",
			"recipients": [
				"andybons@chromium.org",
				"r@golang.org",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thanks for the speedy response, Nigel.\n\nChanges made with a question about the API inline.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go\nFile src/pkg/image/gif/mediancut.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode32\nsrc/pkg/image/gif/mediancut.go:32: type point struct {\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Or just\n> \n> type point [numDimensions]uint32\n> \n> Also, int would seem easier to work with than uint32.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode44\nsrc/pkg/image/gif/mediancut.go:44: b := &block{points: p}\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> return &block{\n>   minCorner: point{0x00, 0x00, 0x00},\n>   maxCorner: point{0xFF, 0xFF, 0xFF},\n>   points: p,\n> }\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode83\nsrc/pkg/image/gif/mediancut.go:83: type By func(p1, p2 *point) bool\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Why is this type exported?\n\nApologies. Lost track of what should be exported to satisfy heap.Interface within this code.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode85\nsrc/pkg/image/gif/mediancut.go:85: func (by By) Sort(points []point) {\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Why is this method exported? We usually don't export methods unless we have to,\n> and we don't have to.\n\nBrain fart syndrome?\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode86\nsrc/pkg/image/gif/mediancut.go:86: ps := &pointSorter{\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> You can inline this into the next line:\n> \n> sort.Sort(&pointSorter{\n>   points: points,\n>   by:     by,\n> })\n> \n> Or just inline the whole method in the one place it gets called below. Then you\n> wouldn't need to define a By type.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode98\nsrc/pkg/image/gif/mediancut.go:98: func (ps *pointSorter) Len() int {\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> I'd change ps to just s.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode111\nsrc/pkg/image/gif/mediancut.go:111: type PriorityQueue []*block\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Why is this type exported?\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode137\nsrc/pkg/image/gif/mediancut.go:137: *pq = old[0 : n-1]\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Drop the 0.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode149\nsrc/pkg/image/gif/mediancut.go:149: type Quantizer interface {\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> This needs documentation comments.\n> \n> I'd also move it to writer.go, near where the Options type is defined.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode150\nsrc/pkg/image/gif/mediancut.go:150: Quantize(m image.Image) (*image.Paletted, error)\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Was this the API that we agreed on??\n\nNope. I should have gotten clarification earlier on the thread. Sorry about that.\n\nWithin the API we had discussed, you had suggested:\n\ntype Quantizer interface {\n  // Quantize sets dst.Palette as well as dst's pixels.\n  // TODO: would we ever want to pass a color.Palette in as a hint?\n  // Is it feasible to use dst.Palette's initial value as that?\n  // TODO: should dst be a draw.Image (with a fast path for image.Paletted)?\n  // Would Quantize then have to return a color.Palette?\n  Quantize(dst image.Paletted, r image.Rectangle, src image.Image, sp image.Point)\n}\n\nIn the above API, what do r and sp specify exactly? Is r the bounds of the src image that the palette should be quantized from? What is sp?\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode153\nsrc/pkg/image/gif/mediancut.go:153: type MedianCutQuantizer struct {\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> This needs documentation comments.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode178\nsrc/pkg/image/gif/mediancut.go:178: block1 := newBlock(points[0:median])\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Drop the 0.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode190\nsrc/pkg/image/gif/mediancut.go:190: sum := make([]uint32, numDimensions)\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> numDimensions is constant, use a (stack-allocated) array instead of a slice.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode201\nsrc/pkg/image/gif/mediancut.go:201: R: uint16(avgPoint.x[0]),\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> I wouldn't bother with an avgPoint variable, and just use\n> sum[0] / len(block.points)\n> directly here.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode215\nsrc/pkg/image/gif/mediancut.go:215: colorSet := make(map[color.Color]bool, q.NumColor)\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> The color.Color implementation could be a func, which is not a valid map key\n> type.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode242\nsrc/pkg/image/gif/mediancut.go:242: pm := image.NewPaletted(m.Bounds(), palette)\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> m.Bounds() could be just bounds.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode243\nsrc/pkg/image/gif/mediancut.go:243: pm.Stride = m.Bounds().Dx()\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Huh?\n\nSince each pixel within a palette is represented by a single byte, and Stride represents the distance between vertically adjacent bytes, the width of the image rectangle is used.\n\nApologies if I\u2019m missing something...?\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/mediancut.go#newcode246\nsrc/pkg/image/gif/mediancut.go:246: pm.Set(x, y, m.At(x, y))\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Add a TODO to do this more efficiently.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go\nFile src/pkg/image/gif/writer.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode41\nsrc/pkg/image/gif/writer.go:41: io.ByteWriter\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Do you call writer.WriteByte anywhere? You probably should, as it should be more\n> efficient that calling Write with 1-byte slices.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode78\nsrc/pkg/image/gif/writer.go:78: b.slice = b.tmp[1:256]\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Why is b.slice a field? Just use b.tmp[1:256] on the next line.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode128\nsrc/pkg/image/gif/writer.go:128: e.buf[0] = 0x21 // Extention Introducer.\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Typo in \"Extension\".\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode129\nsrc/pkg/image/gif/writer.go:129: e.buf[1] = 0xff // Aplication Label.\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Typo in \"Application\".\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode161\nsrc/pkg/image/gif/writer.go:161: e.write(e.buf[:3])\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Making 1 write of 768 bytes will be more efficient than 256 writes of 3 bytes.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode199\nsrc/pkg/image/gif/writer.go:199: writeUint16(e.buf[1:3], uint16(pm.Bounds().Min.X))\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> You should probably return an error if any of these bounds overflow a uint16.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode205\nsrc/pkg/image/gif/writer.go:205: if len(pm.Palette) > 0 {\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> I'd just return an error if pm has an empty palette.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode265\nsrc/pkg/image/gif/writer.go:265: return e.err\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> If e.w was created above by bufio.NewWriter, then you may have unflushed bytes\n> here.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode282\nsrc/pkg/image/gif/writer.go:282: pm, e.err = o.Quantizer.Quantize(m)\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Quantization is unnecessary work if m is already an *image.Paletted:\n> \n> pm, ok := m.(*image.Paletted)\n> if !ok {\n>   // Quantize.\n> }\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer.go#newcode286\nsrc/pkg/image/gif/writer.go:286: e.g = &GIF{Image: []*image.Paletted{pm}}\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> All this below should just be a call to EncodeAll.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer_test.go\nFile src/pkg/image/gif/writer_test.go (right):\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer_test.go#newcode28\nsrc/pkg/image/gif/writer_test.go:28: func readGif(filename string) (*GIF, error) {\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> readGif should be readGIF.\n\nDone.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer_test.go#newcode109\nsrc/pkg/image/gif/writer_test.go:109: Delay:     make([]int, len(frames), 5),\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> Why the \", 5\"?\n\nOops. Removed.\n\nhttps://codereview.appspot.com/10896043/diff/3001/src/pkg/image/gif/writer_test.go#newcode156\nsrc/pkg/image/gif/writer_test.go:156: // Restrict to a 256-color palette to avoid quantization path.\nOn 2013/07/03 03:27:25, nigeltao wrote:\n> I'd also like a benchmark for the quantization path. Your current implementation\n> seems very allocation-heavy.\n\nDone.",
			"disapproval": false,
			"date": "2013-07-03 17:19:34.799610",
			"approval": false
		}
	],
	"owner_email": "andybons@chromium.org",
	"private": false,
	"base_url": "",
	"owner": "Andrew Bonventre",
	"subject": "image/gif: add writer implementation",
	"created": "2013-07-02 23:20:41.001820",
	"patchsets": [
		1,
		3001,
		13001,
		20001,
		26001,
		40001,
		45001,
		52001,
		55001,
		59001,
		55002,
		55003,
		74001,
		81001
	],
	"modified": "2013-07-17 13:57:45.416660",
	"closed": true,
	"issue": 10896043
}