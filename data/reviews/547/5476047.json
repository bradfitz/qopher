{
	"description": "json: Decoder hook to intern strings\n\nSaves memory when decoding large JSON objects with many\nrepeated strings.",
	"cc": [
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"golang-dev@googlegroups.com",
		"rsc@golang.org",
		"ojan@chromium.org"
	],
	"messages": [
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg",
			"disapproval": false,
			"date": "2011-12-09 00:30:56.387375",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I would like to avoid exposing this in the API.\nI don't mind if the decoder has its own lookaside\nmap for this kind of thing (a map[string]string would\nwork just fine), but I don't want clients to know or\nbe able to control it, because that constrains the\nimplementation.\n\nAlso, I would strongly encourage decoding into\na data structure instead of into an interface{}.\nIt requires more up-front work because you have\nto say what fields you care about, but then the\ndecoding only saves what you need.  If you need\nto save an uninterpreted JSON blob then\njson.RawMessage is a good approach; it avoids\nthe decoding entirely.  I can't think of anything\nI'd use the interface{} decoding for other than\ntoy examples.  (It's still fine to make more efficient,\nas long as the API is unchanged.)\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-12 20:16:16.971076",
			"approval": false
		},
		{
			"sender": "ojan@chromium.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"ojan@chromium.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2011/12/12 23:53:59, bradfitz wrote:\n> On Mon, Dec 12, 2011 at 12:16 PM, Russ Cox <mailto:rsc@golang.org> wrote:\n> > Also, I would strongly encourage decoding into\n> > a data structure instead of into an interface{}.\n> > It requires more up-front work because you have\n> > to say what fields you care about, but then the\n> > decoding only saves what you need.\n> \n> IIRC, Ojan's structure couldn't be described by the json package's struct\n> tag scheme.\n\nHere's a slightly simplified version of my format:\n{\n  \"version\": 4,\n  \"BuilderName1\": {\n    \"builds\": [3, 2, 1],\n    \"tests\": {\n      \"foo\" { \n        \"001.html\": { \"results\": [\"F\", \"T\", \"F\"], \"times\": [10, 4, 2],\n        \"002.html\": { \"results\": [\"C\", \"T\", \"F\"], \"times\": [2, 4, 2]\n      },\n      \"003.html\": { \"results\": [\"X\", \"T\", \"F\"], \"times\": [0, 4, 2]\n    }\n  }\n}\n\nThe notable things I wasn't able to represent as a data structure:\n1. BuilderName1 is different in each JSON file. \n2. The structure under \"tests\" is recursive. It maps to a directory structure. Each leaf is a results+times object.\n\nFWIW, after Brad posted this, I tried out interning the strings and didn't notice a meaningful memory improvement. I think there are enough unique strings that it was a wash, but there are a number of arrays that I know won't be modified that are repeating. Using the same technique for arrays saved ~30% memory.",
			"disapproval": false,
			"date": "2011-12-13 00:22:47.095430",
			"approval": false
		},
		{
			"sender": "ojan@chromium.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"ojan@chromium.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2011/12/13 00:26:20, rsc wrote:\n> On Mon, Dec 12, 2011 at 19:22,  <mailto:ojan@chromium.org> wrote:\n> > &nbsp; &nbsp;\"tests\": {\n> > &nbsp; &nbsp; &nbsp;\"foo\" {\n> > &nbsp; &nbsp; &nbsp; &nbsp;\"001.html\": { \"results\": [\"F\", \"T\", \"F\"], \"times\": [10, 4, 2],\n> > &nbsp; &nbsp; &nbsp; &nbsp;\"002.html\": { \"results\": [\"C\", \"T\", \"F\"], \"times\": [2, 4, 2]\n> > &nbsp; &nbsp; &nbsp;},\n> > &nbsp; &nbsp; &nbsp;\"003.html\": { \"results\": [\"X\", \"T\", \"F\"], \"times\": [0, 4, 2]\n> > &nbsp; &nbsp;}\n> \n> I assume there is a : after \"foo\".\n\nHeh. Yes.\n\n> How does one know whether there are one or two levels\n> before you get to a \"results\" object?  For example, if\n> 003.html had been named instead \"results\", is the parsing\n> ambiguous?  This ambiguity of type is the only really\n> problematic part of using data structures here, but it can't\n> be *that* ambiguous.  After all it was generated by a\n> program to begin with.\n\nIt's mutually exclusive. A given level is either a \"directory\" or a \"file\". So, if it has results/times entries it cannot have other entries and vice versa.\n\nIt wouldn't surprise me if my inability to come up with a struct for this is my fault. This is my first Go project.",
			"disapproval": false,
			"date": "2011-12-13 00:38:44.507646",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Background: Ojan, copied, was blowing his App Engine memory limit decoding\na large JSON response for Chrome's buildbots.\n\nAlternative suggestions welcome.\n\n\nOn Thu, Dec 8, 2011 at 4:30 PM, <bradfitz@golang.org> wrote:\n\n> Reviewers: golang-dev_googlegroups.com,\n>\n> Message:\n> Hello golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n>\n> I'd like you to review this change to\n> https://go.googlecode.com/hg\n>\n>\n> Description:\n> json: Decoder hook to intern strings\n>\n> Saves memory when decoding large JSON objects with many\n> repeated strings.\n>\n> Please review this at http://codereview.appspot.com/**5476047/<http://codereview.appspot.com/5476047/>\n>\n> Affected files:\n>  M src/pkg/encoding/json/decode.**go\n>  M src/pkg/encoding/json/stream.**go\n>\n>\n> Index: src/pkg/encoding/json/decode.**go\n> ==============================**==============================**=======\n> --- a/src/pkg/encoding/json/**decode.go\n> +++ b/src/pkg/encoding/json/**decode.go\n> @@ -143,7 +143,8 @@\n>        scan       scanner\n>        nextscan   scanner // for calls to nextValue\n>        savedError error\n> -       tempstr    string // scratch space to avoid some allocations\n> +       tempstr    string              // scratch space to avoid some\n> allocations\n> +       interner   func(string) string // optional\n>  }\n>\n>  // errPhase is used for errors that should not happen unless\n> @@ -171,6 +172,13 @@\n>        }\n>  }\n>\n> +func (d *decodeState) intern(s string) string {\n> +       if d.interner == nil {\n> +               return s\n> +       }\n> +       return d.interner(s)\n> +}\n> +\n>  // next cuts off and returns the next full JSON value in d.data[d.off:].\n>  // The next value is known to be an object or array, not a literal.\n>  func (d *decodeState) next() []byte {\n> @@ -745,6 +753,7 @@\n>                if !ok {\n>                        d.error(errPhase)\n>                }\n> +               key = d.intern(key)\n>\n>                // Read : before value.\n>                if op == scanSkipSpace {\n> @@ -792,6 +801,7 @@\n>                if !ok {\n>                        d.error(errPhase)\n>                }\n> +               s = d.intern(s)\n>                return s\n>\n>        default: // number\n> Index: src/pkg/encoding/json/stream.**go\n> ==============================**==============================**=======\n> --- a/src/pkg/encoding/json/**stream.go\n> +++ b/src/pkg/encoding/json/**stream.go\n> @@ -16,6 +16,10 @@\n>        d    decodeState\n>        scan scanner\n>        err  error\n> +\n> +       // Interner optionally specifies a function to intern\n> +       // strings to save memory.\n> +       Interner func(string) string\n>  }\n>\n>  // NewDecoder returns a new decoder that reads from r.\n>\n>\n>\n",
			"disapproval": false,
			"date": "2011-12-09 00:33:08.169997",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Dec 12, 2011 at 12:16 PM, Russ Cox <rsc@golang.org> wrote:\n\n> I would like to avoid exposing this in the API.\n> I don't mind if the decoder has its own lookaside\n> map for this kind of thing (a map[string]string would\n> work just fine), but I don't want clients to know or\n> be able to control it, because that constrains the\n> implementation.\n>\n\nOn by default?  I imagine repeated strings are common in JSON, but I'm not\nsure how common.\n\n\n> Also, I would strongly encourage decoding into\n> a data structure instead of into an interface{}.\n> It requires more up-front work because you have\n> to say what fields you care about, but then the\n> decoding only saves what you need.\n\n\nIIRC, Ojan's structure couldn't be described by the json package's struct\ntag scheme.\n",
			"disapproval": false,
			"date": "2011-12-12 23:53:59.502768",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Dec 12, 2011 at 19:22,  <ojan@chromium.org> wrote:\n> \u00a0 \u00a0\"tests\": {\n> \u00a0 \u00a0 \u00a0\"foo\" {\n> \u00a0 \u00a0 \u00a0 \u00a0\"001.html\": { \"results\": [\"F\", \"T\", \"F\"], \"times\": [10, 4, 2],\n> \u00a0 \u00a0 \u00a0 \u00a0\"002.html\": { \"results\": [\"C\", \"T\", \"F\"], \"times\": [2, 4, 2]\n> \u00a0 \u00a0 \u00a0},\n> \u00a0 \u00a0 \u00a0\"003.html\": { \"results\": [\"X\", \"T\", \"F\"], \"times\": [0, 4, 2]\n> \u00a0 \u00a0}\n\nI assume there is a : after \"foo\".\n\nHow does one know whether there are one or two levels\nbefore you get to a \"results\" object?  For example, if\n003.html had been named instead \"results\", is the parsing\nambiguous?  This ambiguity of type is the only really\nproblematic part of using data structures here, but it can't\nbe *that* ambiguous.  After all it was generated by a\nprogram to begin with.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-13 00:26:20.653669",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Dec 12, 2011 at 19:38,  <ojan@chromium.org> wrote:\n> It's mutually exclusive. A given level is either a \"directory\" or a\n> \"file\". So, if it has results/times entries it cannot have other entries\n> and vice versa.\n\nThat's too bad.  I don't have any good way to model this.\nIs the format fixed?  It would be a lot nicer if it matched\nup with a typical data structure, like\n\n{\n  \"version\": 4,\n  \"builders\": {\n    \"BuilderName1\": {\n      \"builds\": [3, 2, 1],\n      \"dir\": {\n        \"dir\": {\n          \"foo\": {\n            \"tests\": {\n              \"001.html\": { \"results\": [\"F\", \"T\", \"F\"], \"times\": [10, 4, 2] },\n              \"002.html\": { \"results\": [\"C\", \"T\", \"F\"], \"times\": [2, 4, 2] }\n            }\n          }\n        },\n        \"tests\": {\n          \"003.html\": { \"results\": [\"X\", \"T\", \"F\"], \"times\": [0, 4, 2] }\n        }\n      }\n    }\n  }\n}\n\nThat corresponds to:\n\ntype Log struct {\n\tVersion int `json:\"version\"`\n\tBuilders map[string]*Builder `json:\"builders\"`\n}\n\ntype Builder struct {\n\tBuilds []int `json:\"builds\"`\n\tTestDir *TestDir `json:\"dir\"`\n}\n\ntype Dir struct {\n\tTests map[string]*Test `json:\"tests\"`\n\tDir map[string]*Dir `json:\"dir\"`\n}\n\ntype Test struct {\n\tResults []string `json:\"results\"`\n\tTimes []int `json:\"times\"`\n}\n\nOr, if you can depart from your schema even more, I'd get rid of the maps and\nthe lower case names:\n\n{\n  \"Version\": 4,\n  \"Builders\": [\n    {\n      \"Name\": \"BuilderName1\",\n      \"Builds\": [3, 2, 1],\n      \"Dir\": {\n        \"Dir\": [\n          {\n            \"Name\": \"Foo\",\n            \"Tests\": [\n              {\"Name\": \"001.html\", \"Results\": [\"F\", \"T\", \"F\"],\n\"Times\": [10, 4, 2]},\n              {\"Name\": \"002.html\", \"Results\": [\"C\", \"T\", \"F\"],\n\"Times\": [2, 4, 2]},\n            ],\n          }\n        ],\n        \"Tests\": [\n          {\"Name\": \"003.html\", \"Results\": [\"F\", \"T\", \"F\"], \"Times\": [0, 4, 2]}\n        ]\n      }\n    }\n  ]\n}\n\nThat corresponds to these data structures (no annotations required):\n\ntype Log struct {\n\tVersion int\n\tBuilders []*Builder\n}\n\ntype Builder struct {\n\tName string\n\tBuilds []int\n\tDir *Dir\n}\n\ntype Dir struct {\n\tDir []*Dir  // subdirectories\n\tTests []*Test\n}\n\ntype Test struct {\n\tName string\n\tResults []string\n\tTimes []int\n}\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-14 21:49:58.800965",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Dec 12, 2011 at 18:53, Brad Fitzpatrick <bradfitz@golang.org> wrote:\n> On by default? \u00a0I imagine repeated strings are common in JSON, but I'm not\n> sure how common.\n\nWell, it would be nice to check the actual example that\nis causing problems, but my guess is that keys are\nrepeated all the time (because they are like struct field names)\nand values not so much.  If the map is per-Decoder\n(not global) then there's not much harm in applying it to both.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-13 00:48:08.114651",
			"approval": false
		}
	],
	"owner_email": "bradfitz@golang.org",
	"private": false,
	"base_url": "",
	"owner": "bradfitz",
	"subject": "code review 5476047: json: Decoder hook to intern strings",
	"created": "2011-12-09 00:30:31.243118",
	"patchsets": [
		1,
		2001,
		1002
	],
	"modified": "2012-01-19 00:14:07.136138",
	"closed": true,
	"issue": 5476047
}