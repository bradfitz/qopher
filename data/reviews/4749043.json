{
	"description": "net: ParseCIDR returns IPNet instead of IPMask\n\nNote that this CL will break your existing code which uses\nParseCIDR.\n\nThis CL changes ParseCIDR(\"172.16.253.121/28\") to return\nthe IP address \"172.16.253.121\", the network implied by the\nnetwork number \"172.16.253.112\" and mask \"255.255.255.240\".",
	"cc": [
		"rsc@golang.org",
		"borman@google.com",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "i checked with a networking expert here\nand he says other libraries take your\ninterpretation too.  still seems like an error\nto me but i am happy to be overruled.\n\nwill wait a day or two for others to weigh in.\n",
			"disapproval": false,
			"date": "2011-07-15 15:41:17.531442",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2011-07-15 10:57:46.467873",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I am not convinced.\n\nIf you write 192.168.254.254/24\nyou might have meant 192.168.254.0/24\nor you might have meant 192.168.254.254/31\nWhen the two halves are inconsistent,\nwhy should we assume the second half\nis the right one?\n\nI can just as easily see other software\ninterpreting 192.168.254.254/24 as\nmeaning & with 255.255.255.0 and then\ncheck if it's == 192.168.254.254 (impossible).\n\nThis really seems like an error to diagnose,\nnot something to silently reinterpret.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-07-15 15:33:28.650423",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "ping.\n\nOn Sat, Jul 16, 2011 at 12:41 AM, Russ Cox <rsc@golang.org> wrote:\n\n> i checked with a networking expert here\n> and he says other libraries take your\n> interpretation too. \u00a0still seems like an error\n> to me but i am happy to be overruled.\n>\n> will wait a day or two for others to weigh in.\n",
			"disapproval": false,
			"date": "2011-07-20 02:49:35.237789",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I see that is what Miko proposes :-)\n\n\nOn Fri, Jul 22, 2011 at 12:12 PM, Paul Borman <borman@google.com> wrote:\n\n> I propose we change ParseCIDR to the following:\n>\n> func ParseCIDR(s string) (ip IP, net IP, mask IPMask, err os.Error)\n>\n> returning both the IP address and the network the IP address is part of as\n> x.y.z.w/n really provides you those three things.  If ParseCIDR does not do\n> this I will end up writing a new function because I do need to get back all\n> three pieces when processing certain networking configuration files.\n>\n>     -Paul\n>\n>\n> On Wed, Jul 20, 2011 at 7:57 AM, Russ Cox <rsc@golang.org> wrote:\n>\n>> I found in RFC 4291 some support for your ifconfig command\n>> but it still doesn't help with the ParseCIDR code.\n>>\n>>   When writing both a node address and a prefix of that node address\n>>   (e.g., the node's subnet prefix), the two can be combined as follows:\n>>\n>>      the node address      2001:0DB8:0:CD30:123:4567:89AB:CDEF\n>>      and its subnet number 2001:0DB8:0:CD30::/60\n>>\n>>      can be abbreviated as 2001:0DB8:0:CD30:123:4567:89AB:CDEF/60\n>>\n>> If we allow but do not mask, then callers all have to know to mask.\n>> If we allow but do mask, then the ifconfig thing will silently fail.\n>>\n>> I'm not thrilled with either.\n>>\n>\n>\n",
			"disapproval": false,
			"date": "2011-07-22 19:13:47.299934",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "can you point to some other commonly-used software that does this?\ni am still not convinced the majority agrees that this is a good idea.\ni looked at the RFC and while it doesn't prohibit it, it also never uses\nprefixes that contain bits not set in mask.\n",
			"disapproval": false,
			"date": "2011-07-20 13:17:37.572904",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "This is a normal way to specify an IP address and netmask.\n\nOld way:\n\n    ifconfig exp0 192.168.1.2 --netmask 0xffffff00\n\nNew way\n\n    ifconfig exp0 192.168.1.2/24\n\n        -Paul\n\nOn Wed, Jul 20, 2011 at 6:17 AM, Russ Cox <rsc@golang.org> wrote:\n\n> can you point to some other commonly-used software that does this?\n> i am still not convinced the majority agrees that this is a good idea.\n> i looked at the RFC and while it doesn't prohibit it, it also never uses\n> prefixes that contain bits not set in mask.\n>\n",
			"disapproval": false,
			"date": "2011-07-20 14:52:30.574537",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Jul 20, 2011 at 10:52, Paul Borman <borman@google.com> wrote:\n> This is a normal way to specify an IP address and netmask.\n> Old way:\n> \u00a0 \u00a0 ifconfig exp0 192.168.1.2 --netmask 0xffffff00\n> New way\n> \u00a0 \u00a0 ifconfig exp0 192.168.1.2/24\n> \u00a0\u00a0 \u00a0\u00a0 \u00a0 -Paul\n\nOkay but this code is not serving that purpose,\nbecause it is returning 192.168.1.0 + 255.255.255.0,\nso you can't recover the .2.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-07-20 14:54:42.795003",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I found in RFC 4291 some support for your ifconfig command\nbut it still doesn't help with the ParseCIDR code.\n\n   When writing both a node address and a prefix of that node address\n   (e.g., the node's subnet prefix), the two can be combined as follows:\n\n      the node address      2001:0DB8:0:CD30:123:4567:89AB:CDEF\n      and its subnet number 2001:0DB8:0:CD30::/60\n\n      can be abbreviated as 2001:0DB8:0:CD30:123:4567:89AB:CDEF/60\n\nIf we allow but do not mask, then callers all have to know to mask.\nIf we allow but do mask, then the ifconfig thing will silently fail.\n\nI'm not thrilled with either.\n",
			"disapproval": false,
			"date": "2011-07-20 14:57:26.457800",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Jul 20, 2011 at 11:57 PM, Russ Cox <rsc@golang.org> wrote:\n\n> If we allow but do not mask, then callers all have to know to mask.\n> If we allow but do mask, then the ifconfig thing will silently fail.\n\nHow about this?\n\n// ParseCIDR parses s as a CIDR notation IP address, address prefix\n// and mask, like \"192.168.100.1/24\", \"2001:DB8::/48\", as defined in\n// RFC 4632 and RFC 4291.\nfunc ParseCIDR(s string) (ip IP, pfx IP, mask IPMask, err os.Error)\n\nAdds a new return value pfx which describes its address prefix and\nallows parsing both \"fe80::/64\" and \"192.168.0.254/29\" notations.\n",
			"disapproval": false,
			"date": "2011-07-21 11:09:08.768801",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I propose we change ParseCIDR to the following:\n\nfunc ParseCIDR(s string) (ip IP, net IP, mask IPMask, err os.Error)\n\nreturning both the IP address and the network the IP address is part of as\nx.y.z.w/n really provides you those three things.  If ParseCIDR does not do\nthis I will end up writing a new function because I do need to get back all\nthree pieces when processing certain networking configuration files.\n\n    -Paul\n\n\nOn Wed, Jul 20, 2011 at 7:57 AM, Russ Cox <rsc@golang.org> wrote:\n\n> I found in RFC 4291 some support for your ifconfig command\n> but it still doesn't help with the ParseCIDR code.\n>\n>   When writing both a node address and a prefix of that node address\n>   (e.g., the node's subnet prefix), the two can be combined as follows:\n>\n>      the node address      2001:0DB8:0:CD30:123:4567:89AB:CDEF\n>      and its subnet number 2001:0DB8:0:CD30::/60\n>\n>      can be abbreviated as 2001:0DB8:0:CD30:123:4567:89AB:CDEF/60\n>\n> If we allow but do not mask, then callers all have to know to mask.\n> If we allow but do mask, then the ifconfig thing will silently fail.\n>\n> I'm not thrilled with either.\n>\n",
			"disapproval": false,
			"date": "2011-07-22 19:12:40.219938",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "PTAL.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode572\nsrc/pkg/net/ip.go:572: // address, a network mask, an address prefix and a prefix\nOn 2011/08/07 16:22:06, borman wrote:\n> This is not quite right, an IP network is defined by a network and mask (e.g.,\n> 1.2.3.0/24 or 1.2.3.0 and 255.255.255.0).  This structure is both an IP address\n> and the network to which the IP address belongs.  In any event, I would remove\n> the \"It consists of ...\" part and add a comment to each element.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode578\nsrc/pkg/net/ip.go:578: PrefixLen int\nOn 2011/08/07 16:22:06, borman wrote:\n> While a CIDR mask has a prefix length, not all IP masks do.   I feel IPNet\n> should be a generic structure and not limited to CIDR only networks.  I would\n> also rename Prefix to Network.  I suppose the length could be -1 for non-CIDR\n> masks.\n\naddress filtering w/ wildcards? certainly.\n\n> Also, shouldn't this be up with the other types?\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode578\nsrc/pkg/net/ip.go:578: PrefixLen int\nOn 2011/08/07 16:22:06, borman wrote:\n> While a CIDR mask has a prefix length, not all IP masks do.   I feel IPNet\n> should be a generic structure and not limited to CIDR only networks.  I would\n> also rename Prefix to Network.  I suppose the length could be -1 for non-CIDR\n> masks.\n> \n> Also, shouldn't this be up with the other types?\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode585\nsrc/pkg/net/ip.go:585: func ParseCIDR(s string) (*IPNet, os.Error) {\nOn 2011/08/07 16:22:06, borman wrote:\n> Changing the usage will require gofix to be updated as well.\n> \n> We should consider having the signature being:\n> \n> func ParseCIDR(s string) (IP, *IPNet, os.Error)\n> \n> and having IPNet only define a network.  It will also make gofix easier for some\n> number of calls to ParseCIDR\n> \n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode587\nsrc/pkg/net/ip.go:587: ip   IP\nOn 2011/08/07 16:22:06, borman wrote:\n> No need for this, just use := on line 597\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode589\nsrc/pkg/net/ip.go:589: pfx  IP\nOn 2011/08/07 16:22:06, borman wrote:\n> No need for this, just use := on line 622\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode624\nsrc/pkg/net/ip.go:624: // address prefix must not have any bits not in mask\nOn 2011/08/07 16:22:06, borman wrote:\n> This comment seems a bit off, now.  It made sense to explain why an error was\n> being returned in the original, but now the code seems self explanatory.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip_test.go\nFile src/pkg/net/ip_test.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip_test.go#newcode52\nsrc/pkg/net/ip_test.go:52: {IP{0x20, 0x1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0x1, 0x23, 0, 0x12, 0, 0x1}, \"2001:db8::123:12:1\"},\nOn 2011/08/07 16:22:06, borman wrote:\n> Why was this code changed and a new test added?  I cannot see the applicability\n> to what this CL is about.\n\njust adjusted test table style like others.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip_test.go#newcode52\nsrc/pkg/net/ip_test.go:52: {IP{0x20, 0x1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0x1, 0x23, 0, 0x12, 0, 0x1}, \"2001:db8::123:12:1\"},\nOn 2011/08/07 16:22:06, borman wrote:\n> Why was this code changed and a new test added?  I cannot see the applicability\n> to what this CL is about.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip_test.go#newcode112\nsrc/pkg/net/ip_test.go:112: } else if err == nil && (!isEqual(out.IP, tt.out.IP) || !isEqual(out.Mask, tt.out.Mask) || !isEqual(out.Prefix, tt.out.Prefix) || out.PrefixLen != tt.out.PrefixLen) {\nOn 2011/08/07 16:22:06, borman wrote:\n> Shouldn't this be\n> if !reflect.DeepEqual(out, tt.out) {\n>     t.Errorf(\"ParseCIDR(%q) = %v; want %v\", tt.in, out, tt.out)\n> }\n\nDone.",
			"disapproval": false,
			"date": "2011-08-10 15:57:23.988444",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com, golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-07 15:29:08.509590",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "You probably should wait to hear from Russ before spending too much time on my comments.  Russ may have additional/different/conflicting comments.  Russ clearly had some thoughts on what an IPNet might be.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode572\nsrc/pkg/net/ip.go:572: // address, a network mask, an address prefix and a prefix\nThis is not quite right, an IP network is defined by a network and mask (e.g., 1.2.3.0/24 or 1.2.3.0 and 255.255.255.0).  This structure is both an IP address and the network to which the IP address belongs.  In any event, I would remove the \"It consists of ...\" part and add a comment to each element.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode578\nsrc/pkg/net/ip.go:578: PrefixLen int\nWhile a CIDR mask has a prefix length, not all IP masks do.   I feel IPNet should be a generic structure and not limited to CIDR only networks.  I would also rename Prefix to Network.  I suppose the length could be -1 for non-CIDR masks.\n\nAlso, shouldn't this be up with the other types?\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode585\nsrc/pkg/net/ip.go:585: func ParseCIDR(s string) (*IPNet, os.Error) {\nChanging the usage will require gofix to be updated as well.\n\nWe should consider having the signature being:\n\nfunc ParseCIDR(s string) (IP, *IPNet, os.Error)\n\nand having IPNet only define a network.  It will also make gofix easier for some number of calls to ParseCIDR\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode587\nsrc/pkg/net/ip.go:587: ip   IP\nNo need for this, just use := on line 597\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode589\nsrc/pkg/net/ip.go:589: pfx  IP\nNo need for this, just use := on line 622\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip.go#newcode624\nsrc/pkg/net/ip.go:624: // address prefix must not have any bits not in mask\nThis comment seems a bit off, now.  It made sense to explain why an error was being returned in the original, but now the code seems self explanatory.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip_test.go\nFile src/pkg/net/ip_test.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip_test.go#newcode52\nsrc/pkg/net/ip_test.go:52: {IP{0x20, 0x1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0x1, 0x23, 0, 0x12, 0, 0x1}, \"2001:db8::123:12:1\"},\nWhy was this code changed and a new test added?  I cannot see the applicability to what this CL is about.\n\nhttp://codereview.appspot.com/4749043/diff/15002/src/pkg/net/ip_test.go#newcode112\nsrc/pkg/net/ip_test.go:112: } else if err == nil && (!isEqual(out.IP, tt.out.IP) || !isEqual(out.Mask, tt.out.Mask) || !isEqual(out.Prefix, tt.out.Prefix) || out.PrefixLen != tt.out.PrefixLen) {\nShouldn't this be\nif !reflect.DeepEqual(out, tt.out) {\n    t.Errorf(\"ParseCIDR(%q) = %v; want %v\", tt.in, out, tt.out)\n}",
			"disapproval": false,
			"date": "2011-08-07 16:22:06.203178",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com, golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-07 16:33:43.422443",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Mon, Aug 8, 2011 at 1:22 AM,  <borman@google.com> wrote:\n\n> You probably should wait to hear from Russ before spending too much time\n> on my comments. \u00a0Russ may have additional/different/conflicting\n> comments. \u00a0Russ clearly had some thoughts on what an IPNet might be.\n\nThank you for your suggestions. Agreed, this CL is just a starwman.\n",
			"disapproval": false,
			"date": "2011-08-07 16:44:01.939427",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com, golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-10 15:59:16.240469",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com, golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-10 15:57:50.466007",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Sorry for the delay.\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/cmd/gofix/netparsecidr.go\nFile src/cmd/gofix/netparsecidr.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/cmd/gofix/netparsecidr.go#newcode11\nsrc/cmd/gofix/netparsecidr.go:11: var netparsecidrFix = fix{\nI don't believe a gofix is warranted.\n:= will take care of the simple cases,\nand the hard cases require people to change their code.\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/pkg/net/ip.go#newcode42\nsrc/pkg/net/ip.go:42: Network   IP     // network number\nIP IP \n\nadd three methods\n\n// Net returns the network's base IP address,\n// for example 192.168.0.0 for 192.168.2.3/16.\nfunc (n *IPNet) Net() IP {\n\n// Has reports whether the network includes ip.\nfunc (n *IPNet) Has(ip IP) bool {\n\nfunc (n *IPNet) String() string\n\nI'd like a better name than Has if you have any ideas.\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/pkg/net/ip.go#newcode44\nsrc/pkg/net/ip.go:44: PrefixLen int    // address prefix length\nDelete.  Redundant with Mask.\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/pkg/net/ip.go#newcode582\nsrc/pkg/net/ip.go:582: func ParseCIDR(s string) (IP, *IPNet, os.Error) {\nParseCIDR should return *IPNet, os.Error",
			"disapproval": false,
			"date": "2011-08-16 20:17:06.092222",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode212\nsrc/pkg/net/ip.go:212: if len(mask) == 16 && len(ip) == 4 && bytesEqual(ip[:12], v4InV6Prefix) {\nlen(ip) == 4 so ip[:12] is going to crash.\nI think allFF(mask[:12]) was correct.\nThere should be another if before the n != len(mask) check:\n\nif len(mask) == 16 && len(ip) == 4 {\n    ip = ip.To6()\n}\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode377\nsrc/pkg/net/ip.go:377: // Len returns the length of mask.  If the mask is a sequence of\nI don't know that this is a good idea.\nIt's hard to use Len by itself: you also need\nto know whether mask is a IPv6 or IPv4 mask.\nThe String method really only works because\nit gets paired with an IP address of the right length.\nI don't see any uses of Len in the code.\n\nLet's leave this out.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode427\nsrc/pkg/net/ip.go:427: if n == nil {\nIn general you don't have to worry about nil receivers.\nThe caller shouldn't do that, and if it does, it will crash.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode431\nsrc/pkg/net/ip.go:431: return n.IP.Mask(n.Mask).Equal(ip.Mask(n.Mask))\nThis is doing various allocations.  I would rather see a slightly\nmore complex implementation that never allocated.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode436\nsrc/pkg/net/ip.go:436: // Net returns the network's base IP address,\nCan delete this method now that code can just use n.IP.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode446\nsrc/pkg/net/ip.go:446: if n == nil {\nCan delete.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode621\nsrc/pkg/net/ip.go:621: // number as known as address prefix and network mask like\nI can't parse this.  Suggested new comment:\n\n// ParseCIDR parses s as a CIDR notation IP address and mask,\n// like \"192.168.100.1/16\" or \"2001:DB8::/48\", as defined in\n// RFC 4632 and RFC 4291.\n//\n// It returns the IP address and the network implied by the IP and mask.\n// For example, ParseCIDR(\"192.168.100.1/16\") returns the IP address\n// 192.168.100.1 and the network 192.168.0.0/16.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip_test.go\nFile src/pkg/net/ip_test.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip_test.go#newcode61\nsrc/pkg/net/ip_test.go:61: {nil, \"\"},\nThis is kind of weird.  I know it's what the old code did\nbut I would format nil as \"<nil>\" instead.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip_test.go#newcode135\nsrc/pkg/net/ip_test.go:135: {nil, \"\"},\nSame.",
			"disapproval": false,
			"date": "2011-08-17 17:07:36.484238",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/26002/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/pkg/net/ip.go#newcode582\nsrc/pkg/net/ip.go:582: func ParseCIDR(s string) (IP, *IPNet, os.Error) {\nOn 2011/08/16 20:17:06, rsc wrote:\n> ParseCIDR should return *IPNet, os.Error\n\nThis does not make sense to me.  An IP address is not an IP Network and an IP Network does not require an IP address.  You are getting two distinct things out of this, an IP address and an IP Network.",
			"disapproval": false,
			"date": "2011-08-16 20:29:24.694037",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> This does not make sense to me. \u00a0An IP address is not an IP Network and\n> an IP Network does not require an IP address. \u00a0You are getting two\n> distinct things out of this, an IP address and an IP Network.\n\nI don't understand.\n\nParseCIDR(\"ip/mask\")  returns &IPNet{ip, mask}\n\nIt's a 1:1 relationship between the input and output.\n\nIf you want the IP address, you use n.IP.\nIf you want the base network, you use n.Net().\n",
			"disapproval": false,
			"date": "2011-08-16 20:32:50.903046",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Aug 16, 2011 at 3:52 PM, Russ Cox <rsc@golang.org> wrote:\n\n> > ParseCIDR gives you more than two things, which is why this CL exists at\n> > all.  It gives you an IP Address, the IP Network (host part being 0) and\n> the\n> > IP Mask.  An IP Network is defined by an IP address with the host part\n> being\n> > 0 and an IP Mask (so you can figure out what the host part it).\n> > 1.2.3.4/24 -> An IP Address of 1.2.3.4 and an IP Network of 1.2.3.0/24which\n> > is composed of an Address (1.2.3.0) and a Mask (255.255.255.0).  If IPNet\n> is\n> > the definition of an IP Network then it should only have the latter two.\n>  In\n> > your case the n.Net() is insufficient, that does not tell me the IP\n> network\n> > unless I have the mask as well.  1.0.0.1/24 and 1.0.1.0/16 both would\n> return\n> > 1.0.0.0 as the Net value but they are very much not part of the same\n> > network.\n>\n> Yes, if you wanted to scribble the results somewhere else\n> you would want to save both n.Net() and n.Mask.\n> Why is that a problem?  Why are you scribbling anything\n> instead of just using n itself?\n>\n> Russ\n>\n\nIPNet should be\n\n// An IPNet defines an IP Network\ntype IPNet struct {\n    Network IP\n    Mask IPMask\n}\n\nand that is it.  Adding \"IP IP\" doesn't make sense.  You don't need an IP\nhost address to define an IP Network.  ParseCIDR just happens to give you\nboth an IP address and an IP network (the latter including the mask).\n",
			"disapproval": false,
			"date": "2011-08-16 20:57:57.006096",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Aug 16, 2011 at 3:32 PM, Russ Cox <rsc@golang.org> wrote:\n\n> > This does not make sense to me.  An IP address is not an IP Network and\n> > an IP Network does not require an IP address.  You are getting two\n> > distinct things out of this, an IP address and an IP Network.\n>\n> I don't understand.\n>\n> ParseCIDR(\"ip/mask\")  returns &IPNet{ip, mask}\n>\n> It's a 1:1 relationship between the input and output.\n>\n> If you want the IP address, you use n.IP.\n> If you want the base network, you use n.Net().\n>\n\nParseCIDR gives you more than two things, which is why this CL exists at\nall.  It gives you an IP Address, the IP Network (host part being 0) and the\nIP Mask.  An IP Network is defined by an IP address with the host part being\n0 and an IP Mask (so you can figure out what the host part it).\n\n1.2.3.4/24 -> An IP Address of 1.2.3.4 and an IP Network of 1.2.3.0/24 which\nis composed of an Address (1.2.3.0) and a Mask (255.255.255.0).  If IPNet is\nthe definition of an IP Network then it should only have the latter two.  In\nyour case the n.Net() is insufficient, that does not tell me the IP network\nunless I have the mask as well.  1.0.0.1/24 and 1.0.1.0/16 both would return\n1.0.0.0 as the Net value but they are very much not part of the same\nnetwork.\n\nI do not need an IP host address to have an IP Network address (which\nincludes the mask).\n",
			"disapproval": false,
			"date": "2011-08-16 20:48:02.905723",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Thank you for the review, re-designing API.\nI'll try to fix tonight or tomorrow.\n\n+Paul: you know what I need, that's amazing, thx.\n\nOn Wed, Aug 17, 2011 at 6:13 AM, Russ Cox <rsc@golang.org> wrote:\n\n> Okay, I guess we have to let ParseCIDR return ip, net, err.\n> That said, the struct should still be\n>\n> type IPNet struct {\n> \u00a0 \u00a0IP IP\n> \u00a0 \u00a0Mask IPMask\n> }\n>\n> the IP field is the network IP.\n\nJust for clarification.\n\n> src/cmd/gofix/netparsecidr.go:11: var netparsecidrFix = fix{\n> I don't believe a gofix is warranted.\n> := will take care of the simple cases,\n> and the hard cases require people to change their code.\n\nAgreed, but I have no good idea to above.\nWhat's your suggestion, just warn() call makes sense to you?\n",
			"disapproval": false,
			"date": "2011-08-17 03:40:34.434190",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> ParseCIDR gives you more than two things, which is why this CL exists at\n> all. \u00a0It gives you an IP Address, the IP Network (host part being 0) and the\n> IP Mask. \u00a0An IP Network is defined by an IP address with the host part being\n> 0 and an IP Mask (so you can figure out what the host part it).\n> 1.2.3.4/24 -> An IP Address of 1.2.3.4 and an IP Network of 1.2.3.0/24 which\n> is composed of an Address (1.2.3.0) and a Mask (255.255.255.0). \u00a0If IPNet is\n> the definition of an IP Network then it should only have the latter two. \u00a0In\n> your case the n.Net() is insufficient, that does not tell me the IP network\n> unless I have the mask as well. \u00a01.0.0.1/24 and 1.0.1.0/16 both would return\n> 1.0.0.0 as the Net value but they are very much not part of the same\n> network.\n\nYes, if you wanted to scribble the results somewhere else\nyou would want to save both n.Net() and n.Mask.\nWhy is that a problem?  Why are you scribbling anything\ninstead of just using n itself?\n\nRuss\n",
			"disapproval": false,
			"date": "2011-08-16 20:52:27.464453",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Okay, I guess we have to let ParseCIDR return ip, net, err.\nThat said, the struct should still be\n\ntype IPNet struct {\n    IP IP\n    Mask IPMask\n}\n\nthe IP field is the network IP.\n",
			"disapproval": false,
			"date": "2011-08-16 21:13:26.468183",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Okay, that is fine with me.\n\nOn Tue, Aug 16, 2011 at 4:13 PM, Russ Cox <rsc@golang.org> wrote:\n\n> Okay, I guess we have to let ParseCIDR return ip, net, err.\n> That said, the struct should still be\n>\n> type IPNet struct {\n>    IP IP\n>    Mask IPMask\n> }\n>\n> the IP field is the network IP.\n>\n",
			"disapproval": false,
			"date": "2011-08-16 21:23:42.050226",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": ">> I don't know that this is a good idea.\n>> It's hard to use Len by itself: you also need\n>> to know whether mask is a IPv6 or IPv4 mask.\n>> The String method really only works because\n>> it gets paired with an IP address of the right length.\n>> I don't see any uses of Len in the code.\n>\n> I thought it would be nice when I have to write conventional routing\n> speakers such as OSPF/IS-IS/BGP/etc, because these guys carry\n> pairs of address prefix and prefix length to neighbors, not only\n> routing informations come from neighbors but also static entries\n> via configuration. It does not make sense to me that only prefix\n> length requires string to integer conversion with IPNet.\n>\n>> Let's leave this out.\n>\n> Well, can I put prefix length into IPNet struct again?\n\nNo, because then there's redundant information\nto keep in sync.\n\nI guess we need a method, but Len is not a good name\nfor it, since x.Len() and len(x) would return different numbers.\n\nIt bothers me that if IPMask is an IPv4 mask then you\nget back 24 but if IPMask is an IPv6 mask then you get\nback 120, so you need to know both the count and whether\nthis is an IPv4 mask or an IPv6 mask.  I am worried that\nthat will be a problem, but I don't know how to fix it.\n\nFor now how about:\n\n// Count returns the number of leading ones in the mask.\n// If the mask is not in the canonical form--ones followed by\n// zeros--then Count returns -1.\nfunc (m IPMask) Count() int\n\nRuss\n",
			"disapproval": false,
			"date": "2011-08-18 17:15:56.369264",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-17 16:52:23.491919",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/26002/src/cmd/gofix/netparsecidr.go\nFile src/cmd/gofix/netparsecidr.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/cmd/gofix/netparsecidr.go#newcode11\nsrc/cmd/gofix/netparsecidr.go:11: var netparsecidrFix = fix{\nOn 2011/08/16 20:17:06, rsc wrote:\n> I don't believe a gofix is warranted.\n> := will take care of the simple cases,\n> and the hard cases require people to change their code.\n\nokay, removed.\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/cmd/gofix/netparsecidr.go#newcode11\nsrc/cmd/gofix/netparsecidr.go:11: var netparsecidrFix = fix{\nOn 2011/08/16 20:17:06, rsc wrote:\n> I don't believe a gofix is warranted.\n> := will take care of the simple cases,\n> and the hard cases require people to change their code.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/pkg/net/ip.go#newcode42\nsrc/pkg/net/ip.go:42: Network   IP     // network number\nOn 2011/08/16 20:17:06, rsc wrote:\n> IP IP \n> \n> add three methods\n> \n> // Net returns the network's base IP address,\n> // for example 192.168.0.0 for 192.168.2.3/16.\n> func (n *IPNet) Net() IP {\n> \n> // Has reports whether the network includes ip.\n> func (n *IPNet) Has(ip IP) bool {\n> \n> func (n *IPNet) String() string\n> \n> I'd like a better name than Has if you have any ideas.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/pkg/net/ip.go#newcode44\nsrc/pkg/net/ip.go:44: PrefixLen int    // address prefix length\nOn 2011/08/16 20:17:06, rsc wrote:\n> Delete.  Redundant with Mask.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/26002/src/pkg/net/ip.go#newcode582\nsrc/pkg/net/ip.go:582: func ParseCIDR(s string) (IP, *IPNet, os.Error) {\nOn 2011/08/16 20:29:24, borman wrote:\n> On 2011/08/16 20:17:06, rsc wrote:\n> > ParseCIDR should return *IPNet, os.Error\n> \n> This does not make sense to me.  An IP address is not an IP Network and an IP\n> Network does not require an IP address.  You are getting two distinct things out\n> of this, an IP address and an IP Network.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode64\nsrc/pkg/net/ip.go:64: copy(p, v4InV6Prefix)\nOn 2011/08/17 13:53:08, borman wrote:\n> Why are you switching how an IPv4 mask is represented?  Is this to differentiate\n> IPv6 masks with a prefix length of 96 or greater?\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode64\nsrc/pkg/net/ip.go:64: copy(p, v4InV6Prefix)\nOn 2011/08/17 13:53:08, borman wrote:\n> Why are you switching how an IPv4 mask is represented?  Is this to differentiate\n> IPv6 masks with a prefix length of 96 or greater?\n\nprevious IPMask.String fails the added new test \nTestIPMaskString, seems like a bug.\n\n--- FAIL: net.TestIPMaskString (0.00 seconds)\n\tIPMask.String(ffff:ffff:ffff:fffe::) = `ffff:ffff:ffff:fffe::`, want `63`\n\tIPMask.String(ffff:ff80::) = `ffff:ff80::`, want `25`\n\tIPMask.String(ffff:ffff:ffff:ffff:ffff:ffff:ff00:ff00) = `ffff:ffff:ffff:ffff:ffff:ffff:ff00:ff00`, want `255.0.255.0`\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode428\nsrc/pkg/net/ip.go:428: func (n *IPNet) CanAggregate(ip IP) bool {\nOn 2011/08/17 13:53:08, borman wrote:\n> Perhaps \"Contains\" would be a better name here?  As a verb, aggregate means\n> \"form or group into a class or cluster : [ intrans. ] the butterflies aggregate\n> in dense groups.\"\n\nmakes sense, thx.\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode428\nsrc/pkg/net/ip.go:428: func (n *IPNet) CanAggregate(ip IP) bool {\nOn 2011/08/17 13:53:08, borman wrote:\n> Perhaps \"Contains\" would be a better name here?  As a verb, aggregate means\n> \"form or group into a class or cluster : [ intrans. ] the butterflies aggregate\n> in dense groups.\"\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode433\nsrc/pkg/net/ip.go:433: if ip4 := ip.To4(); ip4 != nil {\nOn 2011/08/17 13:53:08, borman wrote:\n> if a = ip.To4(); a != nil {\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode435\nsrc/pkg/net/ip.go:435: a = ip.To4()\nOn 2011/08/17 13:53:08, borman wrote:\n> Then drop this line\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode443\nsrc/pkg/net/ip.go:443: quo := n.Mask.Len() / 8\nOn 2011/08/17 13:53:08, borman wrote:\n> What if the mask is not a proper prefix?  0xfffff0f0\n> Isn't this all just:\n> \n> return n.IP.Equal(ip.Mask(n.Mask))\n\ngood catch, thx.\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode443\nsrc/pkg/net/ip.go:443: quo := n.Mask.Len() / 8\nOn 2011/08/17 13:53:08, borman wrote:\n> What if the mask is not a proper prefix?  0xfffff0f0\n> Isn't this all just:\n> \n> return n.IP.Equal(ip.Mask(n.Mask))\n\nDone.",
			"disapproval": false,
			"date": "2011-08-17 16:52:03.299398",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Aug 18, 2011 at 2:07 AM,  <rsc@golang.org> wrote:\n\n> http://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode377\n> src/pkg/net/ip.go:377: // Len returns the length of mask. \u00a0If the mask\n> is a sequence of\n> I don't know that this is a good idea.\n> It's hard to use Len by itself: you also need\n> to know whether mask is a IPv6 or IPv4 mask.\n> The String method really only works because\n> it gets paired with an IP address of the right length.\n> I don't see any uses of Len in the code.\n\nI thought it would be nice when I have to write conventional routing\nspeakers such as OSPF/IS-IS/BGP/etc, because these guys carry\npairs of address prefix and prefix length to neighbors, not only\nrouting informations come from neighbors but also static entries\nvia configuration. It does not make sense to me that only prefix\nlength requires string to integer conversion with IPNet.\n\n> Let's leave this out.\n\nWell, can I put prefix length into IPNet struct again?\n",
			"disapproval": false,
			"date": "2011-08-18 00:56:36.487173",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode64\nsrc/pkg/net/ip.go:64: copy(p, v4InV6Prefix)\nWhy are you switching how an IPv4 mask is represented?  Is this to differentiate IPv6 masks with a prefix length of 96 or greater?\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode428\nsrc/pkg/net/ip.go:428: func (n *IPNet) CanAggregate(ip IP) bool {\nPerhaps \"Contains\" would be a better name here?  As a verb, aggregate means \"form or group into a class or cluster : [ intrans. ] the butterflies aggregate in dense groups.\"\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode433\nsrc/pkg/net/ip.go:433: if ip4 := ip.To4(); ip4 != nil {\nif a = ip.To4(); a != nil {\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode435\nsrc/pkg/net/ip.go:435: a = ip.To4()\nThen drop this line\n\nhttp://codereview.appspot.com/4749043/diff/43001/src/pkg/net/ip.go#newcode443\nsrc/pkg/net/ip.go:443: quo := n.Mask.Len() / 8\nWhat if the mask is not a proper prefix?  0xfffff0f0\nIsn't this all just:\n\nreturn n.IP.Equal(ip.Mask(n.Mask))",
			"disapproval": false,
			"date": "2011-08-17 13:53:08.049086",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "My suggestion wrt gofix is to do nothing.\nThe code will stop compiling.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-08-17 14:00:36.371904",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Aug 18, 2011 at 10:15 AM, Russ Cox <rsc@golang.org> wrote:\n\n> >> I don't know that this is a good idea.\n> >> It's hard to use Len by itself: you also need\n> >> to know whether mask is a IPv6 or IPv4 mask.\n> >> The String method really only works because\n> >> it gets paired with an IP address of the right length.\n> >> I don't see any uses of Len in the code.\n> >\n> > I thought it would be nice when I have to write conventional routing\n> > speakers such as OSPF/IS-IS/BGP/etc, because these guys carry\n> > pairs of address prefix and prefix length to neighbors, not only\n> > routing informations come from neighbors but also static entries\n> > via configuration. It does not make sense to me that only prefix\n> > length requires string to integer conversion with IPNet.\n> >\n> >> Let's leave this out.\n> >\n> > Well, can I put prefix length into IPNet struct again?\n>\n> No, because then there's redundant information\n> to keep in sync.\n>\n> I guess we need a method, but Len is not a good name\n> for it, since x.Len() and len(x) would return different numbers.\n>\n> It bothers me that if IPMask is an IPv4 mask then you\n> get back 24 but if IPMask is an IPv6 mask then you get\n> back 120, so you need to know both the count and whether\n> this is an IPv4 mask or an IPv6 mask.  I am worried that\n> that will be a problem, but I don't know how to fix it.\n>\n> For now how about:\n>\n> // Count returns the number of leading ones in the mask.\n> // If the mask is not in the canonical form--ones followed by\n> // zeros--then Count returns -1.\n> func (m IPMask) Count() int\n>\n> Russ\n>\n\nI spent some time talking with my brother, who is a leading member of the IETF\nand was a core developer of the BSD networking stack.  The best name for\nthis would be PrefixLength.  That is what it is.\n\nOn the subject of ParseCIDR, he agrees with Mikio's first proposal of just\nreturn the IP address and Mask.  The network number (which in this case is a\nprefix) is simply ip.Mask(mask).\n\nOne thing he pointed out is a prefix is always a mask but a mask is not\nalways a prefix.\n\nThe actual expanded mask is probably more useful than the prefix length in\nmost instances.\n\nActually, I think PrefixLength should be a method on IPMask instead of\nIPNet.\n\n    -Paul\n",
			"disapproval": false,
			"date": "2011-08-18 19:38:51.630916",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I'd like to take Paul's suggestion: PrefixLength on IPMask,\nbecause it sounds natural to me.\n\n// PrefixLength returns the number of leading ones in the mask.\n// If the mask is not in the canonical form--ones followed by\n// zeros--then PrefixLength returns -1.\nfunc (m IPMask) PrefixLength() int\n\n-- Mikio\n",
			"disapproval": false,
			"date": "2011-08-19 09:18:13.344676",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode212\nsrc/pkg/net/ip.go:212: if len(mask) == 16 && len(ip) == 4 && bytesEqual(ip[:12], v4InV6Prefix) {\nOn 2011/08/17 17:07:36, rsc wrote:\n> len(ip) == 4 so ip[:12] is going to crash.\n> I think allFF(mask[:12]) was correct.\n> There should be another if before the n != len(mask) check:\n> \n> if len(mask) == 16 && len(ip) == 4 {\n>     ip = ip.To6()\n> }\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode377\nsrc/pkg/net/ip.go:377: // Len returns the length of mask.  If the mask is a sequence of\nOn 2011/08/17 17:07:36, rsc wrote:\n> I don't know that this is a good idea.\n> It's hard to use Len by itself: you also need\n> to know whether mask is a IPv6 or IPv4 mask.\n> The String method really only works because\n> it gets paired with an IP address of the right length.\n> I don't see any uses of Len in the code.\n> \n> Let's leave this out.\n\nAs we discussed: func (mask IPMask) PrefixLength() int\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode377\nsrc/pkg/net/ip.go:377: // Len returns the length of mask.  If the mask is a sequence of\nOn 2011/08/17 17:07:36, rsc wrote:\n> I don't know that this is a good idea.\n> It's hard to use Len by itself: you also need\n> to know whether mask is a IPv6 or IPv4 mask.\n> The String method really only works because\n> it gets paired with an IP address of the right length.\n> I don't see any uses of Len in the code.\n> \n> Let's leave this out.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode427\nsrc/pkg/net/ip.go:427: if n == nil {\nOn 2011/08/17 17:07:36, rsc wrote:\n> In general you don't have to worry about nil receivers.\n> The caller shouldn't do that, and if it does, it will crash.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode436\nsrc/pkg/net/ip.go:436: // Net returns the network's base IP address,\nOn 2011/08/17 17:07:36, rsc wrote:\n> Can delete this method now that code can just use n.IP.\n\nremoved.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode436\nsrc/pkg/net/ip.go:436: // Net returns the network's base IP address,\nOn 2011/08/17 17:07:36, rsc wrote:\n> Can delete this method now that code can just use n.IP.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode446\nsrc/pkg/net/ip.go:446: if n == nil {\nOn 2011/08/17 17:07:36, rsc wrote:\n> Can delete.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode621\nsrc/pkg/net/ip.go:621: // number as known as address prefix and network mask like\nOn 2011/08/17 17:07:36, rsc wrote:\n> I can't parse this.  Suggested new comment:\n> \n> // ParseCIDR parses s as a CIDR notation IP address and mask,\n> // like \"192.168.100.1/16\" or \"2001:DB8::/48\", as defined in\n> // RFC 4632 and RFC 4291.\n> //\n> // It returns the IP address and the network implied by the IP and mask.\n> // For example, ParseCIDR(\"192.168.100.1/16\") returns the IP address\n> // 192.168.100.1 and the network 192.168.0.0/16.\n\nThanks.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip.go#newcode621\nsrc/pkg/net/ip.go:621: // number as known as address prefix and network mask like\nOn 2011/08/17 17:07:36, rsc wrote:\n> I can't parse this.  Suggested new comment:\n> \n> // ParseCIDR parses s as a CIDR notation IP address and mask,\n> // like \"192.168.100.1/16\" or \"2001:DB8::/48\", as defined in\n> // RFC 4632 and RFC 4291.\n> //\n> // It returns the IP address and the network implied by the IP and mask.\n> // For example, ParseCIDR(\"192.168.100.1/16\") returns the IP address\n> // 192.168.100.1 and the network 192.168.0.0/16.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip_test.go\nFile src/pkg/net/ip_test.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip_test.go#newcode61\nsrc/pkg/net/ip_test.go:61: {nil, \"\"},\nOn 2011/08/17 17:07:36, rsc wrote:\n> This is kind of weird.  I know it's what the old code did\n> but I would format nil as \"<nil>\" instead.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/48001/src/pkg/net/ip_test.go#newcode135\nsrc/pkg/net/ip_test.go:135: {nil, \"\"},\nOn 2011/08/17 17:07:36, rsc wrote:\n> Same.\n\nDone.",
			"disapproval": false,
			"date": "2011-08-22 17:17:24.745935",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Mon, Aug 22, 2011 at 14:41, Paul Borman <borman@google.com> wrote:\n> Perhaps we should go back to what Mikio first suggested then, return the IP\n> and IPMask represented by x.x.x.x/n or xxxx::xxxxx/n but not mask the IP\n> address as the original code was doing. \u00a0If they want the network they say:\n\nNo, I like having IPNet, if only for the cheaper Contains method.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-08-22 18:50:33.142661",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Looks good.  The only problem is the mask == v4InV6Prefix comparisons.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode212\nsrc/pkg/net/ip.go:212: if len(ip) == 4 && len(mask) == 16 && bytesEqual(mask[:12], v4InV6Prefix) {\nThis should be allFF.  A mask equal to the IP prefix\nwould be a non-canonical mask.  It doesn't make any sense.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode266\nsrc/pkg/net/ip.go:266: // String returns the string form of the IP address ip.  If the\nWhy did this get reformatted?\nPlease unreformat.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode390\nsrc/pkg/net/ip.go:390: if bytesEqual(mask[:12], v4InV6Prefix) {\nI don't understand why this change was made.\nIt seems very wrong to compare the mask to v4InV6Prefix.\nComparing to allFF would make more sense but even then\nit introduces an ambiguity.  I'd rather keep this as it was.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode413\nsrc/pkg/net/ip.go:413: var n int\nSame comment.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode432\nsrc/pkg/net/ip.go:432: if len(ip) == 4 && len(n.Mask) == 16 && bytesEqual(n.Mask[:12], v4InV6Prefix) {\nallFF\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode596\nsrc/pkg/net/ip.go:596: // A ParseError represents a malformed text string and the type of\nPlease unreformat.",
			"disapproval": false,
			"date": "2011-08-22 18:01:11.082363",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-22 17:17:41.974581",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> I was confused by this at first, too, but I think Mikio is doing the\n> right thing. \u00a0A 4 byte IPv4 address is represented as a 16 byte value by\n> prepending it with v4InV6Prefix. \u00a0This is doing the same thing for IPv4\n> masks. \u00a0An IP mask is an IP address, so I think this representation\n> makes sense.\n>\n> In the previous method, using all 1's, you can't tell the difference\n> between a /n IPv4 mask and a /(n+96) IPv6 mask. \u00a0For example, a /8 and\n> /104 (in 16 byte notation) both are:\n>\n> \u00a0 \u00a0ffff:ffff:ffff:ffff:ffff:ffff:ff00:0000\n>\n> With Mikio's change a /8 (in 16 byte notation) is:\n>\n> \u00a0 \u00a00000:0000:0000:0000:0000:ffff:ff00:0000\n>\n> Now the ambiguity is removed.\n\nCan you point to an RFC encouraging this representation?\nIt makes no sense to me: it's not a mask anymore.\n\nYou don't need to tell the difference between /n IPv4 and\n/(n+96) IPv6.  They are the same.  You do need to tell\nthe difference between /n IPv4 and /n IPv6, and the only\nway to do that is to know the mask size len(mask).  C'est la IP.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-08-22 18:26:28.945455",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-24 13:37:42.773145",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Mon, Aug 22, 2011 at 14:52, Mikio Hara <mikioh.mikioh@gmail.com> wrote:\n> On Tue, Aug 23, 2011 at 3:26 AM, Russ Cox <rsc@golang.org> wrote:\n>\n>> Can you point to an RFC encouraging this representation?\n>> It makes no sense to me: it's not a mask anymore.\n>\n> Hmm... what I really need is the prefix length of the network, ah, okay.\n> Does \"func (n* IPNet) PrefixLength() int\" make sense to both of you?\n\nI grudgingly accept it, but I think it is not very useful\nunless you also know whether this is an IPv4 and IPv6 mask:\n/8 for IPv4 is not the same as /8 for IPv6.\nI assume that the caller will be checking that out of band.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-08-22 18:55:46.732523",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> On the subject of ParseCIDR, he agrees with Mikio's first proposal of just\n> return the IP address and Mask. \u00a0The network number (which in this case is a\n> prefix) is simply\u00a0ip.Mask(mask).\n\nReturning the IPNet as a separate thing has the\nimportant advantage of giving people ip.Mask(mask)\nalready computed.  I think many people would assume,\nif we returned (IP, IPMask, os.Error), that the IP was\nitself the network number and forget to mask.\n\n> One thing he pointed out\u00a0is a prefix is always a mask but a mask is not\n> always a prefix.\n> The actual expanded mask is probably more useful than the prefix length in\n> most instances.\n\nRight, this is why ParseCIDR in its current form returns\nan IPMask instead of an int.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-08-22 18:03:50.506634",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode212\nsrc/pkg/net/ip.go:212: if len(ip) == 4 && len(mask) == 16 && bytesEqual(mask[:12], v4InV6Prefix) {\nOn 2011/08/22 18:01:11, rsc wrote:\n> This should be allFF.  A mask equal to the IP prefix\n> would be a non-canonical mask.  It doesn't make any sense.\n\nSee my comment below.  This does make sense.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode390\nsrc/pkg/net/ip.go:390: if bytesEqual(mask[:12], v4InV6Prefix) {\nOn 2011/08/22 18:01:11, rsc wrote:\n> I don't understand why this change was made.\n> It seems very wrong to compare the mask to v4InV6Prefix.\n> Comparing to allFF would make more sense but even then\n> it introduces an ambiguity.  I'd rather keep this as it was.\n\nI was confused by this at first, too, but I think Mikio is doing the right thing.  A 4 byte IPv4 address is represented as a 16 byte value by prepending it with v4InV6Prefix.  This is doing the same thing for IPv4 masks.  An IP mask is an IP address, so I think this representation makes sense.\n\nIn the previous method, using all 1's, you can't tell the difference between a /n IPv4 mask and a /(n+96) IPv6 mask.  For example, a /8 and /104 (in 16 byte notation) both are:\n\n    ffff:ffff:ffff:ffff:ffff:ffff:ff00:0000\n\nWith Mikio's change a /8 (in 16 byte notation) is:\n\n    0000:0000:0000:0000:0000:ffff:ff00:0000\n\nNow the ambiguity is removed.",
			"disapproval": false,
			"date": "2011-08-22 18:21:53.322974",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Aug 23, 2011 at 3:01 AM,  <rsc@golang.org> wrote:\n\n> http://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode212\n> src/pkg/net/ip.go:212: if len(ip) == 4 && len(mask) == 16 &&\n> bytesEqual(mask[:12], v4InV6Prefix) {\n> This should be allFF. \u00a0A mask equal to the IP prefix\n> would be a non-canonical mask. \u00a0It doesn't make any sense.\n\nBut how could I find out the differentiation btw IPv6 IPv4-mapped\naddress and IPv6 address?\n\n> http://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode266\n> src/pkg/net/ip.go:266: // String returns the string form of the IP\n> address ip. \u00a0If the\n> Why did this get reformatted?\n> Please unreformat.\n\nOops, yup, forgot to revert it; I did check godoc behavior at same time\nto investigate issue 2172, 2173.\n",
			"disapproval": false,
			"date": "2011-08-22 18:30:46.343540",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Perhaps we should go back to what Mikio first suggested then, return the IP\nand IPMask represented by x.x.x.x/n or xxxx::xxxxx/n but not mask the IP\naddress as the original code was doing.  If they want the network they say:\n\n    ip, mask, err := ParseCIDR(...)\n\n    net := ip.Mask(mask),\n\n\nOn Mon, Aug 22, 2011 at 11:03 AM, Russ Cox <rsc@golang.org> wrote:\n\n> > On the subject of ParseCIDR, he agrees with Mikio's first proposal of\n> just\n> > return the IP address and Mask.  The network number (which in this case\n> is a\n> > prefix) is simply ip.Mask(mask).\n>\n> Returning the IPNet as a separate thing has the\n> important advantage of giving people ip.Mask(mask)\n> already computed.  I think many people would assume,\n> if we returned (IP, IPMask, os.Error), that the IP was\n> itself the network number and forget to mask.\n>\n> > One thing he pointed out is a prefix is always a mask but a mask is not\n> > always a prefix.\n> > The actual expanded mask is probably more useful than the prefix length\n> in\n> > most instances.\n>\n> Right, this is why ParseCIDR in its current form returns\n> an IPMask instead of an int.\n>\n> Russ\n>\n",
			"disapproval": false,
			"date": "2011-08-22 18:41:38.270475",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": ">> http://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode212\n>> src/pkg/net/ip.go:212: if len(ip) == 4 && len(mask) == 16 &&\n>> bytesEqual(mask[:12], v4InV6Prefix) {\n>> This should be allFF. \u00a0A mask equal to the IP prefix\n>> would be a non-canonical mask. \u00a0It doesn't make any sense.\n>\n> But how could I find out the differentiation btw IPv6 IPv4-mapped\n> address and IPv6 address?\n\nI don't understand why it matters.  Can you give me a\nspecific ParseCIDR + IPNet.Contains sequence that\ncares?\n\nSpecifically, I think that\n\n&IPNet{IP{1,2,0,0}, IPMask{0xff,0xff,0,0}}\n&IPNet{IP{0,0,0,0,0,0,0,0,0,0,0xff,0xff,1,2,0,0},\nIPMask{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0,0}}\n\nare completely equivalent.  The first comes from\nParseCIDR(\"1.2.0.0/16\") and the second from\nParseCIDR(\"::ffff:1.2.0.0/112\").\n\nRuss\n",
			"disapproval": false,
			"date": "2011-08-22 18:50:08.083138",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Aug 23, 2011 at 3:26 AM, Russ Cox <rsc@golang.org> wrote:\n\n> Can you point to an RFC encouraging this representation?\n> It makes no sense to me: it's not a mask anymore.\n\nHmm... what I really need is the prefix length of the network, ah, okay.\nDoes \"func (n* IPNet) PrefixLength() int\" make sense to both of you?\n",
			"disapproval": false,
			"date": "2011-08-22 18:52:57.921919",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Aug 23, 2011 at 3:50 AM, Russ Cox <rsc@golang.org> wrote:\n\n> I don't understand why it matters. \u00a0Can you give me a\n> specific ParseCIDR + IPNet.Contains sequence that\n> cares?\n\nI'd like to see ParseCIDR(\"abcd:2345::/127\") returns the address,\nthe net and *the prefix length of the net\", passes test cases like\nbelow:\n\n{\"172.16.1.127/31\", IPv4(172, 16, 1, 127), &IPNet{IPv4(172, 16, 1,\n126), IPv4Mask(255, 255, 255, 254)}, 31, nil},\n{\"abcd:2345::/127\", ParseIP(\"abcd:2345::\"),\n&IPNet{ParseIP(\"abcd:2345::\"),\nIPMask(ParseIP(\"ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffe\"))}, 127,\nnil},\n\nFor now IPMask never knows the network number of the net, and is\ninternally stored 16-byte form thus returns incorrect prefix length.\n\nIf you can accept IPNet.PrefixLenght...\n\n> I grudgingly accept it, but I think it is not very useful\n> unless you also know whether this is an IPv4 and IPv6 mask:\n> /8 for IPv4 is not the same as /8 for IPv6.\n> I assume that the caller will be checking that out of band.\n\nAh, thanks, let me sleep on it.\n\n-- Mikio\n",
			"disapproval": false,
			"date": "2011-08-22 19:06:56.749592",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-24 08:24:04.448468",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode212\nsrc/pkg/net/ip.go:212: if len(ip) == 4 && len(mask) == 16 && bytesEqual(mask[:12], v4InV6Prefix) {\nOn 2011/08/22 18:01:11, rsc wrote:\n> This should be allFF.  A mask equal to the IP prefix\n> would be a non-canonical mask.  It doesn't make any sense.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode266\nsrc/pkg/net/ip.go:266: // String returns the string form of the IP address ip.  If the\nOn 2011/08/22 18:01:11, rsc wrote:\n> Why did this get reformatted?\n> Please unreformat.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode390\nsrc/pkg/net/ip.go:390: if bytesEqual(mask[:12], v4InV6Prefix) {\nOn 2011/08/22 18:01:11, rsc wrote:\n\n> I don't understand why this change was made.\n> It seems very wrong to compare the mask to v4InV6Prefix.\n> Comparing to allFF would make more sense but even then\n> it introduces an ambiguity.  I'd rather keep this as it was.\n\nOkay, I will retreat from Mask.PreifxLength stuff but \nI'd like to go with func (n *IPNet) PrefixLength() int.\nI understand that you did accept this grudgingly in \nprevious review, hope it has been still kept.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode390\nsrc/pkg/net/ip.go:390: if bytesEqual(mask[:12], v4InV6Prefix) {\nOn 2011/08/22 18:01:11, rsc wrote:\n> I don't understand why this change was made.\n> It seems very wrong to compare the mask to v4InV6Prefix.\n> Comparing to allFF would make more sense but even then\n> it introduces an ambiguity.  I'd rather keep this as it was.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode413\nsrc/pkg/net/ip.go:413: var n int\nOn 2011/08/22 18:01:11, rsc wrote:\n> Same comment.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode432\nsrc/pkg/net/ip.go:432: if len(ip) == 4 && len(n.Mask) == 16 && bytesEqual(n.Mask[:12], v4InV6Prefix) {\nOn 2011/08/22 18:01:11, rsc wrote:\n> allFF\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/53001/src/pkg/net/ip.go#newcode596\nsrc/pkg/net/ip.go:596: // A ParseError represents a malformed text string and the type of\nOn 2011/08/22 18:01:11, rsc wrote:\n> Please unreformat.\n\nDone.",
			"disapproval": false,
			"date": "2011-08-24 07:35:14.760178",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "I am finally starting to understand some of this.\n\nI made a mistake when I implemented IPMask originally:\nI represented an IPMask as 16 byte slice always.\nThis makes the String method impossible to do correctly,\nsince the mask you get from parsing ::ffff:1.2.3.0/120\nand the mask you get from parsing 1.2.3.0/24 have the\nsame 16-byte representation.  The current String\nmethod subtracts 96 from numbers before printing them,\nwhich means reprinting the first input will show as\n::ffff:1.2.3.0/24 which is wrong.  The representation\nis the core issue: an IPv4 IPMask should have len 4.\nI have flagged the relevant lines below.\n\nWith that fix, I think things get clearer.\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode63\nsrc/pkg/net/ip.go:63: p := make(IPMask, IPv6len)\nThis is a mistake (mine).\nTo tell that something is an IPv4 mask it needs\nto have length 4.\n\nreturn IPMask{a,b,c,d}\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode175\nsrc/pkg/net/ip.go:175: // If ip is not an IP address (it is the wrong length), To16\nunreformat\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode392\nsrc/pkg/net/ip.go:392: // String returns the string representation of mask.  If the mask\nPlease unreformat.\n\nThe line breaks in the original comment are where they are\nso that you can skim from sentence to sentence easily.\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode405\nsrc/pkg/net/ip.go:405: if n >= 12*8 {\nThis should be n >= 0.\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode406\nsrc/pkg/net/ip.go:406: return itod(uint(n - 12*8))\nThis should be itod(uint(n))",
			"disapproval": false,
			"date": "2011-08-24 16:47:13.005884",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-24 07:35:32.684222",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-24 10:44:05.508167",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "> The representation is the core issue: an IPv4 IPMask should have len 4.\n\nSounds good, PTAL.\n\n- PrefixLength is moved to IPMask as its method again\n- Made IPMask.String and IPNet.String output format better,\n   probably, I mean, a bit familiar to networking guys\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode175\nsrc/pkg/net/ip.go:175: // If ip is not an IP address (it is the wrong length), To16\nOn 2011/08/24 16:47:13, rsc wrote:\n> unreformat\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode392\nsrc/pkg/net/ip.go:392: // String returns the string representation of mask.  If the mask\nOn 2011/08/24 16:47:13, rsc wrote:\n> Please unreformat.\n> \n> The line breaks in the original comment are where they are\n> so that you can skim from sentence to sentence easily.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode405\nsrc/pkg/net/ip.go:405: if n >= 12*8 {\nOn 2011/08/24 16:47:13, rsc wrote:\n> This should be n >= 0.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode406\nsrc/pkg/net/ip.go:406: return itod(uint(n - 12*8))\nOn 2011/08/24 16:47:13, rsc wrote:\n> This should be itod(uint(n))\n\nDone.",
			"disapproval": false,
			"date": "2011-08-25 03:21:03.837651",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Sep 8, 2011 at 3:00 AM, Russ Cox <rsc@golang.org> wrote:\n\n> we made it to the end!\n\nYeah, many thanks to both of you, Paul and Russ.\n",
			"disapproval": false,
			"date": "2011-09-08 02:54:12.860541",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-25 03:21:22.400011",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Fri, Aug 26, 2011 at 6:19 AM, Russ Cox <rsc@golang.org> wrote:\n\n> I think we are converging, but this CL has grown too large.\n> Let's regroup a bit.\n\nack.\n",
			"disapproval": false,
			"date": "2011-08-25 21:58:02.448643",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-09-06 12:26:20.120418",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-25 21:54:06.505575",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "LGTM",
			"disapproval": false,
			"date": "2011-09-07 16:10:22.179310",
			"approval": true
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode214\nsrc/pkg/net/ip.go:214: if len(ip) == IPv4len && len(mask) == IPv6len {\nThis allows an IPv6 mask to be applied to an IPv4 addresss.  Does that make sense?  1.2.3.4/ffff:ff00:: will get displayed as 1.2.3.4/24 but will result in 0.0.0.0.  Maybe we shouldn't care, I don't know.\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode357\nsrc/pkg/net/ip.go:357: // as hexadeciaml.\nAn IPv6 Mask must be a single series of 1's followed by a single series of 0's.  Anything else is an invalid IPv6 mask.  For IPv4 I see hex and dotted quad equally.  Since this will only happen with a non-CIDR mask, which is the very rare case, after all, I think the previous IP(mask).String() was probably just fine.\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode371\nsrc/pkg/net/ip.go:371: bb.WriteString(\"0x\")\nmove this above the for and remove the check\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode412\nsrc/pkg/net/ip.go:412: return s + \", \" + n.Mask.String()\nThis doesn't make sense to me.  It only is used when the mask is not a CIDR mask but that is the time it can be most difficult to determine if something is a mask or not \"a.b.c.d, e.f.g.h\" looks like 2 IP addresses while \"a.b.c.d/e.f.g.h\" is more clear that the latter is a mask and not a second IP address.",
			"disapproval": false,
			"date": "2011-08-25 16:39:44.011124",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-30 00:44:29.156818",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "> I think Contains is not quite right.  The tests below\n> should tease it out.\n\nAm I missing something wrong? probably, but I don't see \nany problems on Contains method. Please let me know \nany good test cases for shooting the bug you found.\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode25\nsrc/pkg/net/ip.go:25: // or 16-byte (IPv6) arrays as input.  Unless otherwise\nOn 2011/08/31 22:08:05, rsc wrote:\n> Please delete this sentence (Unless otherwise...).\n> It's not true for things like IP.Mask and I don't\n> want people depending on this.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/88001/src/pkg/net/ip_test.go\nFile src/pkg/net/ip_test.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/88001/src/pkg/net/ip_test.go#newcode172\nsrc/pkg/net/ip_test.go:172: }\nOn 2011/08/31 22:08:05, rsc wrote:\n> add\n> if ip4 := tt.ip.To4(); ip4 != nil {\n>     if ok := tt.net.Contains(ip4); ok != tt.ok {\n>         t.Errorf(\"IPNet(%v).Contains(%v.To4()) = %v, want %v\", http://tt.net, tt.ip,\n> ok, tt.ok)\n>     }\n> }\n\nDone.",
			"disapproval": false,
			"date": "2011-09-01 06:20:12.926599",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode412\nsrc/pkg/net/ip.go:412: return s + \", \" + n.Mask.String()\nOn 2011/08/25 16:39:44, borman wrote:\n> This doesn't make sense to me.  It only is used when the mask is not a CIDR mask\n> but that is the time it can be most difficult to determine if something is a\n> mask or not \"a.b.c.d, e.f.g.h\" looks like 2 IP addresses while \"a.b.c.d/e.f.g.h\"\n> is more clear that the latter is a mask and not a second IP address.\n\nShouldn't this just be:\n\nreturn n.IP.String() + \"/\" + n.Mask.String()",
			"disapproval": false,
			"date": "2011-08-25 16:45:51.184332",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I think we are converging, but this CL has grown too large.\nLet's regroup a bit.\n\nFirst, send a CL with the 4->IPv4len and 16->IPv6len\nchanges only.  Then we can get that in.\n\nSecond, send a CL moving the decimal routines to\nparse.go.  Then we can get that in.  Change\nthe itox call to itox(..., 1).\n\nfunc itox(i uint, min int) string {\n\t// Assemble hexadecimal in reverse order.\n\tvar b [32]byte\n\tbp := len(b)\n\tfor ; i > 0 || min > 0; i /= 16 {\n\t\tbp--\n\t\tb[bp] = \"0123456789abcdef\"[byte(i%16)]\n\t\tmin--\n\t}\n\n\treturn string(b[bp:])\n}\n\nThird, send a CL with the changes to IPMask:\n  * IPv4Mask returns a 4-length mask\n  * String returns just unpunctuated hex.\n  * add Size method.\n\n// String returns the hexadecimal form of m, with no punctuation.\nfunc (mask IPMask) String() string {\n\ts := \"\"\n\tfor _, b := range m {\n\t\ts += itox(b, 2)\n\t}\n}\n\n// Size returns the number of leading ones and total bits in the mask.\n// If the mask is not in the canonical form--ones followed by zeros--then\n// Size returns 0, 0.\nfunc (mask IPMask) Size() (ones, bits int)\n\nAny necessary changes to ip.Mask can go here too.\n\nFourth, send a CL (or update this one) adding\nIPNet and changing ParseCIDR.\n\nI think this will speed things along because it\nwill be easier to focus on one thing at a time.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-08-25 21:19:46.221463",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode214\nsrc/pkg/net/ip.go:214: if len(ip) == IPv4len && len(mask) == IPv6len {\nOn 2011/08/25 16:39:44, borman wrote:\n> This allows an IPv6 mask to be applied to an IPv4 addresss.  Does that make\n> sense?  1.2.3.4/ffff:ff00:: will get displayed as 1.2.3.4/24 but will result in\n> 0.0.0.0.  Maybe we shouldn't care, I don't know.\n\nFor now  there's no reason to accept an IPv6 mask for the IPv4 address.\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode214\nsrc/pkg/net/ip.go:214: if len(ip) == IPv4len && len(mask) == IPv6len {\nOn 2011/08/25 16:39:44, borman wrote:\n> This allows an IPv6 mask to be applied to an IPv4 addresss.  Does that make\n> sense?  1.2.3.4/ffff:ff00:: will get displayed as 1.2.3.4/24 but will result in\n> 0.0.0.0.  Maybe we shouldn't care, I don't know.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode357\nsrc/pkg/net/ip.go:357: // as hexadeciaml.\nOn 2011/08/25 16:39:44, borman wrote:\n> An IPv6 Mask must be a single series of 1's followed by a single series of 0's.\n> Anything else is an invalid IPv6 mask.  \n\nI think there's no consensus (and no convention) about that.\n\n> after all, I think the previous IP(mask).String() was probably just\n> fine.\n\nAgreed.\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode357\nsrc/pkg/net/ip.go:357: // as hexadeciaml.\nOn 2011/08/25 16:39:44, borman wrote:\n> An IPv6 Mask must be a single series of 1's followed by a single series of 0's. \n> Anything else is an invalid IPv6 mask.  For IPv4 I see hex and dotted quad\n> equally.  Since this will only happen with a non-CIDR mask, which is the very\n> rare case, after all, I think the previous IP(mask).String() was probably just\n> fine.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode371\nsrc/pkg/net/ip.go:371: bb.WriteString(\"0x\")\nOn 2011/08/25 16:39:44, borman wrote:\n> move this above the for and remove the check\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/74001/src/pkg/net/ip.go#newcode412\nsrc/pkg/net/ip.go:412: return s + \", \" + n.Mask.String()\nOn 2011/08/25 16:45:51, borman wrote:\n> On 2011/08/25 16:39:44, borman wrote:\n> > This doesn't make sense to me.  It only is used when the mask is not a CIDR\n> mask\n> > but that is the time it can be most difficult to determine if something is a\n> > mask or not \"a.b.c.d, e.f.g.h\" looks like 2 IP addresses while\n> \"a.b.c.d/e.f.g.h\"\n> > is more clear that the latter is a mask and not a second IP address.\n> \n> Shouldn't this just be:\n> \n> return n.IP.String() + \"/\" + n.Mask.String()\n\nDone.",
			"disapproval": false,
			"date": "2011-08-25 21:53:33.035118",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/88004/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/88004/src/pkg/net/ip.go#newcode409\nsrc/pkg/net/ip.go:409: return n.IP.String() + \"/\" + itod(uint(l))\nOn 2011/09/01 15:31:11, borman wrote:\n> This will work for IPNet's produced by ParseCIDR but it will not work for an\n> IPNet made up of an IPv4 address that uses a 16 byte mask.  You will get a value\n> greater than 96 to the right of the /.\n\nDone.",
			"disapproval": false,
			"date": "2011-09-02 05:21:19.061589",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "I'm happy with the API.  Splitting it up helped a ton.\nI think Contains is not quite right.  The tests below\nshould tease it out.\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/53005/src/pkg/net/ip.go#newcode25\nsrc/pkg/net/ip.go:25: // or 16-byte (IPv6) arrays as input.  Unless otherwise\nPlease delete this sentence (Unless otherwise...).\nIt's not true for things like IP.Mask and I don't\nwant people depending on this.\n\nhttp://codereview.appspot.com/4749043/diff/88001/src/pkg/net/ip_test.go\nFile src/pkg/net/ip_test.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/88001/src/pkg/net/ip_test.go#newcode172\nsrc/pkg/net/ip_test.go:172: }\nadd\nif ip4 := tt.ip.To4(); ip4 != nil {\n    if ok := tt.net.Contains(ip4); ok != tt.ok {\n        t.Errorf(\"IPNet(%v).Contains(%v.To4()) = %v, want %v\", tt.net, tt.ip, ok, tt.ok)\n    }\n}",
			"disapproval": false,
			"date": "2011-08-31 22:08:05.679528",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-09-02 09:06:05.363413",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=ee93036cddf9 ***\n\nnet: ParseCIDR returns IPNet instead of IPMask\n\nNote that this CL will break your existing code which uses\nParseCIDR.\n\nThis CL changes ParseCIDR(\"172.16.253.121/28\") to return\nthe IP address \"172.16.253.121\", the network implied by the\nnetwork number \"172.16.253.112\" and mask \"255.255.255.240\".\n\nR=rsc, borman\nCC=golang-dev\nhttp://codereview.appspot.com/4749043\n\nCommitter: Russ Cox <rsc@golang.org>\n\nhttp://codereview.appspot.com/4749043/diff/81002/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/81002/src/pkg/net/ip.go#newcode68\nsrc/pkg/net/ip.go:68: // CIDRMask returns an IPMask of size bits with the first n bits\nmove 'set to 1' up here.\nnext line:\n// It returns nil if the parameters are invalid.\n\nhttp://codereview.appspot.com/4749043/diff/81002/src/pkg/net/ip.go#newcode70\nsrc/pkg/net/ip.go:70: func CIDRMask(ones, bits int) IPMask {\ns/ones, bits/n, size/ to match documentation.",
			"disapproval": false,
			"date": "2011-09-07 18:01:16.493596",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-09-03 03:10:33.607238",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-09-01 06:20:37.057488",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-09-02 05:21:51.264529",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Forgot I had written these comments.\nI will send a CL.\n\nOn Wed, Sep 7, 2011 at 14:01,  <rsc@golang.org> wrote:\n> http://codereview.appspot.com/4749043/diff/81002/src/pkg/net/ip.go\n> File src/pkg/net/ip.go (right):\n>\n> http://codereview.appspot.com/4749043/diff/81002/src/pkg/net/ip.go#newcode68\n> src/pkg/net/ip.go:68: // CIDRMask returns an IPMask of size bits with\n> the first n bits\n> move 'set to 1' up here.\n> next line:\n> // It returns nil if the parameters are invalid.\n>\n> http://codereview.appspot.com/4749043/diff/81002/src/pkg/net/ip.go#newcode70\n> src/pkg/net/ip.go:70: func CIDRMask(ones, bits int) IPMask {\n> s/ones, bits/n, size/ to match documentation.\n",
			"disapproval": false,
			"date": "2011-09-07 18:36:30.236014",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/88004/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/88004/src/pkg/net/ip.go#newcode409\nsrc/pkg/net/ip.go:409: return n.IP.String() + \"/\" + itod(uint(l))\nThis will work for IPNet's produced by ParseCIDR but it will not work for an IPNet made up of an IPv4 address that uses a 16 byte mask.  You will get a value greater than 96 to the right of the /.",
			"disapproval": false,
			"date": "2011-09-01 15:31:11.070344",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/88005/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/88005/src/pkg/net/ip.go#newcode371\nsrc/pkg/net/ip.go:371: func networkNumberAndMask(n *IPNet) (IP, IPMask) {\nI had several comments on edge cases and simplification.  To make sure I was right I ended up just writing networkNumberAndMask and corresponding tests.  PTAL.\n\nfunc networkNumberAndMask(n *IPNet) (ip IP, m IPMask) {\n        if ip = n.IP.To4(); ip == nil {\n                ip = n.IP\n                if len(ip) != IPv6len {\n                        return nil, nil\n                }\n        }\n        m = n.Mask\n        switch len(m) {\n        case IPv4len:\n                if len(ip) != IPv4len {\n                        return nil, nil\n                }\n        case IPv6len:\n                if len(ip) == IPv4len {\n                        m = m[12:]\n                }\n        default:\n                return nil, nil\n        }\n        return\n}\n\nThe test I used to test it was:\n\nvar (\n\tv4addr    = IP{1, 2, 3, 4}\n\tv4in6addr = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 1, 2, 3, 4}\n\tv6addr    = IP{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\tv4mask    = IPMask{255, 255, 255, 0}\n\tv4in6mask = IPMask{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0}\n\tv6mask    = IPMask{255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\tbadaddr   = IP{1, 2, 3}\n\tbadmask   = IPMask{255, 255, 0}\n\tz4mask    = IPMask{0, 0, 0, 0}\n)\n\nvar networkNumberAndMaskTest = []struct {\n\tin  IPNet\n\tout IPNet\n}{\n\t{\n\t\tin:  IPNet{v4addr, v4mask},\n\t\tout: IPNet{v4addr, v4mask},\n\t},\n\t{\n\t\tin:  IPNet{v4addr, v4in6mask},\n\t\tout: IPNet{v4addr, v4mask},\n\t},\n\t{\n\t\tin:  IPNet{v4in6addr, v4in6mask},\n\t\tout: IPNet{v4addr, v4mask},\n\t},\n\t{\n\t\tin:  IPNet{v4in6addr, v6mask},\n\t\tout: IPNet{v4addr, z4mask},\n\t},\n\t{\n\t\tin:  IPNet{v4addr, v6mask},\n\t\tout: IPNet{v4addr, z4mask},\n\t},\n\t{\n\t\tin:  IPNet{v6addr, v6mask},\n\t\tout: IPNet{v6addr, v6mask},\n\t},\n\t{\n\t\tin:  IPNet{v6addr, v4in6mask},\n\t\tout: IPNet{v6addr, v4in6mask},\n\t},\n\t{in: IPNet{v6addr, v4mask}},\n\t{in: IPNet{v4addr, badmask}},\n\t{in: IPNet{v4in6addr, badmask}},\n\t{in: IPNet{v6addr, badmask}},\n\t{in: IPNet{badaddr, v4mask}},\n\t{in: IPNet{badaddr, v4in6mask}},\n\t{in: IPNet{badaddr, v6mask}},\n\t{in: IPNet{badaddr, badmask}},\n}\n\nfunc TestNandM(t *testing.T) {\n\tfor i, tt := range networkNumberAndMaskTest {\n\t\tip, m := networkNumberAndMask(&tt.in)\n\t\tout := &IPNet{ip, m}\n\t\tif !reflect.DeepEqual(&tt.out, out) {\n\t\t\tt.Errorf(\"#%d: got %#v, want %#v\", i, out, &tt.out)\n\t\t}\n\t}\n}\n\nhttp://codereview.appspot.com/4749043/diff/88005/src/pkg/net/ip.go#newcode405\nsrc/pkg/net/ip.go:405: if l != len(nn) || l != len(m) {\njust if l != len(nn) (we know len(nn) == len(m))",
			"disapproval": false,
			"date": "2011-09-02 16:49:57.954174",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/88005/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/88005/src/pkg/net/ip.go#newcode371\nsrc/pkg/net/ip.go:371: func networkNumberAndMask(n *IPNet) (IP, IPMask) {\nOn 2011/09/02 16:49:58, borman wrote:\n> I had several comments on edge cases and simplification.  To make sure I was\n> right I ended up just writing networkNumberAndMask and corresponding tests. \n> PTAL.\n\nLooks concise and natural, thanks.\n\nhttp://codereview.appspot.com/4749043/diff/88005/src/pkg/net/ip.go#newcode405\nsrc/pkg/net/ip.go:405: if l != len(nn) || l != len(m) {\nOn 2011/09/02 16:49:58, borman wrote:\n> just if l != len(nn) (we know len(nn) == len(m))\n\nDone.",
			"disapproval": false,
			"date": "2011-09-03 03:10:14.087586",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/91008/src/pkg/net/ip_test.go\nFile src/pkg/net/ip_test.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/91008/src/pkg/net/ip_test.go#newcode133\nsrc/pkg/net/ip_test.go:133: {\"2001:DB8::/48\", ParseIP(\"2001:DB8::\"), &IPNet{ParseIP(\"2001:DB8::\"), IPMask(ParseIP(\"ffff:ffff:ffff::\"))}, nil},\nOn 2011/09/07 06:41:24, borman wrote:\n> This looks good.  Just one more test, say 2001:DB8::1/48 to demonstrate that\n> ParseCIDR works works for IPv6 a well as IPv4 when the IP address has the host\n> part as well as the network part.\n\nDone.",
			"disapproval": false,
			"date": "2011-09-07 07:08:57.766592",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "LGTM\n\nwe made it to the end!\n",
			"disapproval": false,
			"date": "2011-09-07 18:00:44.108846",
			"approval": true
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "It is looking pretty good, but the mixture of 16 and 4 byte representations of IPv4 addresses along with the now ability to mix IPv6 and IPv4 IP/Masks in IPNet keeps adding special cases.  I guess the grand-unification theory is complicated.\n\nhttp://codereview.appspot.com/4749043/diff/90006/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/90006/src/pkg/net/ip.go#newcode411\nsrc/pkg/net/ip.go:411: }\nOkay, that looks like it should work.  The other case that is missing is when n.IP is 16 bytes but n.Mask is 4 bytes.  If n.IP starts with the v4InV6Prefix then it should be okay, but if someone has really mixed an IPv6 address with an IPv4 mask...  I can't see how it would be valid so perhaps it should return \"<nil>\" in that case (though \"<nil>\" is not quite right since it isn't empty).",
			"disapproval": false,
			"date": "2011-09-02 05:38:40.928778",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip.go#newcode70\nsrc/pkg/net/ip.go:70: func CIDRMask(ones, bits int) IPMask {\nOn 2011/09/06 17:41:54, borman wrote:\n> I think this is right, but it is unfortunate that you cannot pass IPv4len or\n> IPv6len as a value.  I would like to hear what Russ thinks in this case.\n\nagreed.\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip.go#newcode71\nsrc/pkg/net/ip.go:71: if bits%8 != 0 {\nOn 2011/09/06 17:41:54, borman wrote:\n> bits <= 0 ||\n> \n> or better yet\n> \n> if bits != IPv4len * 8 && bits != IPv6len * 8\n> \n> Then you don't have check the size of bits below.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip.go#newcode84\nsrc/pkg/net/ip.go:84: m = make(IPMask, IPv6len)\nOn 2011/09/06 17:41:54, borman wrote:\n> You can do both the IPv4 and the IPv6 (actually, any size) case with the code\n> you have for IPv6, just use bits/8 for IPv6len.\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip_test.go\nFile src/pkg/net/ip_test.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip_test.go#newcode119\nsrc/pkg/net/ip_test.go:119: {\"0.0.0.0/0\", IPv4(0, 0, 0, 0), &IPNet{IPv4(0, 0, 0, 0), CIDRMask(0, 32)}, 0, nil},\nOn 2011/09/06 17:41:54, borman wrote:\n> I wish all the test cases had not been changed.  It is making it more\n> challenging to determine if we are covering the same tests as before.  As it\n> stands, I think the first two cases are missing.  I think we should be using the\n> same tests as were initially provided.  No need for the pfxlen argument, that is\n> not being tested here.\n> \n> (I have been comparing against the original tests that existed before this CL)\n\nDone.\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip_test.go#newcode253\nsrc/pkg/net/ip_test.go:253: \nOn 2011/09/06 17:41:54, borman wrote:\n> Please add the tests for networkNumberAndMask.  If networkNumberAndMask fails\n> then both String and Contains can fail.  It is best not to hide the edge cases\n> of networkNumberAndMask in the tests for String and Contains.  This makes it\n> easier to track down bugs that may be introduced at a later time.\n\nDone.",
			"disapproval": false,
			"date": "2011-09-07 06:04:05.725067",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "LGTM with the addition of the missing test case.\n\nhttp://codereview.appspot.com/4749043/diff/91008/src/pkg/net/ip_test.go\nFile src/pkg/net/ip_test.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/91008/src/pkg/net/ip_test.go#newcode133\nsrc/pkg/net/ip_test.go:133: {\"2001:DB8::/48\", ParseIP(\"2001:DB8::\"), &IPNet{ParseIP(\"2001:DB8::\"), IPMask(ParseIP(\"ffff:ffff:ffff::\"))}, nil},\nThis looks good.  Just one more test, say 2001:DB8::1/48 to demonstrate that ParseCIDR works works for IPv6 a well as IPv4 when the IP address has the host part as well as the network part.",
			"disapproval": false,
			"date": "2011-09-07 06:41:24.189765",
			"approval": true
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Fri, Sep 2, 2011 at 2:38 PM,  <borman@google.com> wrote:\n\n> It is looking pretty good, but the mixture of 16 and 4 byte\n> representations of IPv4 addresses along with the now ability to mix IPv6\n> and IPv4 IP/Masks in IPNet keeps adding special cases.\n\nFor now I'd like to follow the convention of existing routing stuff\nimplementation that IP mask is the mask, it belongs to an IP address.\nE.g., func (m *RouteMessage) sockaddr() []Sockaddr in syscall/route_bsd.go\n\n> I guess the grand-unification theory is complicated.\n\nI agree with you but this case wont be a dragon... perhaps.... I hope so.\n\n> http://codereview.appspot.com/4749043/diff/90006/src/pkg/net/ip.go#newcode411\n> src/pkg/net/ip.go:411: }\n> Okay, that looks like it should work. \u00a0The other case that is missing is\n> when n.IP is 16 bytes but n.Mask is 4 bytes. \u00a0If n.IP starts with the\n> v4InV6Prefix then it should be okay, but if someone has really mixed an\n> IPv6 address with an IPv4 mask... \u00a0I can't see how it would be valid so\n> perhaps it should return \"<nil>\" in that case (though \"<nil>\" is not\n> quite right since it isn't empty).\n\nLet me try it, PTAL.\nAnd I think \"<nil>\" is okay, it's better that \"\" for debugging.\n\n-- Mikio\n",
			"disapproval": false,
			"date": "2011-09-02 09:10:17.996609",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-09-07 07:09:13.494811",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2011/09/03 03:40:39, borman wrote:\n\n> I am going to need more time to review the tests (I am in an airplane right now)\n> as they have very long constants.\n\nMuch appreciate it.\n\n> I have to think they would be easier if we\n> had something like:\n(snip)\n> func NewIPPrefix(n, size int) IPMask\n\nOr more straightforwardly: func CIDRMask(ones, bits int) IPMask.",
			"disapproval": false,
			"date": "2011-09-04 07:31:09.534272",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip.go\nFile src/pkg/net/ip.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip.go#newcode70\nsrc/pkg/net/ip.go:70: func CIDRMask(ones, bits int) IPMask {\nI think this is right, but it is unfortunate that you cannot pass IPv4len or IPv6len as a value.  I would like to hear what Russ thinks in this case.\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip.go#newcode71\nsrc/pkg/net/ip.go:71: if bits%8 != 0 {\nbits <= 0 ||\n\nor better yet\n\nif bits != IPv4len * 8 && bits != IPv6len * 8\n\nThen you don't have check the size of bits below.\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip.go#newcode84\nsrc/pkg/net/ip.go:84: m = make(IPMask, IPv6len)\nYou can do both the IPv4 and the IPv6 (actually, any size) case with the code you have for IPv6, just use bits/8 for IPv6len.\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip_test.go\nFile src/pkg/net/ip_test.go (right):\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip_test.go#newcode119\nsrc/pkg/net/ip_test.go:119: {\"0.0.0.0/0\", IPv4(0, 0, 0, 0), &IPNet{IPv4(0, 0, 0, 0), CIDRMask(0, 32)}, 0, nil},\nI wish all the test cases had not been changed.  It is making it more challenging to determine if we are covering the same tests as before.  As it stands, I think the first two cases are missing.  I think we should be using the same tests as were initially provided.  No need for the pfxlen argument, that is not being tested here.\n\n(I have been comparing against the original tests that existed before this CL)\n\nhttp://codereview.appspot.com/4749043/diff/91007/src/pkg/net/ip_test.go#newcode253\nsrc/pkg/net/ip_test.go:253: \nPlease add the tests for networkNumberAndMask.  If networkNumberAndMask fails then both String and Contains can fail.  It is best not to hide the edge cases of networkNumberAndMask in the tests for String and Contains.  This makes it easier to track down bugs that may be introduced at a later time.",
			"disapproval": false,
			"date": "2011-09-06 17:41:54.273186",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "I am going to need more time to review the tests (I am in an airplane right now) as they have very long constants.  I have to think they would be easier if we had something like:\n\n// NewIPPrefix returns an IPMask of size bits with the first n bits set to to 1.\n// nil is returned if the Mask is impossible.\nfunc NewIPPrefix(n, size int) IPMask",
			"disapproval": false,
			"date": "2011-09-03 03:40:39.834170",
			"approval": false
		},
		{
			"sender": "mikioh.mikioh@gmail.com",
			"recipients": [
				"mikioh.mikioh@gmail.com",
				"rsc@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-09-07 06:04:24.641602",
			"approval": false
		}
	],
	"owner_email": "mikioh.mikioh@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "mikio",
	"subject": "code review 4749043: net: ParseCIDR returns IPNet instead of IPMask",
	"created": "2011-07-15 10:57:09.035393",
	"patchsets": [
		1,
		2001,
		5001,
		3003,
		15002,
		18005,
		19003,
		26002,
		43001,
		48001,
		53001,
		64001,
		54003,
		68001,
		53005,
		74001,
		83002,
		88001,
		88004,
		90006,
		88005,
		97002,
		91007,
		91008,
		81002
	],
	"modified": "2011-09-07 22:24:10.048245",
	"closed": true,
	"issue": 4749043
}