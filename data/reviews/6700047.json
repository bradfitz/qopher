{
	"description": "archive/tar: read/write extended pax/gnu tar archives\n\nSupport reading pax archives and applying extended attributes\nlike long names, subsecond mtime resolutions, etc. Default to\nwriting pax archives for long file and link names.\nSupport reading gnu archives using the ././@LongLink extended\nheader for file name and link target.\n\nFixes issue 3300",
	"cc": [
		"dsymonds@golang.org",
		"dave@cheney.net",
		"rogpeppe@gmail.com",
		"remyoudompheng@gmail.com",
		"chressie@gmail.com",
		"rsc@golang.org",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Sorry for the spam, just realized my comments didn't make it out with my last email.\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/common.go\nFile src/pkg/archive/tar/common.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/common.go#newcode37\nsrc/pkg/archive/tar/common.go:37: TypeGnuLongName   = 'L'    // Next file has a long name\nOn 2012/10/16 00:53:13, dsymonds wrote:\n> keep \"GNU\" capitalised. (\"Fifo\" has an unfortunate capitalisation here that\n> can't be changed now)\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode1\nsrc/pkg/archive/tar/reader.go:1: // Copyright 2009 The Go Authors. All rights resesrc/pkg/archive/tar/reader.gorved.\nOn 2012/10/16 00:54:39, dfc wrote:\n> fat finger error\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode63\nsrc/pkg/archive/tar/reader.go:63: if hdr != nil {\nOn 2012/10/16 00:53:13, dsymonds wrote:\n> if hdr == nil {\n>   return hdr, tr.err\n> }\n> \n> // Check for PAX/GNU header.\n> ...\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode66\nsrc/pkg/archive/tar/reader.go:66: //We have a pax extended header. See http://pubs.opengroup.org/onlinepubs/009604599/utilities/pax.html\nOn 2012/10/16 00:54:39, dfc wrote:\n> two line please. space after // here and everywhere else\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode78\nsrc/pkg/archive/tar/reader.go:78: //We have a gnu long name header. It's contents are the real file name.\nOn 2012/10/16 00:54:39, dfc wrote:\n> Its\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode108\nsrc/pkg/archive/tar/reader.go:108: //which is what go already gives us or binary which would\nThanks for correcting me. A re-reading of the spec reveals that I was waaay off. I was under the impression that a string was a sequence of unicode points (encoded as UTF-8) and s[i] for a string was a rune.\n\nOn 2012/10/16 00:53:13, dsymonds wrote:\n> Go does not enforce that strings are UTF-8. What goes wrong if it's not?\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode166\nsrc/pkg/archive/tar/reader.go:166: func parseFloatToTime(t string) (time.Time, error) {\nI actually just wrote this method to get the tests to pass since the reader tests do a byte for byte comparison. ParseFloat introduced representation/rounding errors that caused the tests to fail. Parsing seconds and nanoseconds separately serves 2 purposes: making the tests pass and reproducing the timestamp exactly (when written be tar --format=pax).\n\nOn 2012/10/16 00:53:13, dsymonds wrote:\n> why are you not using strconv.ParseFloat? This doesn't need to be extremely\n> performant code.\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode182\nsrc/pkg/archive/tar/reader.go:182: //pad as needed before converting to a decimal.\nOn 2012/10/16 00:54:39, dfc wrote:\n> space after //\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader_test.go\nFile src/pkg/archive/tar/reader_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader_test.go#newcode168\nsrc/pkg/archive/tar/reader_test.go:168: continue\nOn 2012/10/16 00:54:39, dfc wrote:\n> continue testLoop\n\nDone. Am I right in thinking the original statement (break) was a bug?\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/writer.go#newcode169\nsrc/pkg/archive/tar/writer.go:169: tw.Flush()\nOn 2012/10/16 00:54:39, dfc wrote:\n> should this go below the error check ?\n\nDone. Not really sure on this one. Also realized I was ignoring the return value of flush. I guess there's no point in finishing the write of a record known to be broken.",
			"disapproval": false,
			"date": "2012-10-16 02:14:26.181030",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/reader.go#newcode153\nsrc/pkg/archive/tar/reader.go:153: hdr.Size = int64(size)\nOn 2012/10/16 03:25:12, dfc wrote:\n> Should there be a default condition here ?\n> \n> default:\n>    return errors.New(\"corrupt archive\") \n\nI believe here it makes sense to ignore headers we don't understand, but it's your call. Various versions of gnu have used these headers for sparse files. Another example would be the comment header. We have no useful way to bubble that up to the user, but it's a valid field.\n\nhttp://www.gnu.org/software/tar/manual/html_section/Sparse-Formats.html\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/reader.go#newcode164\nsrc/pkg/archive/tar/reader.go:164: func parseFloatToTime(t string) (time.Time, error) {\nOn 2012/10/16 03:25:12, dfc wrote:\n> Is it really a float ? or a decimal ?\nAn example (found in pax.tar) would be: \n1350244992.023960108\n\nWhile this is a float, it's obviously from clock_gettime, which is to say it's the string representation of a integer number of seconds and an integer number of nanoseconds. Treating this as a result of clock_gettime(3)\nallows us to perfectly reconstruct the timestamp so that byte by byte comparisons in the unit tests work. I don't mind not treating this as: \"A float formed by combining seconds and nanoseconds\", but we'll have to rework the unit tests to not to compare byte by byte.\n\nSo the alternative is to use ParseFloat and take pax.tar out of the test harness and have pax.tar specific tests, would that be preferable?\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/reader.go#newcode182\nsrc/pkg/archive/tar/reader.go:182: if len(nano_buf) < 9 { //nano==10^9\nOn 2012/10/16 03:25:12, dfc wrote:\n> remove the comment, add a const for the magic number 9\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/reader.go#newcode211\nsrc/pkg/archive/tar/reader.go:211: //or the header was empty to start with.\nOn 2012/10/16 03:25:12, dfc wrote:\n> space after // \n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer.go#newcode135\nsrc/pkg/archive/tar/writer.go:135: // slip an extra header in there.\nOn 2012/10/16 03:25:12, dfc wrote:\n> some of your comments start with an upper case letter, others with a lower,\n> please normalise.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer.go#newcode143\nsrc/pkg/archive/tar/writer.go:143: pid := os.Getpid()\nOn 2012/10/16 03:25:12, dfc wrote:\n> this should be cached.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer_test.go#newcode201\nsrc/pkg/archive/tar/writer_test.go:201: err = writer.WriteHeader(hdr)\nOn 2012/10/16 03:25:12, dfc wrote:\n> if err := writer.WriteHeader(hdr) ; err != nil {\n>     t.Fatal(err)\n> }\n\nI wasn't familiar with that idiom. Thanks.\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer_test.go#newcode206\nsrc/pkg/archive/tar/writer_test.go:206: if err != nil {\nOn 2012/10/16 03:25:12, dfc wrote:\n> ditto\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer_test.go#newcode209\nsrc/pkg/archive/tar/writer_test.go:209: writer.Close()\nOn 2012/10/16 03:25:12, dfc wrote:\n> are there any trailing bytes written by writer.Close()? I think you should check\n> the err return here.\n\nDone. Close calls flush, so my understanding is that it can both write out the trailing bytes for the record and then the 2 null records that indicate tar EOF.",
			"disapproval": false,
			"date": "2012-10-16 04:05:04.044240",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, dave@cheney.net (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-10-16 04:05:35.728230",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thank you.\n\nI would like to see unit tests for the parsing routines.\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go#newcode166\nsrc/pkg/archive/tar/reader.go:166: func parseFloatToTime(t string) (time.Time, error) {\nhttp://pubs.opengroup.org/onlinepubs/009604599/utilities/pax.html#tag_04_100_13_05 mentions nothing about floats. I suggest this method be renamed parsePAXTime() and the comment adjusted.",
			"disapproval": false,
			"date": "2012-10-16 04:24:56.011280",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://code.google.com/p/go",
			"disapproval": false,
			"date": "2012-10-15 23:07:48.859650",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/10/16 00:54:38, dfc wrote:\n> Thank you for taking a stab at this. Some initial comments below.\n> \n> What is the licence for the pax.tar file ?\n> \n> Does this also resolve issue 3864 ?\n> \n> http://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go\n> File src/pkg/archive/tar/reader.go (right):\n> \n> http://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode1\n> src/pkg/archive/tar/reader.go:1: // Copyright 2009 The Go Authors. All rights\n> resesrc/pkg/archive/tar/reader.gorved.\n> fat finger error\n> \n> http://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode66\n> src/pkg/archive/tar/reader.go:66: //We have a pax extended header. See\n> http://pubs.opengroup.org/onlinepubs/009604599/utilities/pax.html\n> two line please. space after // here and everywhere else\n> \n> http://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode78\n> src/pkg/archive/tar/reader.go:78: //We have a gnu long name header. It's\n> contents are the real file name.\n> Its\n> \n> http://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode106\n> src/pkg/archive/tar/reader.go:106: //Note: the spec specifies that \"hdrcharset\"\n> specifies the\n> s/Note: //\n> \n> this is a already a note\n> \n> http://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode182\n> src/pkg/archive/tar/reader.go:182: //pad as needed before converting to a\n> decimal.\n> space after //\n> \n> http://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader_test.go\n> File src/pkg/archive/tar/reader_test.go (right):\n> \n> http://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader_test.go#newcode168\n> src/pkg/archive/tar/reader_test.go:168: continue\n> continue testLoop\n> \n> http://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/writer.go\n> File src/pkg/archive/tar/writer.go (right):\n> \n> http://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/writer.go#newcode169\n> src/pkg/archive/tar/writer.go:169: tw.Flush()\n> should this go below the error check ?\n\ndsymonds and dfs, thank you both for taking the time to review this and help me get the hang of the style used in the go std libs, I really appreciate your feedback.\n\n1) This doesn't resolve issue 3864. Sparse files have a typeflag of 'S'. I'd be happy to take a crack at it if there's interest.\n2) The license for pax.tar is whatever you want it to be ; ). It was created using tar --format=pax.\n3) What can I do to bring the coding style more in line with the surrounding code? parsePAX could be a method on tar.Reader and mergePAX could be a method on tar.Header. Would reflection and some sort of map be more idiogomatic for mergePAX? Most of the parsing I'm doing is not for fixed length formats, so I didn't see any opportunity to use slicer other than maybe for the final extraction of one of the PAX values.",
			"disapproval": false,
			"date": "2012-10-16 02:13:17.683740",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Please read\n  http://golang.org/doc/contribute.html\nand\n  http://golang.org/doc/effective_go.html,\nespecially the part about matching the existing coding style. The new code here stands out like a sore thumb.\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/common.go\nFile src/pkg/archive/tar/common.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/common.go#newcode37\nsrc/pkg/archive/tar/common.go:37: TypeGnuLongName   = 'L'    // Next file has a long name\nkeep \"GNU\" capitalised. (\"Fifo\" has an unfortunate capitalisation here that can't be changed now)\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode1\nsrc/pkg/archive/tar/reader.go:1: // Copyright 2009 The Go Authors. All rights resesrc/pkg/archive/tar/reader.gorved.\nuh?\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode63\nsrc/pkg/archive/tar/reader.go:63: if hdr != nil {\nif hdr == nil {\n  return hdr, tr.err\n}\n\n// Check for PAX/GNU header.\n...\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode106\nsrc/pkg/archive/tar/reader.go:106: //Note: the spec specifies that \"hdrcharset\" specifies the\nput a space after \"//\".\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode108\nsrc/pkg/archive/tar/reader.go:108: //which is what go already gives us or binary which would\nGo does not enforce that strings are UTF-8. What goes wrong if it's not?\n\nhttps://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode166\nsrc/pkg/archive/tar/reader.go:166: func parseFloatToTime(t string) (time.Time, error) {\nwhy are you not using strconv.ParseFloat? This doesn't need to be extremely performant code.",
			"disapproval": false,
			"date": "2012-10-16 00:53:12.873980",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thank you for taking a stab at this. Some initial comments below.\n\nWhat is the licence for the pax.tar file ?\n\nDoes this also resolve issue 3864 ?\n\nhttp://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttp://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode1\nsrc/pkg/archive/tar/reader.go:1: // Copyright 2009 The Go Authors. All rights resesrc/pkg/archive/tar/reader.gorved.\nfat finger error\n\nhttp://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode66\nsrc/pkg/archive/tar/reader.go:66: //We have a pax extended header. See http://pubs.opengroup.org/onlinepubs/009604599/utilities/pax.html\ntwo line please. space after // here and everywhere else\n\nhttp://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode78\nsrc/pkg/archive/tar/reader.go:78: //We have a gnu long name header. It's contents are the real file name.\nIts\n\nhttp://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode106\nsrc/pkg/archive/tar/reader.go:106: //Note: the spec specifies that \"hdrcharset\" specifies the\ns/Note: //\n\nthis is a already a note\n\nhttp://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader.go#newcode182\nsrc/pkg/archive/tar/reader.go:182: //pad as needed before converting to a decimal.\nspace after //\n\nhttp://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader_test.go\nFile src/pkg/archive/tar/reader_test.go (right):\n\nhttp://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/reader_test.go#newcode168\nsrc/pkg/archive/tar/reader_test.go:168: continue\ncontinue testLoop\n\nhttp://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttp://codereview.appspot.com/6700047/diff/1001/src/pkg/archive/tar/writer.go#newcode169\nsrc/pkg/archive/tar/writer.go:169: tw.Flush()\nshould this go below the error check ?",
			"disapproval": false,
			"date": "2012-10-16 00:54:38.933390",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, dave@cheney.net (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-10-16 03:17:40.945850",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/reader.go#newcode153\nsrc/pkg/archive/tar/reader.go:153: hdr.Size = int64(size)\nShould there be a default condition here ?\n\ndefault:\n   return errors.New(\"corrupt archive\")\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/reader.go#newcode164\nsrc/pkg/archive/tar/reader.go:164: func parseFloatToTime(t string) (time.Time, error) {\nIs it really a float ? or a decimal ?\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/reader.go#newcode182\nsrc/pkg/archive/tar/reader.go:182: if len(nano_buf) < 9 { //nano==10^9\nremove the comment, add a const for the magic number 9\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/reader.go#newcode211\nsrc/pkg/archive/tar/reader.go:211: //or the header was empty to start with.\nspace after //\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer.go#newcode135\nsrc/pkg/archive/tar/writer.go:135: // slip an extra header in there.\nsome of your comments start with an upper case letter, others with a lower, please normalise.\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer.go#newcode143\nsrc/pkg/archive/tar/writer.go:143: pid := os.Getpid()\nthis should be cached.\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer_test.go#newcode201\nsrc/pkg/archive/tar/writer_test.go:201: err = writer.WriteHeader(hdr)\nif err := writer.WriteHeader(hdr) ; err != nil {\n    t.Fatal(err)\n}\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer_test.go#newcode206\nsrc/pkg/archive/tar/writer_test.go:206: if err != nil {\nditto\n\nhttps://codereview.appspot.com/6700047/diff/5/src/pkg/archive/tar/writer_test.go#newcode209\nsrc/pkg/archive/tar/writer_test.go:209: writer.Close()\nare there any trailing bytes written by writer.Close()? I think you should check the err return here.",
			"disapproval": false,
			"date": "2012-10-16 03:25:12.619200",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "A few trivial comments on the documentation style.\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go#newcode104\nsrc/pkg/archive/tar/reader.go:104: // Merge well known headers according to PAX standard.\ns/Merge/mergePAX merges/\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go#newcode162\nsrc/pkg/archive/tar/reader.go:162: // Take a string of the form %d.%d and convert it to unix standard time. We\n// parseFloatToTime converts a string of the form %d.%d to\n// unix standard time. ... etc\n\nI think I'd move the second sentence inside the function (it describes an implementation detail)\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go#newcode200\nsrc/pkg/archive/tar/reader.go:200: // Parse PAX headers from tr following the rules outlined\n// parsePax parses PAX headers from tr ... etc\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go#newcode245\nsrc/pkg/archive/tar/reader.go:245: // Parse bytes as a NUL-terminated C-style string.\n// cString parses ...",
			"disapproval": false,
			"date": "2012-10-16 10:52:03.660540",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-10-16 17:09:49.302620",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go#newcode104\nsrc/pkg/archive/tar/reader.go:104: // Merge well known headers according to PAX standard.\nOn 2012/10/16 10:52:03, rog wrote:\n> s/Merge/mergePAX merges/\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go#newcode162\nsrc/pkg/archive/tar/reader.go:162: // Take a string of the form %d.%d and convert it to unix standard time. We\nOn 2012/10/16 10:52:03, rog wrote:\n> // parseFloatToTime converts a string of the form %d.%d to\n> // unix standard time. ... etc\n> \n> I think I'd move the second sentence inside the function (it describes an\n> implementation detail)\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go#newcode166\nsrc/pkg/archive/tar/reader.go:166: func parseFloatToTime(t string) (time.Time, error) {\nOn 2012/10/16 04:24:56, dfc wrote:\n> http://pubs.opengroup.org/onlinepubs/009604599/utilities/pax.html#tag_04_100_13_05\n> mentions nothing about floats. I suggest this method be renamed parsePAXTime()\n> and the comment adjusted.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go#newcode200\nsrc/pkg/archive/tar/reader.go:200: // Parse PAX headers from tr following the rules outlined\nOn 2012/10/16 10:52:03, rog wrote:\n> // parsePax parses PAX headers from tr ... etc\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/5009/src/pkg/archive/tar/reader.go#newcode245\nsrc/pkg/archive/tar/reader.go:245: // Parse bytes as a NUL-terminated C-style string.\nOn 2012/10/16 10:52:03, rog wrote:\n> // cString parses ...\n\nDone.",
			"disapproval": false,
			"date": "2012-10-16 17:09:53.919040",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Sorry for the delay. There's a lot to digest here. I've only had a good review of the parsing code.\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode71\nsrc/pkg/archive/tar/reader.go:71: //  We have a PAX extended header. See http://pubs.opengroup.org/onlinepubs/009604599/utilities/pax.html\nno need to repeat the reference here.\n  // PAX extended header\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode198\nsrc/pkg/archive/tar/reader.go:198: // parsePAX parses PAX headers from tr following the rules outlined\n// parsePAX parses a PAX header.\n\nNo need for extra detail; it's not hard to find this in pax.html. No need to spell out the particular error return; nothing is distinguishing that error.\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode201\nsrc/pkg/archive/tar/reader.go:201: func parsePAX(tr io.Reader) (map[string]string, error) {\ntr -> r\n(\"tr\" here returns to the local Reader type, not io.Reader)\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode207\nsrc/pkg/archive/tar/reader.go:207: // We are looking for records of the type:\nThis is a bit confusing.\n\n// Each record is constructed as\n//   \"%d %s=%s\\n\", length, keyword, value\n\n(that is much closer to what pax.html says)\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode212\nsrc/pkg/archive/tar/reader.go:212: if len(buf) == 0 {\nmake this the loop condition.\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode217\nsrc/pkg/archive/tar/reader.go:217: pos = bytes.IndexByte(buf, ' ')\npos -> sp\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode222\nsrc/pkg/archive/tar/reader.go:222: length, err := strconv.ParseInt(string(buf[:pos]), 10, 0)\nlength -> n\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode228\nsrc/pkg/archive/tar/reader.go:228: record := buf[pos+1 : int(length)-1]\nslice off the record and shrink buf in the same step to make it clearer what the operation is.\n\nvar rec []byte\nrec, buf = buf[sp+1:int(n)-1], buf[n:]\n\n(are you sure you need this int cast?)\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode231\nsrc/pkg/archive/tar/reader.go:231: pos = bytes.IndexByte(record, '=')\npos -> eq\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode235\nsrc/pkg/archive/tar/reader.go:235: key := record[:pos]\nkey, value := rec[:pos], rec[pos+1:]\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader_test.go\nFile src/pkg/archive/tar/reader_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader_test.go#newcode298\nsrc/pkg/archive/tar/reader_test.go:298: correctHeaders := []byte(`30 mtime=1350244992.023960108\nmake this a \"\" string, with a \\n instead of a literal line break.",
			"disapproval": false,
			"date": "2012-10-22 06:29:14.076610",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-10-23 03:16:09.765670",
			"approval": false
		},
		{
			"sender": "remyoudompheng@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode243\nsrc/pkg/archive/tar/reader.go:243: // cString parse bytes as a NUL-terminated C-style string.\ns/parse/parses",
			"disapproval": false,
			"date": "2012-10-22 07:05:34.080060",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "dsymonds, I just have one question about ReadAll(tr) vs ReadAll(r).\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode71\nsrc/pkg/archive/tar/reader.go:71: //  We have a PAX extended header. See http://pubs.opengroup.org/onlinepubs/009604599/utilities/pax.html\nOn 2012/10/22 06:29:14, dsymonds wrote:\n> no need to repeat the reference here.\n>   // PAX extended header\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode198\nsrc/pkg/archive/tar/reader.go:198: // parsePAX parses PAX headers from tr following the rules outlined\nOn 2012/10/22 06:29:14, dsymonds wrote:\n> // parsePAX parses a PAX header.\n> \n> No need for extra detail; it's not hard to find this in pax.html. No need to\n> spell out the particular error return; nothing is distinguishing that error.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode201\nsrc/pkg/archive/tar/reader.go:201: func parsePAX(tr io.Reader) (map[string]string, error) {\nOn 2012/10/22 06:29:14, dsymonds wrote:\n> tr -> r\n> (\"tr\" here returns to the local Reader type, not io.Reader)\n\nI actually think this is what I want. ReadAll(tr) gives me the contents of the extended header, which is put in the body of the pax record. wouldn't ReadlAll(r) read the underlying reader until EOF?\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode207\nsrc/pkg/archive/tar/reader.go:207: // We are looking for records of the type:\nOn 2012/10/22 06:29:14, dsymonds wrote:\n> This is a bit confusing.\n> \n> // Each record is constructed as\n> //   \"%d %s=%s\\n\", length, keyword, value\n> \n> (that is much closer to what pax.html says)\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode212\nsrc/pkg/archive/tar/reader.go:212: if len(buf) == 0 {\nOn 2012/10/22 06:29:14, dsymonds wrote:\n> make this the loop condition.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode217\nsrc/pkg/archive/tar/reader.go:217: pos = bytes.IndexByte(buf, ' ')\nOn 2012/10/22 06:29:14, dsymonds wrote:\n> pos -> sp\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode222\nsrc/pkg/archive/tar/reader.go:222: length, err := strconv.ParseInt(string(buf[:pos]), 10, 0)\nOn 2012/10/22 06:29:14, dsymonds wrote:\n> length -> n\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode228\nsrc/pkg/archive/tar/reader.go:228: record := buf[pos+1 : int(length)-1]\nOn 2012/10/22 06:29:14, dsymonds wrote:\n> slice off the record and shrink buf in the same step to make it clearer what the\n> operation is.\n> \n> var rec []byte\n> rec, buf = buf[sp+1:int(n)-1], buf[n:]\n> \n> (are you sure you need this int cast?)\n\nDone.",
			"disapproval": false,
			"date": "2012-10-23 02:54:13.815860",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Sorry again for the delay. I think I've got a handle on this; the rest of the review should proceed quicker.\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode201\nsrc/pkg/archive/tar/reader.go:201: func parsePAX(tr io.Reader) (map[string]string, error) {\nOn 2012/10/23 02:54:14, shanemhansen wrote:\n> On 2012/10/22 06:29:14, dsymonds wrote:\n> > tr -> r\n> > (\"tr\" here returns to the local Reader type, not io.Reader)\n> \n> I actually think this is what I want. ReadAll(tr) gives me the contents of the\n> extended header, which is put in the body of the pax record. wouldn't\n> ReadlAll(r) read the underlying reader until EOF?\n\nI mean here, rather than the call site. This function only uses the functionality of io.Reader (the type it takes), so it should name its parameter accordingly: \"r\". The call site correctly invokes this with tr.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/reader.go#newcode208\nsrc/pkg/archive/tar/reader.go:208: for len(buf) != 0 {\nfor len(buf) > 0 {\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/reader_test.go\nFile src/pkg/archive/tar/reader_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/reader_test.go#newcode343\nsrc/pkg/archive/tar/reader_test.go:343: \"mtime\": \"1350244992.023960108\"}\nput } on its own line\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/reader_test.go#newcode348\nsrc/pkg/archive/tar/reader_test.go:348: // Assert the values were written correctly.\nwant := &Header{\n  ...\n}\nif !reflect.DeepEqual(hdr, want) {\n  t.Errorf(\"incorrect merge: got %+v, want %+v\", hdr, want)\n}\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer.go#newcode26\nsrc/pkg/archive/tar/writer.go:26: // The pid of the current process. Assumes go doesn't fork.\nDon't make this assumption. Just call os.Getpid() as needed; it's not that expensive compared to all the other things going on.\n\nIf this was a big concern, capturing it in NewWriter would be the better approach, but I don't think it's warranted.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer.go#newcode143\nsrc/pkg/archive/tar/writer.go:143: use_pax_header := len(hdr.Name) > 100 || len(hdr.Linkname) > 100\nthese are not Go names. Drop your underscores and use camelCase. See if you can shorten the names too.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer.go#newcode144\nsrc/pkg/archive/tar/writer.go:144: if use_pax_header {\nI think the contents of this if could be its own method, and then you can just inline the condition.\n\nif len(hdr.Name) > 100 || len(hdr.Linkname) > 100 {\n  if err := tw.writePAXHeader(hdr); err != nil {\n    return err\n  }\n}\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode186\nsrc/pkg/archive/tar/writer_test.go:186: // Create a pretend large archive.\ns/pretend //\n\nIt looks real enough to me.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode189\nsrc/pkg/archive/tar/writer_test.go:189: t.Fatal(err)\nPlease use a better error message throughout here. If we get a test failure that just says \"permission denied\" then it's not going to be as easy to track down as \"os.Stat: permission denied\".\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode196\nsrc/pkg/archive/tar/writer_test.go:196: long_name := strings.Repeat(\"0\", 200)\nlongName\n\nsomething more interesting would be good. strings.Repeat(\"ab\", 51)?\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode214\nsrc/pkg/archive/tar/writer_test.go:214: // Test that we can get a nice long name back out of the archive.\ns/nice //\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode215\nsrc/pkg/archive/tar/writer_test.go:215: reader := NewReader(bytes.NewBuffer(buf.Bytes()))\nyou shouldn't have to wrap it in a new buffer. NewReader(&buf) should work.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode220\nsrc/pkg/archive/tar/writer_test.go:220: if !strings.EqualFold(hdr.Name, long_name) {\nwhy fold?",
			"disapproval": false,
			"date": "2012-10-31 02:44:37.174000",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go#newcode198\nsrc/pkg/archive/tar/writer.go:198: msg := fmt.Sprintf(\" path=%s\\n\", hdr.Name)\npull this block into its own function\n\n// paxHeader returns a PAX header for the given \"key=value\" message.\nfunc paxHeader(m string) string {\n  ...\n}\n\nand just use\n  fmt.Fprint(&buf, paxHeader(fmt.Sprintf(\"path=%s\", hdr.Name)))\n\nI think such a function would warrant a test of its own.\n\n(also, please use \"hg gofmt\" before uploading new snapshots)\n\nhttps://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go#newcode213\nsrc/pkg/archive/tar/writer.go:213: _, err := tw.Write(buf.Bytes())\nsnuggle",
			"disapproval": false,
			"date": "2012-11-01 02:51:37.363640",
			"approval": false
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go#newcode192\nsrc/pkg/archive/tar/writer.go:192: dir, file := filepath.Split(hdr.Name)\ni think the delimiter in these archives is always a plain '/'. at least i couldn't find a counter example :)",
			"disapproval": false,
			"date": "2012-11-05 15:51:08.410730",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com, chressie@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-11-07 00:53:53.329400",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/30004/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/30004/src/pkg/archive/tar/writer.go#newcode198\nsrc/pkg/archive/tar/writer.go:198: fmt.Fprint(&buf, paxHeader(fmt.Sprintf(\"path=%s\", hdr.Name)))\nno need for fmt.Sprintf just to concatenate two strings.\n  \"path=\" + hdr.Name\n\nsame for hdr.Linkname\n\nhttps://codereview.appspot.com/6700047/diff/30004/src/pkg/archive/tar/writer.go#newcode219\nsrc/pkg/archive/tar/writer.go:219: padding := 2 // Extra padding for space and newline\nconst padding = 2\n\nhttps://codereview.appspot.com/6700047/diff/30004/src/pkg/archive/tar/writer.go#newcode221\nsrc/pkg/archive/tar/writer.go:221: size += len(strconv.Itoa(size))\nThis still can't be right. What if this += involves a decimal carry? Then the output will be one longer than what is computed here.\n\nplease add a test case that covers this, and fix this code.\n\nhttps://codereview.appspot.com/6700047/diff/30004/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/30004/src/pkg/archive/tar/writer_test.go#newcode228\nsrc/pkg/archive/tar/writer_test.go:228: paxTests := map[string]string{\"name=/etc/hosts\": \"19 name=/etc/hosts\\n\",\none test case per line so we can read it please.\n\nalso add a case that yields a single digit length.",
			"disapproval": false,
			"date": "2012-11-07 01:02:25.375030",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/18001/src/pkg/archive/tar/reader.go#newcode201\nsrc/pkg/archive/tar/reader.go:201: func parsePAX(tr io.Reader) (map[string]string, error) {\nOk, that makes sense. Change made.\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> On 2012/10/23 02:54:14, shanemhansen wrote:\n> > On 2012/10/22 06:29:14, dsymonds wrote:\n> > > tr -> r\n> > > (\"tr\" here returns to the local Reader type, not io.Reader)\n> > \n> > I actually think this is what I want. ReadAll(tr) gives me the contents of the\n> > extended header, which is put in the body of the pax record. wouldn't\n> > ReadlAll(r) read the underlying reader until EOF?\n> \n> I mean here, rather than the call site. This function only uses the\n> functionality of io.Reader (the type it takes), so it should name its parameter\n> accordingly: \"r\". The call site correctly invokes this with tr.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/reader.go#newcode208\nsrc/pkg/archive/tar/reader.go:208: for len(buf) != 0 {\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> for len(buf) > 0 {\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/reader_test.go\nFile src/pkg/archive/tar/reader_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/reader_test.go#newcode343\nsrc/pkg/archive/tar/reader_test.go:343: \"mtime\": \"1350244992.023960108\"}\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> put } on its own line\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/reader_test.go#newcode348\nsrc/pkg/archive/tar/reader_test.go:348: // Assert the values were written correctly.\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> want := &Header{\n>   ...\n> }\n> if !reflect.DeepEqual(hdr, want) {\n>   t.Errorf(\"incorrect merge: got %+v, want %+v\", hdr, want)\n> }\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer.go#newcode26\nsrc/pkg/archive/tar/writer.go:26: // The pid of the current process. Assumes go doesn't fork.\nNo problem. Someone asked me to cache the value, I'll change it back.\n\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> Don't make this assumption. Just call os.Getpid() as needed; it's not that\n> expensive compared to all the other things going on.\n> \n> If this was a big concern, capturing it in NewWriter would be the better\n> approach, but I don't think it's warranted.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer.go#newcode143\nsrc/pkg/archive/tar/writer.go:143: use_pax_header := len(hdr.Name) > 100 || len(hdr.Linkname) > 100\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> these are not Go names. Drop your underscores and use camelCase. See if you can\n> shorten the names too.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer.go#newcode144\nsrc/pkg/archive/tar/writer.go:144: if use_pax_header {\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> I think the contents of this if could be its own method, and then you can just\n> inline the condition.\n> \n> if len(hdr.Name) > 100 || len(hdr.Linkname) > 100 {\n>   if err := tw.writePAXHeader(hdr); err != nil {\n>     return err\n>   }\n> }\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode186\nsrc/pkg/archive/tar/writer_test.go:186: // Create a pretend large archive.\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> s/pretend //\n> \n> It looks real enough to me.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode189\nsrc/pkg/archive/tar/writer_test.go:189: t.Fatal(err)\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> Please use a better error message throughout here. If we get a test failure that\n> just says \"permission denied\" then it's not going to be as easy to track down as\n> \"os.Stat: permission denied\".\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode196\nsrc/pkg/archive/tar/writer_test.go:196: long_name := strings.Repeat(\"0\", 200)\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> longName\n> \n> something more interesting would be good. strings.Repeat(\"ab\", 51)?\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode214\nsrc/pkg/archive/tar/writer_test.go:214: // Test that we can get a nice long name back out of the archive.\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> s/nice //\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode215\nsrc/pkg/archive/tar/writer_test.go:215: reader := NewReader(bytes.NewBuffer(buf.Bytes()))\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> you shouldn't have to wrap it in a new buffer. NewReader(&buf) should work.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/27001/src/pkg/archive/tar/writer_test.go#newcode220\nsrc/pkg/archive/tar/writer_test.go:220: if !strings.EqualFold(hdr.Name, long_name) {\nIgnorance. I was looking for a strings.Equal function.\nA closer reading of the spec reveals that == is defined for the string type. Thanks for pointing that out.\nOn 2012/10/31 02:44:37, dsymonds wrote:\n> why fold?",
			"disapproval": false,
			"date": "2012-10-31 04:26:30.742270",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-11-01 02:42:21.278800",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-10-31 04:33:22.248760",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer.go#newcode202\nsrc/pkg/archive/tar/writer.go:202: fmt.Fprintf(&buf, \"%d%s\", size, msg)\nThe pax standard is weird here. It states that the %d must be the length of the entire message (including) %d. So somehow we have to add that length on. I'm convinced what I have here is wrong, I'll try and submit something better. Here is an example of a real live pax header:\n\n\"30 mtime=1350244992.023960108\\n\"\n\nI'm submitting code which I think does the length adjustment correctly.\nOn 2012/10/31 12:16:25, dsymonds wrote:\n> I am confused by this construction. Shouldn't it be something more like this?\n> \n> msg := fmt.Sprintf(\" path=%s\\n\", hdr.Name)\n> fmt.Fprintf(&buf, \"%d %s\", len(msg), msg)\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer.go#newcode212\nsrc/pkg/archive/tar/writer.go:212: err := tw.WriteHeader(extendedHdr)\nOn 2012/10/31 12:16:25, dsymonds wrote:\n> snuggle these where possible.\n>   if err := tw.WriteHeader(ext); err != nil {\n>     return err\n>   }\n> etc.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer_test.go#newcode193\nsrc/pkg/archive/tar/writer_test.go:193: t.Fatal(\"os.Stat: \" + err.Error())\nOn 2012/10/31 12:16:25, dsymonds wrote:\n> t.Fatalf(\"os.Stat: %v\", err)\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer_test.go#newcode196\nsrc/pkg/archive/tar/writer_test.go:196: long_name := strings.Repeat(\"ab\", 100)\nOn 2012/10/31 12:16:25, dsymonds wrote:\n> long_name -> longName\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer_test.go#newcode220\nsrc/pkg/archive/tar/writer_test.go:220: if !(hdr.Name == long_name) {\nOn 2012/10/31 12:16:25, dsymonds wrote:\n> if hdr.Name != longName\n\nDone.",
			"disapproval": false,
			"date": "2012-11-01 02:40:57.088020",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Nov 1, 2012 at 1:40 PM,  <shanemhansen@gmail.com> wrote:\r\n\r\n> The pax standard is weird here. It states that the %d must be the length\r\n> of the entire message (including) %d. So somehow we have to add that\r\n> length on. I'm convinced what I have here is wrong, I'll try and submit\r\n> something better. Here is an example of a real live pax header:\r\n>\r\n> \"30 mtime=1350244992.023960108\\n\"\r\n>\r\n> I'm submitting code which I think does the length adjustment correctly.\r\n\r\nThat seems nuts. That would mean \"9 a=1234\\n\" and \"10 a=1234\\n\" mean\r\nthe same thing. Did that header you pasted come from a real life tar\r\nimplementation? Which one?\r\n",
			"disapproval": false,
			"date": "2012-11-01 02:44:31.903400",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "It was produced by tar (GNU tar) 1.26\r\nHere's a script to reproduce the behaviour.\r\nhttp://pastebin.com/WVDnyGhR\r\n\r\nIt's pretty weird. I also got that specific example from the pax.tar file\r\nin testdata/\r\n\r\nOn Wed, Oct 31, 2012 at 8:44 PM, David Symonds <dsymonds@golang.org> wrote:\r\n\r\n> On Thu, Nov 1, 2012 at 1:40 PM,  <shanemhansen@gmail.com> wrote:\r\n>\r\n> > The pax standard is weird here. It states that the %d must be the length\r\n> > of the entire message (including) %d. So somehow we have to add that\r\n> > length on. I'm convinced what I have here is wrong, I'll try and submit\r\n> > something better. Here is an example of a real live pax header:\r\n> >\r\n> > \"30 mtime=1350244992.023960108\\n\"\r\n> >\r\n> > I'm submitting code which I think does the length adjustment correctly.\r\n>\r\n> That seems nuts. That would mean \"9 a=1234\\n\" and \"10 a=1234\\n\" mean\r\n> the same thing. Did that header you pasted come from a real life tar\r\n> implementation? Which one?\r\n>\r\n",
			"disapproval": false,
			"date": "2012-11-01 03:16:02.246070",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Okay, just pull it out into a function as I suggest and carefully test it.\r\n",
			"disapproval": false,
			"date": "2012-11-01 03:17:02.110350",
			"approval": false
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go#newcode193\nsrc/pkg/archive/tar/writer.go:193: ext.Name = filepath.Join(dir,\nanother issue i can see is that Join cleans the resulting path. maybe it makes sense to path.Clean(hdr.Name) anyway? but that seems to be an incompatibility with the go1 promise. any thoughts?",
			"disapproval": false,
			"date": "2012-11-05 17:44:47.051450",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go#newcode192\nsrc/pkg/archive/tar/writer.go:192: dir, file := filepath.Split(hdr.Name)\nAccording to my reading of the python tarfile implementation, they use /.\nOn 2012/11/05 15:51:08, chressie1 wrote:\n> i think the delimiter in these archives is always a plain '/'. at least i\n> couldn't find a counter example :)\n\nhttps://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go#newcode193\nsrc/pkg/archive/tar/writer.go:193: ext.Name = filepath.Join(dir,\nSorry, I'm not sure what you mean by cleaning the path.\nOn 2012/11/05 17:44:47, chressie1 wrote:\n> another issue i can see is that Join cleans the resulting path. maybe it makes\n> sense to path.Clean(hdr.Name) anyway? but that seems to be an incompatibility\n> with the go1 promise. any thoughts?",
			"disapproval": false,
			"date": "2012-11-07 00:59:48.053650",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer.go#newcode184\nsrc/pkg/archive/tar/writer.go:184: extendedHdr := new(Header)\nextendedHdr -> ext\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer.go#newcode189\nsrc/pkg/archive/tar/writer.go:189: // The spec asks that we namespace our psuedo files\n\"pseudo\"\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer.go#newcode202\nsrc/pkg/archive/tar/writer.go:202: fmt.Fprintf(&buf, \"%d%s\", size, msg)\nI am confused by this construction. Shouldn't it be something more like this?\n\nmsg := fmt.Sprintf(\" path=%s\\n\", hdr.Name)\nfmt.Fprintf(&buf, \"%d %s\", len(msg), msg)\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer.go#newcode212\nsrc/pkg/archive/tar/writer.go:212: err := tw.WriteHeader(extendedHdr)\nsnuggle these where possible.\n  if err := tw.WriteHeader(ext); err != nil {\n    return err\n  }\netc.\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer_test.go#newcode193\nsrc/pkg/archive/tar/writer_test.go:193: t.Fatal(\"os.Stat: \" + err.Error())\nt.Fatalf(\"os.Stat: %v\", err)\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer_test.go#newcode196\nsrc/pkg/archive/tar/writer_test.go:196: long_name := strings.Repeat(\"ab\", 100)\nlong_name -> longName\n\nhttps://codereview.appspot.com/6700047/diff/29004/src/pkg/archive/tar/writer_test.go#newcode220\nsrc/pkg/archive/tar/writer_test.go:220: if !(hdr.Name == long_name) {\nif hdr.Name != longName",
			"disapproval": false,
			"date": "2012-10-31 12:16:25.438460",
			"approval": false
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go#newcode192\nsrc/pkg/archive/tar/writer.go:192: dir, file := filepath.Split(hdr.Name)\nOn 2012/11/07 00:59:48, shanemhansen wrote:\n> According to my reading of the python tarfile implementation, they use /.\n\nexactly. and therefore you should use the path package (which handles / separated paths) and not path/filepath (which uses os.PathSeparator separated paths)\n\nhttps://codereview.appspot.com/6700047/diff/34007/src/pkg/archive/tar/writer.go#newcode193\nsrc/pkg/archive/tar/writer.go:193: ext.Name = filepath.Join(dir,\nOn 2012/11/07 00:59:48, shanemhansen wrote:\n> Sorry, I'm not sure what you mean by cleaning the path.\nFrom [0]: \"Clean returns the shortest path name equivalent to path by purely lexical processing.\"\n\nthat means if someone wants to have a path like \"a/b/../../c///\" in his tarball, he'll get instead the cleaned path equivalent \"c\".\n\nthat is bad because of 2 things: (1) it's not what the tarball creator expects, because its not documented; (2) the trailing slash is gone.\n\ni think cleaning the path would make sense, but then it needs to be done (1) for all hdr.Name (not only the ones which are >100 chars) and (2) the trailing slash needs to be appended (that's what gnu tar 1.26 does).. but this might break go1 compatibility.\n\n[0]: http://golang.org/pkg/path/#Clean",
			"disapproval": false,
			"date": "2012-11-07 06:42:51.447080",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hi Shane,\n\nAny progress on this? It seems like this CL is close to being done.",
			"disapproval": false,
			"date": "2012-12-04 00:00:03.990970",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/12/04 00:00:03, dsymonds wrote:\n> Hi Shane,\n> \n> Any progress on this? It seems like this CL is close to being done.\n\nMy apologies, didn't mean to be flaky. Thanksgiving and a laptop failure got in the way, thanks for reminding me.",
			"disapproval": false,
			"date": "2012-12-04 00:01:22.388250",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "ping. Time for another progress report? This CL is pretty close to being done.",
			"disapproval": false,
			"date": "2012-12-15 11:42:29.670460",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/reader.go#newcode248\nsrc/pkg/archive/tar/reader.go:248: // Check for binary format first.\nOn 2013/01/09 02:13:17, dsymonds wrote:\n> This is already in the tree; I think you need to sync your client and do an 'hg\n> upload'.\nDone. I think. I certainly did a hg sync and hg upload.\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/writer.go#newcode205\nsrc/pkg/archive/tar/writer.go:205: dir, file := filepath.Split(hdr.Name)\nOn 2013/01/09 02:13:17, dsymonds wrote:\n> yeah, as mentioned by chressie1 these should use path rather than filepath. tar\n> names are always / separated.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/writer.go#newcode220\nsrc/pkg/archive/tar/writer.go:220: _, err := tw.Write(buf.Bytes())\nOn 2013/01/09 02:13:17, dsymonds wrote:\n> please snuggle this.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/writer_test.go#newcode232\nsrc/pkg/archive/tar/writer_test.go:232: {\"a=name\", \"10 a=name\\n\"},   //Test case involving multiple acceptable lengths\nOn 2013/01/09 02:13:17, dsymonds wrote:\n> a single space after //\n\nDone.",
			"disapproval": false,
			"date": "2013-01-09 02:40:27.836430",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com, chressie@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-01-09 01:46:56.963130",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com, chressie@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-01-09 02:40:15.497900",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "FYI\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/reader.go#newcode179\nsrc/pkg/archive/tar/reader.go:179: nano_buf := string(buf[pos+1:])\nnanoBuf\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/reader.go#newcode213\nsrc/pkg/archive/tar/reader.go:213: if sp == -1 {\nsp < 0\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/reader.go#newcode228\nsrc/pkg/archive/tar/reader.go:228: if eq == -1 {\neq < 0\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/writer.go#newcode136\nsrc/pkg/archive/tar/writer.go:136: // Decide whether or not to use PAX extensions\nPlease don't use PAX headers for names that are only 101 bytes long.\nAn option that should be used before then is to use the split ustar header form,\nin which a prefix of at most 155 bytes appears after the Devminor bytes. The full name is prefix + \"/\" + name. I expect that more readers will be able to handle this than will know about PAX extensions. I am looking at one right now.\n\nMy suggestion also matches what BSD tar does:\n\n$ tar c tmp/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/long/name | xd -c | sed 200q\n0000000   v  e  r  y  /  v  e  r  y  /  v  e  r  y  /  v\n0000010   e  r  y  /  v  e  r  y  /  v  e  r  y  /  v  e\n0000020   r  y  /  v  e  r  y  /  v  e  r  y  /  v  e  r\n0000030   y  /  v  e  r  y  /  v  e  r  y  /  v  e  r  y\n0000040   /  v  e  r  y  /  v  e  r  y  /  v  e  r  y  /\n0000050   v  e  r  y  /  v  e  r  y  /  l  o  n  g  /  n\n0000060   a  m  e 00  0  0  0  6  4  4    00  0  5  2  4\n0000070   5  5    00  0  0  0  0  0  0    00  0  0  0  0\n0000080   0  0  0  0  0  0  3     1  2  0  7  3  3  4  3\n0000090   4  0  1     0  5  1  5  7  2 00     0 00 00 00\n00000a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00000b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00000c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00000d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00000e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00000f0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000100  00  u  s  t  a  r 00  0  0  r  s  c 00 00 00 00\n0000110  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000120  00 00 00 00 00 00 00 00 00  w  h  e  e  l 00 00\n0000130  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000140  00 00 00 00 00 00 00 00 00  0  0  0  0  0  0   \n0000150  00  0  0  0  0  0  0    00  t  m  p  /  v  e  r\n0000160   y  /  v  e  r  y  /  v  e  r  y  /  v  e  r  y\n0000170   /  v  e  r  y  /  v  e  r  y  /  v  e  r  y  /\n0000180   v  e  r  y  /  v  e  r  y  /  v  e  r  y  /  v\n0000190   e  r  y  /  v  e  r  y  /  v  e  r  y 00 00 00\n00001a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00001b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\n(OS X).\n\nI tried the same on Linux and I got a tar file using the GNU ././@LongLink extension:\n\n0000000   .  /  .  /  @  L  o  n  g  L  i  n  k 00 00 00\n0000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000050  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000060  00 00 00 00  0  0  0  0  0  0  0 00  0  0  0  0\n0000070   0  0  0 00  0  0  0  0  0  0  0 00  0  0  0  0\n0000080   0  0  0  0  2  5  1 00  0  0  0  0  0  0  0  0\n0000090   0  0  0 00  0  1  1  5  6  3 00     L 00 00 00\n00000a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00000b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00000c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00000d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00000e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00000f0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000100  00  u  s  t  a  r       00  r  o  o  t 00 00 00\n0000110  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000120  00 00 00 00 00 00 00 00 00  r  o  o  t 00 00 00\n0000130  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000140  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000150  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000160  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000170  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000180  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000190  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00001a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00001b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00001c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00001d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00001e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00001f0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000200   t  m  p  /  v  e  r  y  /  v  e  r  y  /  v  e\n0000210   r  y  /  v  e  r  y  /  v  e  r  y  /  v  e  r\n0000220   y  /  v  e  r  y  /  v  e  r  y  /  v  e  r  y\n0000230   /  v  e  r  y  /  v  e  r  y  /  v  e  r  y  /\n0000240   v  e  r  y  /  v  e  r  y  /  v  e  r  y  /  v\n0000250   e  r  y  /  v  e  r  y  /  v  e  r  y  /  v  e\n0000260   r  y  /  v  e  r  y  /  v  e  r  y  /  v  e  r\n0000270   y  /  v  e  r  y  /  v  e  r  y  /  v  e  r  y\n0000280   /  v  e  r  y  /  v  e  r  y  /  v  e  r  y  /\n0000290   v  e  r  y  /  v  e  r  y  /  v  e  r  y  /  l\n00002a0   o  n  g  /  n  a  m  e 00 00 00 00 00 00 00 00\n00002b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00002c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00002d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00002e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00002f0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\nIn neither case did I get a PAX header. I am worried that nothing generates\nPAX headers and therefore nothing will read them. I would rather see either\nof these forms (preferably the BSD one, which I believe is more widespread)\nbefore the PAX header here.\n\nI have no problem with this package reading the PAX stuff, only with writing it.",
			"disapproval": false,
			"date": "2013-01-09 19:43:49.003620",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/01/09 02:42:34, dsymonds wrote:\n> LGTM\n> \n> This looks good to me.\n> \n> Given the subtlety and complexity of this CL I'll let it sit for a couple of\n> days to allow others to chime in (even with just a \"LGTM\"); I'll submit it after\n> that if there's no problems turned up.\n> \n> Thanks for working through this!\n\nThanks for everyone's patience and feedback, it's been a great introduction to an unfamiliar toolset and process. I've appreciated getting a better understanding of idiomatic go.",
			"disapproval": false,
			"date": "2013-01-09 02:45:42.044950",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com, chressie@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-01-09 01:52:10.170250",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This looks pretty close to me.\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/reader.go#newcode248\nsrc/pkg/archive/tar/reader.go:248: // Check for binary format first.\nThis is already in the tree; I think you need to sync your client and do an 'hg upload'.\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/writer.go#newcode205\nsrc/pkg/archive/tar/writer.go:205: dir, file := filepath.Split(hdr.Name)\nyeah, as mentioned by chressie1 these should use path rather than filepath. tar names are always / separated.\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/writer.go#newcode220\nsrc/pkg/archive/tar/writer.go:220: _, err := tw.Write(buf.Bytes())\nplease snuggle this.\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/51001/src/pkg/archive/tar/writer_test.go#newcode232\nsrc/pkg/archive/tar/writer_test.go:232: {\"a=name\", \"10 a=name\\n\"},   //Test case involving multiple acceptable lengths\na single space after //",
			"disapproval": false,
			"date": "2013-01-09 02:13:17.149350",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nThis looks good to me.\n\nGiven the subtlety and complexity of this CL I'll let it sit for a couple of days to allow others to chime in (even with just a \"LGTM\"); I'll submit it after that if there's no problems turned up.\n\nThanks for working through this!",
			"disapproval": false,
			"date": "2013-01-09 02:42:34.738550",
			"approval": true
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/reader.go\nFile src/pkg/archive/tar/reader.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/reader.go#newcode179\nsrc/pkg/archive/tar/reader.go:179: nano_buf := string(buf[pos+1:])\nOn 2013/01/09 19:43:49, rsc wrote:\n> nanoBuf\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/reader.go#newcode213\nsrc/pkg/archive/tar/reader.go:213: if sp == -1 {\nOn 2013/01/09 19:43:49, rsc wrote:\n> sp < 0\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/reader.go#newcode228\nsrc/pkg/archive/tar/reader.go:228: if eq == -1 {\nOn 2013/01/09 19:43:49, rsc wrote:\n> eq < 0\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/writer.go#newcode136\nsrc/pkg/archive/tar/writer.go:136: // Decide whether or not to use PAX extensions\nOn 2013/01/09 19:43:49, rsc wrote:\n> Please don't use PAX headers for names that are only 101 bytes long.\n> An option that should be used before then is to use the split ustar header form,\n> in which a prefix of at most 155 bytes appears after the Devminor bytes. The\n> full name is prefix + \"/\" + name. I expect that more readers will be able to\n> handle this than will know about PAX extensions. I am looking at one right now.\n> \n> My suggestion also matches what BSD tar does:\n> \n> $ tar c\n> tmp/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/very/long/name\n> | xd -c | sed 200q\n> 0000000   v  e  r  y  /  v  e  r  y  /  v  e  r  y  /  v\n> 0000010   e  r  y  /  v  e  r  y  /  v  e  r  y  /  v  e\n> 0000020   r  y  /  v  e  r  y  /  v  e  r  y  /  v  e  r\n> 0000030   y  /  v  e  r  y  /  v  e  r  y  /  v  e  r  y\n> 0000040   /  v  e  r  y  /  v  e  r  y  /  v  e  r  y  /\n> 0000050   v  e  r  y  /  v  e  r  y  /  l  o  n  g  /  n\n> 0000060   a  m  e 00  0  0  0  6  4  4    00  0  5  2  4\n> 0000070   5  5    00  0  0  0  0  0  0    00  0  0  0  0\n> 0000080   0  0  0  0  0  0  3     1  2  0  7  3  3  4  3\n> 0000090   4  0  1     0  5  1  5  7  2 00     0 00 00 00\n> 00000a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00000b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00000c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00000d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00000e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00000f0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000100  00  u  s  t  a  r 00  0  0  r  s  c 00 00 00 00\n> 0000110  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000120  00 00 00 00 00 00 00 00 00  w  h  e  e  l 00 00\n> 0000130  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000140  00 00 00 00 00 00 00 00 00  0  0  0  0  0  0   \n> 0000150  00  0  0  0  0  0  0    00  t  m  p  /  v  e  r\n> 0000160   y  /  v  e  r  y  /  v  e  r  y  /  v  e  r  y\n> 0000170   /  v  e  r  y  /  v  e  r  y  /  v  e  r  y  /\n> 0000180   v  e  r  y  /  v  e  r  y  /  v  e  r  y  /  v\n> 0000190   e  r  y  /  v  e  r  y  /  v  e  r  y 00 00 00\n> 00001a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00001b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> \n> (OS X).\n> \n> I tried the same on Linux and I got a tar file using the GNU ././@LongLink\n> extension:\n> \n> 0000000   .  /  .  /  @  L  o  n  g  L  i  n  k 00 00 00\n> 0000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000050  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000060  00 00 00 00  0  0  0  0  0  0  0 00  0  0  0  0\n> 0000070   0  0  0 00  0  0  0  0  0  0  0 00  0  0  0  0\n> 0000080   0  0  0  0  2  5  1 00  0  0  0  0  0  0  0  0\n> 0000090   0  0  0 00  0  1  1  5  6  3 00     L 00 00 00\n> 00000a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00000b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00000c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00000d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00000e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00000f0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000100  00  u  s  t  a  r       00  r  o  o  t 00 00 00\n> 0000110  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000120  00 00 00 00 00 00 00 00 00  r  o  o  t 00 00 00\n> 0000130  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000140  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000150  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000160  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000170  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000180  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000190  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00001a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00001b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00001c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00001d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00001e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00001f0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000200   t  m  p  /  v  e  r  y  /  v  e  r  y  /  v  e\n> 0000210   r  y  /  v  e  r  y  /  v  e  r  y  /  v  e  r\n> 0000220   y  /  v  e  r  y  /  v  e  r  y  /  v  e  r  y\n> 0000230   /  v  e  r  y  /  v  e  r  y  /  v  e  r  y  /\n> 0000240   v  e  r  y  /  v  e  r  y  /  v  e  r  y  /  v\n> 0000250   e  r  y  /  v  e  r  y  /  v  e  r  y  /  v  e\n> 0000260   r  y  /  v  e  r  y  /  v  e  r  y  /  v  e  r\n> 0000270   y  /  v  e  r  y  /  v  e  r  y  /  v  e  r  y\n> 0000280   /  v  e  r  y  /  v  e  r  y  /  v  e  r  y  /\n> 0000290   v  e  r  y  /  v  e  r  y  /  v  e  r  y  /  l\n> 00002a0   o  n  g  /  n  a  m  e 00 00 00 00 00 00 00 00\n> 00002b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00002c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00002d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00002e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 00002f0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> 0000300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n> \n> In neither case did I get a PAX header. I am worried that nothing generates\n> PAX headers and therefore nothing will read them. I would rather see either\n> of these forms (preferably the BSD one, which I believe is more widespread)\n> before the PAX header here.\n> \n> I have no problem with this package reading the PAX stuff, only with writing it.\n\nI'm not super familiar with bsd. I've downloaded freebsd, and my experiments seem to indicate that for filenames < 100 characters, you get a standard tar file. For 100 < len(name) < 255, you get ustar headers. BSD tar goes ahead and uses pax extensions for larger files. Is that an acceptable behavior for go?",
			"disapproval": false,
			"date": "2013-01-11 01:52:42.653680",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Sorry for the late reply. Using PAX is fine as long as it's restricted to namelen >= 255.",
			"disapproval": false,
			"date": "2013-01-23 04:47:56.456050",
			"approval": false
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/01/23 04:47:56, rsc wrote:\n> Sorry for the late reply. Using PAX is fine as long as it's restricted to\n> namelen >= 255.\n\ni think this is very close to be finished. if there's help required, i'd be happy to update this CL..",
			"disapproval": false,
			"date": "2013-01-30 13:04:24.906670",
			"approval": false
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/01/30 13:04:24, chressie1 wrote:\n\n> i think this is very close to be finished. if there's help required, i'd be\n> happy to update this CL..\n\nto be clear, i'm thinking about merging https://codereview.appspot.com/6814084/ into this CL.",
			"disapproval": false,
			"date": "2013-01-30 13:12:54.465390",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hi Chressie1,\nSorry I've been so busy, but I haven't gone mia. I'd be happy to have you merge your changes into this review. I'm generally on #go-nuts if you have any questions.\n\nOn 2013/01/30 13:12:54, chressie1 wrote:\n> On 2013/01/30 13:04:24, chressie1 wrote:\n> \n> > i think this is very close to be finished. if there's help required, i'd be\n> > happy to update this CL..\n> \n> to be clear, i'm thinking about merging https://codereview.appspot.com/6814084/\n> into this CL.",
			"disapproval": false,
			"date": "2013-01-31 03:00:18.824810",
			"approval": false
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/01/31 03:00:18, shanemhansen wrote:\n> Hi Chressie1,\n> Sorry I've been so busy, but I haven't gone mia. I'd be happy to have you merge\n> your changes into this review. I'm generally on #go-nuts if you have any\n> questions.\n\nno worries :)\n\nunfortunately i cannot update this CL, so i created a merge CL here:\n\nhttps://codereview.appspot.com/7229066\n\ndsymonds, i'd suppose to submit this now as is and to address rsc's concern in the other CL?\n\nthanks,\nchressie",
			"disapproval": false,
			"date": "2013-01-31 11:24:06.204510",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I think we should just get Shane's CL finished off (I believe it's\r\nvery close), and add chressie's changes in separately.\r\n",
			"disapproval": false,
			"date": "2013-01-31 22:56:14.889270",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Sounds good to me. I'll work on adding support for ustar long names.\r\n\r\nThanks for your patience.\r\nOn Thu, Jan 31, 2013 at 3:56 PM, David Symonds <dsymonds@golang.org> wrote:\r\n\r\n> I think we should just get Shane's CL finished off (I believe it's\r\n> very close), and add chressie's changes in separately.\r\n>\r\n",
			"disapproval": false,
			"date": "2013-02-06 03:48:16.250680",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Sorry for all the spam. I had a little trouble doing a hg file XXXX\r\nsomefile to add the new ustar test data.\r\n\r\nOn Wed, Feb 6, 2013 at 8:36 PM, <shanemhansen@gmail.com> wrote:\r\n\r\n> Hello dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com,\r\n> remyoudompheng@gmail.com, chressie@gmail.com, rsc@golang.org (cc:\r\n> golang-dev@googlegroups.com),\r\n>\r\n> Please take another look.\r\n>\r\n>\r\n> https://codereview.appspot.**com/6700047/<https://codereview.appspot.com/6700047/>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-02-07 03:57:23.171410",
			"approval": false
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "sorry, i'm afraid, i wasn't clear in the first place. the merge CL\r\nhttps://codereview.appspot.com/7229066 is exactly about adding ustar\r\nlong names (i.e. using the 155 chars prefix field) to the current CL.\r\nfeel free to copy'n'paste it, if you want.\r\n\r\nOn Wed, Feb 6, 2013 at 4:48 AM, Shane Hansen <shanemhansen@gmail.com> wrote:\r\n> Sounds good to me. I'll work on adding support for ustar long names.\r\n>\r\n> Thanks for your patience.\r\n> On Thu, Jan 31, 2013 at 3:56 PM, David Symonds <dsymonds@golang.org> wrote:\r\n>>\r\n>> I think we should just get Shane's CL finished off (I believe it's\r\n>> very close), and add chressie's changes in separately.\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-02-06 07:18:33.995930",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nUnless anyone pounces with yet more changes to make, I'll submit this later today.\n\nThanks for battling through this, Shane!",
			"disapproval": false,
			"date": "2013-02-10 21:45:46.696520",
			"approval": true
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "one last thing..\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/writer_test.go#newcode225\nsrc/pkg/archive/tar/writer_test.go:225: func aTestPAXHeader(t *testing.T) {\nthis test is never executed (due to the leading 'a')..\n\ni noticed that it fails, because of the ambiguity of the \"multiple acceptable lengths\" tests. this should be cleaned up before activating the test.",
			"disapproval": false,
			"date": "2013-02-06 07:22:17.990830",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/69010/src/pkg/archive/tar/reader_test.go\nFile src/pkg/archive/tar/reader_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/69010/src/pkg/archive/tar/reader_test.go#newcode308\nsrc/pkg/archive/tar/reader_test.go:308: t.Errorf(\"Couldn't parse correctly formatted headers %v\", err)\nOn 2013/02/07 04:45:29, dsymonds wrote:\n> still missing a colon before the \" %v\"\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/69010/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/69010/src/pkg/archive/tar/writer.go#newcode178\nsrc/pkg/archive/tar/writer.go:178: // indicating\nOn 2013/02/07 04:45:29, dsymonds wrote:\n> ah, I see. This is fine. drop this line and add a period to the end of the\n> previous one.\n\nDone.",
			"disapproval": false,
			"date": "2013-02-07 04:48:21.648210",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Good find.\n\nThis would be done last night except I switched to an \nOSX system and learned that:\n1) bsd tar uses ' ' (20) to pad octal group names instead of \\0 (0)\n2) bsd and gnu tar use different heuristics for where to split the filename.\n\nSo it looks like in order to be go tar compatible we need to use gnu tar for the test ustar\nfile (for \\0 padding), which means I have to update the file splitting heuristic.\n\nFor a brief mention of \\0 and ' ' see:\nhttp://en.wikipedia.org/wiki/Tar_(computing)#UStar_format\n\nShould be done soon.\n\nOn 2013/02/06 07:22:17, chressie1 wrote:\n> one last thing..\n> \n> https://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/writer_test.go\n> File src/pkg/archive/tar/writer_test.go (right):\n> \n> https://codereview.appspot.com/6700047/diff/53007/src/pkg/archive/tar/writer_test.go#newcode225\n> src/pkg/archive/tar/writer_test.go:225: func aTestPAXHeader(t *testing.T) {\n> this test is never executed (due to the leading 'a')..\n> \n> i noticed that it fails, because of the ambiguity of the \"multiple acceptable\n> lengths\" tests. this should be cleaned up before activating the test.",
			"disapproval": false,
			"date": "2013-02-06 17:14:38.836830",
			"approval": false
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nthanks!",
			"disapproval": false,
			"date": "2013-02-08 07:39:14.574880",
			"approval": true
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/common.go\nFile src/pkg/archive/tar/common.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/common.go#newcode62\nsrc/pkg/archive/tar/common.go:62: FileNameSize       = 100\nthese don't need to be exported. they could also do with slightly more detailed comments.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/reader_test.go\nFile src/pkg/archive/tar/reader_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/reader_test.go#newcode308\nsrc/pkg/archive/tar/reader_test.go:308: t.Fatalf(\"Couldn't parse correctly formatted headers %s\", err)\n\"...: %v\" at the end of the error string.\n\nt.Errorf + continue would be better here too so that we get to see all the failures, not just the first.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/reader_test.go#newcode311\nsrc/pkg/archive/tar/reader_test.go:311: t.Fatalf(\"mtime header incorrectly parsed\")\ninclude the got/want in the error output, and make this t.Errorf+continue too.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode116\nsrc/pkg/archive/tar/writer.go:116: // Calling afte a Close will return ErrWriteAfterClose.\n\"after\"\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode137\nsrc/pkg/archive/tar/writer.go:137: // or the link name is too long, use PAX headers.\ns/,/;/\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode142\nsrc/pkg/archive/tar/writer.go:142: }\nany other error should be returned, no?\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode149\nsrc/pkg/archive/tar/writer.go:149: tw.cString(s.next(FileNameSize), suffix)\nif this is a cstring, don't the limits above need to be >= instead of >?\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode177\nsrc/pkg/archive/tar/writer.go:177: copy(header[257:265], []byte(\"ustar\\000\"))\nplease add a comment explaining why this magic is different to the one a few lines above.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode196\nsrc/pkg/archive/tar/writer.go:196: // writeUSTARLongName splits a USTAR long name hdr.Name\nadd a period, then add \"name\" to the start of the next line.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode200\nsrc/pkg/archive/tar/writer.go:200: func (tw *Writer) splitUSTARLongName(hdr *Header) (prefix, suffix string, err error) {\nmake the argument \"name string\", and pass hdr.Name above.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer_test.go\nFile src/pkg/archive/tar/writer_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer_test.go#newcode252\nsrc/pkg/archive/tar/writer_test.go:252: {\"a=names\", \"11 a=names\\n\"}, // Test case involving carrys\n\"carries\"",
			"disapproval": false,
			"date": "2013-02-07 04:16:27.406100",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\npatchset #20 now looks fine to me. Let's see what other people say.\n\nhttps://codereview.appspot.com/6700047/diff/69010/src/pkg/archive/tar/reader_test.go\nFile src/pkg/archive/tar/reader_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/69010/src/pkg/archive/tar/reader_test.go#newcode308\nsrc/pkg/archive/tar/reader_test.go:308: t.Errorf(\"Couldn't parse correctly formatted headers %v\", err)\nstill missing a colon before the \" %v\"\n\nhttps://codereview.appspot.com/6700047/diff/69010/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/69010/src/pkg/archive/tar/writer.go#newcode178\nsrc/pkg/archive/tar/writer.go:178: // indicating\nah, I see. This is fine. drop this line and add a period to the end of the previous one.",
			"disapproval": false,
			"date": "2013-02-07 04:45:29.504530",
			"approval": true
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com, chressie@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-02-08 07:35:34.818130",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com, chressie@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-02-07 03:35:37.046670",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "You can use hg upload NNNN to avoid sending mail until you are happy with the results, at that point hg mail. \r\n\r\nOn 07/02/2013, at 14:57, Shane jt Hansen <shanemhansen@gmail.com> wrote:\r\n\r\n> Sorry for all the spam. I had a little trouble doing a hg file XXXX somefile to add the new ustar test data.\r\n> \r\n> On Wed, Feb 6, 2013 at 8:36 PM, <shanemhansen@gmail.com> wrote:\r\n>> Hello dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com,\r\n>> remyoudompheng@gmail.com, chressie@gmail.com, rsc@golang.org (cc:\r\n>> golang-dev@googlegroups.com),\r\n>> \r\n>> Please take another look.\r\n>> \r\n>> \r\n>> https://codereview.appspot.com/6700047/\r\n> \r\n",
			"disapproval": false,
			"date": "2013-02-07 04:02:22.279470",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go#newcode210\nsrc/pkg/archive/tar/writer.go:210: nlen := length - i - 1\nOn 2013/02/08 07:32:10, chressie1 wrote:\n> On 2013/02/07 19:50:27, shanemhansen wrote:\n> > You have an excellent point. I transliterated this algorithm from gnu tar\n> since\n> > our test suite requires we be compatible with a real world tar file. Here's\n> the\n> > original source:\n> > http://git.gag.com/?p=debian/tar;a=blob;f=src/create.c#l591\n> > \n> > Did I make a mistake in transliterating, or do you think there's a bug in the\n> > gnu implementation?\n> \n> they use length to init the for loop, so if name ends with a slash, we want to\n> look for the 2nd last slash in effect. i think the equivalent should be\n> something like:\n> \n>  strings.LastIndex(name[:length], \"/\")\n> \n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go#newcode211\nsrc/pkg/archive/tar/writer.go:211: if i == 0 || nlen > fileNameSize || nlen == 0 {\nOn 2013/02/08 07:32:10, chressie1 wrote:\n> in addition, i think you need to check for i <= 0, because if i == -1, we have a\n> single really long name which can't be splitted.\n\nDone.",
			"disapproval": false,
			"date": "2013-02-08 07:35:34.214970",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com, chressie@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-02-07 03:36:39.378930",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go#newcode202\nsrc/pkg/archive/tar/writer.go:202: func (tw *Writer) splitUSTARLongName(name string) (prefix, suffix string, err error) {\nIt is, it assumes only long filenames are being passed to it.\n\nOn 2013/02/07 08:03:39, chressie1 wrote:\n> it looks like the method is splitting also the file names < 100 chars..\n> \n>  if length <= 100 {\n>   return \"\", name, nil\n>  }\n\nhttps://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go#newcode210\nsrc/pkg/archive/tar/writer.go:210: nlen := length - i - 1\nYou have an excellent point. I transliterated this algorithm from gnu tar since our test suite requires we be compatible with a real world tar file. Here's the original source:\nhttp://git.gag.com/?p=debian/tar;a=blob;f=src/create.c#l591\n\nDid I make a mistake in transliterating, or do you think there's a bug in the gnu implementation?\nOn 2013/02/07 08:03:39, chressie1 wrote:\n> if name ends with a slash and the length of name is <= fileNamePrefixSize, nlen\n> will be -2.",
			"disapproval": false,
			"date": "2013-02-07 19:50:27.477530",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thanks Shane, I think all the blood has been squeezed from this stone.",
			"disapproval": false,
			"date": "2013-02-11 00:32:43.996760",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello dsymonds@golang.org, dave@cheney.net, rogpeppe@gmail.com, remyoudompheng@gmail.com, chressie@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-02-07 04:36:49.979200",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/common.go\nFile src/pkg/archive/tar/common.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/common.go#newcode62\nsrc/pkg/archive/tar/common.go:62: FileNameSize       = 100\nOn 2013/02/07 04:16:27, dsymonds wrote:\n> these don't need to be exported. they could also do with slightly more detailed\n> comments.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/reader_test.go\nFile src/pkg/archive/tar/reader_test.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/reader_test.go#newcode308\nsrc/pkg/archive/tar/reader_test.go:308: t.Fatalf(\"Couldn't parse correctly formatted headers %s\", err)\nOn 2013/02/07 04:16:27, dsymonds wrote:\n> \"...: %v\" at the end of the error string.\n> \n> t.Errorf + continue would be better here too so that we get to see all the\n> failures, not just the first.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/reader_test.go#newcode311\nsrc/pkg/archive/tar/reader_test.go:311: t.Fatalf(\"mtime header incorrectly parsed\")\nOn 2013/02/07 04:16:27, dsymonds wrote:\n> include the got/want in the error output, and make this t.Errorf+continue too.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode137\nsrc/pkg/archive/tar/writer.go:137: // or the link name is too long, use PAX headers.\nOn 2013/02/07 04:16:27, dsymonds wrote:\n> s/,/;/\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode149\nsrc/pkg/archive/tar/writer.go:149: tw.cString(s.next(FileNameSize), suffix)\nI could be wrong, but I don't think we need to change the limits. cString() doesn't necessarily place a null terminator in the if the value fills the space in the struct. That's why you can have  100 character names and not 99 character names in standard tar.\n\nOn 2013/02/07 04:16:27, dsymonds wrote:\n> if this is a cstring, don't the limits above need to be >= instead of >?\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode177\nsrc/pkg/archive/tar/writer.go:177: copy(header[257:265], []byte(\"ustar\\000\"))\nNot sure what would be appropriate. It's the ustar (POSIX 1998) magic rather than the gnu magic. We're using it because we are using ustar long names. Should I add a reference to the POSIX 1998 spec?\n\nOn 2013/02/07 04:16:27, dsymonds wrote:\n> please add a comment explaining why this magic is different to the one a few\n> lines above.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode196\nsrc/pkg/archive/tar/writer.go:196: // writeUSTARLongName splits a USTAR long name hdr.Name\nOn 2013/02/07 04:16:27, dsymonds wrote:\n> add a period, then add \"name\" to the start of the next line.\n\nDone.\n\nhttps://codereview.appspot.com/6700047/diff/65002/src/pkg/archive/tar/writer.go#newcode200\nsrc/pkg/archive/tar/writer.go:200: func (tw *Writer) splitUSTARLongName(hdr *Header) (prefix, suffix string, err error) {\nOn 2013/02/07 04:16:27, dsymonds wrote:\n> make the argument \"name string\", and pass hdr.Name above.\n\nDone.",
			"disapproval": false,
			"date": "2013-02-07 04:35:43.155920",
			"approval": false
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go#newcode202\nsrc/pkg/archive/tar/writer.go:202: func (tw *Writer) splitUSTARLongName(name string) (prefix, suffix string, err error) {\nit looks like the method is splitting also the file names < 100 chars..\n\n if length <= 100 {\n  return \"\", name, nil\n }\n\nhttps://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go#newcode207\nsrc/pkg/archive/tar/writer.go:207: length--\nshouldn't this be length++ ? (explanation below)\n\nhttps://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go#newcode210\nsrc/pkg/archive/tar/writer.go:210: nlen := length - i - 1\nif name ends with a slash and the length of name is <= fileNamePrefixSize, nlen will be -2.",
			"disapproval": false,
			"date": "2013-02-07 08:03:39.515380",
			"approval": false
		},
		{
			"sender": "chressie@gmail.com",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go\nFile src/pkg/archive/tar/writer.go (right):\n\nhttps://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go#newcode210\nsrc/pkg/archive/tar/writer.go:210: nlen := length - i - 1\nOn 2013/02/07 19:50:27, shanemhansen wrote:\n> You have an excellent point. I transliterated this algorithm from gnu tar since\n> our test suite requires we be compatible with a real world tar file. Here's the\n> original source:\n> http://git.gag.com/?p=debian/tar;a=blob;f=src/create.c#l591\n> \n> Did I make a mistake in transliterating, or do you think there's a bug in the\n> gnu implementation?\n\nthey use length to init the for loop, so if name ends with a slash, we want to look for the 2nd last slash in effect. i think the equivalent should be something like:\n\n strings.LastIndex(name[:length], \"/\")\n\nhttps://codereview.appspot.com/6700047/diff/71008/src/pkg/archive/tar/writer.go#newcode211\nsrc/pkg/archive/tar/writer.go:211: if i == 0 || nlen > fileNameSize || nlen == 0 {\nin addition, i think you need to check for i <= 0, because if i == -1, we have a single really long name which can't be splitted.",
			"disapproval": false,
			"date": "2013-02-08 07:32:10.619880",
			"approval": false
		},
		{
			"sender": "shanemhansen@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Yay. Thanks for all the helpful feedback along the way, it was much\r\nappreciated.\r\n\r\n--Shane\r\n\r\nOn Sun, Feb 10, 2013 at 5:36 PM, <dsymonds@golang.org> wrote:\r\n\r\n> *** Submitted as\r\n> https://code.google.com/p/go/**source/detail?r=7ad748c63169<https://code.google.com/p/go/source/detail?r=7ad748c63169>***\r\n>\r\n> archive/tar: read/write extended pax/gnu tar archives\r\n>\r\n> Support reading pax archives and applying extended attributes\r\n> like long names, subsecond mtime resolutions, etc. Default to\r\n> writing pax archives for long file and link names.\r\n> Support reading gnu archives using the ././@LongLink extended\r\n> header for file name and link target.\r\n>\r\n> Fixes issue 3300\r\n>\r\n> R=dsymonds, dave, rogpeppe, remyoudompheng, chressie, rsc\r\n> CC=golang-dev\r\n> https://codereview.appspot.**com/6700047<https://codereview.appspot.com/6700047>\r\n>\r\n> Committer: David Symonds <dsymonds@golang.org>\r\n>\r\n>\r\n> https://codereview.appspot.**com/6700047/<https://codereview.appspot.com/6700047/>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-02-11 18:13:10.611090",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"shanemhansen@gmail.com",
				"dsymonds@golang.org",
				"dave@cheney.net",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"chressie@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=7ad748c63169 ***\n\narchive/tar: read/write extended pax/gnu tar archives\n\nSupport reading pax archives and applying extended attributes\nlike long names, subsecond mtime resolutions, etc. Default to\nwriting pax archives for long file and link names.\nSupport reading gnu archives using the ././@LongLink extended\nheader for file name and link target.\n\nFixes issue 3300\n\nR=dsymonds, dave, rogpeppe, remyoudompheng, chressie, rsc\nCC=golang-dev\nhttps://codereview.appspot.com/6700047\n\nCommitter: David Symonds <dsymonds@golang.org>",
			"disapproval": false,
			"date": "2013-02-11 00:36:48.696990",
			"approval": false
		}
	],
	"owner_email": "shanemhansen@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "shanemhansen",
	"subject": "code review 6700047: archive/tar: read/write extended pax/gnu tar archives",
	"created": "2012-10-15 23:06:38.179620",
	"patchsets": [
		1,
		1001,
		5,
		5009,
		18001,
		27001,
		29004,
		34007,
		30004,
		47001,
		51001,
		54002,
		53007,
		69001,
		70007,
		69008,
		76001,
		65002,
		77008,
		69010,
		71008,
		74008,
		71009
	],
	"modified": "2013-02-12 06:58:58.934580",
	"closed": true,
	"issue": 6700047
}