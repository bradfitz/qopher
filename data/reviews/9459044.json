{
	"description": "bufio: reuse Writer buffers after Flush\n\nA bufio.Writer.Flush marks the usual end of a Writer's\nlife. Recycle its internal buffer on those explicit flushes,\nbut not on normal, as-needed internal flushes.\n\nbenchmark               old ns/op    new ns/op    delta\nBenchmarkWriterEmpty         1959          727  -62.89%\n\nbenchmark              old allocs   new allocs    delta\nBenchmarkWriterEmpty            2            1  -50.00%\n\nbenchmark               old bytes    new bytes    delta\nBenchmarkWriterEmpty         4215           83  -98.03%",
	"cc": [
		"gri@golang.org",
		"iant@golang.org",
		"gobot@golang.org",
		"golang-dev@googlegroups.com",
		"voidlogic7@gmail.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2013-05-21 00:01:19.765920",
			"approval": false
		},
		{
			"sender": "voidlogic7@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "\"A bufio.Writer.Flush marks the usual end of a Writer's life. \"\r\n\r\nThis is also often not the case. I have some programs that need to keep \r\ntransaction logs. These programs have *bufio.Writers with large buffers, \r\n64, 128 MB. To maintain consistency these programs will often flush their \r\n*bufio.Writer and sync the underlying file at set intervals, 5 seconds, 30 \r\nseconds, etc. I worry about this proposed change causing increased GC \r\nactivity in these kind of programs (assuming this large buffers are not \r\nadded to the buffer pool). I also have network communications that are \r\nbuffered that often use Flush, only to immediately start writing data again.\r\n\r\nWould it be possible to note, with a bool field or something, if the Writer \r\nhad to reallocate a buffer after its last Flush(), and if so disable the \r\nnew behaviour? This would allow the new behaviour without adding knobs or \r\nforcing people to write their own buffers. Another idea would be to not \r\nrecycle buffers that are larger than a given size, say 1 MB, perhaps this \r\nis already the case.\r\n\r\nOn Monday, May 20, 2013 7:01:19 PM UTC-5, Brad Fitzpatrick wrote:\r\n>\r\n> Reviewers: golang-dev1, \r\n>\r\n> Message: \r\n> Hello golan...@googlegroups.com <javascript:>, \r\n>\r\n> I'd like you to review this change to \r\n> https://go.googlecode.com/hg/ \r\n>\r\n>\r\n> Description: \r\n> bufio: reuse Writer buffers after Flush \r\n>\r\n> A bufio.Writer.Flush marks the usual end of a Writer's \r\n> life. Recycle its internal buffer on those explicit flushes, \r\n> but not on normal, as-needed internal flushes. \r\n>\r\n> benchmark               old ns/op    new ns/op    delta \r\n> BenchmarkWriterEmpty         1959          727  -62.89% \r\n>\r\n> benchmark              old allocs   new allocs    delta \r\n> BenchmarkWriterEmpty            2            1  -50.00% \r\n>\r\n> benchmark               old bytes    new bytes    delta \r\n> BenchmarkWriterEmpty         4215           83  -98.03% \r\n>\r\n> Please review this at https://codereview.appspot.com/9459044/ \r\n>\r\n> Affected files: \r\n>    M src/pkg/bufio/bufio.go \r\n>    M src/pkg/bufio/bufio_test.go \r\n>\r\n>\r\n> Index: src/pkg/bufio/bufio.go \r\n> =================================================================== \r\n> --- a/src/pkg/bufio/bufio.go \r\n> +++ b/src/pkg/bufio/bufio.go \r\n> @@ -29,7 +29,7 @@ \r\n>\r\n>   // Reader implements buffering for an io.Reader object. \r\n>   type Reader struct { \r\n> -        buf          []byte // either nil or []byte of size bufSize \r\n> +        buf          []byte // either nil or []byte of length bufSize \r\n>           bufSize      int \r\n>           rd           io.Reader \r\n>           r, w         int \r\n> @@ -314,7 +314,7 @@ \r\n>                   } \r\n>\r\n>                   // Buffer is full? \r\n> -                if b.Buffered() >= len(b.buf) { \r\n> +                if b.Buffered() >= b.bufSize { \r\n>                           b.r = b.w \r\n>                           return b.buf, ErrBufferFull \r\n>                   } \r\n> @@ -473,10 +473,11 @@ \r\n>   // If an error occurs writing to a Writer, no more data will be \r\n>   // accepted and all subsequent writes will return the error. \r\n>   type Writer struct { \r\n> -        err error \r\n> -        buf []byte \r\n> -        n   int \r\n> -        wr  io.Writer \r\n> +        err     error \r\n> +        buf     []byte // either nil or []byte of length bufSize \r\n> +        bufSize int \r\n> +        n       int \r\n> +        wr      io.Writer \r\n>   } \r\n>\r\n>   // NewWriterSize returns a new Writer whose buffer has at least the   \r\n> specified \r\n> @@ -485,16 +486,20 @@ \r\n>   func NewWriterSize(wr io.Writer, size int) *Writer { \r\n>           // Is it already a Writer? \r\n>           b, ok := wr.(*Writer) \r\n> -        if ok && len(b.buf) >= size { \r\n> +        if ok && b.bufSize >= size { \r\n>                   return b \r\n>           } \r\n>           if size <= 0 { \r\n>                   size = defaultBufSize \r\n>           } \r\n> -        b = new(Writer) \r\n> -        // TODO(bradfitz): make Writer buffers lazy too, like Reader's \r\n> -        b.buf = make([]byte, size) \r\n> -        b.wr = wr \r\n> +        b = &Writer{ \r\n> +                wr:      wr, \r\n> +                bufSize: size, \r\n> +        } \r\n> +        if size > defaultBufSize { \r\n> +                // TODO(bradfitz): make all buffer sizes recycle \r\n> +                b.buf = make([]byte, b.bufSize) \r\n> +        } \r\n>           return b \r\n>   } \r\n>\r\n> @@ -503,8 +508,38 @@ \r\n>           return NewWriterSize(wr, defaultBufSize) \r\n>   } \r\n>\r\n> +// allocBuf makes b.buf non-nil. \r\n> +func (b *Writer) allocBuf() { \r\n> +        if b.buf != nil { \r\n> +                return \r\n> +        } \r\n> +        select { \r\n> +        case b.buf = <-bufCache: \r\n> +                b.buf = b.buf[:b.bufSize] \r\n> +        default: \r\n> +                b.buf = make([]byte, b.bufSize, defaultBufSize) \r\n> +        } \r\n> +} \r\n> + \r\n> +// putBuf returns b.buf if it's unused. \r\n> +func (b *Writer) putBuf() { \r\n> +        if b.n == 0 && cap(b.buf) == defaultBufSize { \r\n> +                select { \r\n> +                case bufCache <- b.buf: \r\n> +                        b.buf = nil \r\n> +                default: \r\n> +                } \r\n> +        } \r\n> +} \r\n> + \r\n>   // Flush writes any buffered data to the underlying io.Writer. \r\n>   func (b *Writer) Flush() error { \r\n> +        err := b.flush() \r\n> +        b.putBuf() \r\n> +        return err \r\n> +} \r\n> + \r\n> +func (b *Writer) flush() error { \r\n>           if b.err != nil { \r\n>                   return b.err \r\n>           } \r\n> @@ -528,7 +563,7 @@ \r\n>   } \r\n>\r\n>   // Available returns how many bytes are unused in the buffer. \r\n> -func (b *Writer) Available() int { return len(b.buf) - b.n } \r\n> +func (b *Writer) Available() int { return b.bufSize - b.n } \r\n>\r\n>   // Buffered returns the number of bytes that have been written into the \r\n>   \r\n> current buffer. \r\n>   func (b *Writer) Buffered() int { return b.n } \r\n> @@ -538,6 +573,7 @@ \r\n>   // If nn < len(p), it also returns an error explaining \r\n>   // why the write is short. \r\n>   func (b *Writer) Write(p []byte) (nn int, err error) { \r\n> +        b.allocBuf() \r\n>           for len(p) > b.Available() && b.err == nil { \r\n>                   var n int \r\n>                   if b.Buffered() == 0 { \r\n> @@ -547,7 +583,7 @@ \r\n>                   } else { \r\n>                           n = copy(b.buf[b.n:], p) \r\n>                           b.n += n \r\n> -                        b.Flush() \r\n> +                        b.flush() \r\n>                   } \r\n>                   nn += n \r\n>                   p = p[n:] \r\n> @@ -566,9 +602,12 @@ \r\n>           if b.err != nil { \r\n>                   return b.err \r\n>           } \r\n> -        if b.Available() <= 0 && b.Flush() != nil { \r\n> +        if b.Available() <= 0 && b.flush() != nil { \r\n>                   return b.err \r\n>           } \r\n> +        if b.buf == nil { \r\n> +                b.allocBuf() \r\n> +        } \r\n>           b.buf[b.n] = c \r\n>           b.n++ \r\n>           return nil \r\n> @@ -577,6 +616,9 @@ \r\n>   // WriteRune writes a single Unicode code point, returning \r\n>   // the number of bytes written and any error. \r\n>   func (b *Writer) WriteRune(r rune) (size int, err error) { \r\n> +        if b.buf == nil { \r\n> +                b.allocBuf() \r\n> +        } \r\n>           if r < utf8.RuneSelf { \r\n>                   err = b.WriteByte(byte(r)) \r\n>                   if err != nil { \r\n> @@ -589,7 +631,7 @@ \r\n>           } \r\n>           n := b.Available() \r\n>           if n < utf8.UTFMax { \r\n> -                if b.Flush(); b.err != nil { \r\n> +                if b.flush(); b.err != nil { \r\n>                           return 0, b.err \r\n>                   } \r\n>                   n = b.Available() \r\n> @@ -608,13 +650,14 @@ \r\n>   // If the count is less than len(s), it also returns an error explaining \r\n>   // why the write is short. \r\n>   func (b *Writer) WriteString(s string) (int, error) { \r\n> +        b.allocBuf() \r\n>           nn := 0 \r\n>           for len(s) > b.Available() && b.err == nil { \r\n>                   n := copy(b.buf[b.n:], s) \r\n>                   b.n += n \r\n>                   nn += n \r\n>                   s = s[n:] \r\n> -                b.Flush() \r\n> +                b.flush() \r\n>           } \r\n>           if b.err != nil { \r\n>                   return nn, b.err \r\n> @@ -627,6 +670,7 @@ \r\n>\r\n>   // ReadFrom implements io.ReaderFrom. \r\n>   func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) { \r\n> +        b.allocBuf() \r\n>           if b.Buffered() == 0 { \r\n>                   if w, ok := b.wr.(io.ReaderFrom); ok { \r\n>                           return w.ReadFrom(r) \r\n> @@ -641,7 +685,7 @@ \r\n>                   b.n += m \r\n>                   n += int64(m) \r\n>                   if b.Available() == 0 { \r\n> -                        if err1 := b.Flush(); err1 != nil { \r\n> +                        if err1 := b.flush(); err1 != nil { \r\n>                                   return n, err1 \r\n>                           } \r\n>                   } \r\n> Index: src/pkg/bufio/bufio_test.go \r\n> =================================================================== \r\n> --- a/src/pkg/bufio/bufio_test.go \r\n> +++ b/src/pkg/bufio/bufio_test.go \r\n> @@ -1098,3 +1098,21 @@ \r\n>                   } \r\n>           } \r\n>   } \r\n> + \r\n> +func BenchmarkWriterEmpty(b *testing.B) { \r\n> +        b.ReportAllocs() \r\n> +        str := strings.Repeat(\"x\", 1<<10) \r\n> +        bs := []byte(str) \r\n> +        for i := 0; i < b.N; i++ { \r\n> +                bw := NewWriter(ioutil.Discard) \r\n> +                bw.Flush() \r\n> +                bw.WriteByte('a') \r\n> +                bw.Flush() \r\n> +                bw.WriteRune('B') \r\n> +                bw.Flush() \r\n> +                bw.Write(bs) \r\n> +                bw.Flush() \r\n> +                bw.WriteString(str) \r\n> +                bw.Flush() \r\n> +        } \r\n> +} \r\n>\r\n>\r\n>",
			"disapproval": false,
			"date": "2013-05-21 15:22:47.417400",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Tylor,\r\n\r\nThat's true, but the additional cost (flushing to the fastest possible\r\nwriter: ioutil.Discard) is 70ns. I'm not concerned. Anything you'd actually\r\nflush regularly to (e.g. the network), as opposed to a flush-at-end-only,\r\nshould dwarf that.  And that 70ns will drop once runtime.xchg is inlined by\r\ncmd/6c for the channel operations in the runtime and/or we have a\r\nsync.Cache type.\r\n\r\nSo I think this CL is fine as-is.\r\n\r\n\r\n\r\nOn Tue, May 21, 2013 at 8:22 AM, <voidlogic7@gmail.com> wrote:\r\n\r\n> \"A bufio.Writer.Flush marks the usual end of a Writer's life. \"\r\n>\r\n> This is also often not the case. I have some programs that need to keep\r\n> transaction logs. These programs have *bufio.Writers with large buffers,\r\n> 64, 128 MB. To maintain consistency these programs will often flush their\r\n> *bufio.Writer and sync the underlying file at set intervals, 5 seconds, 30\r\n> seconds, etc. I worry about this proposed change causing increased GC\r\n> activity in these kind of programs (assuming this large buffers are not\r\n> added to the buffer pool). I also have network communications that are\r\n> buffered that often use Flush, only to immediately start writing data again.\r\n>\r\n> Would it be possible to note, with a bool field or something, if the\r\n> Writer had to reallocate a buffer after its last Flush(), and if so disable\r\n> the new behaviour? This would allow the new behaviour without adding knobs\r\n> or forcing people to write their own buffers. Another idea would be to not\r\n> recycle buffers that are larger than a given size, say 1 MB, perhaps this\r\n> is already the case.\r\n>\r\n> On Monday, May 20, 2013 7:01:19 PM UTC-5, Brad Fitzpatrick wrote:\r\n>>\r\n>> Reviewers: golang-dev1,\r\n>>\r\n>> Message:\r\n>> Hello golan...@googlegroups.com,\r\n>>\r\n>> I'd like you to review this change to\r\n>> https://go.googlecode.com/hg/\r\n>>\r\n>>\r\n>> Description:\r\n>> bufio: reuse Writer buffers after Flush\r\n>>\r\n>> A bufio.Writer.Flush marks the usual end of a Writer's\r\n>> life. Recycle its internal buffer on those explicit flushes,\r\n>> but not on normal, as-needed internal flushes.\r\n>>\r\n>> benchmark               old ns/op    new ns/op    delta\r\n>> BenchmarkWriterEmpty         1959          727  -62.89%\r\n>>\r\n>> benchmark              old allocs   new allocs    delta\r\n>> BenchmarkWriterEmpty            2            1  -50.00%\r\n>>\r\n>> benchmark               old bytes    new bytes    delta\r\n>> BenchmarkWriterEmpty         4215           83  -98.03%\r\n>>\r\n>> Please review this at https://codereview.appspot.**com/9459044/<https://codereview.appspot.com/9459044/>\r\n>>\r\n>> Affected files:\r\n>>    M src/pkg/bufio/bufio.go\r\n>>    M src/pkg/bufio/bufio_test.go\r\n>>\r\n>>\r\n>> Index: src/pkg/bufio/bufio.go\r\n>> ==============================**==============================**=======\r\n>> --- a/src/pkg/bufio/bufio.go\r\n>> +++ b/src/pkg/bufio/bufio.go\r\n>> @@ -29,7 +29,7 @@\r\n>>\r\n>>   // Reader implements buffering for an io.Reader object.\r\n>>   type Reader struct {\r\n>> -        buf          []byte // either nil or []byte of size bufSize\r\n>> +        buf          []byte // either nil or []byte of length bufSize\r\n>>           bufSize      int\r\n>>           rd           io.Reader\r\n>>           r, w         int\r\n>> @@ -314,7 +314,7 @@\r\n>>                   }\r\n>>\r\n>>                   // Buffer is full?\r\n>> -                if b.Buffered() >= len(b.buf) {\r\n>> +                if b.Buffered() >= b.bufSize {\r\n>>                           b.r = b.w\r\n>>                           return b.buf, ErrBufferFull\r\n>>                   }\r\n>> @@ -473,10 +473,11 @@\r\n>>   // If an error occurs writing to a Writer, no more data will be\r\n>>   // accepted and all subsequent writes will return the error.\r\n>>   type Writer struct {\r\n>> -        err error\r\n>> -        buf []byte\r\n>> -        n   int\r\n>> -        wr  io.Writer\r\n>> +        err     error\r\n>> +        buf     []byte // either nil or []byte of length bufSize\r\n>> +        bufSize int\r\n>> +        n       int\r\n>> +        wr      io.Writer\r\n>>   }\r\n>>\r\n>>   // NewWriterSize returns a new Writer whose buffer has at least the\r\n>> specified\r\n>> @@ -485,16 +486,20 @@\r\n>>   func NewWriterSize(wr io.Writer, size int) *Writer {\r\n>>           // Is it already a Writer?\r\n>>           b, ok := wr.(*Writer)\r\n>> -        if ok && len(b.buf) >= size {\r\n>> +        if ok && b.bufSize >= size {\r\n>>                   return b\r\n>>           }\r\n>>           if size <= 0 {\r\n>>                   size = defaultBufSize\r\n>>           }\r\n>> -        b = new(Writer)\r\n>> -        // TODO(bradfitz): make Writer buffers lazy too, like Reader's\r\n>> -        b.buf = make([]byte, size)\r\n>> -        b.wr = wr\r\n>> +        b = &Writer{\r\n>> +                wr:      wr,\r\n>> +                bufSize: size,\r\n>> +        }\r\n>> +        if size > defaultBufSize {\r\n>> +                // TODO(bradfitz): make all buffer sizes recycle\r\n>> +                b.buf = make([]byte, b.bufSize)\r\n>> +        }\r\n>>           return b\r\n>>   }\r\n>>\r\n>> @@ -503,8 +508,38 @@\r\n>>           return NewWriterSize(wr, defaultBufSize)\r\n>>   }\r\n>>\r\n>> +// allocBuf makes b.buf non-nil.\r\n>> +func (b *Writer) allocBuf() {\r\n>> +        if b.buf != nil {\r\n>> +                return\r\n>> +        }\r\n>> +        select {\r\n>> +        case b.buf = <-bufCache:\r\n>> +                b.buf = b.buf[:b.bufSize]\r\n>> +        default:\r\n>> +                b.buf = make([]byte, b.bufSize, defaultBufSize)\r\n>> +        }\r\n>> +}\r\n>> +\r\n>> +// putBuf returns b.buf if it's unused.\r\n>> +func (b *Writer) putBuf() {\r\n>> +        if b.n == 0 && cap(b.buf) == defaultBufSize {\r\n>> +                select {\r\n>> +                case bufCache <- b.buf:\r\n>> +                        b.buf = nil\r\n>> +                default:\r\n>> +                }\r\n>> +        }\r\n>> +}\r\n>> +\r\n>>   // Flush writes any buffered data to the underlying io.Writer.\r\n>>   func (b *Writer) Flush() error {\r\n>> +        err := b.flush()\r\n>> +        b.putBuf()\r\n>> +        return err\r\n>> +}\r\n>> +\r\n>> +func (b *Writer) flush() error {\r\n>>           if b.err != nil {\r\n>>                   return b.err\r\n>>           }\r\n>> @@ -528,7 +563,7 @@\r\n>>   }\r\n>>\r\n>>   // Available returns how many bytes are unused in the buffer.\r\n>> -func (b *Writer) Available() int { return len(b.buf) - b.n }\r\n>> +func (b *Writer) Available() int { return b.bufSize - b.n }\r\n>>\r\n>>   // Buffered returns the number of bytes that have been written into the\r\n>>\r\n>> current buffer.\r\n>>   func (b *Writer) Buffered() int { return b.n }\r\n>> @@ -538,6 +573,7 @@\r\n>>   // If nn < len(p), it also returns an error explaining\r\n>>   // why the write is short.\r\n>>   func (b *Writer) Write(p []byte) (nn int, err error) {\r\n>> +        b.allocBuf()\r\n>>           for len(p) > b.Available() && b.err == nil {\r\n>>                   var n int\r\n>>                   if b.Buffered() == 0 {\r\n>> @@ -547,7 +583,7 @@\r\n>>                   } else {\r\n>>                           n = copy(b.buf[b.n:], p)\r\n>>                           b.n += n\r\n>> -                        b.**Flush()\r\n>> +                        b.**flush()\r\n>>                   }\r\n>>                   nn += n\r\n>>                   p = p[n:]\r\n>> @@ -566,9 +602,12 @@\r\n>>           if b.err != nil {\r\n>>                   return b.err\r\n>>           }\r\n>> -        if b.Available() <= 0 && b.Flush() != nil {\r\n>> +        if b.Available() <= 0 && b.flush() != nil {\r\n>>                   return b.err\r\n>>           }\r\n>> +        if b.buf == nil {\r\n>> +                b.allocBuf()\r\n>> +        }\r\n>>           b.buf[b.n] = c\r\n>>           b.n++\r\n>>           return nil\r\n>> @@ -577,6 +616,9 @@\r\n>>   // WriteRune writes a single Unicode code point, returning\r\n>>   // the number of bytes written and any error.\r\n>>   func (b *Writer) WriteRune(r rune) (size int, err error) {\r\n>> +        if b.buf == nil {\r\n>> +                b.allocBuf()\r\n>> +        }\r\n>>           if r < utf8.RuneSelf {\r\n>>                   err = b.WriteByte(byte(r))\r\n>>                   if err != nil {\r\n>> @@ -589,7 +631,7 @@\r\n>>           }\r\n>>           n := b.Available()\r\n>>           if n < utf8.UTFMax {\r\n>> -                if b.Flush(); b.err != nil {\r\n>> +                if b.flush(); b.err != nil {\r\n>>                           return 0, b.err\r\n>>                   }\r\n>>                   n = b.Available()\r\n>> @@ -608,13 +650,14 @@\r\n>>   // If the count is less than len(s), it also returns an error\r\n>> explaining\r\n>>   // why the write is short.\r\n>>   func (b *Writer) WriteString(s string) (int, error) {\r\n>> +        b.allocBuf()\r\n>>           nn := 0\r\n>>           for len(s) > b.Available() && b.err == nil {\r\n>>                   n := copy(b.buf[b.n:], s)\r\n>>                   b.n += n\r\n>>                   nn += n\r\n>>                   s = s[n:]\r\n>> -                b.Flush()\r\n>> +                b.flush()\r\n>>           }\r\n>>           if b.err != nil {\r\n>>                   return nn, b.err\r\n>> @@ -627,6 +670,7 @@\r\n>>\r\n>>   // ReadFrom implements io.ReaderFrom.\r\n>>   func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {\r\n>> +        b.allocBuf()\r\n>>           if b.Buffered() == 0 {\r\n>>                   if w, ok := b.wr.(io.ReaderFrom); ok {\r\n>>                           return w.ReadFrom(r)\r\n>> @@ -641,7 +685,7 @@\r\n>>                   b.n += m\r\n>>                   n += int64(m)\r\n>>                   if b.Available() == 0 {\r\n>> -                        if err1 := b.Flush(); err1 != nil {\r\n>> +                        if err1 := b.flush(); err1 != nil {\r\n>>                                 **  return n, err1\r\n>>                           }\r\n>>                   }\r\n>> Index: src/pkg/bufio/bufio_test.go\r\n>> ==============================**==============================**=======\r\n>> --- a/src/pkg/bufio/bufio_test.go\r\n>> +++ b/src/pkg/bufio/bufio_test.go\r\n>> @@ -1098,3 +1098,21 @@\r\n>>                   }\r\n>>           }\r\n>>   }\r\n>> +\r\n>> +func BenchmarkWriterEmpty(b *testing.B) {\r\n>> +        b.ReportAllocs()\r\n>> +        str := strings.Repeat(\"x\", 1<<10)\r\n>> +        bs := []byte(str)\r\n>> +        for i := 0; i < b.N; i++ {\r\n>> +                bw := NewWriter(ioutil.Discard)\r\n>> +                bw.Flush()\r\n>> +                bw.WriteByte(**'a')\r\n>> +                bw.Flush()\r\n>> +                bw.WriteRune(**'B')\r\n>> +                bw.Flush()\r\n>> +                bw.Write(bs)\r\n>> +                bw.Flush()\r\n>> +                bw.**WriteString(str)\r\n>> +                bw.Flush()\r\n>> +        }\r\n>> +}\r\n>>\r\n>>\r\n>>\r\n",
			"disapproval": false,
			"date": "2013-05-21 22:35:44.448820",
			"approval": false
		},
		{
			"sender": "gobot@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"voidlogic7@gmail.com",
				"gobot@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "R=gri (assigned by bradfitz)",
			"disapproval": false,
			"date": "2013-05-21 22:44:06.982180",
			"approval": false
		},
		{
			"sender": "iant@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"gri@golang.org",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"voidlogic7@gmail.com",
				"gobot@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM",
			"disapproval": false,
			"date": "2013-05-21 22:49:05.888740",
			"approval": true
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"gri@golang.org",
				"iant@golang.org",
				"gobot@golang.org",
				"golang-dev@googlegroups.com",
				"voidlogic7@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=8e41e8e4a2ab ***\n\nbufio: reuse Writer buffers after Flush\n\nA bufio.Writer.Flush marks the usual end of a Writer's\nlife. Recycle its internal buffer on those explicit flushes,\nbut not on normal, as-needed internal flushes.\n\nbenchmark               old ns/op    new ns/op    delta\nBenchmarkWriterEmpty         1959          727  -62.89%\n\nbenchmark              old allocs   new allocs    delta\nBenchmarkWriterEmpty            2            1  -50.00%\n\nbenchmark               old bytes    new bytes    delta\nBenchmarkWriterEmpty         4215           83  -98.03%\n\nR=gri, iant\nCC=gobot, golang-dev, voidlogic7\nhttps://codereview.appspot.com/9459044",
			"disapproval": false,
			"date": "2013-05-21 22:51:55.157120",
			"approval": false
		}
	],
	"owner_email": "bradfitz@golang.org",
	"private": false,
	"base_url": "",
	"owner": "bradfitz",
	"subject": "code review 9459044: bufio: reuse Writer buffers after Flush",
	"created": "2013-05-21 00:00:44.556980",
	"patchsets": [
		1,
		2001,
		3003,
		10001
	],
	"modified": "2013-05-21 22:51:55.157120",
	"closed": true,
	"issue": 9459044
}