{
	"description": "exp/ssh: add experimental ssh client\n\nRequires CL 5285044\n\nclient.go:\n* add Dial, ClientConn, ClientChan, ClientConfig and Cmd.\n\ndoc.go:\n* add Client documentation.\n\nserver.go:\n* adjust for readVersion change.\n\ntransport.go:\n* return an os.Error not a bool from readVersion.",
	"cc": [
		"rsc@golang.org",
		"agl@golang.org",
		"n13m3y3r@gmail.com",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2011-10-07 22:38:44.853804",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "<gentle nudge/>",
			"disapproval": false,
			"date": "2011-10-12 23:21:51.183066",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Fixed client example in doc.go, thanks Jacek Masiulaniec.\n\nI have also written a very basic ssh cli client which I have been using to test this package. \n\nhttps://github.com/davecheney/essessaich\n\nPTAL",
			"disapproval": false,
			"date": "2011-10-09 21:18:10.360697",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5162047/diff/23001/src/pkg/exp/ssh/client.go\nFile src/pkg/exp/ssh/client.go (right):\n\nhttp://codereview.appspot.com/5162047/diff/23001/src/pkg/exp/ssh/client.go#newcode339\nsrc/pkg/exp/ssh/client.go:339: SupportedKexAlgos, SupportedHostKeyAlgos, SupportedCiphers, SupportedMACs, SupportedCompressions []string\nEach on its own line, commented.\ns/Algo/Alg/\n\nhttp://codereview.appspot.com/5162047/diff/23001/src/pkg/exp/ssh/client.go#newcode419\nsrc/pkg/exp/ssh/client.go:419: binary.Write(b, binary.BigEndian, term)\nI don't think binary.Write accepts strings.\nIf it does, that's a mistake.\nYou're better off with something like:\n\nb := make([]byte, 4+len(term)+4*4+9)\nbinary.BigEndian.PutUint32(b[0:], uint32(len(term))\ncopy(b[4:], term)\nn := 4+len(term)\nbinary.BigEndian.PutUint32(b[n:], uint32(h))\nbinary.BigEndian.PutUint32(b[n+4:], uint32(w))\nbinary.BigEndian.PutUint32(b[n+8:], uint32(h*8))\nbinary.BigEndian.PutUint32(b[n+12:], uint32(w*8))\ncopy(b[n+16:], emptyModeList)\n\nOr something like that.  Using PutUint32 directly is\neasier and clearer than invoking Write.",
			"disapproval": false,
			"date": "2011-10-14 21:53:31.912912",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I'm excited to see this, but it's a lot of code.\nPlease split client.go into a separate CL: it\nseems easy to treat client and server as different\nchanges.\n\nPlease make a pass through the code to double-check\nthat exported types, vars, funcs, and methods have\ncomments and that the comments begin by naming the\nthing being described (see http://golang.org/doc/effective_go.html#commentary).\n\nPlease compare the listener API here with the one in \ncrypto/tls.  NewListener is missing, and maybe other\nthings I didn't notice.  crypto/tls is a good place to crib\ncomments too.\n\nThanks.\nRuss\n",
			"disapproval": false,
			"date": "2011-10-14 21:55:53.377841",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Thanks for you comments Russ, I have a suspicion that this patch\nshould have been split into chunks. I have now done this and will\nsubmit individual changes for the cleanup, the client support and\nserver changes.\n\nCheers\n\nDave\n\nOn Sat, Oct 15, 2011 at 8:55 AM, Russ Cox <rsc@golang.org> wrote:\n> I'm excited to see this, but it's a lot of code.\n> Please split client.go into a separate CL: it\n> seems easy to treat client and server as different\n> changes.\n>\n> Please make a pass through the code to double-check\n> that exported types, vars, funcs, and methods have\n> comments and that the comments begin by naming the\n> thing being described (see http://golang.org/doc/effective_go.html#commentary).\n>\n> Please compare the listener API here with the one in\n> crypto/tls. \u00a0NewListener is missing, and maybe other\n> things I didn't notice. \u00a0crypto/tls is a good place to crib\n> comments too.\n>\n> Thanks.\n> Russ\n>\n",
			"disapproval": false,
			"date": "2011-10-14 22:39:32.964036",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-10-16 04:53:10.446298",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-10-16 04:53:31.320748",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Thanks for your feedback Russ. PTAL\n\nhttp://codereview.appspot.com/5162047/diff/23001/src/pkg/exp/ssh/client.go\nFile src/pkg/exp/ssh/client.go (right):\n\nhttp://codereview.appspot.com/5162047/diff/23001/src/pkg/exp/ssh/client.go#newcode339\nsrc/pkg/exp/ssh/client.go:339: SupportedKexAlgos, SupportedHostKeyAlgos, SupportedCiphers, SupportedMACs, SupportedCompressions []string\nI've removed those options, as you can't choose anything except a single alg at the moment anyway.\n\nOn 2011/10/14 21:53:31, rsc wrote:\n> Each on its own line, commented.\n> s/Algo/Alg/\n\nhttp://codereview.appspot.com/5162047/diff/23001/src/pkg/exp/ssh/client.go#newcode419\nsrc/pkg/exp/ssh/client.go:419: binary.Write(b, binary.BigEndian, term)\nOn 2011/10/14 21:53:31, rsc wrote:\n> I don't think binary.Write accepts strings.\n> If it does, that's a mistake.\n> You're better off with something like:\n> \n> b := make([]byte, 4+len(term)+4*4+9)\n> binary.BigEndian.PutUint32(b[0:], uint32(len(term))\n> copy(b[4:], term)\n> n := 4+len(term)\n> binary.BigEndian.PutUint32(b[n:], uint32(h))\n> binary.BigEndian.PutUint32(b[n+4:], uint32(w))\n> binary.BigEndian.PutUint32(b[n+8:], uint32(h*8))\n> binary.BigEndian.PutUint32(b[n+12:], uint32(w*8))\n> copy(b[n+16:], emptyModeList)\n> \n> Or something like that.  Using PutUint32 directly is\n> easier and clearer than invoking Write.\n\nDone.",
			"disapproval": false,
			"date": "2011-10-16 04:54:17.650307",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"agl@golang.org",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Thank you for your comments. PTAL.\n\nGustavo, if you want to experiment, here is a working example of an ssh client. https://github.com/davecheney/essessaich\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go\nFile src/pkg/exp/ssh/client.go (right):\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode20\nsrc/pkg/exp/ssh/client.go:20: var clientVersion = []byte(\"SSH-2.0-Go\\r\\n\")\nAgreed, but I'd prefer to save it for a later CL.\n\nOn 2011/10/19 16:56:00, agl1 wrote:\n> This could probably be merged into serverVersion and become just \"version\".\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode118\nsrc/pkg/exp/ssh/client.go:118: fmt.Errorf(\"ssh: unexpected key exchange algorithm %v\", kexAlgo)\nThis one was Russ's suggestion, I don't think there is much harm in a fmt.Errorf call in the slow path.\n\nOn 2011/10/19 16:56:00, agl1 wrote:\n> kexAlgo is just a string, so + can be used to concat the values here\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode174\nsrc/pkg/exp/ssh/client.go:174: func (c *ClientConn) sendUserAuthReq(method string) os.Error {\nFor the client \"none\" authentication doesn't work, yet. Once I get proper auth negotiation going this method will need to be scrapped/modified.\n\nOn 2011/10/19 16:56:00, agl1 wrote:\n> If not sure if this is correct for the \"none\" case. In that case, a password\n> payload (with an empty string) will be sent, but I don't think that \"none\"\n> should have any payload.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode255\nsrc/pkg/exp/ssh/client.go:255: return nil, os.NewError(msg.Message)\nGood catch.\n\nOn 2011/10/19 16:56:00, agl1 wrote:\n> In these events, don't we need to tidy up the channel?\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode264\nsrc/pkg/exp/ssh/client.go:264: func (c *ClientConn) mainloop() {\nDone. Not sure what the precedent is here, maybe this should be an anon goroutine.\n\nOn 2011/10/19 16:56:00, agl1 wrote:\n> Maybe s/mainloop/mainLoop/ ?\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode383\nsrc/pkg/exp/ssh/client.go:383: func (c *ClientChan) Setenv(name, value string) os.Error {\nLooks like this one is grandfathered in.\n\nOn 2011/10/19 20:06:44, niemeyer wrote:\n> Should this be SetEnv?  Names in the os package in general are not a good\n> example to replicate.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode438\nsrc/pkg/exp/ssh/client.go:438: // Closing *Cmd.Stdin will be observed by the remote process.\nOn 2011/10/19 19:34:18, rsc wrote:\n> d\n> (move to Cmd)\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode457\nsrc/pkg/exp/ssh/client.go:457: // Closing *Cmd.Stdin will be observed by the remote process.\nOn 2011/10/19 19:34:18, rsc wrote:\n> d\n> (move to Cmd)\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode484\nsrc/pkg/exp/ssh/client.go:484: for i := uint32(0); i < 2^31; i++ {\nSorry, that was a Javaism. See the TODO in the struct definition.\n\nOn 2011/10/19 19:34:18, rsc wrote:\n> 2^31 == 29.  s/2^/1<</\n>\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode503\nsrc/pkg/exp/ssh/client.go:503: c.chans[id] = nil, false\nDone. Woohoo.\n\nOn 2011/10/19 16:56:00, agl1 wrote:\n> should use delete() now.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode506\nsrc/pkg/exp/ssh/client.go:506: // Cmd represents the file descriptors of a remote process.\nOn 2011/10/19 19:34:18, rsc wrote:\n> // A Cmd represents a connection to a remote command or shell.\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode508\nsrc/pkg/exp/ssh/client.go:508: Stdin  io.WriteCloser\nExcellent description, thank you.\n\nOn 2011/10/19 19:34:18, rsc wrote:\n> // Writes to Stdin are made available to the command's standard input.\n> // Closing Stdin causes the command to observe an EOF on its standard input.\n> Stdin io.WriteCloser\n> \n> // Reads from Stdout consume the command's standard output.\n> // There is a fixed amount of buffering of the command's standard output.\n> // Failing to read from Stdout will eventually cause the command to block\n> // when writing to its standard output.  Closing Stdout unblocks any\n> // such writes and makes them return errors.\n> Stdout io.ReadCloser\n\nThat should be correct, stdoutReader probably needs more logic to accurately manage the number of slots in it's channel buffer and to convert them back into window size adjust messages. I've added a TODO.\n\n> \n> // Reads from Stderr consume the command's standard error.\n> // The SSH protocol assumes it can always send standard error;\n> // the command will never block writing to its standard error.\n> // However, failure to read from Stderr will eventually cause the\n> // SSH protocol to jam, so it is important to arrange for reading\n> // from Stderr, even if by\n> //    go io.Copy(ioutil.Discard, cmd.Stderr)\n> Stderr io.Reader\n\nYes, there is no flow control on stderr/channelExtendedData. I could make writes to that channel none blocking. I'll add a TODO\n\n> \n> \n> Maybe the API should be different, but that's my understanding of\n> how the current code works.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode518\nsrc/pkg/exp/ssh/client.go:518: packetWriter     // for sending channeDataMsg\nOn 2011/10/19 16:56:00, agl1 wrote:\n> typo: s/channe/channel/\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode591\nsrc/pkg/exp/ssh/client.go:591: // Read reads a line of data from the remote process's stderr.\nstdErr isn't a stream, there is no way to send an EOF. The schema for the packet says it's an SSH string. I unpack that into a buf []byte so it can be read from stderr as a byte stream. If this string <> byte conversion was handled in mainLoop, possibly we could reused stdoutReader.\n\nOn 2011/10/19 16:56:00, agl1 wrote:\n> The comment mentions a \"line\", but I don't see any reason why the data should be\n> line based. Am I missing something?",
			"disapproval": false,
			"date": "2011-10-19 20:16:48.659971",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Agreed. Thank you for submitting this in it's current form, hopefully\nothers will be able to contribute to it now.\n\nOn Thu, Oct 20, 2011 at 7:18 AM, Russ Cox <rsc@golang.org> wrote:\n>> Yes, there is no flow control on stderr/channelExtendedData. I could\n>> make writes to that channel none blocking. I'll add a TODO\n>\n> That would be a bad TODO, because it would cause data to be lost.\n> I'd rather see a program hang than get half the standard error output.\n> It is worth thinking about whether you can change the API here\n> to be closer to package exec, and then some of these considerations\n> just go away, but not for this CL.\n>\n> Will submit later today.\n>\n> Russ\n>\n",
			"disapproval": false,
			"date": "2011-10-19 20:25:53.824099",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"agl@golang.org",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=e2a58806ccd6 ***\n\nexp/ssh: add experimental ssh client\n\nRequires CL 5285044\n\nclient.go:\n* add Dial, ClientConn, ClientChan, ClientConfig and Cmd.\n\ndoc.go:\n* add Client documentation.\n\nserver.go:\n* adjust for readVersion change.\n\ntransport.go:\n* return an os.Error not a bool from readVersion.\n\nR=rsc, agl, n13m3y3r\nCC=golang-dev\nhttp://codereview.appspot.com/5162047\n\nCommitter: Adam Langley <agl@golang.org>",
			"disapproval": false,
			"date": "2011-10-20 19:45:18.059757",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Oct 20, 2011 at 3:39 PM,  <dave@cheney.net> wrote:\n> What are the next steps here, would you like another round of reviews or\n> are you happy to commit it ?\n\nI'll commit it now.\n\n\nCheers\n\nAGL\n",
			"disapproval": false,
			"date": "2011-10-20 19:43:33.122512",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, agl@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-10-19 11:36:11.406407",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "coming along nicely...\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go\nFile src/pkg/exp/ssh/client.go (right):\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode29\nsrc/pkg/exp/ssh/client.go:29: // Client returns a new SSH client side connection using conn\ns/ side//\ns/conn/c/\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode54\nsrc/pkg/exp/ssh/client.go:54: func checkConfig(config *ClientConfig) {\nDelete.  It doesn't return anything, so the first if has no effect.\nThe second if is not okay - it edits a config that is owned by\nthe caller.  Instead, add a rand() method that will return the\nappropriate rand.  Look at the methods on crypto/tls's Config.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode63\nsrc/pkg/exp/ssh/client.go:63: // Perform the client side key exchange. See RFC 4253 Section 7.\n// handshake performs\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode76\nsrc/pkg/exp/ssh/client.go:76: version, ok := readVersion(c)\nThis should return an error, which you can then return.\nReturning a bool means you have to make up what happened\n(on the next line).\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode130\nsrc/pkg/exp/ssh/client.go:130: err = os.NewError(\"ssh: internal error\")\nMight as well say a little more:\n\nerr = fmt.Errorf(\"ssh: unexpected key exchange algorithm %v\", kexAlgo)\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode151\nsrc/pkg/exp/ssh/client.go:151: // Attempt to authenticate with the remote server. See RFC 4252. Currently\n// authenticate authenticates with the remote server...\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode151\nsrc/pkg/exp/ssh/client.go:151: // Attempt to authenticate with the remote server. See RFC 4252. Currently\ns/Currently//\n\n(almost always redundant)\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode167\nsrc/pkg/exp/ssh/client.go:167: // TODO(dfc) support proper authentication method negotation\nPlease define this in a followup CL.\nSee smtp.Auth for a possible example of using interfaces.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode189\nsrc/pkg/exp/ssh/client.go:189: // payload[0] = boolean (false)\nwhy not say that\n\npayload[0] = 0  // false\n\nIt won't kill the performance of this code, and it's clear.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode247\nsrc/pkg/exp/ssh/client.go:247: // Open a new client side channel. Valid session types are listed in RFC 4250 4.9.1.\n// OpenChan opens a new client channel.\n// The most common session types are \"xxx\" and \"yyy\".\n// The full set of valid session types are listed in RFC 4250 4.9.1.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode272\nsrc/pkg/exp/ssh/client.go:272: // Drain incoming messages and route channel messages to their respective ClientChans.\n// mainloop reads incoming messages and routes channel messages\n// to their respective ClientChans.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode276\nsrc/pkg/exp/ssh/client.go:276: go func() {\nWhy do this in a separate goroutine?\nI can't see that the mainloop is doing\nanything else that's interesting, so it \nmight as well be the one that calls readPacket.\nIs this left over from an earlier implementation?\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode356\nsrc/pkg/exp/ssh/client.go:356: // ClientChan represents a single RFC 4254 channel that is multiplexed over a single\ns/ClientChan/A ClientChan/\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode396\nsrc/pkg/exp/ssh/client.go:396: // Pass an environment variable to a channel to be applied to any Shell or\n// Setenv sets an environment variable that will be applied to any\n// command executed by Shell or Exec.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode433\nsrc/pkg/exp/ssh/client.go:433: // Ptyreq requests a pty to be allocated on the remote side of this channel.\ns/Ptyreq/RequestPty/\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode451\nsrc/pkg/exp/ssh/client.go:451: // Execute command on the remote host. Exec returns a tupple of a WriteCloser,\nthere aren't tuples in Go.  you can name the result variables,\neven if you don't use the names in the function, as good documentation:\n\n// Exec runs cmd on the remote host.\n// Typically, the remote server passes cmd to the shell for interpretation.\n// Closing stdin will be observed by the remote process.\nfunc (c *ClientChan) Exec(cmd string) (stdin io.WriteCloser, stdout io.ReadCloser, stderr io.Reader, err os.Error) {\n\nit is unclear to me why you'd want to close stdout.  The remote process\ncannot observe that, unless it gets a SIGPIPE trying to write to stdout.\nAnd if stdout can be closed, why not stderr?\n\nI think you want stdout to be an io.Reader here:\n\nfunc (c *ClientChan) Exec(cmd string) (stdin io.WriteCloser, stdout, stderr io.Reader, err os.Error)\n\nIt is possible that Exec should return (*Cmd, os.Error)\nand Cmd can be\n\ntype Cmd struct {\n    Stdin io.WriteCloser\n    Stdout io.Reader\n    Stderr io.Reader\n}\n\nfunc (c *Cmd) Kill() os.Error\n\nif the SSH protocol provides a way to kill a running command.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode468\nsrc/pkg/exp/ssh/client.go:468: // Execute the default shell for the remote user. Shell returns a tupple of a\n// Shell starts a login shell on the remote host.\n// Closing stdin will be observed by the remote process.\nfunc (c *ClientChan) Shell() (stdin io.WriterCloser, stdout, stderr io.Reader, err os.Error)\n\nsame comment about possibly wanting *Cmd here\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode514\nsrc/pkg/exp/ssh/client.go:514: // Represents the stdin stream to the remote peer.\n// A stdinWriter represents...\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode522\nsrc/pkg/exp/ssh/client.go:522: // Write writes data to stdin of the remote channel.\n// Write writes data to the remote channel's standard input.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode549\nsrc/pkg/exp/ssh/client.go:549: // Represents the stdout stream from the remote peer.\n// A stdoutReader represents ...\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode558\nsrc/pkg/exp/ssh/client.go:558: // Read data from stdout on the remote channel.\n// Read reads data from the remote channel's standard output.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode586\nsrc/pkg/exp/ssh/client.go:586: // Represents the stderr stream from the remote peer.\n// A stderrReader represents...",
			"disapproval": false,
			"date": "2011-10-18 19:43:51.665916",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Thank you for your detailed review Russ.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go\nFile src/pkg/exp/ssh/client.go (right):\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode29\nsrc/pkg/exp/ssh/client.go:29: // Client returns a new SSH client side connection using conn\nOn 2011/10/18 19:43:51, rsc wrote:\n> s/ side//\n> s/conn/c/\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode54\nsrc/pkg/exp/ssh/client.go:54: func checkConfig(config *ClientConfig) {\nDone. Private methods on ClientConfig are a much better solution.\nOn 2011/10/18 19:43:51, rsc wrote:\n> Delete.  It doesn't return anything, so the first if has no effect.\n> The second if is not okay - it edits a config that is owned by\n> the caller.  Instead, add a rand() method that will return the\n> appropriate rand.  Look at the methods on crypto/tls's Config.\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode63\nsrc/pkg/exp/ssh/client.go:63: // Perform the client side key exchange. See RFC 4253 Section 7.\nOn 2011/10/18 19:43:51, rsc wrote:\n> // handshake performs\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode76\nsrc/pkg/exp/ssh/client.go:76: version, ok := readVersion(c)\nDone. This required making a small change to transport.go and server.go.\n\nOn 2011/10/18 19:43:51, rsc wrote:\n> This should return an error, which you can then return.\n> Returning a bool means you have to make up what happened\n> (on the next line).\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode130\nsrc/pkg/exp/ssh/client.go:130: err = os.NewError(\"ssh: internal error\")\nOn 2011/10/18 19:43:51, rsc wrote:\n> Might as well say a little more:\n> \n> err = fmt.Errorf(\"ssh: unexpected key exchange algorithm %v\", kexAlgo)\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode151\nsrc/pkg/exp/ssh/client.go:151: // Attempt to authenticate with the remote server. See RFC 4252. Currently\nOn 2011/10/18 19:43:51, rsc wrote:\n> // authenticate authenticates with the remote server...\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode151\nsrc/pkg/exp/ssh/client.go:151: // Attempt to authenticate with the remote server. See RFC 4252. Currently\nOn 2011/10/18 19:43:51, rsc wrote:\n> // authenticate authenticates with the remote server...\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode167\nsrc/pkg/exp/ssh/client.go:167: // TODO(dfc) support proper authentication method negotation\nWill do. Proper auth negotiation is next on my list.\n\nOn 2011/10/18 19:43:51, rsc wrote:\n> Please define this in a followup CL.\n> See smtp.Auth for a possible example of using interfaces.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode189\nsrc/pkg/exp/ssh/client.go:189: // payload[0] = boolean (false)\nOn 2011/10/18 19:43:51, rsc wrote:\n> why not say that\n> \n> payload[0] = 0  // false\n> \n> It won't kill the performance of this code, and it's clear.\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode272\nsrc/pkg/exp/ssh/client.go:272: // Drain incoming messages and route channel messages to their respective ClientChans.\nOn 2011/10/18 19:43:51, rsc wrote:\n> // mainloop reads incoming messages and routes channel messages\n> // to their respective ClientChans.\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode276\nsrc/pkg/exp/ssh/client.go:276: go func() {\nIndeed it is a hang over from when mainloop() was also responsible for sending responses. Fixed.\n\nOn 2011/10/18 19:43:51, rsc wrote:\n> Why do this in a separate goroutine?\n> I can't see that the mainloop is doing\n> anything else that's interesting, so it \n> might as well be the one that calls readPacket.\n> Is this left over from an earlier implementation?\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode356\nsrc/pkg/exp/ssh/client.go:356: // ClientChan represents a single RFC 4254 channel that is multiplexed over a single\nOn 2011/10/18 19:43:51, rsc wrote:\n> s/ClientChan/A ClientChan/\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode396\nsrc/pkg/exp/ssh/client.go:396: // Pass an environment variable to a channel to be applied to any Shell or\nOn 2011/10/18 19:43:51, rsc wrote:\n> // Setenv sets an environment variable that will be applied to any\n> // command executed by Shell or Exec.\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode433\nsrc/pkg/exp/ssh/client.go:433: // Ptyreq requests a pty to be allocated on the remote side of this channel.\nOn 2011/10/18 19:43:51, rsc wrote:\n> s/Ptyreq/RequestPty/\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode451\nsrc/pkg/exp/ssh/client.go:451: // Execute command on the remote host. Exec returns a tupple of a WriteCloser,\nYup, total mouthful, your version is vastly improved.\n\nOn 2011/10/18 19:43:51, rsc wrote:\n> there aren't tuples in Go.  you can name the result variables,\n> even if you don't use the names in the function, as good documentation:\n> \n> // Exec runs cmd on the remote host.\n> // Typically, the remote server passes cmd to the shell for interpretation.\n> // Closing stdin will be observed by the remote process.\n> func (c *ClientChan) Exec(cmd string) (stdin io.WriteCloser, stdout\n> io.ReadCloser, stderr io.Reader, err os.Error) {\n> \n> it is unclear to me why you'd want to close stdout.  The remote process\n> cannot observe that, unless it gets a SIGPIPE trying to write to stdout.\n> And if stdout can be closed, why not stderr?\n\nstdin/out are independent data streams from ssh's point of view, you can pass a channelData message in either direction, and close that direction when done with a channelEOF message. Making stdin/out closeable models this.\n\nstderr isn't a channel, it's simulated by channelExtendedData messages, which pass raw strings (presumably line buffered). There is no way for the server to signal EOF for channelExtendedData.\n\n> It is possible that Exec should return (*Cmd, os.Error)\n> and Cmd can be\n> \n> type Cmd struct {\n>     Stdin io.WriteCloser\n>     Stdout io.Reader\n>     Stderr io.Reader\n> }\n\nThis is a great addition. My pipe dream is to be able to mix exec.Cmd's and ssh.Cmds so a Go process can deal with local and remote children as transparently as possible.\n\n> func (c *Cmd) Kill() os.Error\n> \n> if the SSH protocol provides a way to kill a running command.\n\nYou can encode signals to be delivered to the remote process, but I haven't got to that yet.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode468\nsrc/pkg/exp/ssh/client.go:468: // Execute the default shell for the remote user. Shell returns a tupple of a\nOn 2011/10/18 19:43:51, rsc wrote:\n> // Shell starts a login shell on the remote host.\n> // Closing stdin will be observed by the remote process.\n> func (c *ClientChan) Shell() (stdin io.WriterCloser, stdout, stderr io.Reader,\n> err os.Error)\n> \n> same comment about possibly wanting *Cmd here\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode514\nsrc/pkg/exp/ssh/client.go:514: // Represents the stdin stream to the remote peer.\nOn 2011/10/18 19:43:51, rsc wrote:\n> // A stdinWriter represents...\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode522\nsrc/pkg/exp/ssh/client.go:522: // Write writes data to stdin of the remote channel.\nOn 2011/10/18 19:43:51, rsc wrote:\n> // Write writes data to the remote channel's standard input.\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode549\nsrc/pkg/exp/ssh/client.go:549: // Represents the stdout stream from the remote peer.\nOn 2011/10/18 19:43:51, rsc wrote:\n> // A stdoutReader represents ...\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode558\nsrc/pkg/exp/ssh/client.go:558: // Read data from stdout on the remote channel.\nOn 2011/10/18 19:43:51, rsc wrote:\n> // Read reads data from the remote channel's standard output.\n\nDone.\n\nhttp://codereview.appspot.com/5162047/diff/40001/src/pkg/exp/ssh/client.go#newcode586\nsrc/pkg/exp/ssh/client.go:586: // Represents the stderr stream from the remote peer.\nOn 2011/10/18 19:43:51, rsc wrote:\n> // A stderrReader represents...\n\nDone.",
			"disapproval": false,
			"date": "2011-10-19 11:36:56.385135",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> Yes, there is no flow control on stderr/channelExtendedData. I could\n> make writes to that channel none blocking. I'll add a TODO\n\nThat would be a bad TODO, because it would cause data to be lost.\nI'd rather see a program hang than get half the standard error output.\nIt is worth thinking about whether you can change the API here\nto be closer to package exec, and then some of these considerations\njust go away, but not for this CL.\n\nWill submit later today.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-10-19 20:18:55.138707",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Mostly LGTM. I don't know if rsc want's another round.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go\nFile src/pkg/exp/ssh/client.go (right):\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode20\nsrc/pkg/exp/ssh/client.go:20: var clientVersion = []byte(\"SSH-2.0-Go\\r\\n\")\nThis could probably be merged into serverVersion and become just \"version\".\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode118\nsrc/pkg/exp/ssh/client.go:118: fmt.Errorf(\"ssh: unexpected key exchange algorithm %v\", kexAlgo)\nkexAlgo is just a string, so + can be used to concat the values here\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode174\nsrc/pkg/exp/ssh/client.go:174: func (c *ClientConn) sendUserAuthReq(method string) os.Error {\nIf not sure if this is correct for the \"none\" case. In that case, a password payload (with an empty string) will be sent, but I don't think that \"none\" should have any payload.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode255\nsrc/pkg/exp/ssh/client.go:255: return nil, os.NewError(msg.Message)\nIn these events, don't we need to tidy up the channel?\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode264\nsrc/pkg/exp/ssh/client.go:264: func (c *ClientConn) mainloop() {\nMaybe s/mainloop/mainLoop/ ?\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode503\nsrc/pkg/exp/ssh/client.go:503: c.chans[id] = nil, false\nshould use delete() now.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode518\nsrc/pkg/exp/ssh/client.go:518: packetWriter     // for sending channeDataMsg\ntypo: s/channe/channel/\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode591\nsrc/pkg/exp/ssh/client.go:591: // Read reads a line of data from the remote process's stderr.\nThe comment mentions a \"line\", but I don't see any reason why the data should be line based. Am I missing something?",
			"disapproval": false,
			"date": "2011-10-19 16:56:00.742684",
			"approval": true
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "LGTM modulo the comment edits below.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go\nFile src/pkg/exp/ssh/client.go (right):\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode438\nsrc/pkg/exp/ssh/client.go:438: // Closing *Cmd.Stdin will be observed by the remote process.\nd\n(move to Cmd)\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode457\nsrc/pkg/exp/ssh/client.go:457: // Closing *Cmd.Stdin will be observed by the remote process.\nd\n(move to Cmd)\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode484\nsrc/pkg/exp/ssh/client.go:484: for i := uint32(0); i < 2^31; i++ {\n2^31 == 29.  s/2^/1<</\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode506\nsrc/pkg/exp/ssh/client.go:506: // Cmd represents the file descriptors of a remote process.\n// A Cmd represents a connection to a remote command or shell.\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode508\nsrc/pkg/exp/ssh/client.go:508: Stdin  io.WriteCloser\n// Writes to Stdin are made available to the command's standard input.\n// Closing Stdin causes the command to observe an EOF on its standard input.\nStdin io.WriteCloser\n\n// Reads from Stdout consume the command's standard output.\n// There is a fixed amount of buffering of the command's standard output.\n// Failing to read from Stdout will eventually cause the command to block\n// when writing to its standard output.  Closing Stdout unblocks any\n// such writes and makes them return errors.\nStdout io.ReadCloser\n\n// Reads from Stderr consume the command's standard error.\n// The SSH protocol assumes it can always send standard error;\n// the command will never block writing to its standard error.\n// However, failure to read from Stderr will eventually cause the\n// SSH protocol to jam, so it is important to arrange for reading\n// from Stderr, even if by\n//    go io.Copy(ioutil.Discard, cmd.Stderr)\nStderr io.Reader\n\n\nMaybe the API should be different, but that's my understanding of\nhow the current code works.",
			"disapproval": false,
			"date": "2011-10-19 19:34:17.847182",
			"approval": true
		},
		{
			"sender": "n13m3y3r@gmail.com",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"agl@golang.org",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Thanks a lot for the work on this, Dave.\n\nI'll try to take some time to play around with the package while it's still in exp. For now, just a trivial I noticed en passant:\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go\nFile src/pkg/exp/ssh/client.go (right):\n\nhttp://codereview.appspot.com/5162047/diff/48001/src/pkg/exp/ssh/client.go#newcode383\nsrc/pkg/exp/ssh/client.go:383: func (c *ClientChan) Setenv(name, value string) os.Error {\nShould this be SetEnv?  Names in the os package in general are not a good example to replicate.",
			"disapproval": false,
			"date": "2011-10-19 20:06:44.746829",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "since it has the same meaning, please use Setenv.\n",
			"disapproval": false,
			"date": "2011-10-19 20:09:25.895256",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"agl@golang.org",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, agl@golang.org, n13m3y3r@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-10-19 20:13:12.679468",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"agl@golang.org",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hi Russ,\n\nWhat are the next steps here, would you like another round of reviews or are you happy to commit it ?\n\nCheers\n\nDave\n\nOn 2011/10/19 20:25:53, dfc wrote:\n> Agreed. Thank you for submitting this in it's current form, hopefully\n> others will be able to contribute to it now.\n> \n> On Thu, Oct 20, 2011 at 7:18 AM, Russ Cox <mailto:rsc@golang.org> wrote:\n> >> Yes, there is no flow control on stderr/channelExtendedData. I could\n> >> make writes to that channel none blocking. I'll add a TODO\n> >\n> > That would be a bad TODO, because it would cause data to be lost.\n> > I'd rather see a program hang than get half the standard error output.\n> > It is worth thinking about whether you can change the API here\n> > to be closer to package exec, and then some of these considerations\n> > just go away, but not for this CL.\n> >\n> > Will submit later today.\n> >\n> > Russ\n> >",
			"disapproval": false,
			"date": "2011-10-20 19:39:11.017627",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"dave@cheney.net",
				"rsc@golang.org",
				"agl@golang.org",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Many thanks to the reviewers for their time and comments.\n\nOn 2011/10/20 19:45:18, agl1 wrote:\n> *** Submitted as http://code.google.com/p/go/source/detail?r=e2a58806ccd6 ***\n> \n> exp/ssh: add experimental ssh client\n> \n> Requires CL 5285044\n> \n> client.go:\n> * add Dial, ClientConn, ClientChan, ClientConfig and Cmd.\n> \n> doc.go:\n> * add Client documentation.\n> \n> server.go:\n> * adjust for readVersion change.\n> \n> transport.go:\n> * return an os.Error not a bool from readVersion.\n> \n> R=rsc, agl, n13m3y3r\n> CC=golang-dev\n> http://codereview.appspot.com/5162047\n> \n> Committer: Adam Langley <mailto:agl@golang.org>",
			"disapproval": false,
			"date": "2011-10-20 20:03:36.861874",
			"approval": false
		}
	],
	"owner_email": "dave@cheney.net",
	"private": false,
	"base_url": "",
	"owner": "dfc",
	"subject": "code review 5162047: exp/ssh: add experimental ssh client",
	"created": "2011-10-02 07:42:54.395736",
	"patchsets": [
		1,
		2001,
		5001,
		8001,
		11001,
		14001,
		17001,
		19001,
		23001,
		24002,
		28001,
		31001,
		34001,
		37001,
		40001,
		48001,
		56001
	],
	"modified": "2011-10-20 20:08:50.326423",
	"closed": true,
	"issue": 5162047
}