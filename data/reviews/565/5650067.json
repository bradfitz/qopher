{
	"description": "go.crypto/ssh: add client support for OpenSSH certificates\nRefactor key parsing, marshaling, and serialization to be a bit more flexible",
	"cc": [
		"agl@golang.org",
		"dave@cheney.net",
		"djm@djm.net.au",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "agl@golang.org",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "If there is refactoring that you believe makes the code cleaner overall then I'd encourage you to do it. Although I do wonder why you opted to skip using marshal/unmarshal. They would need some extending, of course, but it appears that it would save you writing another (un)marshal function for the V01 certs.\n\nIn general, do enough people still use DSA with SSH to make it worthwhile? I feel that DSA is now, cryptographically, a patent-based anachronism.\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go\nFile ssh/openssh.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode12\nssh/openssh.go:12: // CertType defines the entity type an OpenSSH certificate is used to represent.\nIt seems that this file could have a more specific name. 'certs.go'?\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode41\nssh/openssh.go:41: Constraints             []tuple\nis this []tuple rather than map[string]string because we need to preserve order?\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode50\nssh/openssh.go:50: algo, in, ok := parseString(in)\nyou can just s/algo/_/ here and remove line 54.\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode77\nssh/openssh.go:77: case 1:\nUserCert?\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode79\nssh/openssh.go:79: case 2:\nHostCert?\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode82\nssh/openssh.go:82: panic(\"Unknown certificate type.\")\nreturn with ok=false?\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode91\nssh/openssh.go:91: vp, in, ok := parseLengthPrefixedNameList(in)\ns/vp/pubCert.ValidPrincipals/? (and remove the ':')\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode109\nssh/openssh.go:109: cons, in, ok := parseTupleList(in)\nsame here and below.",
			"disapproval": false,
			"date": "2012-02-13 15:57:00.362721",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"golang-dev@googlegroups.com",
				"agl@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com (cc: agl@golang.org, dave@cheney.net, golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://code.google.com/p/go.crypto",
			"disapproval": false,
			"date": "2012-02-12 18:08:37.354199",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"golang-dev@googlegroups.com",
				"agl@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com (cc: agl@golang.org, dave@cheney.net, golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-13 04:05:28.423632",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"golang-dev@googlegroups.com",
				"agl@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Please be as critical as you need with this CL.  I am still trying to fully grasp where this code is going.  Criticisms and praises welcome.\n\nFYI,\nInstead of extending the functionality of unmarshal, I wrote a temporary solution for parsing the certificate.  Initially I was planning to support rsa and dsa, but I removed those bits in favor of just rsa for now (hence the \"_ = algo\" line).  I mainly wanted to demonstrate what is needed to get this running.\n\nSome other parts that were added to get this working feel a bit hackish.  What are the plans for supporting more than just RSA keys throughout?\n\nWhat I was thinking I would like to see is general support for each type of key/cert with generic functions that handle determining what to do with each type individually.  There is some of that now (algoname, serializePublicKey, etc), but the coverage appears spotty.  For example, there is a parseRSA, but not a generic parseKey that strips off the algorithm type, matches that to the parseRSA function, and lets parseRSA handle the rest of the bytes.  As of now, parseRSA strips off the algorithm type, makes sure it is the right kind, and then proceeds.  I feel that by the time you get to parseRSA, you should already know you are dealing with an rsa key.\n\nI also have an additional file (agent.go) that adds basic client side ssh agent support to this package, but felt that should be left for another CL.  If you want to see it (as it makes use of some of the things I have added), just let me know where to put it.\n\nOn 2012/02/13 04:05:28, jmpittman wrote:\n> Hello mailto:golang-dev@googlegroups.com (cc: mailto:agl@golang.org, mailto:dave@cheney.net,\n> mailto:golang-dev@googlegroups.com),\n> \n> Please take another look.",
			"disapproval": false,
			"date": "2012-02-13 05:04:19.015239",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello agl@golang.org, dave@cheney.net (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-13 22:43:19.177167",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello agl@golang.org, dave@cheney.net (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-13 22:18:21.278733",
			"approval": false
		},
		{
			"sender": "djm@djm.net.au",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "A couple of initial comments before I dive in deeper.\n\nhttp://codereview.appspot.com/5650067/diff/11002/ssh/common.go\nFile ssh/common.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/11002/ssh/common.go#newcode150\nssh/common.go:150: case \"ssh-dss-cert-v00@openssh.com\", \"ssh-dss-cert-v01@openssh.com\":\nI wouldn't bother implementing the -v00 cert types, they are scheduled for deprecation (and indeed should have been deleted in OpenSSH by now)\n\nhttp://codereview.appspot.com/5650067/diff/11002/ssh/openssh.go\nFile ssh/openssh.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/11002/ssh/openssh.go#newcode58\nssh/openssh.go:58: return nil, false\nI don't think there is any hard requirement that RSA e is < 2^64. I've never seen a key use modulus > 65537 in the wild, but I don't think they are illegal.\n\nhttp://codereview.appspot.com/5650067/diff/11002/ssh/openssh.go#newcode211\nssh/openssh.go:211: func parseTupleList(in []byte) (out []tuple, rest []byte, ok bool) {\nFWIW I consider the extensions and critical options more like a map than a tuple. OpenSSH considers it an error for most name keys to appear more than once (e.g it will refuse a cert if source-address appears multiply, but will accept multiple \"permit-user-rc\").\n\nI'll update PROTOCOL.certkeys to mention that names should be unique in these fields.",
			"disapproval": false,
			"date": "2012-02-14 01:51:22.070611",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "For now, I skipped unmarshal/unmarshal since the approach marshal is going for leans toward specific message types.  A cert is also not a message, just another series of bytes embedded in a message.  There is also the parseRSA function for parsing an rsa public key.  A cert is basically a key with additional \"certificate\" like data tacked onto the end.  Unless I fabricate a byte to prepend to the byte stream of a certificate, unmarshal will expect something to identify it, but will have nothing useful.\n\n(FWIW, ssh agent support will be more friendly with the unmarshal/marshal functions as they are written now.)\n\nAs for DSA, I don't know how useful or useless it might be.  I just know that it is supposed to be available and specifically required by RFC 4253 6.6.\n\nssh-dss      REQUIRED    sign Raw DSS Key\nssh-rsa      RECOMMENDED sign Raw RSA Key\npgp-sign-rsa OPTIONAL    sign OpenPGP certificates (RSA key)\npgp-sign-dss OPTIONAL    sign OpenPGP certificates (DSS key)\n\nWith the latest editions of OpenSSH certificates, the entire support includes...\n\nssh-rsa-cert-v00@openssh.com\nssh-dss-cert-v00@openssh.com\nssh-rsa-cert-v01@openssh.com\nssh-dss-cert-v01@openssh.com\necdsa-sha2-nistp256-cert-v01@openssh.com\necdsa-sha2-nistp384-cert-v01@openssh.com\necdsa-sha2-nistp521-cert-v01@openssh.com\n\nFor some of the refactoring I was considering proposing, should it be included in this CL or wait for another?\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go\nFile ssh/openssh.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode12\nssh/openssh.go:12: // CertType defines the entity type an OpenSSH certificate is used to represent.\nOn 2012/02/13 15:57:00, agl1 wrote:\n> It seems that this file could have a more specific name. 'certs.go'?\n\nConsidering that ssh allows for OpenPGP certificates, I felt it proper to define this as OpenSSH since that was the goal of this file...  to add support for OpenSSH certificates.  However, certs.go is probably a fine name.  Will change this later.\n\nConsequently, I decided to remove the \"CertType\" type and just go with uint32 for these values.  I am not certain that it added much value to make it a separate type with only two simple options.\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode41\nssh/openssh.go:41: Constraints             []tuple\nOn 2012/02/13 15:57:00, agl1 wrote:\n> is this []tuple rather than map[string]string because we need to preserve order?\n\nYes.  Is there a better/preferred way of doing this without a []tuple?\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode50\nssh/openssh.go:50: algo, in, ok := parseString(in)\nOn 2012/02/13 15:57:00, agl1 wrote:\n> you can just s/algo/_/ here and remove line 54.\n\nYeah, forgot to remove this.  It was leftover when I was originally differentiating between rsa & dss/dsa.\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode77\nssh/openssh.go:77: case 1:\nOn 2012/02/13 15:57:00, agl1 wrote:\n> UserCert?\n\nReferenced from above.  I didn't like this little bit of code.  Changed.  PTAL.\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode79\nssh/openssh.go:79: case 2:\nOn 2012/02/13 15:57:00, agl1 wrote:\n> HostCert?\n\nsame\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode82\nssh/openssh.go:82: panic(\"Unknown certificate type.\")\nOn 2012/02/13 15:57:00, agl1 wrote:\n> return with ok=false?\n\nremoved\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode91\nssh/openssh.go:91: vp, in, ok := parseLengthPrefixedNameList(in)\nOn 2012/02/13 15:57:00, agl1 wrote:\n> s/vp/pubCert.ValidPrincipals/? (and remove the ':')\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/3006/ssh/openssh.go#newcode109\nssh/openssh.go:109: cons, in, ok := parseTupleList(in)\nOn 2012/02/13 15:57:00, agl1 wrote:\n> same here and below.\n\nDone.",
			"disapproval": false,
			"date": "2012-02-13 22:30:42.512010",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5650067/diff/11002/ssh/common.go\nFile ssh/common.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/11002/ssh/common.go#newcode150\nssh/common.go:150: case \"ssh-dss-cert-v00@openssh.com\", \"ssh-dss-cert-v01@openssh.com\":\nOn 2012/02/14 01:51:22, djm wrote:\n> I wouldn't bother implementing the -v00 cert types, they are scheduled for\n> deprecation (and indeed should have been deleted in OpenSSH by now)\n\nNoted.  Any plans for a v02 in the near future, or will v01 be around for a bit?  Is there potential harm in supporting v00 (i.e. security flaws)?  What are the chances v00 will still be in use in the world for a while after deprecation?\n\nhttp://codereview.appspot.com/5650067/diff/11002/ssh/openssh.go\nFile ssh/openssh.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/11002/ssh/openssh.go#newcode58\nssh/openssh.go:58: return nil, false\nOn 2012/02/14 01:51:22, djm wrote:\n> I don't think there is any hard requirement that RSA e is < 2^64. I've never\n> seen a key use modulus > 65537 in the wild, but I don't think they are illegal.\n\nInteresting point.  The rsa.PublicKey implementation in Go (http://weekly.golang.org/pkg/crypto/rsa/#PublicKey) defines E (public exponent) as an int while N (modulus) is defined as a *big.Int.  This is the primary reason for the Int64 reference.  If this were to be changed, it would initially need to be changed in the rsa package to define E as a big.Int.\n\nhttp://codereview.appspot.com/5650067/diff/11002/ssh/openssh.go#newcode211\nssh/openssh.go:211: func parseTupleList(in []byte) (out []tuple, rest []byte, ok bool) {\nOn 2012/02/14 01:51:22, djm wrote:\n> FWIW I consider the extensions and critical options more like a map than a\n> tuple. OpenSSH considers it an error for most name keys to appear more than once\n> (e.g it will refuse a cert if source-address appears multiply, but will accept\n> multiple \"permit-user-rc\").\n> \n> I'll update PROTOCOL.certkeys to mention that names should be unique in these\n> fields.\n\nSince the list of options appears small and finite, at one time I had thought to hard code them in as variables.  However, that doesn't do much for marshal/unmarshaling.  It would be more useful for construction and possibly some level of validation.\n\nDo you suggest producing an error during parsing if a name is found more than once?  Or only do that for critical options, but not extensions?  Should the validation/refusal be reserved for the server side or also be considered for the client side?\n\nAnother question popped up about the use of a []tuple vs map[string]string.  I had gone with tuple since I thought the order mattered.  Does the ordering matter within critical options or within extensions?  If a cert is unmarshaled and marshaled will a change in order to these options cause any problems?",
			"disapproval": false,
			"date": "2012-02-14 04:01:42.268861",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello agl@golang.org, dave@cheney.net (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-13 22:32:54.650803",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/02/13 22:43:19, jmpittman wrote:\n> Hello mailto:agl@golang.org, mailto:dave@cheney.net (cc: mailto:golang-dev@googlegroups.com),\n> \n> Please take another look.\n\nSorry, forgot to remove some references to the recently removed CertType.",
			"disapproval": false,
			"date": "2012-02-13 22:43:55.247969",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Feb 13, 2012 at 11:01 PM,  <jmpittman@google.com> wrote:\n> Noted. \u00a0Any plans for a v02 in the near future, or will v01 be around\n> for a bit? \u00a0Is there potential harm in supporting v00 (i.e. security\n> flaws)? \u00a0What are the chances v00 will still be in use in the world for\n> a while after deprecation?\n\n(p.s. I support dropping the -v00 code unless there's a clear use.\nLess code is good.)\n\n> Interesting point. \u00a0The rsa.PublicKey implementation in Go\n> (http://weekly.golang.org/pkg/crypto/rsa/#PublicKey) defines E (public\n> exponent) as an int while N (modulus) is defined as a *big.Int. \u00a0This is\n> the primary reason for the Int64 reference. \u00a0If this were to be changed,\n> it would initially need to be changed in the rsa package to define E as\n> a big.Int.\n\nLarge public modulus is `legal', but a complete waste of CPU time. I'm\nhappy to not support them. In [1] they found two large exponents out\nof 11.5M RSA keys and they suspect that they were bugs.\n\n[1] http://eprint.iacr.org/2012/064.pdf\n\n\n\nCheers\n\nAGL\n",
			"disapproval": false,
			"date": "2012-02-17 17:22:40.964988",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello agl@golang.org, dave@cheney.net, djm@djm.net.au (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-19 03:36:26.467567",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thank you for your continued work on this addition. My only other comment would be to suggest making the \"ssh-rsa-cert-v00@openssh.com\" and friends constants.\n\nhttp://codereview.appspot.com/5650067/diff/13002/ssh/certs.go\nFile ssh/certs.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/13002/ssh/certs.go#newcode18\nssh/certs.go:18: )\nDo these need to be typed constants? If these are constants defined in the OpenSSH cert format maybe a comment or a link to the spec would be useful. Otherwise maybe\n\n\nconst (\n        UserCert = iota\n        HostCert \n)\n\nhttp://codereview.appspot.com/5650067/diff/13002/ssh/certs.go#newcode348\nssh/certs.go:348: length := 4 /* uint32 length prefix */\n// uint32 length prefix\n\nhttp://codereview.appspot.com/5650067/diff/13002/ssh/certs.go#newcode393\nssh/certs.go:393: length := 4 /* uint32 length prefix */\n// uint32 length prefix\n\nhttp://codereview.appspot.com/5650067/diff/13002/ssh/certs.go#newcode408\nssh/certs.go:408: func parseSignature(in []byte) (out signature, rest []byte, ok bool) {\nI think the use of named return values, and using return out, nil, false is a bit confusing. I would suggest either dropping them, and declaring \n\nvar out signature\n\nat the top of the function, or making the function look more like parseTupleList above.",
			"disapproval": false,
			"date": "2012-02-19 07:02:31.572265",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/02/19 03:36:26, jmpittman wrote:\n> Hello mailto:agl@golang.org, mailto:dave@cheney.net, mailto:djm@djm.net.au (cc:\n> mailto:golang-dev@googlegroups.com),\n> \n> Please take another look.\n\nI added some of the refactoring I was considering.  For the moment, I want to leave in the v00 support.  v00 is currently the only type I have available to use.  Although, I am being led to believe that v01 certs are on my horizon within a few months.  At that point, I won't have a stake in using v00 any longer.\n\nI suppose, for the purpose of this implementation, I could remove them and just keep a patch around for myself to play with as needed.  If no one is in favor of keeping them around (and it sounds like that is the case), I'll do that on my next update to this CL after some more review.",
			"disapproval": false,
			"date": "2012-02-19 03:46:26.080132",
			"approval": false
		},
		{
			"sender": "djm@djm.net.au",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 3:01 PM,  <jmpittman@google.com> wrote:\n>\n> http://codereview.appspot.com/5650067/diff/11002/ssh/common.go\n> File ssh/common.go (right):\n>\n> http://codereview.appspot.com/5650067/diff/11002/ssh/common.go#newcode150\n> ssh/common.go:150: case \"ssh-dss-cert-v00@openssh.com\",\n> \"ssh-dss-cert-v01@openssh.com\":\n> On 2012/02/14 01:51:22, djm wrote:\n>>\n>> I wouldn't bother implementing the -v00 cert types, they are scheduled\n>\n> for\n>>\n>> deprecation (and indeed should have been deleted in OpenSSH by now)\n>\n>\n> Noted. \u00a0Any plans for a v02 in the near future, or will v01 be around\n> for a bit?\n\nI'd expect v01 to be around for a while; between critical options,\nextensions and the reserved field there is plenty of scope for adding\nmissing bits without needing a new format.\n\n>\u00a0Is there potential harm in supporting v00 (i.e. security\n> flaws)?\n\nIncreased attack surface is the main risk. Supporting both\nsimultaneously in OpenSSH already caused one bug.\n\n> What are the chances v00 will still be in use in the world for\n> a while after deprecation?\n\nThere might be one or two users, but OpenSSH has generated v01 certs\nby default for >18 months.\n\n>> I'll update PROTOCOL.certkeys to mention that names should be unique\n>\n> in these\n>>\n>> fields.\n>\n>\n> Since the list of options appears small and finite, at one time I had\n> thought to hard code them in as variables. \u00a0However, that doesn't do\n> much for marshal/unmarshaling. \u00a0It would be more useful for construction\n> and possibly some level of validation.\n>\n> Do you suggest producing an error during parsing if a name is found more\n> than once? \u00a0Or only do that for critical options, but not extensions?\n> Should the validation/refusal be reserved for the server side or also be\n> considered for the client side?\n\nYou should definitely ban duplication of critical options, as these\nare supposed to be restrictive and any ambiguity could lead to\nunintended access (consider conflicting \"source-address\"\nrestrictions).\n\nFor extensions, you could probably afford to be more liberal in\ninterpretation without nasty consequence. I think OpenSSH effectively\ntreats the options here as idempotent.\n\nThere are no client-side options at the moment, but IMO the same rules\nshould apply.\n\n> Another question popped up about the use of a []tuple vs\n> map[string]string. \u00a0I had gone with tuple since I thought the order\n> mattered. \u00a0Does the ordering matter within critical options or within\n> extensions? \u00a0If a cert is unmarshaled and marshaled will a change in\n> order to these options cause any problems?\n\nThe PROTOCOL.certkeys defines them as to occur in lexical order, but\nOpenSSH doesn't enforce this at the moment. I'd recommend that you\noutput them in order when you marshal, but I don't see much\nconsequence to being a bit liberal when unmarshalling.\n\n-d\n",
			"disapproval": false,
			"date": "2012-02-21 00:08:58.235594",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5650067/diff/21006/ssh/certs.go\nFile ssh/certs.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode46\nssh/certs.go:46: Key                     interface{} // rsa or dsa PublicKey\ninsert '*' before 'PublicKey'\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode63\nssh/certs.go:63: return nil, nil, false\nAll the return statements in this function (except the last) can simply be \"return\" if you use another name for |out|\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode72\nssh/certs.go:72: out.Key = *rsaPubKey\nI don't think you want to dereference here (or below for |dsaPubKey|)\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode144\nssh/certs.go:144: case rsa.PublicKey:\n*rsa.PublicKey (and on the other lines here)\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode149\nssh/certs.go:149: pubKey = marshalPubDSA(&k)\ndefault:\n  panic(\"ssh: unknown public key type in cert\")\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode182\nssh/certs.go:182: marshalSignature(r, cert.Signature)\nr = marshalSignature(r, cert.Signature)\nif len(r) > 0 {\n  panic(\"internal error\")\n}\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode189\nssh/certs.go:189: length += stringLength([]byte(name))\nlength += 4 /* length prefix */\nlength += len(name)\n\n(otherwise I fear lots of copying will happen.)\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode196\nssh/certs.go:196: nlBytes := to[:length]\nrather than introducing n1Bytes, can't you just say:\nto = marshalUint32(to, uint32(length-4)))\n\nand so on, finally returning to?\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode228\nssh/certs.go:228: length += stringLength([]byte(t.Name))\nI would inline stringLength again here.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode236\nssh/certs.go:236: tlBytes := to[:length]\nditto about using 'to'.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/keys.go\nFile ssh/keys.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/keys.go#newcode23\nssh/keys.go:23: return *key, rest, ok\ndon't dereference key (here and elsewhere).\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/keys.go#newcode29\nssh/keys.go:29: return *key, rest, ok\ndefault:\n  panic(...)",
			"disapproval": false,
			"date": "2012-02-21 23:08:02.017295",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> I'd expect v01 to be around for a while; between critical options,\n> extensions and the reserved field there is plenty of scope for adding\n> missing bits without needing a new format.\n\nGood to know.\n\n> Increased attack surface is the main risk. Supporting both\n> simultaneously in OpenSSH already caused one bug.\n\nFair enough.\n\n> There might be one or two users, but OpenSSH has generated v01 certs\n> by default for >18 months.\n\nI will go ahead and remove them from this CL, but keep a patch around for myself for the time being until I am switched over to v01 in my regular use.  If there are any reasons to add them back it will not take much.\n\n> You should definitely ban duplication of critical options, as these\n> are supposed to be restrictive and any ambiguity could lead to\n> unintended access (consider conflicting \"source-address\"\n> restrictions).\n> \n> For extensions, you could probably afford to be more liberal in\n> interpretation without nasty consequence. I think OpenSSH effectively\n> treats the options here as idempotent.\n> \n> There are no client-side options at the moment, but IMO the same rules\n> should apply.\n\n> The PROTOCOL.certkeys defines them as to occur in lexical order, but\n> OpenSSH doesn't enforce this at the moment. I'd recommend that you\n> output them in order when you marshal, but I don't see much\n> consequence to being a bit liberal when unmarshalling.\n> \n> -d\n\nWith respect to duplicate critical options, do you have a recommendation about whether to fail the deserialization process or to perform a separate validation after parsing is complete?  My first thought is that deserialization should be concerned only with validity of structure, not validity of options.  If it does not affect the client side at the moment, it sounds as though the server side should do separate validation.  Thoughts?\n\nSwitching from a tuple to a map[string]string might simplify some things.  However, a map would not allow for being liberal with multiple extensions using the same name.\n\nThe concern I had with using a map and handling ordering had to do with any comparison, validation, or hashing that might occur on the certificate.  For example, say a certificate is encountered with the options not in lexical order.  If I go the route of unmarshaling as options are encountered, but then I marshal in lexical order, will that cause any issues?  The original and new serialized forms as well as base64 encoded forms would not be the same.  If there are multiple extensions using the same name, they would be deduped by the map.  Upon re-serialization, the duplicates would be missing and the certificate length would be shorter.\n\nIf none of that actually matters in spec, in theory, or in practice, then switching to a map is relatively simple.",
			"disapproval": false,
			"date": "2012-02-21 04:07:36.078494",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello agl@golang.org, dave@cheney.net, djm@djm.net.au (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-20 05:13:14.083122",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello agl@golang.org, dave@cheney.net, djm@djm.net.au (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-21 18:53:22.946824",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5650067/diff/13002/ssh/certs.go\nFile ssh/certs.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/13002/ssh/certs.go#newcode18\nssh/certs.go:18: )\nOn 2012/02/19 07:02:31, dfc wrote:\n> Do these need to be typed constants? If these are constants defined in the\n> OpenSSH cert format maybe a comment or a link to the spec would be useful.\n> Otherwise maybe\n> \n> \n> const (\n>         UserCert = iota\n>         HostCert \n> )\n\nI am not certain they need to be typed here as a uint32.  When they are used in a certificate, used for comparison, or encoded for going over the wire, they need to be treated as a uint32.\n\nReworded for clarity and linked to the spec.\n\nhttp://codereview.appspot.com/5650067/diff/13002/ssh/certs.go#newcode348\nssh/certs.go:348: length := 4 /* uint32 length prefix */\nOn 2012/02/19 07:02:31, dfc wrote:\n> // uint32 length prefix\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/13002/ssh/certs.go#newcode393\nssh/certs.go:393: length := 4 /* uint32 length prefix */\nOn 2012/02/19 07:02:31, dfc wrote:\n> // uint32 length prefix\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/13002/ssh/certs.go#newcode408\nssh/certs.go:408: func parseSignature(in []byte) (out signature, rest []byte, ok bool) {\nOn 2012/02/19 07:02:31, dfc wrote:\n> I think the use of named return values, and using return out, nil, false is a\n> bit confusing. I would suggest either dropping them, and declaring \n> \n> var out signature\n> \n> at the top of the function, or making the function look more like parseTupleList\n> above.\n\nPTAL",
			"disapproval": false,
			"date": "2012-02-20 05:14:12.735822",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thanks! Had a few questions.  Comments in common.go.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go\nFile ssh/certs.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode46\nssh/certs.go:46: Key                     interface{} // rsa or dsa PublicKey\nOn 2012/02/21 23:08:02, agl1 wrote:\n> insert '*' before 'PublicKey'\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode63\nssh/certs.go:63: return nil, nil, false\nOn 2012/02/21 23:08:02, agl1 wrote:\n> All the return statements in this function (except the last) can simply be\n> \"return\" if you use another name for |out|\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode72\nssh/certs.go:72: out.Key = *rsaPubKey\nOn 2012/02/21 23:08:02, agl1 wrote:\n> I don't think you want to dereference here (or below for |dsaPubKey|)\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode144\nssh/certs.go:144: case rsa.PublicKey:\nOn 2012/02/21 23:08:02, agl1 wrote:\n> *rsa.PublicKey (and on the other lines here)\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode149\nssh/certs.go:149: pubKey = marshalPubDSA(&k)\nOn 2012/02/21 23:08:02, agl1 wrote:\n> default:\n>   panic(\"ssh: unknown public key type in cert\")\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode182\nssh/certs.go:182: marshalSignature(r, cert.Signature)\nOn 2012/02/21 23:08:02, agl1 wrote:\n> r = marshalSignature(r, cert.Signature)\n> if len(r) > 0 {\n>   panic(\"internal error\")\n> }\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode189\nssh/certs.go:189: length += stringLength([]byte(name))\nOn 2012/02/21 23:08:02, agl1 wrote:\n> length += 4 /* length prefix */\n> length += len(name)\n> \n> (otherwise I fear lots of copying will happen.)\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode196\nssh/certs.go:196: nlBytes := to[:length]\nOn 2012/02/21 23:08:02, agl1 wrote:\n> rather than introducing n1Bytes, can't you just say:\n> to = marshalUint32(to, uint32(length-4)))\n> \n> and so on, finally returning to?\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode228\nssh/certs.go:228: length += stringLength([]byte(t.Name))\nOn 2012/02/21 23:08:02, agl1 wrote:\n> I would inline stringLength again here.\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/certs.go#newcode236\nssh/certs.go:236: tlBytes := to[:length]\nOn 2012/02/21 23:08:02, agl1 wrote:\n> ditto about using 'to'.\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/common.go\nFile ssh/common.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/common.go#newcode172\nssh/common.go:172: case rsa.PublicKey:\nSince the parse and marshal functions as well as structs for keys and certs are passing around pointers, should this be case *rsa.PublicKey (and so on...)?  This is the reason why I was dereferencing in those other places.  A *rsa.PublicKey was causing a panic since it expects an rsa.PublicKey.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/common.go#newcode192\nssh/common.go:192: case rsa.PublicKey:\nDitto from 172.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/keys.go\nFile ssh/keys.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/keys.go#newcode23\nssh/keys.go:23: return *key, rest, ok\nOn 2012/02/21 23:08:02, agl1 wrote:\n> don't dereference key (here and elsewhere).\n\nDone.\n\nhttp://codereview.appspot.com/5650067/diff/21006/ssh/keys.go#newcode29\nssh/keys.go:29: return *key, rest, ok\nOn 2012/02/21 23:08:02, agl1 wrote:\n> default:\n>   panic(...)\n\nDone.",
			"disapproval": false,
			"date": "2012-02-22 18:28:00.140332",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello agl@golang.org, dave@cheney.net, djm@djm.net.au (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-22 18:26:45.098830",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I've done http://codereview.appspot.com/5686067/ to address the *rsa.PublicKey stuff. If you can respin the patch in light of that and confirm that everything is working then I think this is good to land.\n\nhttp://codereview.appspot.com/5650067/diff/21007/ssh/certs.go\nFile ssh/certs.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/21007/ssh/certs.go#newcode185\nssh/certs.go:185: marshalSignature(r, cert.Signature)\nthere's no \"r = \" on this line so I think the next line will always panic. (See comment on this line in the previous patch set.)",
			"disapproval": false,
			"date": "2012-02-23 15:43:30.378220",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5650067/diff/21007/ssh/certs.go\nFile ssh/certs.go (right):\n\nhttp://codereview.appspot.com/5650067/diff/21007/ssh/certs.go#newcode185\nssh/certs.go:185: marshalSignature(r, cert.Signature)\nOn 2012/02/23 15:43:30, agl1 wrote:\n> there's no \"r = \" on this line so I think the next line will always panic. (See\n> comment on this line in the previous patch set.)\n\nDone.",
			"disapproval": false,
			"date": "2012-02-23 16:10:22.211612",
			"approval": false
		},
		{
			"sender": "jmpittman@google.com",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello agl@golang.org, dave@cheney.net, djm@djm.net.au (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-23 16:08:20.733317",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"jmpittman@google.com",
				"agl@golang.org",
				"dave@cheney.net",
				"djm@djm.net.au",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=82579bac06b4&repo=crypto ***\n\ngo.crypto/ssh: add client support for OpenSSH certificates\nRefactor key parsing, marshaling, and serialization to be a bit more flexible\n\nR=agl, dave, djm\nCC=golang-dev\nhttp://codereview.appspot.com/5650067\n\nCommitter: Adam Langley <agl@golang.org>",
			"disapproval": false,
			"date": "2012-02-24 17:52:12.781619",
			"approval": false
		}
	],
	"owner_email": "jmpittman@google.com",
	"private": false,
	"base_url": "",
	"owner": "jmpittman",
	"subject": "code review 5650067: go.crypto/ssh: add client support for OpenSSH certificates",
	"created": "2012-02-12 18:03:55.893030",
	"patchsets": [
		1,
		2001,
		3003,
		3006,
		6001,
		10001,
		11002,
		13002,
		19001,
		21006,
		21007,
		28001
	],
	"modified": "2012-03-03 16:19:39.220346",
	"closed": true,
	"issue": 5650067
}