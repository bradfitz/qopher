{
	"description": "cmd/go: allow go get with arbitrary URLs\n\nThis CL permits using arbitrary, non-VCS-qualified URLs as\naliases for fully VCS-qualified and/or well-known code hosting\nsites.\n\nExample 1) A VCS-qualified URL can now be shorter.\n\nBefore:\n$ go get camlistore.org/r/p/camlistore.git/pkg/blobref\nAfter:\n$ go get camlistore.org/pkg/blobref\n\nExample 2) A custom domain can be used as the import,\nreferencing a well-known code hosting site.\n\nBefore:\n$ go get github.com/bradfitz/sonden\nAfter:\n$ go get bradfitz.com/pkg/sonden\n\nThe mechanism used is a <meta> tag in the HTML document\nretrieved from fetching:\n\n    https://<import>?go-get=1  (preferred)\n    http://<import>?go-get=1   (fallback)\n\nThe meta tag should look like:\n\n<meta name=\"go-import\" content=\"import-alias-prefix vcs full-repo-root\">\n\nThe full-repo-root must be a full URL root to a repository containing\na scheme and *not* containing a \".vcs\" qualifier.\n\nThe vcs is one of \"git\", \"hg\", \"svn\", etc.\n\nThe import-alias-prefix must be a prefix or exact match of the\npackage being fetched with \"go get\".\n\nIf there are multiple meta tags, only the one with a prefix\nmatching the import path is used. It is an error if multiple\ngo-import values match the import prefix.\n\nIf the import-alias-prefix is not an exact match for the import,\nanother HTTP fetch is performed, at the declared root (which does\n*not* need to be the domain's root).\n\nFor example, assuming that \"camlistore.org/pkg/blobref\" declares\nin its HTML head:\n\n<meta name=\"go-import\" content=\"camlistore.org git https://camlistore.org/r/p/camlistore\" />\n\n... then:\n\n$ go get camlistore.org/pkg/blobref\n\n... looks at the following URLs:\n\n   https://camlistore.org/pkg/blobref?go-get=1\n   http://camlistore.org/pkg/blobref?go-get=1\n   https://camlistore.org/?go-get=1\n   http://camlistore.org/?go-get=1\n\nUltimately it finds, at the root (camlistore.org/), the same go-import:\n\n<meta name=\"go-import\" content=\"camlistore.org git https://camlistore.org/r/p/camlistore\" />\n\n... and proceeds to trust it, checking out git //camlistore.org/r/p/camlistore at\nthe import path of \"camlistore.org\" on disk.\n\nFixes issue 3099",
	"cc": [
		"r@google.com",
		"rsc@golang.org",
		"gary.burd@gmail.com",
		"eikeon@eikeon.com",
		"untheoretic@googlemail.com",
		"n13m3y3r@gmail.com",
		"rsc@google.com",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"rogpeppe@gmail.com"
	],
	"messages": [
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "i like the general redirect idea but not so much\nthe implementation.  i'll sleep on it.\n",
			"disapproval": false,
			"date": "2012-02-14 05:53:36.223242",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2012-02-14 05:34:30.766676",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "i appreciate the end but not the means.\n\n-rob\n\n",
			"disapproval": false,
			"date": "2012-02-14 05:44:08.330228",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 4:46 PM, Brad Fitzpatrick <bradfitz@golang.org> wrote:\n\n> because it doesn't have .git in it.\n\nI thought the go tool did some probing to work out the VCS type if it\ncouldn't deduce it from the URL.\n\n\nDave.\n",
			"disapproval": false,
			"date": "2012-02-14 05:50:56.077866",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 4:50 PM, David Symonds <dsymonds@golang.org> wrote:\n\n> On Tue, Feb 14, 2012 at 4:46 PM, Brad Fitzpatrick <bradfitz@golang.org>\n> wrote:\n>\n> > because it doesn't have .git in it.\n>\n> I thought the go tool did some probing to work out the VCS type if it\n> couldn't deduce it from the URL.\n\n\nnot the current one.  did the old one?\n\nthe current one requires .git, .hg, .svn immediately in the URL, and then\nthe only probing it does is which sub-protocol of the git, hg, svn to use\n(http, https, native)\n",
			"disapproval": false,
			"date": "2012-02-14 05:52:29.361872",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I'm not a fan. It's adding more magic to something that is already\nfairly magical.\n\n\nDave.\n",
			"disapproval": false,
			"date": "2012-02-14 05:36:56.046760",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I'm not a fan of,\n\n1) ugly import paths\n2) making github, bitbucket et al 1st class while relegating people running\ntheir own servers to crappy import paths\n\nOn Tue, Feb 14, 2012 at 4:36 PM, David Symonds <dsymonds@golang.org> wrote:\n\n> I'm not a fan. It's adding more magic to something that is already\n> fairly magical.\n>\n>\n> Dave.\n>\n",
			"disapproval": false,
			"date": "2012-02-14 05:40:58.729085",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 00:50, David Symonds <dsymonds@golang.org> wrote:\n> I thought the go tool did some probing to work out the VCS type if it\n> couldn't deduce it from the URL.\n\nan early draft tried every possible vcs at every possible element\nalong the path, but that was rejected as expensive\nand error prone.\n",
			"disapproval": false,
			"date": "2012-02-14 05:52:21.502491",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 4:44 PM, David Symonds <dsymonds@golang.org> wrote:\n\n> Can't you set up a symlink or something on the server-side so that\n> camlistore.org/testlib looks like a git repo and thus works with the\n> go tool?\n>\n\nno\n\nbecause it doesn't have .git in it.\n\nThe shortest I could make it is:\n\ncamlistore.org/x.git/testlib\n\nwhich is still gross.\n",
			"disapproval": false,
			"date": "2012-02-14 05:46:27.172343",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Can't you set up a symlink or something on the server-side so that\ncamlistore.org/testlib looks like a git repo and thus works with the\ngo tool?\n\n\nDave.\n",
			"disapproval": false,
			"date": "2012-02-14 05:44:24.853144",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Cool. I'm not wed to specific implementations.\n\nOn Tue, Feb 14, 2012 at 4:53 PM, Russ Cox <rsc@golang.org> wrote:\n\n> i like the general redirect idea but not so much\n> the implementation.  i'll sleep on it.\n>\n",
			"disapproval": false,
			"date": "2012-02-14 05:58:03.867475",
			"approval": false
		},
		{
			"sender": "gary.burd@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Suggestion:\n\nIf the URL is not recognized, then send a HEAD request for the URL.  If the \nresponse is redirect, then use the redirect location to find the repository \nusing the usual rules.\n",
			"disapproval": false,
			"date": "2012-02-14 06:21:49.067739",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 01:21, Gary Burd <gary.burd@gmail.com> wrote:\n> If the URL is not recognized, then send a HEAD request for the URL. \u00a0If the\n> response is redirect, then use the redirect location to find the repository\n> using the usual rules.\n\nhow does that help you if you have an\nimport path that turns out to be a subdirectory?\ndo you have to redirect the entire tree to\nparallel paths?  is that easy on most web servers?\n",
			"disapproval": false,
			"date": "2012-02-14 06:24:40.320509",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 14:25, Gary Burd <gary.burd@gmail.com> wrote:\n> Amazon S3 does not have the feature. \u00a0There's no way to specify redirect\n> rules or control the response status code for an object.\n\nHow many people run web sites directly out of S3\nand would want to use those domain names as import paths?\nA redirect is a pretty fundamental concept for a web site.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-14 19:29:44.284197",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 5:21 PM, Gary Burd <gary.burd@gmail.com> wrote:\n\n> Suggestion:\n>\n> If the URL is not recognized, then send a HEAD request for the URL.  If\n> the response is redirect, then use the redirect location to find the\n> repository using the usual rules.\n>\n\nThat does mean that domain.org/PKGNAME must exist, but that's probably a\ngood thing.\n\nIf we did that, we'd want to send a certain Accept header from the go tool,\nso domain.org/PKGNAME can vary its redirect for humans vs. the tool.\n (redirecting to a source browser / info page, instead of a raw git URL).\n\nIt is harder for most people to configure redirects than upload files,\nthough.  Especially for something like HEAD-vs-GET redirects.\n",
			"disapproval": false,
			"date": "2012-02-14 06:25:54.152131",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 5:30 PM, Russ Cox <rsc@golang.org> wrote:\n\n> On Tue, Feb 14, 2012 at 01:26, David Symonds <dsymonds@golang.org> wrote:\n>> I know it's easy for Apache, and it's easy enough to do with a Go web server.\n>\n> I care a lot more about people running non-programmable web servers.\n> What is the .htaccess line? \u00a0Is it one line?\n\nAdvanced .htaccess configuration tends to vary between servers, but at\nleast for Apache it's easy:\n  RedirectMatch 301 /testlib/(.*) /ugly/path/testlib.git/$1\n\n\nDave.\n",
			"disapproval": false,
			"date": "2012-02-14 06:39:17.953041",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I think it is important that this work across servers.\nI like the idea that you can delegate your own import path space\nto hosting services, so that you are not tied to physical repo\nlocation or choice of version control system.\n\nI want to preserve the current property that an import path is\na URL you can load in a browser.  That property is not actually\ntrue all the time even now (I have feature requests in at\nGoogle Code, GitHub, and Bitbucket), so ideally whatever fix\nwe come up with would make it true more of the time, not less.\n\nI also want it to be easy/trivial for people to set up.  You\nshouldn't have to write your own web server (not that there's\nanything wrong with that) to set up a delegation.\n\nAll those properties suggest that something like Gary proposed\nis a better choice than .well-known.  The Accept header is\nprobably overkill; Gary says it is hard to handle, and I will\nadd that it is hard to test using a browser.\n\nMaybe a query parameter, like http://importpath?go-get-package=1.\nThat can be handled in Apache with\n\nRewriteEngine On\nRewriteCond %{QUERY_STRING} ^go-get-vcs=1$\nRewriteRule ^/my/package/dir$ https://github.com/me/package/dir [R=302,L]\n\nIf we do this, we should change the canonical import paths for\nthe subrepositories to be golang.org/crypto, golang.org/net,\nand so on.\n\nThese redirects would be a little restricted in their form:\na redirect for a specific import path would have to go to\na known hosting import path with a location within the repo\nthat was already contained in the original URL.  For example,\nthe fact that you can't do a checkout of just a subdirectory\nfrom git or hg means that swtch.com/csearch cannot delegate\nto code.google.com/p/codesearch/cmd/csearch, because\nthere would be nowhere to write the cmd directory.\nHere the path within the repo is cmd/csearch, and that path\nmust appear in the original for this to be well-defined.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-14 16:53:29.259050",
			"approval": false
		},
		{
			"sender": "gary.burd@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> The Accept header is probably overkill; Gary says it is hard to handle,\n\nThe Accept header configuration is similar to your query string \nconfiguration. Conditional redirects are more complex than unconditional \nredirects on Apache because conditional redirects require some knowledge of \nmod_rewrite.\n",
			"disapproval": false,
			"date": "2012-02-14 17:58:54.246369",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 15:58, Gary Burd <gary.burd@gmail.com> wrote:\n>>\u00a0The Accept header is\u00a0probably overkill; Gary says it is hard to handle,\n>\n> The Accept header configuration is similar to your query string\n> configuration.\u00a0Conditional\u00a0redirects are more complex than unconditional\n> redirects on Apache because\u00a0conditional\u00a0redirects require some\u00a0knowledge\u00a0of\n> mod_rewrite.\n\nIndeed it is similar for Apache, but it'd be nice to be able to easily\nemulate the behavior of go get from a browser for testing and\nintrospection purposes, and making it unconditional is not an option\nif we want to be able to send people and go get to different places\n(doc vs. repo).\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I'm not absolutely sure of anything.\n",
			"disapproval": false,
			"date": "2012-02-14 18:04:56.270121",
			"approval": false
		},
		{
			"sender": "gary.burd@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Amazon S3 does not have the feature.  There's no way to specify redirect \nrules or control the response status code for an object. \n",
			"disapproval": false,
			"date": "2012-02-14 19:25:14.506284",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 5:24 PM, Russ Cox <rsc@golang.org> wrote:\n\n> On Tue, Feb 14, 2012 at 01:21, Gary Burd <gary.burd@gmail.com> wrote:\n>> If the URL is not recognized, then send a HEAD request for the URL. \u00a0If the\n>> response is redirect, then use the redirect location to find the repository\n>> using the usual rules.\n>\n> how does that help you if you have an\n> import path that turns out to be a subdirectory?\n> do you have to redirect the entire tree to\n> parallel paths? \u00a0is that easy on most web servers?\n\nI know it's easy for Apache, and it's easy enough to do with a Go web server.\n\n\nDave.\n",
			"disapproval": false,
			"date": "2012-02-14 06:26:54.521914",
			"approval": false
		},
		{
			"sender": "gary.burd@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "A problem with redirects is that sites hosted on Amazon S3 and similar \nservices cannot use redirects.\n\nHere are some other suggestions:\n\n- Redirect using regexp and expand template pairs found in a /.well-known \nfile.\n\n- If the URL is not understood, then fetch the resource at the URL and look \nan alternate location specified in a <link rel=\"alternate\"> element.  This \nrequires a one to one mapping between documents on the site and packages in \nthe repository. \n\n",
			"disapproval": false,
			"date": "2012-02-14 18:29:22.672741",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 01:26, David Symonds <dsymonds@golang.org> wrote:\n> I know it's easy for Apache, and it's easy enough to do with a Go web server.\n\nI care a lot more about people running non-programmable web servers.\nWhat is the .htaccess line?  Is it one line?\n",
			"disapproval": false,
			"date": "2012-02-14 06:30:00.375444",
			"approval": false
		},
		{
			"sender": "gary.burd@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "The entire tree should be redirected to parallel paths.  This is easy on \nmany web servers.",
			"disapproval": false,
			"date": "2012-02-14 06:30:54.925240",
			"approval": false
		},
		{
			"sender": "gary.burd@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> How many people run web sites directly out of S3\n\nAmazon added the features to run a site out of S3 one year ago \n(http://www.allthingsdistributed.com/2011/02/website_amazon_s3.html). \nGithub supported static sites before that.\n\nI don't know how many people are using static sites, but the popularity \nseems to be increasing based on discussions at news.ycombinator.com \n(http://www.google.com/search?q=jekyll+site:news.ycombinator.com).\n\nI host my site on S3. Werner Vogels' site linked above is also hosted on \nS3. \n",
			"disapproval": false,
			"date": "2012-02-14 19:45:44.447376",
			"approval": false
		},
		{
			"sender": "gary.burd@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> we'd want to send a certain Accept header from the go tool, \n> so domain.org/PKGNAME can vary its redirect for humans \n> vs. the tool\n\nThis is where my suggestion runs into some trouble.  Apache supports \nconditional redirects based on the Accept header, but the server \nconfiguration is a big step up in complexity from the unconditional \nredirect. \n\n>  Especially for something like HEAD-vs-GET redirects.\n\nI am not suggesting that the server redirect differently for HEAD and GET \nrequests.  Because the go tool does not care about the response body in \nthis scenario, the tool can send a HEAD instead of a GET.\n",
			"disapproval": false,
			"date": "2012-02-14 07:43:08.043529",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> RewriteEngine On\n> RewriteCond %{QUERY_STRING} ^go-get-vcs=1$\n> RewriteRule ^/my/package/dir$ https://github.com/me/package/dir [R=302,L]\n\nThe ability to send people and go get to different locations would be\ngreat indeed.\n\n> If we do this, we should change the canonical import paths for\n> the subrepositories to be golang.org/crypto, golang.org/net,\n> and so on.\n\nOr golang.org/pkg/net. Either that, or change godoc so it serves\ndocumentation at /<pkg>.\n\n> that was already contained in the original URL. \u00a0For example,\n> the fact that you can't do a checkout of just a subdirectory\n> from git or hg means that swtch.com/csearch cannot delegate\n> to code.google.com/p/codesearch/cmd/csearch, because\n> there would be nowhere to write the cmd directory.\n\nThis sounds like a good idea anyway, even without considering the\ntechnical limitation.\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I'm not absolutely sure of anything.\n",
			"disapproval": false,
			"date": "2012-02-14 17:36:55.168331",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 12:58, Gary Burd <gary.burd@gmail.com> wrote:\n> The Accept header configuration is similar to your query string\n> configuration.\u00a0Conditional\u00a0redirects are more complex than unconditional\n> redirects on Apache because\u00a0conditional\u00a0redirects require some\u00a0knowledge\u00a0of\n> mod_rewrite.\n\nI see.  That's fine, but it still doesn't address testing.\nI want to be able to test in a browser.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-14 18:07:46.811737",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 13:29, Gary Burd <gary.burd@gmail.com> wrote:\n> A problem with redirects is that sites hosted on Amazon S3 and similar\n> services cannot use redirects.\n\nWhy not?\n",
			"disapproval": false,
			"date": "2012-02-14 18:49:34.582083",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Okay, let's suppose we're not going to use the redirect.  It has this S3\nproblem but also has the implicit constraints I mentioned earlier.\n\nWhat if instead we said that you fetch the page at that URL and look\nfor a <meta> tag?\n\n<meta name=\"go-import\" content=\"swtch.com/codesearch hg\nhttps://code.google.com/p/codesearch\">\n\nThe three space-separated fields are import path prefix, vcs, repo root\ncorresponding to that import path prefix.  There can be more than one\nmeta tag, but if we just fetched the HTML for x.com/y/z then we're only\ninterested in the tag with a prefix that is a prefix of x.com/y/z.\n\nIn the most trivial case, you can write a list of all your repositories and\nput it in a global HTML template or in the 404 page.  You don't have to\ngenerate a different line for each URL you serve (like you'd have to\ngenerate a different redirect for each URL), it works with static content\nservers, and it is still trivially testable in a browser.  In fact it encourages\npeople to make their import paths work in a browser.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-14 20:01:58.787220",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 15:39, Gustavo Niemeyer <gustavo@niemeyer.net> wrote:\n> That looks nice, but can we please introduce the aspect of \"go get\"\n> using a query argument?\n\nok\n",
			"disapproval": false,
			"date": "2012-02-14 20:41:40.257348",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Feb 14, 2012 at 18:01, Russ Cox <rsc@golang.org> wrote:\n> What if instead we said that you fetch the page at that URL and look\n> for a <meta> tag?\n>\n> <meta name=\"go-import\" content=\"swtch.com/codesearch hg\n> https://code.google.com/p/codesearch\">\n\nThat looks nice, but can we please introduce the aspect of \"go get\"\nusing a query argument? Without something like that, we can't\ndistinguish who's being served at the server side, which restricts\npossibilities like redirecting people to an external documentation\nsite like Gary's gopkgdoc, for example, or even generating the page\nfor go get dynamically without interfering with the normal site\ncontent.\n\n> In the most trivial case, you can write a list of all your repositories and\n> put it in a global HTML template or in the 404 page. \u00a0You don't have to\n\nImplementing this with Apache is still no harder than using a\nredirect. It may glob a prefix and serve a static page for everything\nunder it, assuming one doesn't want to render the data as part of the\nnormal site.\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I'm not absolutely sure of anything.\n",
			"disapproval": false,
			"date": "2012-02-14 20:39:39.699903",
			"approval": false
		},
		{
			"sender": "eikeon@eikeon.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "\nOn Feb 14, 2012, at 3:01 PM, Russ Cox wrote:\n\n> What if instead we said that you fetch the page at that URL and look\n> for a <meta> tag?\n\nNice. +1 here.\n\nWould the <meta> tag be optional for those wanting to define a short package url and those wanting to be explicit with the current behavior remaining when no <meta> tag is found?\n\n\n\n\n",
			"disapproval": false,
			"date": "2012-02-14 21:05:13.012467",
			"approval": false
		},
		{
			"sender": "untheoretic@googlemail.com",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"gustavo@niemeyer.net",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/02/14 20:01:58, rsc wrote:\n> Okay, let's suppose we're not going to use the redirect.  It has this S3\n> problem but also has the implicit constraints I mentioned earlier.\n> \n> What if instead we said that you fetch the page at that URL and look\n> for a <meta> tag?\n\nIsn't this worse than the original bradftz's json based method?",
			"disapproval": false,
			"date": "2012-02-16 06:47:25.030803",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Recognized paths (github, bitbucket, things with .git in the\nimport path) would not follow this process.\n",
			"disapproval": false,
			"date": "2012-02-14 21:28:24.904908",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Feb 16, 2012 at 01:47,  <untheoretic@googlemail.com> wrote:\n> Isn't this worse than the original bradftz's json based method?\n\nNo.\n",
			"disapproval": false,
			"date": "2012-02-16 19:27:18.912029",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Feb 13, 2012 at 9:34 PM, <bradfitz@golang.org> wrote:\n\n> Reviewers: golang-dev_googlegroups.com,\n>\n> Message:\n> Hello golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n>\n> I'd like you to review this change to\n> https://go.googlecode.com/hg/\n>\n>\n> Description:\n> cmd/go: allow short custom domain imports\n>\n> For discussion.\n>\n> With this CL, I can now type:\n>\n> $ go get camlistore.org/testlib\n>\n> Instead of:\n>\n> $ go get camlistore.org/r/p/camlistore.**git/testlib<http://camlistore.org/r/p/camlistore.git/testlib>\n>\n> ... which is an ugly import path.\n>\n\nI've deleted testlib and testlib2 from the camlistore.org repo.\n\nTo test this CL, try instead:\n\n$ go get camlistore.org/pkg/blobref\n$ go get camlistore.org/pkg/jsonsign\n\netc\n",
			"disapproval": false,
			"date": "2012-02-21 09:59:53.356941",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Are you planning to update this CL to implement the scheme we converged on?\nI am not a fan of /.well-known because, among other things, it requires control\nof the root directory of the web server.\n",
			"disapproval": false,
			"date": "2012-02-21 19:09:01.494241",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Feb 22, 2012 at 6:09 AM, Russ Cox <rsc@golang.org> wrote:\n\n> Are you planning to update this CL to implement the scheme we converged on?\n>\n\nSure.  I didn't know we'd converged.\n\nI've created http://code.google.com/p/go/issues/detail?id=3099 ... please\nupdate that if I missed any design details.\n",
			"disapproval": false,
			"date": "2012-02-21 22:03:35.415156",
			"approval": false
		},
		{
			"sender": "n13m3y3r@gmail.com",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"gustavo@niemeyer.net",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Very nice, thanks Brad. A few comments:\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/http.go\nFile src/cmd/go/http.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/http.go#newcode82\nsrc/cmd/go/http.go:82: // serve a meta import in their 404 page. Be stricter here?\nAs long as the page contains the metadata, I don't see any problem in taking it as a valid response. That said, the logic above seems a bit problematic. Isn't it ignoring non-200 responses on the https side entirely?\n\nMaybe return both bodies, and let the call site decide which one to use based on the content?\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go\nFile src/cmd/go/vcs.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode285\nsrc/cmd/go/vcs.go:285: // (thus root is a prefix of importPath)\ns/importPath/the import path/?\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode301\nsrc/cmd/go/vcs.go:301: // repoRootForImportPathStatic attempts to map importPath to a\nOn the nitpicky side, these names seem to be getting a bit too long. Names like findRepoRoot, staticRepoRoot and customRepoRoot might not be too bad.\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode370\nsrc/cmd/go/vcs.go:370: func repoRootForImportCustom(importPath string) (*repoRoot, error) {\nA quick comment above this function regarding what a custom import is would be nice.\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode422\nsrc/cmd/go/vcs.go:422: // Try again, with the \".vcs\" suffix.\nIs this necessary? If the static import path needs the \".vcs\", the import metadata in the page could easily provide it.\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode481\nsrc/cmd/go/vcs.go:481: if !ok || !strings.EqualFold(e.Name.Local, \"meta\") {\nShouldn't this be checking for \"go-import\" in the name attr too?",
			"disapproval": false,
			"date": "2012-02-23 13:40:35.054171",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"gustavo@niemeyer.net",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, r@google.com, rsc@golang.org, gary.burd@gmail.com, gustavo@niemeyer.net, eikeon@eikeon.com, untheoretic@googlemail.com, n13m3y3r@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-23 22:29:02.779392",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Feb 23, 2012 at 02:49, Brad Fitzpatrick <bradfitz@golang.org> wrote:\n> If the import-alias-prefix is not an exact match for the import,\n> another HTTP fetch is performed, at the declared root.\n\nCan we remove this?  I'd strongly prefer not to make the root\nspecial, so that we are not creating functionality only usable\nby people who have control over their domain's root.\n\nThe only advantage I see to it is that you don't have to\nmake a working URL corresponding to the import path,\nbut that's not an advantage for potential users.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-23 17:49:32.101237",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"gustavo@niemeyer.net",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, dsymonds@golang.org, r@google.com, rsc@golang.org, gary.burd@gmail.com, gustavo@niemeyer.net, eikeon@eikeon.com, untheoretic@googlemail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-23 07:48:57.454506",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Feb 23, 2012 at 14:39, Brad Fitzpatrick <bradfitz@golang.org> wrote:\n> No, I don't think so. \u00a0See the big comment in the code about why it's\n> necessary.\n\nSorry, I missed that \"declared root\" != \"domain root\".\nNo objection there.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-23 19:43:20.786818",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Missing from this email is the new CL description:\n\ncmd/go: allow go get with arbitrary URLs\n\nThis CL permits using arbitrary, non-VCS-qualified URLs as\naliases for fully VCS-qualified and/or well-known code hosting\nsites.\n\nExample 1) A VCS-qualified URL can now be shorter.\n\nBefore:\n$ go get camlistore.org/r/p/camlistore.git/pkg/camlistore\nAfter:\n$ go get camlistore.org/pkg/blobref\n\nExample 2) A custom domain can be used as the import,\nreferencing a well-known code hosting site.\n\nBefore:\n$ go get github.com/bradfitz/sonden\nAfter:\n$ go get bradfitz.com/pkg/sonden\n\nThe mechanism used is a <meta> tag in the HTML document\nretrieved from fetching:\n\n    https://<import>?go-get=1  (preferred)\n    http://<import>?go-get=1   (fallback)\n\nThe meta tag should look like:\n\n<meta name=\"go-import\" content=\"import-alias-prefix vcs full-repo-root\">\n\nThe full-repo-root must be a fully-qualified or well-known code\nhosting site.\n\nThe vcs is one of \"git\", \"hg\", \"svn\", etc.\n\nThe import-alias-prefix must be a prefix or exact match of the\npackage being fetched with \"go get\".\n\nIf there are multiple meta tags, only the prefix one is used. It is\nan error if multiple go-import values match the prefix.\n\nIf the import-alias-prefix is not an exact match for the import,\nanother HTTP fetch is performed, at the declared root.\n\nFor example,\n\n$ go get camlistore.org/pkg/blobref\n\nLooks at the following URLs:\n\n   https://camlistore.org/pkg/blobref?go-get=1\n   http://camlistore.org/pkg/blobref?go-get=1\n   https://camlistore.org/?go-get=1\n   http://camlistore.org/?go-get=1\n\nUltimately it finds:\n\n<meta name=\"go-import\" content=\"camlistore.org git\nhttps://camlistore.org/r/p/camlistore.git\" />\n\nIn this case, the second \"git\" is redundant, as the repo root\ncontains a \".git\" suffix. All three fields are required,\nhowever, and must be consistent.\n\nFixes issue 3099\n\n\nOn Thu, Feb 23, 2012 at 6:48 PM, <bradfitz@golang.org> wrote:\n\n> Hello golang-dev@googlegroups.com, dsymonds@golang.org, r@google.com,\n> rsc@golang.org, gary.burd@gmail.com, gustavo@niemeyer.net,\n> eikeon@eikeon.com, untheoretic@googlemail.com (cc:\n> golang-dev@googlegroups.com),\n>\n> Please take another look.\n>\n>\n> http://codereview.appspot.5660051com/**5660051/<http://codereview.appspot.com/5660051/>\n>\n",
			"disapproval": false,
			"date": "2012-02-23 07:49:50.818725",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Feb 23, 2012 at 9:49 AM, Russ Cox <rsc@golang.org> wrote:\n\n> On Thu, Feb 23, 2012 at 02:49, Brad Fitzpatrick <bradfitz@golang.org>\n> wrote:\n> > If the import-alias-prefix is not an exact match for the import,\n> > another HTTP fetch is performed, at the declared root.\n>\n> Can we remove this?\n\n\nNo, I don't think so.  See the big comment in the code about why it's\nnecessary.\n\n\n>  I'd strongly prefer not to make the root\n> special, so that we are not creating functionality only usable\n> by people who have control over their domain's root.\n>\n> The only advantage I see to it is that you don't have to\n> make a working URL corresponding to the import path,\n> but that's not an advantage for potential users.\n>\n\n\n\n\n>\n> Russ\n>\n",
			"disapproval": false,
			"date": "2012-02-23 19:39:41.808976",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"gustavo@niemeyer.net",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go\nFile src/cmd/go/vcs.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode285\nsrc/cmd/go/vcs.go:285: // (thus root is a prefix of importPath)\nOn 2012/02/23 13:40:35, niemeyer wrote:\n> s/importPath/the import path/?\n\nDeleted. This was moved from an old comment. It no longer makes sense out of context.\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode301\nsrc/cmd/go/vcs.go:301: // repoRootForImportPathStatic attempts to map importPath to a\nOn 2012/02/23 13:40:35, niemeyer wrote:\n> On the nitpicky side, these names seem to be getting a bit too long. Names like\n> findRepoRoot, staticRepoRoot and customRepoRoot might not be too bad.\n\nI fought with the names for a bit and I'm not a huge fan either, BUT--- they're private.  So I don't care too much.  They're not set in Go 1 Stone for life.\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode370\nsrc/cmd/go/vcs.go:370: func repoRootForImportCustom(importPath string) (*repoRoot, error) {\nOn 2012/02/23 13:40:35, niemeyer wrote:\n> A quick comment above this function regarding what a custom import is would be\n> nice.\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode422\nsrc/cmd/go/vcs.go:422: // Try again, with the \".vcs\" suffix.\nOn 2012/02/23 13:40:35, niemeyer wrote:\n> Is this necessary? If the static import path needs the \".vcs\", the import\n> metadata in the page could easily provide it.\n\nI thought so too, and was thinking along those lines too, but that leads to asking why you need the middle VCS field in the meta tag at all.  But--- once you require the third field to be VCS-qualified, that breaks if we later add a new well-known code hosting site, since it's an error to add a \".git\" to a github URL.  So with two fields:\n\n\"name.tld/pkg/foo https://nextgithub.com/user/fixiejs.git\"\n\n... and that's valid, but then we add nextgithub.com to our known hosting site list, and the above line is now invalid.\n\nSo I thought it's better to have:\n\n\"name.tld/pkg/foo git https://nextgithub.com/user/fixiejs\"\n\n... where the third field is exactly the git clone URL.\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode481\nsrc/cmd/go/vcs.go:481: if !ok || !strings.EqualFold(e.Name.Local, \"meta\") {\nOn 2012/02/23 13:40:35, niemeyer wrote:\n> Shouldn't this be checking for \"go-import\" in the name attr too?\n\nWhoops, indeed. Fixed.",
			"disapproval": false,
			"date": "2012-02-23 22:26:58.596151",
			"approval": false
		},
		{
			"sender": "n13m3y3r@gmail.com",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"gustavo@niemeyer.net",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5660051/diff/25001/src/cmd/go/http.go\nFile src/cmd/go/http.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/http.go#newcode82\nsrc/cmd/go/http.go:82: // serve a meta import in their 404 page. Be stricter here?\nOn 2012/02/23 13:40:35, niemeyer wrote:\n> As long as the page contains the metadata, I don't see any problem in taking it\n> as a valid response. That said, the logic above seems a bit problematic. Isn't\n> it ignoring non-200 responses on the https side entirely?\n> \n> Maybe return both bodies, and let the call site decide which one to use based on\n> the content?\n\nHave you seen this one?\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go\nFile src/cmd/go/vcs.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode301\nsrc/cmd/go/vcs.go:301: // repoRootForImportPathStatic attempts to map importPath to a\nOn 2012/02/23 22:26:58, bradfitz wrote:\n> On 2012/02/23 13:40:35, niemeyer wrote:\n> > On the nitpicky side, these names seem to be getting a bit too long. Names\n> like\n> > findRepoRoot, staticRepoRoot and customRepoRoot might not be too bad.\n> \n> I fought with the names for a bit and I'm not a huge fan either, BUT--- they're\n> private.  So I don't care too much.  They're not set in Go 1 Stone for life.\n\nSorry, it's just that it jumped in the eye. I guess it's still 8 characters away from reconstructActiveFormattingElements.\n\nhttp://codereview.appspot.com/5660051/diff/25001/src/cmd/go/vcs.go#newcode422\nsrc/cmd/go/vcs.go:422: // Try again, with the \".vcs\" suffix.\nOn 2012/02/23 22:26:58, bradfitz wrote:\n> On 2012/02/23 13:40:35, niemeyer wrote:\n> > Is this necessary? If the static import path needs the \".vcs\", the import\n> > metadata in the page could easily provide it.\n> \n> I thought so too, and was thinking along those lines too, but that leads to\n> asking why you need the middle VCS field in the meta tag at all.  But--- once\n> you require the third field to be VCS-qualified, that breaks if we later add a\n> new well-known code hosting site, since it's an error to add a \".git\" to a\n> github URL.  So with two fields:\n\nWe can easily not make an error to provide a URL in the import metadata that is actually the right URL for a repository, and prevent guessing remote URLs unnecessarily. Seems like a win-win situation.\n\nThe no-.git rule, as far as I know, prevents people from using .git in the import path unnecessarily. That's still reasonable for the existing mechanism, but unrelated to that new mechanism since people will never see the third field in normal usage. It is not an import path.\n\n> \"name.tld/pkg/foo https://nextgithub.com/user/fixiejs.git%22\n> \n> ... and that's valid, but then we add http://nextgithub.com to our known hosting site\n> list, and the above line is now invalid.\n\nThat sounds like \"name.tld/pkg/foo git https://nextgithub.com/user/fixiejs.git\". The \"git\" string is redundant due to git's own conventions. There's no problem with that, and other vcss don't have that characteristic.",
			"disapproval": false,
			"date": "2012-02-23 23:51:39.517304",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "ping\n\nOn Thu, Feb 23, 2012 at 2:29 PM, <bradfitz@golang.org> wrote:\n\n> Hello golang-dev@googlegroups.com, dsymonds@golang.org, r@google.com,\n> rsc@golang.org, gary.burd@gmail.com, gustavo@niemeyer.net,\n> eikeon@eikeon.com, untheoretic@googlemail.com, n13m3y3r@gmail.com (cc:\n>\n> golang-dev@googlegroups.com),\n>\n> Please take another look.\n>\n>\n> http://codereview.appspot.com/**5660051/<http://codereview.appspot.com/5660051/>\n>\n",
			"disapproval": false,
			"date": "2012-02-29 20:16:51.804051",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Sorry, I'm trying to wrap up other work on the go tool to send out\nfor review.  Once that's out I will review this.\n",
			"disapproval": false,
			"date": "2012-02-29 20:20:39.164939",
			"approval": false
		},
		{
			"sender": "n13m3y3r@gmail.com",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"dsymonds@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"gustavo@niemeyer.net",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "For reference, moving pending comments to the current diff.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go\nFile src/cmd/go/http.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go#newcode82\nsrc/cmd/go/http.go:82: // serve a meta import in their 404 page. Be stricter here?\nAs long as the page contains the metadata, I don't see any problem in taking it as a valid response. That said, the logic above seems a bit problematic. Isn't it ignoring non-200 responses on the https side entirely?\n\nMaybe return both bodies, and let the call site decide which one to use based on the content?\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go\nFile src/cmd/go/vcs.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode426\nsrc/cmd/go/vcs.go:426: // Try again, with the \".vcs\" suffix.\nOn 2012/02/23 22:26:58, bradfitz wrote:\n> On 2012/02/23 13:40:35, niemeyer wrote:\n> > Is this necessary? If the static import path needs the \".vcs\", the import\n> > metadata in the page could easily provide it.\n> \n> I thought so too, and was thinking along those lines too, but that leads to\n> asking why you need the middle VCS field in the meta tag at all.  But--- once\n> you require the third field to be VCS-qualified, that breaks if we later add a\n> new well-known code hosting site, since it's an error to add a \".git\" to a\n> github URL.  So with two fields:\n\nWe can easily not make an error to provide a URL in the import metadata that is\nactually the right URL for a repository, and prevent guessing remote URLs\nunnecessarily. Seems like a win-win situation.\n\nThe no-.git rule, as far as I know, prevents people from using .git in the\nimport path unnecessarily. That's still reasonable for the existing mechanism,\nbut unrelated to that new mechanism since people will never see the third field\nin normal usage. It is not an import path.\n\n> \"name.tld/pkg/foo https://nextgithub.com/user/fixiejs.git%22\n> \n> ... and that's valid, but then we add http://nextgithub.com to our known hosting site\n> list, and the above line is now invalid.\n\nThat sounds like \"name.tld/pkg/foo git https://nextgithub.com/user/fixiejs.git\".\nThe \"git\" string is redundant due to git's own conventions. There's no problem\nwith that, and other vcss don't have that characteristic.",
			"disapproval": false,
			"date": "2012-02-29 20:24:56.227417",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I'm not going to update code until we agree on desired behavior.\n On Feb 29, 2012 12:24 PM, <n13m3y3r@gmail.com> wrote:\n\n> For reference, moving pending comments to the current diff.\n>\n>\n> http://codereview.appspot.com/**5660051/diff/26008/src/cmd/go/**http.go<http://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go>\n> File src/cmd/go/http.go (right):\n>\n> http://codereview.appspot.com/**5660051/diff/26008/src/cmd/go/**\n> http.go#newcode82<http://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go#newcode82>\n> src/cmd/go/http.go:82: // serve a meta import in their 404 page. Be\n> stricter here?\n> As long as the page contains the metadata, I don't see any problem in\n> taking it as a valid response. That said, the logic above seems a bit\n> problematic. Isn't it ignoring non-200 responses on the https side\n> entirely?\n>\n> Maybe return both bodies, and let the call site decide which one to use\n> based on the content?\n>\n> http://codereview.appspot.com/**5660051/diff/26008/src/cmd/go/**vcs.go<http://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go>\n> File src/cmd/go/vcs.go (right):\n>\n> http://codereview.appspot.com/**5660051/diff/26008/src/cmd/go/**\n> vcs.go#newcode426<http://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode426>\n> src/cmd/go/vcs.go:426: // Try again, with the \".vcs\" suffix.\n> On 2012/02/23 22:26:58, bradfitz wrote:\n>\n>> On 2012/02/23 13:40:35, niemeyer wrote:\n>> > Is this necessary? If the static import path needs the \".vcs\", the\n>>\n> import\n>\n>> > metadata in the page could easily provide it.\n>>\n>\n>  I thought so too, and was thinking along those lines too, but that\n>>\n> leads to\n>\n>> asking why you need the middle VCS field in the meta tag at all.\n>>\n> But--- once\n>\n>> you require the third field to be VCS-qualified, that breaks if we\n>>\n> later add a\n>\n>> new well-known code hosting site, since it's an error to add a \".git\"\n>>\n> to a\n>\n>> github URL.  So with two fields:\n>>\n>\n> We can easily not make an error to provide a URL in the import metadata\n> that is\n> actually the right URL for a repository, and prevent guessing remote\n> URLs\n> unnecessarily. Seems like a win-win situation.\n>\n> The no-.git rule, as far as I know, prevents people from using .git in\n> the\n> import path unnecessarily. That's still reasonable for the existing\n> mechanism,\n> but unrelated to that new mechanism since people will never see the\n> third field\n> in normal usage. It is not an import path.\n>\n>  \"name.tld/pkg/foo https://nextgithub.com/user/**fixiejs.git%22<https://nextgithub.com/user/fixiejs.git%22>\n>>\n>\n>  ... and that's valid, but then we add http://nextgithub.com to our\n>>\n> known hosting site\n>\n>> list, and the above line is now invalid.\n>>\n>\n> That sounds like \"name.tld/pkg/foo git\n> https://nextgithub.com/user/**fixiejs.git<https://nextgithub.com/user/fixiejs.git>\n> \".\n> The \"git\" string is redundant due to git's own conventions. There's no\n> problem\n> with that, and other vcss don't have that characteristic.\n>\n> http://codereview.appspot.com/**5660051/<http://codereview.appspot.com/5660051/>\n>\n",
			"disapproval": false,
			"date": "2012-02-29 20:27:58.246138",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5660051/diff/26008/src/cmd/dist/build.c\nFile src/cmd/dist/build.c (right):\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/dist/build.c#newcode1130\nsrc/cmd/dist/build.c:1130: \"pkg/encoding/xml\",\nCan we move the xml stuff into the stub file so that it doesn't need to be listed here?\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go\nFile src/cmd/go/http.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go#newcode44\nsrc/cmd/go/http.go:44: // https resource or, if unavailable, the http resource.\nI'm a little sad about the downgrade but I guess we can't force people to run https servers.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go#newcode64\nsrc/cmd/go/http.go:64: re := <-httpsCh\nI am not sure the goroutines are buying you much.\nYou get to run the HTTP request in parallel with the HTTPS\nrequest, but you still wait for the HTTPS request before \nusing the HTTP result, and I'd expect the HTTPS one to be\nthe one that might just sit and timeout.  \n\nMaybe drop the channels here and just do\n\nres, err := fetch(\"http\")\n...\n\nThen you don't have to cancel/consume the HTTP request either.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go#newcode81\nsrc/cmd/go/http.go:81: // TODO(bradfitz): I'm currently accepting a non-200 OK here, so people can\nLGTM as is.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go\nFile src/cmd/go/vcs.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode275\nsrc/cmd/go/vcs.go:275: \nPlease sync and merge in the recent changes, specifically vcsForDir.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode376\nsrc/cmd/go/vcs.go:376: if slash == -1 {\nif slash < 0 please\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode399\nsrc/cmd/go/vcs.go:399: log.Printf(\"discovery of %q finds prefix %q; verifying prefix...\", importPath, metaImport.Prefix)\nif verbose or something\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode410\nsrc/cmd/go/vcs.go:410: metaImport, err = matchGoImport(imports, importPath)\nIf metaImport disagrees here with what you started with, that's probably an error.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode418\nsrc/cmd/go/vcs.go:418: if i := strings.Index(metaImport.RepoRoot, \"://\"); i != -1 {\ni >= 0\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode424\nsrc/cmd/go/vcs.go:424: rr, err := repoRootForImportPathStatic(newImportPath, repoScheme)\nThis doesn't look right to me.  All the required information should be here already.  We shouldn't have to run the static tests.",
			"disapproval": false,
			"date": "2012-03-05 20:53:10.380077",
			"approval": true
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go\nFile src/cmd/go/http.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go#newcode44\nsrc/cmd/go/http.go:44: // https resource or, if unavailable, the http resource.\nOn 2012/03/05 20:53:10, rsc wrote:\n> I'm a little sad about the downgrade but I guess we can't force people to run\n> https servers.\n\nYeah.  I figure we could always support HSTS or similar in the future.  This policy works for now.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go#newcode64\nsrc/cmd/go/http.go:64: re := <-httpsCh\nOn 2012/03/05 20:53:10, rsc wrote:\n> I am not sure the goroutines are buying you much.\n> You get to run the HTTP request in parallel with the HTTPS\n> request, but you still wait for the HTTPS request before \n> using the HTTP result, and I'd expect the HTTPS one to be\n> the one that might just sit and timeout.  \n> \n> Maybe drop the channels here and just do\n> \n> res, err := fetch(\"http\")\n> ...\n> \n> Then you don't have to cancel/consume the HTTP request either.\n\nI still have painful memories of the latency from Australia (where I originally wrote this patch) to the US.  I'd prefer to save a round-trip when possible.  I could clean up the code or break it into some some functions for draining or something, though?\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go#newcode81\nsrc/cmd/go/http.go:81: // TODO(bradfitz): I'm currently accepting a non-200 OK here, so people can\nOn 2012/03/05 20:53:10, rsc wrote:\n> LGTM as is.\n\nk. updated comment.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go\nFile src/cmd/go/vcs.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode275\nsrc/cmd/go/vcs.go:275: \nOn 2012/03/05 20:53:10, rsc wrote:\n> Please sync and merge in the recent changes, specifically vcsForDir.\n\nDone.\n\nAt least, it works now after I resolved the trivial merge problem.  Did I miss a larger issue?\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode376\nsrc/cmd/go/vcs.go:376: if slash == -1 {\nOn 2012/03/05 20:53:10, rsc wrote:\n> if slash < 0 please\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode376\nsrc/cmd/go/vcs.go:376: if slash == -1 {\nOn 2012/03/05 20:53:10, rsc wrote:\n> if slash < 0 please\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode399\nsrc/cmd/go/vcs.go:399: log.Printf(\"discovery of %q finds prefix %q; verifying prefix...\", importPath, metaImport.Prefix)\nOn 2012/03/05 20:53:10, rsc wrote:\n> if verbose or something\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode410\nsrc/cmd/go/vcs.go:410: metaImport, err = matchGoImport(imports, importPath)\nOn 2012/03/05 20:53:10, rsc wrote:\n> If metaImport disagrees here with what you started with, that's probably an\n> error.\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode418\nsrc/cmd/go/vcs.go:418: if i := strings.Index(metaImport.RepoRoot, \"://\"); i != -1 {\nOn 2012/03/05 20:53:10, rsc wrote:\n> i >= 0\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode424\nsrc/cmd/go/vcs.go:424: rr, err := repoRootForImportPathStatic(newImportPath, repoScheme)\nOn 2012/03/05 20:53:10, rsc wrote:\n> This doesn't look right to me.  All the required information should be here\n> already.  We shouldn't have to run the static tests.\n\nBackground: (discussed earlier in this review/email somewhere)\n\nKnown sites don't allow you to list the vcs suffix.  For instance,\n\n$ go get github.com/bradfitz/rfbgo.git\npackage github.com/bradfitz/rfbgo.git: invalid version control suffix in github.com/ path\n\nSo, to permit new code hosting sites to be added later without breaking once we start recognizing their patterns, we really need to tell me to *not* add the .vcs to their meta import lines, so:\n\n\"proj.org git nextgithub.com/bob/proj\"\n\n... which will try \"nextgithub.com/bob/proj\", fail, and then try \"nextgithub.com/bob/proj.git\" and succeed.\n\nOnce nextgithub.com is added as a known site, then the first step will success and the \".git\" suffix will never be added, or only be used to distinguish between VCSes when multiple are known for that code hosting site.\n\nAt least, that was the rationale.\n\nAlternate designs welcome.",
			"disapproval": false,
			"date": "2012-03-05 23:56:59.082176",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Mar 6, 2012 at 00:33,  <bradfitz@golang.org> wrote:\n> no, it doesn't. \u00a0(get.go just returns it, as it has no extra context)\n\n$ go get a/b/c/d/e\npackage a/b/c/d/e: unrecognized import path \"a/b/c/d/e\"\n$\n",
			"disapproval": false,
			"date": "2012-03-06 05:38:37.525947",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "And now with more -v logging, to help people debug.\n\nOn Mon, Mar 5, 2012 at 8:44 PM, <bradfitz@golang.org> wrote:\n\n> Hello r@google.com, rsc@golang.org, gary.burd@gmail.com,\n> eikeon@eikeon.com, untheoretic@googlemail.com, n13m3y3r@gmail.com,\n> rsc@google.com (cc: golang-dev@googlegroups.com),\n>\n> Please take another look.\n>\n>\n> http://codereview.appspot.com/**5660051/<http://codereview.appspot.com/5660051/>\n>\n",
			"disapproval": false,
			"date": "2012-03-06 04:45:17.680772",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"rsc@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello r@google.com, rsc@golang.org, gary.burd@gmail.com, eikeon@eikeon.com, untheoretic@googlemail.com, n13m3y3r@gmail.com, rsc@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-03-06 04:27:46.430927",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"rsc@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello r@google.com, rsc@golang.org, gary.burd@gmail.com, eikeon@eikeon.com, untheoretic@googlemail.com, n13m3y3r@gmail.com, rsc@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-03-06 04:44:55.491865",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"rsc@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=0af5bcfdb4c1 ***\n\ncmd/go: allow go get with arbitrary URLs\n\nThis CL permits using arbitrary, non-VCS-qualified URLs as\naliases for fully VCS-qualified and/or well-known code hosting\nsites.\n\nExample 1) A VCS-qualified URL can now be shorter.\n\nBefore:\n$ go get camlistore.org/r/p/camlistore.git/pkg/blobref\nAfter:\n$ go get camlistore.org/pkg/blobref\n\nExample 2) A custom domain can be used as the import,\nreferencing a well-known code hosting site.\n\nBefore:\n$ go get github.com/bradfitz/sonden\nAfter:\n$ go get bradfitz.com/pkg/sonden\n\nThe mechanism used is a <meta> tag in the HTML document\nretrieved from fetching:\n\n    https://<import>?go-get=1  (preferred)\n    http://<import>?go-get=1   (fallback)\n\nThe meta tag should look like:\n\n<meta name=\"go-import\" content=\"import-alias-prefix vcs full-repo-root\">\n\nThe full-repo-root must be a full URL root to a repository containing\na scheme and *not* containing a \".vcs\" qualifier.\n\nThe vcs is one of \"git\", \"hg\", \"svn\", etc.\n\nThe import-alias-prefix must be a prefix or exact match of the\npackage being fetched with \"go get\".\n\nIf there are multiple meta tags, only the one with a prefix\nmatching the import path is used. It is an error if multiple\ngo-import values match the import prefix.\n\nIf the import-alias-prefix is not an exact match for the import,\nanother HTTP fetch is performed, at the declared root (which does\n*not* need to be the domain's root).\n\nFor example, assuming that \"camlistore.org/pkg/blobref\" declares\nin its HTML head:\n\n<meta name=\"go-import\" content=\"camlistore.org git https://camlistore.org/r/p/camlistore\" />\n\n... then:\n\n$ go get camlistore.org/pkg/blobref\n\n... looks at the following URLs:\n\n   https://camlistore.org/pkg/blobref?go-get=1\n   http://camlistore.org/pkg/blobref?go-get=1\n   https://camlistore.org/?go-get=1\n   http://camlistore.org/?go-get=1\n\nUltimately it finds, at the root (camlistore.org/), the same go-import:\n\n<meta name=\"go-import\" content=\"camlistore.org git https://camlistore.org/r/p/camlistore\" />\n\n... and proceeds to trust it, checking out git //camlistore.org/r/p/camlistore at\nthe import path of \"camlistore.org\" on disk.\n\nFixes issue 3099\n\nR=r, rsc, gary.burd, eikeon, untheoretic, n13m3y3r, rsc\nCC=golang-dev\nhttp://codereview.appspot.com/5660051",
			"disapproval": false,
			"date": "2012-03-06 06:36:20.568486",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello r@google.com, rsc@golang.org, gary.burd@gmail.com, eikeon@eikeon.com, untheoretic@googlemail.com, n13m3y3r@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-03-05 23:57:11.780907",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"rsc@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go\nFile src/cmd/go/http.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go#newcode64\nsrc/cmd/go/http.go:64: re := <-httpsCh\nOn 2012/03/05 23:56:59, bradfitz wrote:\n> On 2012/03/05 20:53:10, rsc wrote:\n> > I am not sure the goroutines are buying you much.\n> > You get to run the HTTP request in parallel with the HTTPS\n> > request, but you still wait for the HTTPS request before \n> > using the HTTP result, and I'd expect the HTTPS one to be\n> > the one that might just sit and timeout.  \n> > \n> > Maybe drop the channels here and just do\n> > \n> > res, err := fetch(\"http\")\n> > ...\n> > \n> > Then you don't have to cancel/consume the HTTP request either.\n> \n> I still have painful memories of the latency from Australia (where I originally\n> wrote this patch) to the US.  I'd prefer to save a round-trip when possible.  I\n> could clean up the code or break it into some some functions for draining or\n> something, though?\n\nWe don't do this shotgun approach network traffic anywhere else.\nI'd like to remove this.  It only runs when doing the initial checkout.\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go\nFile src/cmd/go/vcs.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode424\nsrc/cmd/go/vcs.go:424: rr, err := repoRootForImportPathStatic(newImportPath, repoScheme)\nOn 2012/03/05 23:56:59, bradfitz wrote:\n> On 2012/03/05 20:53:10, rsc wrote:\n> > This doesn't look right to me.  All the required information should be here\n> > already.  We shouldn't have to run the static tests.\n> \n> Background: (discussed earlier in this review/email somewhere)\n> \n> Known sites don't allow you to list the vcs suffix.  For instance,\n> \n> $ go get github.com/bradfitz/rfbgo.git\n> package github.com/bradfitz/rfbgo.git: invalid version control suffix in\n> github.com/ path\n> \n> So, to permit new code hosting sites to be added later without breaking once we\n> start recognizing their patterns, we really need to tell me to *not* add the\n> .vcs to their meta import lines, so:\n> \n> \"proj.org git nextgithub.com/bob/proj\"\n> \n> ... which will try \"nextgithub.com/bob/proj\", fail, and then try\n> \"nextgithub.com/bob/proj.git\" and succeed.\n> \n> Once http://nextgithub.com is added as a known site, then the first step will success\n> and the \".git\" suffix will never be added, or only be used to distinguish\n> between VCSes when multiple are known for that code hosting site.\n> \n> At least, that was the rationale.\n> \n> Alternate designs welcome.\n\nMy alternate design is don't call repoRootForImportPathStatic.\nThis function needs to return vcs + repo + root.\nAll that information is in the meta tag.\n\nIf you don't call repoRootForImportPathStatic, then you don't\nhave to worry about this future compatibility, and there's no\n.vcs guessing.",
			"disapproval": false,
			"date": "2012-03-06 04:12:09.865425",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "k, both fixed.  PTAL.\n\nOn Mon, Mar 5, 2012 at 8:12 PM, <rsc@google.com> wrote:\n\n>\n> http://codereview.appspot.com/**5660051/diff/26008/src/cmd/go/**http.go<http://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go>\n> File src/cmd/go/http.go (right):\n>\n> http://codereview.appspot.com/**5660051/diff/26008/src/cmd/go/**\n> http.go#newcode64<http://codereview.appspot.com/5660051/diff/26008/src/cmd/go/http.go#newcode64>\n> src/cmd/go/http.go:64: re := <-httpsCh\n> On 2012/03/05 23:56:59, bradfitz wrote:\n>\n>> On 2012/03/05 20:53:10, rsc wrote:\n>> > I am not sure the goroutines are buying you much.\n>> > You get to run the HTTP request in parallel with the HTTPS\n>> > request, but you still wait for the HTTPS request before\n>> > using the HTTP result, and I'd expect the HTTPS one to be\n>> > the one that might just sit and timeout.\n>> >\n>> > Maybe drop the channels here and just do\n>> >\n>> > res, err := fetch(\"http\")\n>> > ...\n>> >\n>> > Then you don't have to cancel/consume the HTTP request either.\n>>\n>\n>  I still have painful memories of the latency from Australia (where I\n>>\n> originally\n>\n>> wrote this patch) to the US.  I'd prefer to save a round-trip when\n>>\n> possible.  I\n>\n>> could clean up the code or break it into some some functions for\n>>\n> draining or\n>\n>> something, though?\n>>\n>\n> We don't do this shotgun approach network traffic anywhere else.\n> I'd like to remove this.  It only runs when doing the initial checkout.\n>\n>\n> http://codereview.appspot.com/**5660051/diff/26008/src/cmd/go/**vcs.go<http://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go>\n> File src/cmd/go/vcs.go (right):\n>\n> http://codereview.appspot.com/**5660051/diff/26008/src/cmd/go/**\n> vcs.go#newcode424<http://codereview.appspot.com/5660051/diff/26008/src/cmd/go/vcs.go#newcode424>\n> src/cmd/go/vcs.go:424: rr, err :=\n> repoRootForImportPathStatic(**newImportPath, repoScheme)\n> On 2012/03/05 23:56:59, bradfitz wrote:\n>\n>> On 2012/03/05 20:53:10, rsc wrote:\n>> > This doesn't look right to me.  All the required information should\n>>\n> be here\n>\n>> > already.  We shouldn't have to run the static tests.\n>>\n>\n>  Background: (discussed earlier in this review/email somewhere)\n>>\n>\n>  Known sites don't allow you to list the vcs suffix.  For instance,\n>>\n>\n>  $ go get github.com/bradfitz/rfbgo.git\n>> package github.com/bradfitz/rfbgo.git: invalid version control suffix\n>>\n> in\n>\n>> github.com/ path\n>>\n>\n>  So, to permit new code hosting sites to be added later without\n>>\n> breaking once we\n>\n>> start recognizing their patterns, we really need to tell me to *not*\n>>\n> add the\n>\n>> .vcs to their meta import lines, so:\n>>\n>\n>  \"proj.org git nextgithub.com/bob/proj\"\n>>\n>\n>  ... which will try \"nextgithub.com/bob/proj\", fail, and then try\n>> \"nextgithub.com/bob/proj.git\" and succeed.\n>>\n>\n>  Once http://nextgithub.com is added as a known site, then the first\n>>\n> step will success\n>\n>> and the \".git\" suffix will never be added, or only be used to\n>>\n> distinguish\n>\n>> between VCSes when multiple are known for that code hosting site.\n>>\n>\n>  At least, that was the rationale.\n>>\n>\n>  Alternate designs welcome.\n>>\n>\n> My alternate design is don't call repoRootForImportPathStatic.\n> This function needs to return vcs + repo + root.\n> All that information is in the meta tag.\n>\n> If you don't call repoRootForImportPathStatic, then you don't\n> have to worry about this future compatibility, and there's no\n> .vcs guessing.\n>\n> http://codereview.appspot.com/**5660051/<http://codereview.appspot.com/5660051/>\n>\n",
			"disapproval": false,
			"date": "2012-03-06 04:27:55.294435",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mar 5, 2012 9:38 PM, \"Russ Cox\" <rsc@google.com> wrote:\n>\n> On Tue, Mar 6, 2012 at 00:33,  <bradfitz@golang.org> wrote:\n> > no, it doesn't.  (get.go just returns it, as it has no extra context)\n>\n> $ go get a/b/c/d/e\n> package a/b/c/d/e: unrecognized import path \"a/b/c/d/e\"\n> $\n\nAh, I only looked one level up in the code.\n\nCan't say I get error context best practices yet. Maybe I should read\nsomething.\n",
			"disapproval": false,
			"date": "2012-03-06 05:47:34.222021",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"rsc@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Very close; just fine-tuning errors and logging.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go\nFile src/cmd/go/vcs.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode340\nsrc/cmd/go/vcs.go:340: return nil, fmt.Errorf(\"scheme in import path %q\", importPath)\ninvalid import path %q\nis probably fine\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode408\nsrc/cmd/go/vcs.go:408: return nil, fmt.Errorf(\"no slash in import %q\", importPath)\ni don't think the code needs to say %q\nexcept for syntax errors like the scheme error above.\nit will be added in the error message that\ngets printed, no?\n\nmissing / in import path\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode412\nsrc/cmd/go/vcs.go:412: return nil, fmt.Errorf(\"error fetching %q: %v\", importPath, err)\nfetch %s: %v\n\n(url, err)\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode418\nsrc/cmd/go/vcs.go:418: return nil, fmt.Errorf(\"error parsing %q: %v\", importPath, err)\nparse %s: %v\n\n(url, err)\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode423\nsrc/cmd/go/vcs.go:423: log.Printf(\"discovery of %q finds %#v\", importPath, metaImport)\nget %q: found meta tag %#v at %s\n\nlast arg is url\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode433\nsrc/cmd/go/vcs.go:433: log.Printf(\"discovery of %q finds prefix %q; verifying prefix...\", importPath, metaImport.Prefix)\nget %q: found prefix %q at %s\n\nlast arg is url\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode437\nsrc/cmd/go/vcs.go:437: log.Printf(\"meta's prefix %q doesn't match desired import path %q, but fetching %q's meta to verify it failed\",\nget %q: fetch %s: %v\n\nnot sure this is necessary given that the error return is next.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode439\nsrc/cmd/go/vcs.go:439: return nil, fmt.Errorf(\"error fetching %q: %v\", metaImport.Prefix, err)\nfetch %s: %v\n\n(url, err)\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode443\nsrc/cmd/go/vcs.go:443: return nil, fmt.Errorf(\"no go-imports meta tags found parsing %q\", metaImport.Prefix)\nfetch %s: no go-import meta tag\n\n(url)\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode447\nsrc/cmd/go/vcs.go:447: return nil, fmt.Errorf(\"meta's prefix %q doesn't match desired import path %q, and parsing %q's HTML = %v\",\nif err != nil || metaImport != metaImport2 {\n%s and %s disagree about go-import for %s\nurl1, url2, prefix\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode455\nsrc/cmd/go/vcs.go:455: if i := strings.Index(metaImport.RepoRoot, \"://\"); i < 0 {\n!strings.Contains\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode456\nsrc/cmd/go/vcs.go:456: return nil, fmt.Errorf(\"meta tag's repo root of %q doesn't contain a scheme\", metaImport.RepoRoot)\nreturn nil, fmt.Errorf(\"%s: invalid repo root %q\", url, metaImport.RepoRoot)\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode464\nsrc/cmd/go/vcs.go:464: return nil, fmt.Errorf(\"unknown vcs %q\", metaImport.VCS)\nreturn nil, fmt.Errorf(\"%s: unknown vcs %q\", url, metaImport.VCS)",
			"disapproval": false,
			"date": "2012-03-06 05:13:22.164276",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"rsc@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello r@google.com, rsc@golang.org, gary.burd@gmail.com, eikeon@eikeon.com, untheoretic@googlemail.com, n13m3y3r@gmail.com, rsc@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-03-06 05:33:19.020415",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"rsc@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nhttp://codereview.appspot.com/5660051/diff/43007/src/cmd/go/vcs.go\nFile src/cmd/go/vcs.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/43007/src/cmd/go/vcs.go#newcode412\nsrc/cmd/go/vcs.go:412: return nil, fmt.Errorf(\"http or https fetch for import %q: %v\", importPath, err)\nhttp/https\n\nhttp://codereview.appspot.com/5660051/diff/43007/src/cmd/go/vcs.go#newcode433\nsrc/cmd/go/vcs.go:433: log.Printf(\"get %q: verifying non-authorative meta tag\", importPath)\ns/ra/ri/ in authoritative",
			"disapproval": false,
			"date": "2012-03-06 05:41:24.478059",
			"approval": true
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Mar 6, 2012 at 00:47, Brad Fitzpatrick <bradfitz@golang.org> wrote:\n> Can't say I get error context best practices yet. Maybe I should read\n> something.\n\nPick something other than the cmd/go sources.\nI'm not entirely happy with how they're handled here yet.\n",
			"disapproval": false,
			"date": "2012-03-06 05:49:11.196508",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"r@google.com",
				"rsc@golang.org",
				"gary.burd@gmail.com",
				"eikeon@eikeon.com",
				"untheoretic@googlemail.com",
				"n13m3y3r@gmail.com",
				"rsc@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I think I got most of them, at least in spirit.\n\nPTAL?\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go\nFile src/cmd/go/vcs.go (right):\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode340\nsrc/cmd/go/vcs.go:340: return nil, fmt.Errorf(\"scheme in import path %q\", importPath)\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> invalid import path %q\n> is probably fine\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode408\nsrc/cmd/go/vcs.go:408: return nil, fmt.Errorf(\"no slash in import %q\", importPath)\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> i don't think the code needs to say %q\n> except for syntax errors like the scheme error above.\n> it will be added in the error message that\n> gets printed, no?\n\nno, it doesn't.  (get.go just returns it, as it has no extra context)\n\nplus, I've always been told to include the context you have in your errors.  your callers add the context they have and you don't.  no?\n\n> missing / in import path\n\ndone\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode412\nsrc/cmd/go/vcs.go:412: return nil, fmt.Errorf(\"error fetching %q: %v\", importPath, err)\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> fetch %s: %v\n> \n> (url, err)\n\nurl isn't valid here. but did something else.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode418\nsrc/cmd/go/vcs.go:418: return nil, fmt.Errorf(\"error parsing %q: %v\", importPath, err)\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> parse %s: %v\n> \n> (url, err)\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode423\nsrc/cmd/go/vcs.go:423: log.Printf(\"discovery of %q finds %#v\", importPath, metaImport)\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> get %q: found meta tag %#v at %s\n> \n> last arg is url\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode437\nsrc/cmd/go/vcs.go:437: log.Printf(\"meta's prefix %q doesn't match desired import path %q, but fetching %q's meta to verify it failed\",\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> get %q: fetch %s: %v\n> \n> not sure this is necessary given that the error return is next.\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode437\nsrc/cmd/go/vcs.go:437: log.Printf(\"meta's prefix %q doesn't match desired import path %q, but fetching %q's meta to verify it failed\",\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> get %q: fetch %s: %v\n> \n> not sure this is necessary given that the error return is next.\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode439\nsrc/cmd/go/vcs.go:439: return nil, fmt.Errorf(\"error fetching %q: %v\", metaImport.Prefix, err)\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> fetch %s: %v\n> \n> (url, err)\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode443\nsrc/cmd/go/vcs.go:443: return nil, fmt.Errorf(\"no go-imports meta tags found parsing %q\", metaImport.Prefix)\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> fetch %s: no go-import meta tag\n> \n> (url)\n> \n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode447\nsrc/cmd/go/vcs.go:447: return nil, fmt.Errorf(\"meta's prefix %q doesn't match desired import path %q, and parsing %q's HTML = %v\",\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> if err != nil || metaImport != metaImport2 {\n> %s and %s disagree about go-import for %s\n> url1, url2, prefix\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode455\nsrc/cmd/go/vcs.go:455: if i := strings.Index(metaImport.RepoRoot, \"://\"); i < 0 {\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> !strings.Contains\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode456\nsrc/cmd/go/vcs.go:456: return nil, fmt.Errorf(\"meta tag's repo root of %q doesn't contain a scheme\", metaImport.RepoRoot)\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> return nil, fmt.Errorf(\"%s: invalid repo root %q\", url, metaImport.RepoRoot)\n\nDone.\n\nhttp://codereview.appspot.com/5660051/diff/44001/src/cmd/go/vcs.go#newcode464\nsrc/cmd/go/vcs.go:464: return nil, fmt.Errorf(\"unknown vcs %q\", metaImport.VCS)\nOn 2012/03/06 05:13:22, rsc1 wrote:\n> return nil, fmt.Errorf(\"%s: unknown vcs %q\", url, metaImport.VCS)\n\nDone.",
			"disapproval": false,
			"date": "2012-03-06 05:33:10.343021",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 6 March 2012 05:33,  <bradfitz@golang.org> wrote:\n> plus, I've always been told to include the context you have in your\n> errors. \u00a0your callers add the context they have and you don't. \u00a0no?\n\ni wish this was the case.\n\nthe current situation (some functions add context to their errors,\nsome don't) is not ideal for producing predictably good diagnostics.\n",
			"disapproval": false,
			"date": "2012-03-06 11:31:08.634220",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Mar 6, 2012 at 06:31, roger peppe <rogpeppe@gmail.com> wrote:\n> i wish this was the case.\n>\n> the current situation (some functions add context to their errors,\n> some don't) is not ideal for producing predictably good diagnostics.\n\nIt is definitely true that exported functions should include context,\nlike os.Open does.  If they don't, then after Go 1 send us CLs\nand we can fix them.  (It is too late for this kind of minor tweaking now.)\n\nInside a package or a binary, the line gets fuzzier: often when calling\na helper function you can generate the most consistent messages if\nthe caller adds the context, so that it only gets handled in one place.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-03-06 14:27:22.216755",
			"approval": false
		}
	],
	"owner_email": "bradfitz@golang.org",
	"private": false,
	"base_url": "",
	"owner": "bradfitz",
	"subject": "code review 5660051: cmd/go: allow go get with arbitrary URLs",
	"created": "2012-02-14 05:34:11.156867",
	"patchsets": [
		1,
		2001,
		4001,
		20003,
		25001,
		26008,
		37002,
		38007,
		44001,
		43007,
		39013
	],
	"modified": "2012-03-06 11:31:08.740715",
	"closed": true,
	"issue": 5660051
}