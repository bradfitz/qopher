{
	"description": "all: fix typos",
	"cc": [
		"golang-dev@googlegroups.com",
		"bradfitz@golang.org",
		"khr@golang.org",
		"r@golang.org"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "ping.",
			"disapproval": false,
			"date": "2013-06-04 22:39:23.695270",
			"approval": false
		},
		{
			"sender": "khr@golang.org",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"khr@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM",
			"disapproval": false,
			"date": "2013-06-05 01:59:54.311310",
			"approval": true
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"khr@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, bradfitz@golang.org, khr@golang.org (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://code.google.com/p/go",
			"disapproval": false,
			"date": "2013-06-07 09:32:43.915020",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\r\n\r\nI think khr already LGTMed an earlier version of this CL too.\r\n On Jun 7, 2013 11:32 AM, <minux.ma@gmail.com> wrote:\r\n\r\n> Reviewers: golang-dev1, bradfitz, khr,\r\n>\r\n> Message:\r\n> Hello golang-dev@googlegroups.com, bradfitz@golang.org, khr@golang.org\r\n> (cc: golang-dev@googlegroups.com),\r\n>\r\n> I'd like you to review this change to\r\n> https://code.google.com/p/go\r\n>\r\n>\r\n> Description:\r\n> all: fix typos\r\n>\r\n> Please review this at https://codereview.appspot.**com/7461046/<https://codereview.appspot.com/7461046/>\r\n>\r\n> Affected files:\r\n>   M src/cmd/5c/peep.c\r\n>   M src/cmd/5g/gsubr.c\r\n>   M src/cmd/5g/peep.c\r\n>   M src/cmd/5g/reg.c\r\n>   M src/cmd/5l/pass.c\r\n>   M src/cmd/6c/peep.c\r\n>   M src/cmd/6c/txt.c\r\n>   M src/cmd/6g/cgen.c\r\n>   M src/cmd/6g/gsubr.c\r\n>   M src/cmd/6g/peep.c\r\n>   M src/cmd/8c/peep.c\r\n>   M src/cmd/8c/txt.c\r\n>   M src/cmd/8g/cgen.c\r\n>   M src/cmd/8g/peep.c\r\n>   M src/cmd/8g/reg.c\r\n>   M src/cmd/cc/funct.c\r\n>   M src/cmd/cc/lexbody\r\n>   M src/cmd/cc/pgen.c\r\n>   M src/cmd/cc/pswt.c\r\n>   M src/cmd/dist/plan9.c\r\n>   M src/cmd/dist/unix.c\r\n>   M src/cmd/gc/obj.c\r\n>   M src/cmd/gc/swt.c\r\n>   M src/cmd/go/test.bash\r\n>   M src/cmd/ld/data.c\r\n>   M src/cmd/ld/dwarf.c\r\n>   M src/cmd/yacc/units.txt\r\n>   M src/libmach/6obj.c\r\n>   M src/libmach/8obj.c\r\n>   M test/chan/doubleselect.go\r\n>\r\n>\r\n> Index: src/cmd/5c/peep.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/5c/peep.c\r\n> +++ b/src/cmd/5c/peep.c\r\n> @@ -462,7 +462,7 @@\r\n>                 }\r\n>                 t = copyu(p, v2, A);\r\n>                 switch(t) {\r\n> -               case 2: /* rar, cant split */\r\n> +               case 2: /* rar, can't split */\r\n>                         if(debug['P'])\r\n>                                 print(\"; %Drar; return 0\\n\", v2);\r\n>                         return 0;\r\n> Index: src/cmd/5g/gsubr.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/5g/gsubr.c\r\n> +++ b/src/cmd/5g/gsubr.c\r\n> @@ -1905,7 +1905,7 @@\r\n>\r\n>         for(i=1; i<o; i++) {\r\n>                 if(oary[i] >= 0)\r\n> -                       fatal(\"cant happen\");\r\n> +                       fatal(\"can't happen\");\r\n>                 gins(AMOVW, &n1, reg);\r\n>                 n1.xoffset = -(oary[i]+1);\r\n>         }\r\n> Index: src/cmd/5g/peep.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/5g/peep.c\r\n> +++ b/src/cmd/5g/peep.c\r\n> @@ -496,7 +496,7 @@\r\n>                 }\r\n>                 t = copyu(p, v2, A);\r\n>                 switch(t) {\r\n> -               case 2: /* rar, cant split */\r\n> +               case 2: /* rar, can't split */\r\n>                         if(debug['P'])\r\n>                                 print(\"; %Drar; return 0\\n\", v2);\r\n>                         return 0;\r\n> @@ -973,7 +973,7 @@\r\n>         switch(p->as) {\r\n>\r\n>         default:\r\n> -               print(\"copyu: cant find %A\\n\", p->as);\r\n> +               print(\"copyu: can't find %A\\n\", p->as);\r\n>                 return 2;\r\n>\r\n>         case AMOVM:\r\n> @@ -1288,7 +1288,7 @@\r\n>                                 return 1;\r\n>                         return 0;\r\n>                 }\r\n> -               print(\"copyau1: cant tell %P\\n\", p);\r\n> +               print(\"copyau1: can't tell %P\\n\", p);\r\n>         }\r\n>         return 0;\r\n>  }\r\n> Index: src/cmd/5g/reg.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/5g/reg.c\r\n> +++ b/src/cmd/5g/reg.c\r\n> @@ -816,7 +816,7 @@\r\n>                 a->type = D_CONST;\r\n>\r\n>         if(v->addr)\r\n> -               fatal(\"addmove: shouldnt be doing this %A\\n\", a);\r\n> +               fatal(\"addmove: shouldn't be doing this %A\\n\", a);\r\n>\r\n>         switch(v->etype) {\r\n>         default:\r\n> Index: src/cmd/5l/pass.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/5l/pass.c\r\n> +++ b/src/cmd/5l/pass.c\r\n> @@ -130,7 +130,7 @@\r\n>                                 r = prg();\r\n>                                 *r = *p;\r\n>                                 if(!(r->mark&FOLL))\r\n> -                                       print(\"cant happen 1\\n\");\r\n> +                                       print(\"can't happen 1\\n\");\r\n>                                 r->mark |= FOLL;\r\n>                                 if(p != q) {\r\n>                                         p = p->link;\r\n> @@ -150,7 +150,7 @@\r\n>                                 if(!(r->link->mark&FOLL))\r\n>                                         xfol(r->link, last);\r\n>                                 if(!(r->cond->mark&FOLL))\r\n> -                                       print(\"cant happen 2\\n\");\r\n> +                                       print(\"can't happen 2\\n\");\r\n>                                 return;\r\n>                         }\r\n>                 }\r\n> Index: src/cmd/6c/peep.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/6c/peep.c\r\n> +++ b/src/cmd/6c/peep.c\r\n> @@ -483,7 +483,7 @@\r\n>                 }\r\n>                 t = copyu(p, v2, A);\r\n>                 switch(t) {\r\n> -               case 2: /* rar, cant split */\r\n> +               case 2: /* rar, can't split */\r\n>                         if(debug['P'])\r\n>                                 print(\"; %D rar; return 0\\n\", v2);\r\n>                         return 0;\r\n> Index: src/cmd/6c/txt.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/6c/txt.c\r\n> +++ b/src/cmd/6c/txt.c\r\n> @@ -1188,7 +1188,7 @@\r\n>         else if(n->left->op == OREGISTER)\r\n>                 idx.ptr = n->left->reg;\r\n>         else if(n->left->op != OADDR) {\r\n> -               reg[D_BP]++;    // cant be used as a base\r\n> +               reg[D_BP]++;    // can't be used as a base\r\n>                 regalloc(&nod1, &qregnode, Z);\r\n>                 cgen(n->left, &nod1);\r\n>                 idx.ptr = nod1.reg;\r\n> Index: src/cmd/6g/cgen.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/6g/cgen.c\r\n> +++ b/src/cmd/6g/cgen.c\r\n> @@ -1480,7 +1480,7 @@\r\n>   * Small structs or arrays with elements of basic type are\r\n>   * also supported.\r\n>   * nr is N when assigning a zero value.\r\n> - * return 1 if can do, 0 if cant.\r\n> + * return 1 if can do, 0 if can't.\r\n>   */\r\n>  int\r\n>  componentgen(Node *nr, Node *nl)\r\n> Index: src/cmd/6g/gsubr.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/6g/gsubr.c\r\n> +++ b/src/cmd/6g/gsubr.c\r\n> @@ -494,7 +494,7 @@\r\n>                 break;\r\n>\r\n>         case 2:         // offset output arg\r\n> -fatal(\"shouldnt be used\");\r\n> +fatal(\"shouldn't be used\");\r\n>                 n->op = OINDREG;\r\n>                 n->val.u.reg = D_SP;\r\n>                 n->xoffset += types[tptr]->width;\r\n> @@ -2038,7 +2038,7 @@\r\n>\r\n>         for(i=1; i<o; i++) {\r\n>                 if(oary[i] >= 0)\r\n> -                       fatal(\"cant happen\");\r\n> +                       fatal(\"can't happen\");\r\n>                 gins(AMOVQ, &n1, reg);\r\n>                 n1.xoffset = -(oary[i]+1);\r\n>         }\r\n> Index: src/cmd/6g/peep.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/6g/peep.c\r\n> +++ b/src/cmd/6g/peep.c\r\n> @@ -843,7 +843,7 @@\r\n>                 }\r\n>                 t = copyu(p, v2, A);\r\n>                 switch(t) {\r\n> -               case 2: /* rar, cant split */\r\n> +               case 2: /* rar, can't split */\r\n>                         if(debug['P'])\r\n>                                 print(\"; %D rar; return 0\\n\", v2);\r\n>                         return 0;\r\n> Index: src/cmd/8c/peep.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/8c/peep.c\r\n> +++ b/src/cmd/8c/peep.c\r\n> @@ -403,7 +403,7 @@\r\n>                 }\r\n>                 t = copyu(p, v2, A);\r\n>                 switch(t) {\r\n> -               case 2: /* rar, cant split */\r\n> +               case 2: /* rar, can't split */\r\n>                         if(debug['P'])\r\n>                                 print(\"; %D rar; return 0\\n\", v2);\r\n>                         return 0;\r\n> Index: src/cmd/8c/txt.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/8c/txt.c\r\n> +++ b/src/cmd/8c/txt.c\r\n> @@ -963,7 +963,7 @@\r\n>         else if(n->left->op == OREGISTER)\r\n>                 idx.ptr = n->left->reg;\r\n>         else if(n->left->op != OADDR) {\r\n> -               reg[D_BP]++;    // cant be used as a base\r\n> +               reg[D_BP]++;    // can't be used as a base\r\n>                 regalloc(&nod1, &regnode, Z);\r\n>                 cgen(n->left, &nod1);\r\n>                 idx.ptr = nod1.reg;\r\n> Index: src/cmd/8g/cgen.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/8g/cgen.c\r\n> +++ b/src/cmd/8g/cgen.c\r\n> @@ -1319,7 +1319,7 @@\r\n>   * copy a composite value by moving its individual components.\r\n>   * Slices, strings and interfaces are supported.\r\n>   * nr is N when assigning a zero value.\r\n> - * return 1 if can do, 0 if cant.\r\n> + * return 1 if can do, 0 if can't.\r\n>   */\r\n>  int\r\n>  componentgen(Node *nr, Node *nl)\r\n> Index: src/cmd/8g/peep.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/8g/peep.c\r\n> +++ b/src/cmd/8g/peep.c\r\n> @@ -608,7 +608,7 @@\r\n>                 }\r\n>                 t = copyu(p, v2, A);\r\n>                 switch(t) {\r\n> -               case 2: /* rar, cant split */\r\n> +               case 2: /* rar, can't split */\r\n>                         if(debug['P'])\r\n>                                 print(\"; %D rar; return 0\\n\", v2);\r\n>                         return 0;\r\n> Index: src/cmd/8g/reg.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/8g/reg.c\r\n> +++ b/src/cmd/8g/reg.c\r\n> @@ -1824,7 +1824,7 @@\r\n>  static void\r\n>  fixtemp(Prog *firstp)\r\n>  {\r\n> -       static uint8 counts[1<<16]; // A hash table to count variable\r\n> occurences.\r\n> +       static uint8 counts[1<<16]; // A hash table to count variable\r\n> occurrences.\r\n>         int i;\r\n>         Prog *p, *p2;\r\n>         uint32 h;\r\n> Index: src/cmd/cc/funct.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/cc/funct.c\r\n> +++ b/src/cmd/cc/funct.c\r\n> @@ -235,7 +235,7 @@\r\n>         return 0;\r\n>\r\n>  bad:\r\n> -       diag(n, \"cant rewrite typestr for op %O\\n\", o);\r\n> +       diag(n, \"can't rewrite typestr for op %O\\n\", o);\r\n>         prtree(n, \"isfunct\");\r\n>         n->type = T;\r\n>         return 1;\r\n> Index: src/cmd/cc/lexbody\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/cc/lexbody\r\n> +++ b/src/cmd/cc/lexbody\r\n> @@ -762,7 +762,7 @@\r\n>                 return;\r\n>         }\r\n>         fr = frexp(native, &exp);\r\n> -       f = 2097152L;           /* shouldnt use fp constants here */\r\n> +       f = 2097152L;           /* shouldn't use fp constants here */\r\n>         fr = modf(fr*f, &ho);\r\n>         ieee->h = ho;\r\n>         ieee->h &= 0xfffffL;\r\n> Index: src/cmd/cc/pgen.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/cc/pgen.c\r\n> +++ b/src/cmd/cc/pgen.c\r\n> @@ -75,7 +75,7 @@\r\n>          */\r\n>         for(n1 = nn;; n1 = n1->left) {\r\n>                 if(n1 == Z) {\r\n> -                       diag(nn, \"cant find function name\");\r\n> +                       diag(nn, \"can't find function name\");\r\n>                         return;\r\n>                 }\r\n>                 if(n1->op == ONAME)\r\n> Index: src/cmd/cc/pswt.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/cc/pswt.c\r\n> +++ b/src/cmd/cc/pswt.c\r\n> @@ -156,7 +156,7 @@\r\n>                 return;\r\n>         }\r\n>         fr = frexp(native, &exp);\r\n> -       f = 2097152L;           /* shouldnt use fp constants here */\r\n> +       f = 2097152L;           /* shouldn't use fp constants here */\r\n>         fr = modf(fr*f, &ho);\r\n>         ieee->h = ho;\r\n>         ieee->h &= 0xfffffL;\r\n> Index: src/cmd/dist/plan9.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/dist/plan9.c\r\n> +++ b/src/cmd/dist/plan9.c\r\n> @@ -578,7 +578,7 @@\r\n>         return np >= ns && strcmp(p+np-ns, suffix) == 0;\r\n>  }\r\n>\r\n> -// hasprefix reports whether p begins wtih prefix.\r\n> +// hasprefix reports whether p begins with prefix.\r\n>  bool\r\n>  hasprefix(char *p, char *prefix)\r\n>  {\r\n> Index: src/cmd/dist/unix.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/dist/unix.c\r\n> +++ b/src/cmd/dist/unix.c\r\n> @@ -548,7 +548,7 @@\r\n>         return np >= ns && strcmp(p+np-ns, suffix) == 0;\r\n>  }\r\n>\r\n> -// hasprefix reports whether p begins wtih prefix.\r\n> +// hasprefix reports whether p begins with prefix.\r\n>  bool\r\n>  hasprefix(char *p, char *prefix)\r\n>  {\r\n> Index: src/cmd/gc/obj.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/gc/obj.c\r\n> +++ b/src/cmd/gc/obj.c\r\n> @@ -235,7 +235,7 @@\r\n>                 return;\r\n>         }\r\n>         fr = frexp(native, &exp);\r\n> -       f = 2097152L;           /* shouldnt use fp constants here */\r\n> +       f = 2097152L;           /* shouldn't use fp constants here */\r\n>         fr = modf(fr*f, &ho);\r\n>         h = ho;\r\n>         h &= 0xfffffL;\r\n> Index: src/cmd/gc/swt.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/gc/swt.c\r\n> +++ b/src/cmd/gc/swt.c\r\n> @@ -315,7 +315,7 @@\r\n>                 }\r\n>                 stat = concat(stat, n->nbody);\r\n>\r\n> -               // botch - shouldnt fall thru declaration\r\n> +               // botch - shouldn't fall thru declaration\r\n>                 last = stat->end->n;\r\n>                 if(last->op == OXFALL) {\r\n>                         if(typeswvar) {\r\n> Index: src/cmd/go/test.bash\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/go/test.bash\r\n> +++ b/src/cmd/go/test.bash\r\n> @@ -151,7 +151,7 @@\r\n>  fi\r\n>  rm -f test_std.list\r\n>\r\n> -# issue 4096. Validate the output of unsucessful go install foo/quxx\r\n> +# issue 4096. Validate the output of unsuccessful go install foo/quxx\r\n>  if [ $(./testgo install 'foo/quxx' 2>&1 | grep -c 'cannot find package\r\n> \"foo/quxx\" in any of') -ne 1 ] ; then\r\n>         echo 'go install foo/quxx expected error: .*cannot find package\r\n> \"foo/quxx\" in any of'\r\n>         ok=false\r\n> Index: src/cmd/ld/data.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/ld/data.c\r\n> +++ b/src/cmd/ld/data.c\r\n> @@ -367,7 +367,7 @@\r\n>  {\r\n>         Sym *s;\r\n>\r\n> -       // -d supresses dynamic loader format, so we may as well not\r\n> +       // -d suppresses dynamic loader format, so we may as well not\r\n>         // compute these sections or mark their symbols as reachable.\r\n>         if(debug['d'] && HEADTYPE != Hwindows)\r\n>                 return;\r\n> Index: src/cmd/ld/dwarf.c\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/ld/dwarf.c\r\n> +++ b/src/cmd/ld/dwarf.c\r\n> @@ -133,7 +133,7 @@\r\n>  /*\r\n>   * Defining Abbrevs.  This is hardcoded, and there will be\r\n>   * only a handful of them.  The DWARF spec places no restriction on\r\n> - * the ordering of atributes in the Abbrevs and DIEs, and we will\r\n> + * the ordering of attributes in the Abbrevs and DIEs, and we will\r\n>   * always write them out in the order of declaration in the abbrev.\r\n>   * This implementation relies on tag, attr < 127, so they serialize as\r\n>   * a char.  Higher numbered user-defined tags or attributes can be used\r\n> @@ -1646,7 +1646,7 @@\r\n>  }\r\n>\r\n>  /*\r\n> - * Generate short opcodes when possible, long ones when neccesary.\r\n> + * Generate short opcodes when possible, long ones when necessary.\r\n>   * See section 6.2.5\r\n>   */\r\n>\r\n> @@ -1938,7 +1938,7 @@\r\n>  {\r\n>         CIERESERVE = 16,\r\n>         DATAALIGNMENTFACTOR = -4,       // TODO -PtrSize?\r\n> -       FAKERETURNCOLUMN = 16           // TODO gdb6 doesnt like > 15?\r\n> +       FAKERETURNCOLUMN = 16           // TODO gdb6 doesn't like > 15?\r\n>  };\r\n>\r\n>  static void\r\n> Index: src/cmd/yacc/units.txt\r\n> ==============================**==============================**=======\r\n> --- a/src/cmd/yacc/units.txt\r\n> +++ b/src/cmd/yacc/units.txt\r\n> @@ -481,7 +481,7 @@\r\n>  mh                     millihenry\r\n>  mhz                    1e+6/sec\r\n>  mil                    1e-3 in\r\n> -millenium              1000 year\r\n> +millennium             1000 year\r\n>  minersinch             1.5 ft\u00b3/min\r\n>  minim                  1|60 fldr\r\n>  mo                     month\r\n> Index: src/libmach/6obj.c\r\n> ==============================**==============================**=======\r\n> --- a/src/libmach/6obj.c\r\n> +++ b/src/libmach/6obj.c\r\n> @@ -52,7 +52,7 @@\r\n>  {\r\n>         uchar *s = (uchar*)t;\r\n>\r\n> -       return  s[0] == (ANAME&0xff)                    /* aslo = ANAME */\r\n> +       return  s[0] == (ANAME&0xff)                    /* also = ANAME */\r\n>                 && s[1] == ((ANAME>>8)&0xff)\r\n>                 && s[2] == D_FILE                       /* type */\r\n>                 && s[3] == 1                            /* sym */\r\n> Index: src/libmach/8obj.c\r\n> ==============================**==============================**=======\r\n> --- a/src/libmach/8obj.c\r\n> +++ b/src/libmach/8obj.c\r\n> @@ -52,7 +52,7 @@\r\n>  {\r\n>         uchar *s = (uchar*)t;\r\n>\r\n> -       return  s[0] == (ANAME&0xff)                    /* aslo = ANAME */\r\n> +       return  s[0] == (ANAME&0xff)                    /* also = ANAME */\r\n>                 && s[1] == ((ANAME>>8)&0xff)\r\n>                 && s[2] == D_FILE                       /* type */\r\n>                 && s[3] == 1                            /* sym */\r\n> Index: test/chan/doubleselect.go\r\n> ==============================**==============================**=======\r\n> --- a/test/chan/doubleselect.go\r\n> +++ b/test/chan/doubleselect.go\r\n> @@ -36,7 +36,7 @@\r\n>  }\r\n>\r\n>  // mux receives the values from sender and forwards them onto another\r\n> channel.\r\n> -// It would be simplier to just have sender's four cases all be the same\r\n> +// It would be simpler to just have sender's four cases all be the same\r\n>  // channel, but this doesn't actually trigger the bug.\r\n>  func mux(out chan<- int, in <-chan int, done chan<- bool) {\r\n>         for v := range in {\r\n>\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-06-07 09:54:59.031560",
			"approval": true
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM but i must say ill miss kens lack of apostrophes\r\n",
			"disapproval": false,
			"date": "2013-06-07 15:19:27.696260",
			"approval": true
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"khr@golang.org",
				"r@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=b2d048b10cfc ***\n\nall: fix typos\n\nR=golang-dev, bradfitz, khr, r\nCC=golang-dev\nhttps://codereview.appspot.com/7461046",
			"disapproval": false,
			"date": "2013-06-09 13:50:41.610530",
			"approval": false
		}
	],
	"owner_email": "minux.ma@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "minux",
	"subject": "code review 7461046: all: fix typos",
	"created": "2013-03-03 14:36:08.948410",
	"patchsets": [
		1,
		24001,
		19002,
		3106,
		28001,
		44001,
		47001,
		52001,
		55001,
		59001
	],
	"modified": "2013-06-09 13:50:47.598940",
	"closed": true,
	"issue": 7461046
}