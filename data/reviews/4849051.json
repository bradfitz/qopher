{
	"description": "gc: inlining functions.",
	"cc": [
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"rsc@golang.org",
		"dvyukov@google.com"
	],
	"messages": [
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4849051/diff/4001/src/cmd/gc/print.c\nFile src/cmd/gc/print.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/4001/src/cmd/gc/print.c#newcode464\nsrc/cmd/gc/print.c:464: case ORETURN:\nDon't you need to delete the old ORETURN case?",
			"disapproval": false,
			"date": "2011-08-09 14:44:03.423450",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": ">\u00a0f(arg) int { return g(arg) } \u00a0where g is also inlinable.\n\nhow do you prevent\n\nf(arg) int { return f(arg) }\n\n?\n",
			"disapproval": false,
			"date": "2011-08-09 19:54:33.627399",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Aug 9, 2011 at 18:55, Russ Cox <rsc@golang.org> wrote:\n\n> On Tue, Aug 9, 2011 at 12:43, Luuk van Dijk <lvd@google.com> wrote:\n> > yes, because the new ->init may contain assignments to inlinable calls\n> > again. f(g()) has 4 possibilities, and i didnt want four paths, nor\n> > arbitrarily exclude f(g(h()))\n>\n> i think you want to do it at the top of the function,\n> so that f(g()) handles the g() in the recursion and\n> then is left to handle f.\n>\n\nbut then you dont get  f(arg) int { return g(arg) }  where g is also\ninlinable.\n\n\n>\n> by the way, there is code in gc that handles\n> the f(g()) case where you can't just memmove\n> the g results onto the f parameters.  it splits\n> them out into temporaries and then rewrites.\n> if you can trigger that (or just copy it) for the\n> inlined calls then you can eliminate that special case.\n>\n\n i saw that.  anything from the walk phase is good for inspiration and\ncopying but typically can't be called directly.  i think the version that i\nhad was already simpler than convas and ascompatte and friends.\n\nwe'll see.  let me fiddle a bit more.\n\n\n>\n> russ\n>\n",
			"disapproval": false,
			"date": "2011-08-09 19:20:36.767277",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2011-08-09 14:36:08.540184",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Aug 9, 2011 at 12:43, Luuk van Dijk <lvd@google.com> wrote:\n> yes, because the new ->init may contain assignments to inlinable calls\n> again. f(g()) has 4 possibilities, and i didnt want four paths, nor\n> arbitrarily exclude f(g(h()))\n\ni think you want to do it at the top of the function,\nso that f(g()) handles the g() in the recursion and\nthen is left to handle f.\n\nby the way, there is code in gc that handles\nthe f(g()) case where you can't just memmove\nthe g results onto the f parameters.  it splits\nthem out into temporaries and then rewrites.\nif you can trigger that (or just copy it) for the\ninlined calls then you can eliminate that special case.\n\nruss\n",
			"disapproval": false,
			"date": "2011-08-09 16:56:01.585760",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "You seem to forget to add inl.c",
			"disapproval": false,
			"date": "2011-08-09 14:45:33.643744",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Aug 9, 2011 at 15:20, Luuk van Dijk <lvd@google.com> wrote:\n>> i think you want to do it at the top of the function,\n>> so that f(g()) handles the g() in the recursion and\n>> then is left to handle f.\n>\n> but then you dont get \u00a0f(arg) int { return g(arg) } \u00a0where g is also\n> inlinable.\n\nhandle g first.\notherwise you're duplicating effort.\n\nruss\n",
			"disapproval": false,
			"date": "2011-08-09 19:42:10.378311",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Aug 9, 2011 at 16:44, <dvyukov@google.com> wrote:\n\n>\n> http://codereview.appspot.com/**4849051/diff/4001/src/cmd/gc/**print.c<http://codereview.appspot.com/4849051/diff/4001/src/cmd/gc/print.c>\n> File src/cmd/gc/print.c (right):\n>\n> http://codereview.appspot.com/**4849051/diff/4001/src/cmd/gc/**\n> print.c#newcode464<http://codereview.appspot.com/4849051/diff/4001/src/cmd/gc/print.c#newcode464>\n> src/cmd/gc/print.c:464: case ORETURN:\n> Don't you need to delete the old ORETURN case?\n\n\nmust have shown up in the merge i just did.  i'll revert changes to print.c\nthey were for debuging only.\n\n\n>\n>\n> http://codereview.appspot.com/**4849051/<http://codereview.appspot.com/4849051/>\n>\n",
			"disapproval": false,
			"date": "2011-08-09 14:45:45.644188",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "thanks for your quick review.\n\nOn Tue, Aug 9, 2011 at 18:19, <rsc@golang.org> wrote:\n\n> Looks good, but I think it can be simpler.\n>\n>\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**go.h<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/go.h>\n> File src/cmd/gc/go.h (right):\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**\n> go.h#newcode260<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/go.h#newcode260>\n> src/cmd/gc/go.h:260: NodeList*  inln;   // inf functions: copy of the body\n>\n> for use in inlining, in names: link to tmpnames currently being\n> expanded.\n> You are inconsistent about spelling inline inl vs inln.\n> (See for example all the functions in inl.c.)\n> Please standardize on one.\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**inl.c<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c>\n> File src/cmd/gc/inl.c (right):\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**\n> inl.c#newcode59<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode59>\n> src/cmd/gc/inl.c:59: void\n> caninln means fn can be inlined, so inln sounds like it means\n> you are inlining fn.  but you are actually inlining the things fn calls.\n>\n> // Inline any calls made by fn to inline functions.\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**\n> inl.c#newcode126<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode126>\n> src/cmd/gc/inl.c:126: parms = nil;\n> I think that after you set up the variables:\n>\n> for(ll = fn->dcl; ll; ll=ll->next)\n>    if(ll->n->op == ONAME)\n>        inlvar(ll->n);\n>\n> You can insert the assignments:\n>\n> body = nil;\n> if(call->op == OCALLMETH)\n>    body = list(body, nod(OAS, rcvr->inlinevar, call->left));\n> for(param p)\n>    body = list(body, nod(OAS, p->inlinevar, argxxx));\n>\n> And then copy the body, substituting ONAME nodes\n> by using ->inlinevar and rewriting ORETURN as\n> assignment to the newly introduced return variables\n> (new ones always, not the named outputs) + goto:\n>\n> label = nod(OLABEL, N, N);\n> label->sym = lookup(\".ret%d\");\n> body = inlsubstlist(fn->inlinebody, label->sym);\n> body = list(body, label);\n>\n> And then end by substituting the new return variables\n> where the function call was:\n>\n> ret = list of output inlinevars\n> switch(n->op) {\n> case OAS2FUNC:\n>    n->rlist = ret;\n>    *np = liststmt(list(body, n));\n> default:\n>    // used as expression - must be just 1\n>    n = nod(OCONVNOP, ret->n, N);\n>    n->left = ret->n;\n>    n->ninit = body;\n>    *np = n;\n> }\n>\n> The current code has many special cases that I don't\n> believe are special.\n>\n\nright, i've been trying to eliminate as many as possible.  thanks for the\nideas, i'll try em out.\n\n\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**\n> inl.c#newcode184<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode184>\n> src/cmd/gc/inl.c:184: inlnode(&n->left);\n> Is it right to do this on the stuff we just inlined?\n>\n\nyes, because the new ->init may contain assignments to inlinable calls\nagain. f(g()) has 4 possibilities, and i didnt want four paths, nor\narbitrarily exclude f(g(h()))\n\n\n> I expected this to be in the default case of the\n> switch above, or before the switch entirely.\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**\n> inl.c#newcode207<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode207>\n> src/cmd/gc/inl.c:207: inlvar(Node* var) {\n> {\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**\n> inl.c#newcode213<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode213>\n> src/cmd/gc/inl.c:213: n->sym       = lookup(namebuf);\n> s/ +/ /g\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**\n> inl.c#newcode221<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode221>\n> src/cmd/gc/inl.c:221: var->inln = list1(n);\n> Instead of overloading the inln field I'd rather have\n>\n> var->inlinevar = n;\n>\n\ni was a bit worried about unlimited introduction of fields in the node, as\nmost nodes use only a handful of them and they are pretty abundant.  but if\nyou think it's ok.\n\n\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**\n> inl.c#newcode230<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode230>\n> src/cmd/gc/inl.c:230: inlvarclear(Node* var) {\n> {\n>\n> http://codereview.appspot.com/**4849051/diff/12002/src/cmd/gc/**\n> inl.c#newcode259<http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode259>\n> src/cmd/gc/inl.c:259: inltreecopy(Node *n)\n> I think you should have two of these,\n> inlcopy (only copies) and inlsubst.\n> Right now it is doing double-duty and\n> somewhat confusing about context.\n>\n> inlcopy can leave ORETURN and ONAME\n> alone (it is a pure copy), and then\n> inlsubst can rewrite ORETURN and ONAME.\n> by preserving the ORETURN in copy,\n> the subst will be easier.\n>\n>\nthat is probably a very good idea.  i'l go try it out and ping you when it\ncompiles the tree.\n\nfor import/export i wanted to just print %#N the body on a single line in\nthe export section, and then convince the parser to just parse them, and\nthen do whatever it takes if anything, to convince typecheck that its ok to\naccess private fields from other packages. but that's probably for tomorrow.\n\n\n>\n> http://codereview.appspot.com/**4849051/<http://codereview.appspot.com/4849051/>\n>\n",
			"disapproval": false,
			"date": "2011-08-09 16:43:23.880069",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "ha! well spotted.\n\nOn Tue, Aug 9, 2011 at 16:45, <dvyukov@google.com> wrote:\n\n> You seem to forget to add inl.c\n>\n>\n> http://codereview.appspot.com/**4849051/<http://codereview.appspot.com/4849051/>\n>\n",
			"disapproval": false,
			"date": "2011-08-09 14:46:00.837458",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "mostly done.  still missing a typecheck somewhere in the generated code.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode59\nsrc/cmd/gc/inl.c:59: void\nOn 2011/08/09 16:19:19, rsc wrote:\n> caninln means fn can be inlined, so inln sounds like it means\n> you are inlining fn.  but you are actually inlining the things fn calls.\n> \n> // Inline any calls made by fn to inline functions.\n\nDone.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode126\nsrc/cmd/gc/inl.c:126: parms = nil;\nmostly done.  the label can wait b/c at the moment it's only single statement functions.\n\nOn 2011/08/09 16:19:19, rsc wrote:\n> I think that after you set up the variables:\n> \n> for(ll = fn->dcl; ll; ll=ll->next)\n>     if(ll->n->op == ONAME)\n>         inlvar(ll->n);\n> \n> You can insert the assignments:\n> \n> body = nil;\n> if(call->op == OCALLMETH)\n>     body = list(body, nod(OAS, rcvr->inlinevar, call->left));\n> for(param p)\n>     body = list(body, nod(OAS, p->inlinevar, argxxx));\n> \n> And then copy the body, substituting ONAME nodes\n> by using ->inlinevar and rewriting ORETURN as \n> assignment to the newly introduced return variables\n> (new ones always, not the named outputs) + goto:\n> \n> label = nod(OLABEL, N, N);\n> label->sym = lookup(\".ret%d\");\n> body = inlsubstlist(fn->inlinebody, label->sym);\n> body = list(body, label);\n> \n> And then end by substituting the new return variables\n> where the function call was:\n> \n> ret = list of output inlinevars\n> switch(n->op) {\n> case OAS2FUNC:\n>     n->rlist = ret;\n>     *np = liststmt(list(body, n));\n> default:\n>     // used as expression - must be just 1\n>     n = nod(OCONVNOP, ret->n, N);\n>     n->left = ret->n;\n>     n->ninit = body;\n>     *np = n;\n> }\n> \n> The current code has many special cases that I don't\n> believe are special.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode207\nsrc/cmd/gc/inl.c:207: inlvar(Node* var) {\nOn 2011/08/09 16:19:19, rsc wrote:\n> {\n\nDone.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode221\nsrc/cmd/gc/inl.c:221: var->inln = list1(n);\nOn 2011/08/09 16:19:19, rsc wrote:\n> Instead of overloading the inln field I'd rather have \n> \n> var->inlinevar = n;\n\nDone.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode230\nsrc/cmd/gc/inl.c:230: inlvarclear(Node* var) {\nOn 2011/08/09 16:19:19, rsc wrote:\n> {\n\nDone.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode259\nsrc/cmd/gc/inl.c:259: inltreecopy(Node *n)\nOn 2011/08/09 16:19:19, rsc wrote:\n> I think you should have two of these,\n> inlcopy (only copies) and inlsubst.\n> Right now it is doing double-duty and\n> somewhat confusing about context.\n> \n> inlcopy can leave ORETURN and ONAME\n> alone (it is a pure copy), and then \n> inlsubst can rewrite ORETURN and ONAME.\n> by preserving the ORETURN in copy,\n> the subst will be easier.\n\nDone.",
			"disapproval": false,
			"date": "2011-08-10 14:25:39.394810",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Looks good, but I think it can be simpler.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/go.h#newcode260\nsrc/cmd/gc/go.h:260: NodeList*\tinln;\t// inf functions: copy of the body for use in inlining, in names: link to tmpnames currently being expanded.\nYou are inconsistent about spelling inline inl vs inln.\n(See for example all the functions in inl.c.)\nPlease standardize on one.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode59\nsrc/cmd/gc/inl.c:59: void\ncaninln means fn can be inlined, so inln sounds like it means\nyou are inlining fn.  but you are actually inlining the things fn calls.\n\n// Inline any calls made by fn to inline functions.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode126\nsrc/cmd/gc/inl.c:126: parms = nil;\nI think that after you set up the variables:\n\nfor(ll = fn->dcl; ll; ll=ll->next)\n    if(ll->n->op == ONAME)\n        inlvar(ll->n);\n\nYou can insert the assignments:\n\nbody = nil;\nif(call->op == OCALLMETH)\n    body = list(body, nod(OAS, rcvr->inlinevar, call->left));\nfor(param p)\n    body = list(body, nod(OAS, p->inlinevar, argxxx));\n\nAnd then copy the body, substituting ONAME nodes\nby using ->inlinevar and rewriting ORETURN as \nassignment to the newly introduced return variables\n(new ones always, not the named outputs) + goto:\n\nlabel = nod(OLABEL, N, N);\nlabel->sym = lookup(\".ret%d\");\nbody = inlsubstlist(fn->inlinebody, label->sym);\nbody = list(body, label);\n\nAnd then end by substituting the new return variables\nwhere the function call was:\n\nret = list of output inlinevars\nswitch(n->op) {\ncase OAS2FUNC:\n    n->rlist = ret;\n    *np = liststmt(list(body, n));\ndefault:\n    // used as expression - must be just 1\n    n = nod(OCONVNOP, ret->n, N);\n    n->left = ret->n;\n    n->ninit = body;\n    *np = n;\n}\n\nThe current code has many special cases that I don't\nbelieve are special.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode184\nsrc/cmd/gc/inl.c:184: inlnode(&n->left);\nIs it right to do this on the stuff we just inlined?\nI expected this to be in the default case of the\nswitch above, or before the switch entirely.\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode207\nsrc/cmd/gc/inl.c:207: inlvar(Node* var) {\n{\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode213\nsrc/cmd/gc/inl.c:213: n->sym\t   = lookup(namebuf);\ns/ +/ /g\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode221\nsrc/cmd/gc/inl.c:221: var->inln = list1(n);\nInstead of overloading the inln field I'd rather have \n\nvar->inlinevar = n;\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode230\nsrc/cmd/gc/inl.c:230: inlvarclear(Node* var) {\n{\n\nhttp://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode259\nsrc/cmd/gc/inl.c:259: inltreecopy(Node *n)\nI think you should have two of these,\ninlcopy (only copies) and inlsubst.\nRight now it is doing double-duty and\nsomewhat confusing about context.\n\ninlcopy can leave ORETURN and ONAME\nalone (it is a pure copy), and then \ninlsubst can rewrite ORETURN and ONAME.\nby preserving the ORETURN in copy,\nthe subst will be easier.",
			"disapproval": false,
			"date": "2011-08-09 16:19:18.630589",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Aug 9, 2011 at 21:42, Russ Cox <rsc@golang.org> wrote:\n\n> On Tue, Aug 9, 2011 at 15:20, Luuk van Dijk <lvd@google.com> wrote:\n> >> i think you want to do it at the top of the function,\n> >> so that f(g()) handles the g() in the recursion and\n> >> then is left to handle f.\n> >\n> > but then you dont get  f(arg) int { return g(arg) }  where g is also\n> > inlinable.\n>\n> handle g first.\n> otherwise you're duplicating effort.\n>\n\nthen i have to do that in caninl(), b/c in the inlnode recursion as it is\nnow, there is no g.\n\n\n>\n> russ\n>\n",
			"disapproval": false,
			"date": "2011-08-09 19:53:33.981303",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "i was just thinking the same thing.\n\nOn Tue, Aug 9, 2011 at 21:54, Russ Cox <rsc@golang.org> wrote:\n\n> > f(arg) int { return g(arg) }  where g is also inlinable.\n>\n> how do you prevent\n>\n> f(arg) int { return f(arg) }\n>\n> ?\n>\n",
			"disapproval": false,
			"date": "2011-08-09 20:01:46.975951",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2011/08/10 14:25:39, lvd wrote:\n> mostly done.  still missing a typecheck somewhere in the generated code.\n\noh that turns out to be the case   anyfn(inlineablefn(...))  which is not happy with an OBLOCK substituted for the inlineable call.\n\n> \n> http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c\n> File src/cmd/gc/inl.c (right):\n> \n> http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode59\n> src/cmd/gc/inl.c:59: void\n> On 2011/08/09 16:19:19, rsc wrote:\n> > caninln means fn can be inlined, so inln sounds like it means\n> > you are inlining fn.  but you are actually inlining the things fn calls.\n> > \n> > // Inline any calls made by fn to inline functions.\n> \n> Done.\n> \n> http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode126\n> src/cmd/gc/inl.c:126: parms = nil;\n> mostly done.  the label can wait b/c at the moment it's only single statement\n> functions.\n> \n> On 2011/08/09 16:19:19, rsc wrote:\n> > I think that after you set up the variables:\n> > \n> > for(ll = fn->dcl; ll; ll=ll->next)\n> >     if(ll->n->op == ONAME)\n> >         inlvar(ll->n);\n> > \n> > You can insert the assignments:\n> > \n> > body = nil;\n> > if(call->op == OCALLMETH)\n> >     body = list(body, nod(OAS, rcvr->inlinevar, call->left));\n> > for(param p)\n> >     body = list(body, nod(OAS, p->inlinevar, argxxx));\n> > \n> > And then copy the body, substituting ONAME nodes\n> > by using ->inlinevar and rewriting ORETURN as \n> > assignment to the newly introduced return variables\n> > (new ones always, not the named outputs) + goto:\n> > \n> > label = nod(OLABEL, N, N);\n> > label->sym = lookup(\".ret%d\");\n> > body = inlsubstlist(fn->inlinebody, label->sym);\n> > body = list(body, label);\n> > \n> > And then end by substituting the new return variables\n> > where the function call was:\n> > \n> > ret = list of output inlinevars\n> > switch(n->op) {\n> > case OAS2FUNC:\n> >     n->rlist = ret;\n> >     *np = liststmt(list(body, n));\n> > default:\n> >     // used as expression - must be just 1\n> >     n = nod(OCONVNOP, ret->n, N);\n> >     n->left = ret->n;\n> >     n->ninit = body;\n> >     *np = n;\n> > }\n> > \n> > The current code has many special cases that I don't\n> > believe are special.\n> \n> http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode207\n> src/cmd/gc/inl.c:207: inlvar(Node* var) {\n> On 2011/08/09 16:19:19, rsc wrote:\n> > {\n> \n> Done.\n> \n> http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode221\n> src/cmd/gc/inl.c:221: var->inln = list1(n);\n> On 2011/08/09 16:19:19, rsc wrote:\n> > Instead of overloading the inln field I'd rather have \n> > \n> > var->inlinevar = n;\n> \n> Done.\n> \n> http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode230\n> src/cmd/gc/inl.c:230: inlvarclear(Node* var) {\n> On 2011/08/09 16:19:19, rsc wrote:\n> > {\n> \n> Done.\n> \n> http://codereview.appspot.com/4849051/diff/12002/src/cmd/gc/inl.c#newcode259\n> src/cmd/gc/inl.c:259: inltreecopy(Node *n)\n> On 2011/08/09 16:19:19, rsc wrote:\n> > I think you should have two of these,\n> > inlcopy (only copies) and inlsubst.\n> > Right now it is doing double-duty and\n> > somewhat confusing about context.\n> > \n> > inlcopy can leave ORETURN and ONAME\n> > alone (it is a pure copy), and then \n> > inlsubst can rewrite ORETURN and ONAME.\n> > by preserving the ORETURN in copy,\n> > the subst will be easier.\n> \n> Done.",
			"disapproval": false,
			"date": "2011-08-10 14:41:19.089387",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Just a quick first skim.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/go.h#newcode946\nsrc/cmd/gc/go.h:946: void\tcaninl(Node* fn);\ns/* / */g\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode15\nsrc/cmd/gc/inl.c:15: static void\tinlconv2stmt(Node* n);\ns/* / */g\n\nIt happens a bunch of times throughout this file.\nToo much C++ for you.  :-)\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/lex.c\nFile src/cmd/gc/lex.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/lex.c#newcode276\nsrc/cmd/gc/lex.c:276: #if 0\nPlease use /* */\nAmong other things, #if 0 will break on Plan 9.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/walk.c\nFile src/cmd/gc/walk.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/walk.c#newcode188\nsrc/cmd/gc/walk.c:188: walkstmtlist(n->ninit);\nHmm.  This is not right.  The walk is supposed to\nvisit things in the order they happen, and the ninit\nhappens first.  Also, the stuff that got added by\nwalkexpr to *init should already have been walked.\nI think this should be\n\nwalkstmtlist(n->ninit);\ninit = n->ninit;\nn->ninit = nil;\nwalkexpr(&n, &init);\nn->ninit = concat(init, n->ninit);\n\nwith no final walkstmtlist.  In fact the starting\nwalkstmtlist can be hoisted out above the switch.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/walk.c#newcode367\nsrc/cmd/gc/walk.c:367: \nIt seems likely that there should be a general\n\nif(n->ninit != nil) {\n    walkstmtlist(n->ninit);\n    *init = concat(*init, n->ninit);\n    n->ninit = nil;\n}\n\nand then it doesn't have to be in the individual cases.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/walk.c#newcode1182\nsrc/cmd/gc/walk.c:1182: if (init && *init)  // hammer it down dammit\nIt will be interesting to see if the suggestions\nabove make this unnecessary.  \n\nThe idea is that things appended to *init are\nalready walked.  If you find a place where that is\nnot the case, we should fix that.",
			"disapproval": false,
			"date": "2011-08-24 15:38:21.576004",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, dvyukov@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-08-23 18:25:21.605779",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "This looks very nice.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode9\nsrc/cmd/gc/inl.c:9: //\nmake blank line\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode11\nsrc/cmd/gc/inl.c:11: \nadd comment, leave work for later\n\n// TODO: once general case is solid, simplify trivial rewrites\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode20\nsrc/cmd/gc/inl.c:20: static Node*\tinltreecopy(Node *n);\ns/tree//g\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode44\nsrc/cmd/gc/inl.c:44: if (fn->type->isddd)  // TODO\nFeel free to drop the TODO.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode53\nsrc/cmd/gc/inl.c:53: case OAS2:\ncase OAS2:\ncase OAS2FUNC:\ncase OAS2MAPR:\ncase OAS2MAPW:\ncase OAS2RECV:\ncase OAS2DOTTYPE:\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode62\nsrc/cmd/gc/inl.c:62: if (debug['W']>1) print(\"can inline %#N as: %#T { %#N }\\n\", fn->nname, fn->type, fn->inl->n);\nmultiline\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode67\nsrc/cmd/gc/inl.c:67: // recursively expand inlinable bodies up to 4 times\nThis is a very scary rule.  Please delete.\nWe can discuss extensions after basics work.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode79\nsrc/cmd/gc/inl.c:79: inlnode(&fn);\nIt's scary to see a possible function getting replaced here.\ninlnodelist(fn->nbody)\n?\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode104\nsrc/cmd/gc/inl.c:104: return;\nCannot inline the defer or go call,\nbut can inline the argument evaluations.\nFine to leave out for now.\nI think I would pick it off by setting\n\nn->left->etype = n->op\n\nduring a typecheck of ODEFER or OPROC (or even right here)\nand then you can look for it in the OCALLMETH etc.\n\ncase OCALLFUNC:\ncase OCALLINTER:\ncase OCALLMETH:\n    if(n->op == ODEFER || n->op == OPROC)\n        break;\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode109\nsrc/cmd/gc/inl.c:109: if (l->n->op == OINLCALL)\nThis gets pretty repetitive.  I wonder if the\ninlnode and inlnodelist functions should have\na parameter that gets passed down to mkinlcall\nto say what the context is.\n\nIt would simplify this section to something like\n\ninlnodelist(n->ninit, inlconv2stmt);\ninlnode(&n->left, inlconv2expr);\ninlnode(&n->right, inlconv2expr);\n\nYou could pass nil to not convert, as when\nyou need to do more OINLCALL checks like for\nORETURN.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode139\nsrc/cmd/gc/inl.c:139: case OCALLINTER:\n(harmless but) delete\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode199\nsrc/cmd/gc/inl.c:199: if (debug['W']>1) print(\"%L:call to func %#N\\n\", n->lineno, n->left);\nmultiline\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode203\nsrc/cmd/gc/inl.c:203: if (debug['W']>1) print(\"%L:call to method %#N\\n\", n->lineno, n->left->right);\nmultiline\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode313\nsrc/cmd/gc/inl.c:313: if (debug['W']>1) dump(\"After inlining\", *np);\nmultiline\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode339\nsrc/cmd/gc/inl.c:339: snprint(namebuf, sizeof(namebuf), \".r%.4d\", statuniqgen++);\nI'd pass in the number to retvar.  Then the return values\nare named .r0 .r1 .r2 for three results, which will\nbe easier to read.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode383\nsrc/cmd/gc/inl.c:383: m = n;\neven better: return n;\nand then the default doesn't need\nto be part of the switch.\nsame below.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/lex.c\nFile src/cmd/gc/lex.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/lex.c#newcode271\nsrc/cmd/gc/lex.c:271: // Find functions that can be inlined and clone them before walk expands it.\nThere will need to be a flag to enable this,\nuntil we have cross-package inlining working\n(which we should save for another CL).\nI don't want to create a performance incentive\nthat will affect where people draw package \nboundaries: whatever we enable needs to work\nequally well within and across packages.",
			"disapproval": false,
			"date": "2011-08-24 16:26:08.784508",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Aug 24, 2011 at 18:26, <rsc@golang.org> wrote:\n\n> This looks very nice.\n>\n>\nthanks.  re below: all good ideas, will do.\n\nin codereview i see comments in walk but not here.  strange. anyway: thx for\nthe walk hint, thats what i needed.\n\n\n>\n>\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**inl.c<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c>\n> File src/cmd/gc/inl.c (right):\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode9<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode9>\n> src/cmd/gc/inl.c:9: //\n> make blank line\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode11<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode11>\n> src/cmd/gc/inl.c:11:\n> add comment, leave work for later\n>\n> // TODO: once general case is solid, simplify trivial rewrites\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode20<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode20>\n> src/cmd/gc/inl.c:20: static Node*       inltreecopy(Node *n);\n> s/tree//g\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode44<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode44>\n> src/cmd/gc/inl.c:44: if (fn->type->isddd)  // TODO\n> Feel free to drop the TODO.\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode53<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode53>\n> src/cmd/gc/inl.c:53: case OAS2:\n> case OAS2:\n> case OAS2FUNC:\n> case OAS2MAPR:\n> case OAS2MAPW:\n> case OAS2RECV:\n> case OAS2DOTTYPE:\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode62<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode62>\n> src/cmd/gc/inl.c:62: if (debug['W']>1) print(\"can inline %#N as: %#T {\n> %#N }\\n\", fn->nname, fn->type, fn->inl->n);\n> multiline\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode67<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode67>\n> src/cmd/gc/inl.c:67: // recursively expand inlinable bodies up to 4\n> times\n> This is a very scary rule.  Please delete.\n> We can discuss extensions after basics work.\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode79<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode79>\n> src/cmd/gc/inl.c:79: inlnode(&fn);\n> It's scary to see a possible function getting replaced here.\n> inlnodelist(fn->nbody)\n> ?\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode104<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode104>\n> src/cmd/gc/inl.c:104: return;\n> Cannot inline the defer or go call,\n> but can inline the argument evaluations.\n> Fine to leave out for now.\n> I think I would pick it off by setting\n>\n> n->left->etype = n->op\n>\n> during a typecheck of ODEFER or OPROC (or even right here)\n> and then you can look for it in the OCALLMETH etc.\n>\n> case OCALLFUNC:\n> case OCALLINTER:\n> case OCALLMETH:\n>    if(n->op == ODEFER || n->op == OPROC)\n>        break;\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode109<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode109>\n> src/cmd/gc/inl.c:109: if (l->n->op == OINLCALL)\n> This gets pretty repetitive.  I wonder if the\n> inlnode and inlnodelist functions should have\n> a parameter that gets passed down to mkinlcall\n> to say what the context is.\n>\n> It would simplify this section to something like\n>\n> inlnodelist(n->ninit, inlconv2stmt);\n> inlnode(&n->left, inlconv2expr);\n> inlnode(&n->right, inlconv2expr);\n>\n> You could pass nil to not convert, as when\n> you need to do more OINLCALL checks like for\n> ORETURN.\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode139<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode139>\n> src/cmd/gc/inl.c:139: case OCALLINTER:\n> (harmless but) delete\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode199<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode199>\n> src/cmd/gc/inl.c:199: if (debug['W']>1) print(\"%L:call to func %#N\\n\",\n> n->lineno, n->left);\n> multiline\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode203<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode203>\n> src/cmd/gc/inl.c:203: if (debug['W']>1) print(\"%L:call to method %#N\\n\",\n> n->lineno, n->left->right);\n> multiline\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode313<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode313>\n> src/cmd/gc/inl.c:313: if (debug['W']>1) dump(\"After inlining\", *np);\n> multiline\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode339<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode339>\n> src/cmd/gc/inl.c:339: snprint(namebuf, sizeof(namebuf), \".r%.4d\",\n> statuniqgen++);\n> I'd pass in the number to retvar.  Then the return values\n> are named .r0 .r1 .r2 for three results, which will\n> be easier to read.\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> inl.c#newcode383<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode383>\n> src/cmd/gc/inl.c:383: m = n;\n> even better: return n;\n> and then the default doesn't need\n> to be part of the switch.\n> same below.\n>\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**lex.c<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/lex.c>\n> File src/cmd/gc/lex.c (right):\n>\n> http://codereview.appspot.com/**4849051/diff/39001/src/cmd/gc/**\n> lex.c#newcode271<http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/lex.c#newcode271>\n> src/cmd/gc/lex.c:271: // Find functions that can be inlined and clone\n> them before walk expands it.\n> There will need to be a flag to enable this,\n> until we have cross-package inlining working\n> (which we should save for another CL).\n> I don't want to create a performance incentive\n> that will affect where people draw package\n> boundaries: whatever we enable needs to work\n> equally well within and across packages.\n>\n>\n> http://codereview.appspot.com/**4849051/<http://codereview.appspot.com/4849051/>\n>\n",
			"disapproval": false,
			"date": "2011-08-25 06:29:18.378416",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "mostly done or about to.  the walk/init suggestion worked.  most packages compile and some even test fine, but cgo crashes, which i narrowed down to something that happens when inlining is switched on for go/parser/\n\nddd functions cant be detected as fn->type->isddd, so now that happens much later.\n\ni'll ping you when it's ready for another look.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode79\nsrc/cmd/gc/inl.c:79: inlnode(&fn);\nOn 2011/08/24 16:26:08, rsc wrote:\n> It's scary to see a possible function getting replaced here.\n> inlnodelist(fn->nbody)\n> ?\n\nthen you dont get the inlconv2stmt, unless i add that explicitly.  instead i add a fatal check here if fn actually changed\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode104\nsrc/cmd/gc/inl.c:104: return;\nOn 2011/08/24 16:26:08, rsc wrote:\n> Cannot inline the defer or go call,\n> but can inline the argument evaluations.\n> Fine to leave out for now.\n> I think I would pick it off by setting\n> \n> n->left->etype = n->op\n> \n> during a typecheck of ODEFER or OPROC (or even right here)\n> and then you can look for it in the OCALLMETH etc.\n> \n> case OCALLFUNC:\n> case OCALLINTER:\n> case OCALLMETH:\n>     if(n->op == ODEFER || n->op == OPROC)\n>         break;\n>     \n\nDone.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode109\nsrc/cmd/gc/inl.c:109: if (l->n->op == OINLCALL)\nOn 2011/08/24 16:26:08, rsc wrote:\n> This gets pretty repetitive.  I wonder if the\n> inlnode and inlnodelist functions should have\n> a parameter that gets passed down to mkinlcall\n> to say what the context is.\n> \n> It would simplify this section to something like\n> \n\ni'll think about it.  it's also nice to have it all here, some of them have to.\n\n> inlnodelist(n->ninit, inlconv2stmt);\n> inlnode(&n->left, inlconv2expr);\n> inlnode(&n->right, inlconv2expr);\n> \n> You could pass nil to not convert, as when\n> you need to do more OINLCALL checks like for\n> ORETURN.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode139\nsrc/cmd/gc/inl.c:139: case OCALLINTER:\nOn 2011/08/24 16:26:08, rsc wrote:\n> (harmless but) delete\n\n?  arguments to interface calls can be inlined calls themselves, no?\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode383\nsrc/cmd/gc/inl.c:383: m = n;\nOn 2011/08/24 16:26:08, rsc wrote:\n> even better: return n;\n> and then the default doesn't need\n> to be part of the switch.\n> same below.\n\nDone.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/lex.c\nFile src/cmd/gc/lex.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/lex.c#newcode271\nsrc/cmd/gc/lex.c:271: // Find functions that can be inlined and clone them before walk expands it.\nOn 2011/08/24 16:26:08, rsc wrote:\n> There will need to be a flag to enable this,\n\n-l was free.\n\n> until we have cross-package inlining working\n> (which we should save for another CL).\n> I don't want to create a performance incentive\n> that will affect where people draw package \n> boundaries: whatever we enable needs to work\n> equally well within and across packages.\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/lex.c#newcode276\nsrc/cmd/gc/lex.c:276: #if 0\nOn 2011/08/24 15:38:21, rsc wrote:\n> Please use /* */\n> Among other things, #if 0 will break on Plan 9.\n\nits just my working copy, would never check that in\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/walk.c\nFile src/cmd/gc/walk.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/walk.c#newcode1182\nsrc/cmd/gc/walk.c:1182: if (init && *init)  // hammer it down dammit\nOn 2011/08/24 15:38:21, rsc wrote:\n> It will be interesting to see if the suggestions\n> above make this unnecessary.  \n\nyep, all seems to work\n\n> \n> The idea is that things appended to *init are\n> already walked.  If you find a place where that is\n> not the case, we should fix that.",
			"disapproval": false,
			"date": "2011-08-25 11:41:17.664532",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/4849051/diff/39001/src/cmd/gc/inl.c#newcode139\nsrc/cmd/gc/inl.c:139: case OCALLINTER:\nOn 2011/08/25 11:41:17, lvd wrote:\n> On 2011/08/24 16:26:08, rsc wrote:\n> > (harmless but) delete\n> \n> ?  arguments to interface calls can be inlined calls themselves, no?\n\nright, never mind.  i was reading this wrong.",
			"disapproval": false,
			"date": "2011-08-25 13:23:29.061142",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Abandoned ***",
			"disapproval": false,
			"date": "2011-11-22 22:03:08.582137",
			"approval": false
		}
	],
	"owner_email": "lvd@google.com",
	"private": false,
	"base_url": "",
	"owner": "lvd",
	"subject": "code review 4849051: gc: inlining functions.",
	"created": "2011-08-09 14:35:49.077801",
	"patchsets": [
		1,
		1001,
		4001,
		12001,
		12002,
		19001,
		21001,
		24001,
		27001,
		31001,
		25006,
		33001,
		35001,
		38001,
		33002,
		39001,
		45001,
		48001,
		51001
	],
	"modified": "2011-11-22 22:03:10.136177",
	"closed": true,
	"issue": 4849051
}