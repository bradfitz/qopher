{
	"description": "",
	"cc": [
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"r@golang.org",
		"rsc@golang.org",
		"rogpeppe@gmail.com"
	],
	"messages": [
		{
			"sender": "sam.thorogood@gmail.com",
			"recipients": [
				"sam.thorogood@gmail.com",
				"r@golang.org",
				"rsc@golang.org",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hi! As per some previous discussions, here is an initial part of my RE2 implementation, done in Go.\n\nI've extracted out a small (~550 lines vs ~1650 lines) part of my sre2 library, already ostensibly hosted here: http://code.google.com/p/sre2\nAs well as removing large chunks of the code for an initial review, I've made some small changes / added comments in this review, so it's not a direct port of what's available on Google Code currently.\n\nFWIW, the version hosted on Google Code already implements the entire RE2 spec, sans the '\\C' operator (which PCRE chokes on in some 'modes' anyway).\n\nI've actually omitted tests at this point; they are currently all bundled up into a single file in the existing code. If it's desirable (and it probably is) I can rework them to be more specific to each component and push them back out along with this review.",
			"disapproval": false,
			"date": "2010-09-21 05:45:03.888676",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"sam.thorogood@gmail.com",
				"r@golang.org",
				"rsc@golang.org",
				"reply@codereview.appspotmail.com"
			],
			"text": "i only had time to look at a bit of this, and none of the implementation. more tomorrow.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/ascii.go\nFile sre2-review/ascii.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/ascii.go#newcode1\nsre2-review/ascii.go:1: package sre2\nwhat is the 's' for?  in other words, how about package re2?\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/ascii.go#newcode7\nsre2-review/ascii.go:7: // Notably, Perl character classes should match to the following ASCII classes:\ns/ to//\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/ascii.go#newcode16\nsre2-review/ascii.go:16: var _alnum = []unicode.Range{\nwhy the underscores?\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/data.go\nFile sre2-review/data.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/data.go#newcode6\nsre2-review/data.go:6: \ndelete blank line, for godoc\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go\nFile sre2-review/regexp.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode1\nsre2-review/regexp.go:1: package sre2\nsomewhere there should be a package comment\n\nalso think about licensing clauses etc\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode43\nsre2-review/regexp.go:43: // Describes an instruction type for regexp's internal state machine.\nthroughout: these are not for godoc but it's good to follow the conventions anyway:\n\n//instrMode describes ...\n\nthink of the difference this style makes if you do 'grep instrMode *.go'\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode48\nsre2-review/regexp.go:48: kSplit        instrMode = iota // proceed down out & out1\nthis k thing is google-specific and annoying to me, but it's your call.\nif anything, it's an iSplit or something like that because it's for instrMode.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode49\nsre2-review/regexp.go:49: kAltBegin                      // begin of alt section, i.e. '('\n( isn't necessary for an alt, so the comment is misleading\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode61\nsre2-review/regexp.go:61: bNone            boundaryMode = iota\nhere it's b not k. you already agree.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode90\nsre2-review/regexp.go:90: // This provides a string-representation of any given instruction.\ns/-/ /\n\nanyway it's a weird comment. 'any given X' applies to any given method. :)\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode92\nsre2-review/regexp.go:92: str := fmt.Sprintf(\"{%d\", i.idx)\nit's not important, because it's for debugging, so don't do what i'm suggesting...\n\nbut when you're building a big string like this for real code, use a bytes.Buffer to accumulate it and return buf.String().  it's far fewer allocations.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode186\nsre2-review/regexp.go:186: response := fmt.Sprintf(\"could not parse `%s`, error: %s\", src, x)\n`%s` should perhaps be %#q, or else something not go-specific like <%s>\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/submatch.go\nFile sre2-review/submatch.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/submatch.go#newcode4\nsre2-review/submatch.go:4: \ndelete blank line, for godoc",
			"disapproval": false,
			"date": "2010-09-21 06:39:23.453268",
			"approval": false
		},
		{
			"sender": "sam.thorogood@gmail.com",
			"recipients": [
				"sam.thorogood@gmail.com",
				"r@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "I'm adding golang-dev to this existing review. This is the initial workings of a native RE2 library, written in Go.\n\nThere is a feature-complete and usable version of this already checked in here: http://code.google.com/p/sre2\nThe purpose of this review is to break it up into smaller parts to be reviewed 'in the open' to both improve the quality of the code, and potentially ready it for introduction into Go's standard package library.",
			"disapproval": false,
			"date": "2010-09-22 07:02:15.906658",
			"approval": false
		},
		{
			"sender": "sam.thorogood@gmail.com",
			"recipients": [
				"sam.thorogood@gmail.com",
				"r@golang.org",
				"rsc@golang.org",
				"reply@codereview.appspotmail.com"
			],
			"text": "Thanks for the initial review.\nDo you have opinions regarding whether this code should be reviewed in the open? I'm happy to send it along to golang-dev@googlegroups.com if you think it's a good idea.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/ascii.go\nFile sre2-review/ascii.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/ascii.go#newcode1\nsre2-review/ascii.go:1: package sre2\nOn 2010/09/21 06:39:23, r wrote:\n> what is the 's' for?  in other words, how about package re2?\n\nDone. Again, this was kind of because I didn't want to assume this code would end up being the canonical RE2. However, since this code is basically a review branch, I've changed it here and the Google Code version can remain sre2 (FWIW, 's' = 'Sam' or 'Simple').\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/ascii.go#newcode7\nsre2-review/ascii.go:7: // Notably, Perl character classes should match to the following ASCII classes:\nOn 2010/09/21 06:39:23, r wrote:\n> s/ to//\n\nDone.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/ascii.go#newcode16\nsre2-review/ascii.go:16: var _alnum = []unicode.Range{\nOn 2010/09/21 06:39:23, r wrote:\n> why the underscores?\n\nThis was inspired by unicode/tables.go, which does a similar thing for unicode sets (e.g. _Lm _Ll etc). I've no particular preference.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/data.go\nFile sre2-review/data.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/data.go#newcode6\nsre2-review/data.go:6: \nOn 2010/09/21 06:39:23, r wrote:\n> delete blank line, for godoc\n\nDone.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go\nFile sre2-review/regexp.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode1\nsre2-review/regexp.go:1: package sre2\nOn 2010/09/21 06:39:23, r wrote:\n> somewhere there should be a package comment\n> \n\nI'll think about this and mail it out later.\n\n> also think about licensing clauses etc\n> \n\nCurrently, the Google Code project uses the New BSD License. It probably depends where the code ends up; if it's in Go's source tree I'll happily adhere to that.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode43\nsre2-review/regexp.go:43: // Describes an instruction type for regexp's internal state machine.\nOn 2010/09/21 06:39:23, r wrote:\n> throughout: these are not for godoc but it's good to follow the conventions\n> anyway:\n> \n> //instrMode describes ...\n> \n> think of the difference this style makes if you do 'grep instrMode *.go'\n> \n\nokay, thanks for the suggestion - I had noticed this in many of the standard packages. I've updated this in a couple of places and will keep it in mind as we go along.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode48\nsre2-review/regexp.go:48: kSplit        instrMode = iota // proceed down out & out1\nOn 2010/09/21 06:39:23, r wrote:\n> this k thing is google-specific and annoying to me, but it's your call.\n> if anything, it's an iSplit or something like that because it's for instrMode.\n\nI've changed it to iSplit/etc. I guess I'm trying to avoid pollution by just calling them 'split', 'altEnd' etc, and a short prefix helps in trying to make it obvious they're explicitly intended to be enum-like values.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode49\nsre2-review/regexp.go:49: kAltBegin                      // begin of alt section, i.e. '('\nOn 2010/09/21 06:39:23, r wrote:\n> ( isn't necessary for an alt, so the comment is misleading\n\nDone.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode90\nsre2-review/regexp.go:90: // This provides a string-representation of any given instruction.\nOn 2010/09/21 06:39:23, r wrote:\n> s/-/ /\n> \n> anyway it's a weird comment. 'any given X' applies to any given method. :)\n\nChanged to \"Describes the given instr in a human-readable format for debugging\".\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode92\nsre2-review/regexp.go:92: str := fmt.Sprintf(\"{%d\", i.idx)\nOn 2010/09/21 06:39:23, r wrote:\n> it's not important, because it's for debugging, so don't do what i'm\n> suggesting...\n> \n> but when you're building a big string like this for real code, use a\n> bytes.Buffer to accumulate it and return buf.String().  it's far fewer\n> allocations.\n\nThat was pretty much my thought when I wrote this bit. I've added a TODO to fix this later, it's not unreasonable.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/regexp.go#newcode186\nsre2-review/regexp.go:186: response := fmt.Sprintf(\"could not parse `%s`, error: %s\", src, x)\nOn 2010/09/21 06:39:23, r wrote:\n> `%s` should perhaps be %#q, or else something not go-specific like <%s>\n> \n\nI wasn't aware of %#q. It's a great fit.\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/submatch.go\nFile sre2-review/submatch.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/2001/sre2-review/submatch.go#newcode4\nsre2-review/submatch.go:4: \nOn 2010/09/21 06:39:23, r wrote:\n> delete blank line, for godoc\n\ndone, updated comment slightly to refer to the expected output of the method.",
			"disapproval": false,
			"date": "2010-09-22 04:56:36.054059",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "the underscores in the unicode package hide upper-case names that come\ndirectly from unicode.  your variables are already lower-case and\ntherefore private.\n\nwe can do this in public if you like.\n\n-rob\n",
			"disapproval": false,
			"date": "2010-09-22 05:24:46.084059",
			"approval": false
		},
		{
			"sender": "sam.thorogood@gmail.com",
			"recipients": [
				"sam.thorogood@gmail.com",
				"r@golang.org",
				"rsc@golang.org",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2010/09/22 05:24:46, r wrote:\n> the underscores in the unicode package hide upper-case names that come\n> directly from unicode.  your variables are already lower-case and\n> therefore private.\n> \n\nSo, after pondering this for a little while, I somewhat like the idea of having an underscore: I'm trying to pre-prepare variables so I don't have to inline them into the map definition, but otherwise I'm not overly interested in accessing them directly. The underscore seems like a simple hint for that.\n\n(also, e.g. 'print' is a keyword so I'd have to come up with some prefix for it anyway).\n\n> we can do this in public if you like.\n> \n> -rob\n>",
			"disapproval": false,
			"date": "2010-09-22 06:59:47.888576",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "print is not a keyword, but the underscores are fine.\n\n-rob\n",
			"disapproval": false,
			"date": "2010-09-22 07:01:13.492725",
			"approval": false
		},
		{
			"sender": "sam.thorogood@gmail.com",
			"recipients": [
				"sam.thorogood@gmail.com",
				"r@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2010/09/22 07:01:13, r wrote:\n> print is not a keyword, but the underscores are fine.\n> \n> -rob\n\nadg has asked me to ping this CL.\n\nTo restate my aim with this initial review; I want to break up SRE2 into some smaller components. This first review is basically the following components;\n- regexp struct and states\n- simple matcher (non-submatches) to run patterns on the regexp\n- other boilerplate including simple public interface (MatchIndex and Match)\n\nThings that are missing;\n- the entire parser (including code to build individual rune matchers)\n- complex matcher that cares about submatches\n\nThings that could be added to this review;\n- there's no tests since they were built for the entire package; it might make sense to write a couple of tests that manually construct regexp's and test them on the simple matcher",
			"disapproval": false,
			"date": "2010-10-20 04:47:09.568152",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "the names are still not right.\nalt is short for alternation.  x|y|z is an alternation.\nit has nothing to do with parentheses.\n\ncapturing parentheses are something else entirely.\nif you want a short word for that, i'd use cap.\n\ni think you've simplified a bit too much here.\nlook at the re2 Prog and Inst structures.\nthey're simple but also sufficient.  i think you\nwant to adapt what you've got to use a data\nstructure like those.\n\nruss\n",
			"disapproval": false,
			"date": "2010-10-20 04:58:09.706260",
			"approval": false
		},
		{
			"sender": "sam.thorogood@gmail.com",
			"recipients": [
				"sam.thorogood@gmail.com",
				"r@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2010/10/20 04:58:09, rsc wrote:\n> the names are still not right.\n> alt is short for alternation.  x|y|z is an alternation.\n> it has nothing to do with parentheses.\n> \n> capturing parentheses are something else entirely.\n> if you want a short word for that, i'd use cap.\n> \n> i think you've simplified a bit too much here.\n> look at the re2 Prog and Inst structures.\n> they're simple but also sufficient.  i think you\n> want to adapt what you've got to use a data\n> structure like those.\n> \n> russ\n\no. I've removed references to alt and replaced them with cap/subexps. It makes a lot of sense, although my original process was that x|y|z has to be bounded by a () (well - not entirely true, you could compile a re like \"a|b|c\" but internally it's still wrapped in brackets), so I treated the whole thing as an alt start/alt end.\n\no. I've also removed the start/end distinction for caps.\n\no. Added a test for the simple matcher where I've manually built a RE.\n\nSo, there are a couple of ways I think my code could come closer to RE2. Can you let me know which ones are most relevant (or if I should just do all of them).\n- change {out,out1} to refer to an index rather than a ptr to the instr\n- change boundaryMode to an emptyOp and allow it to merge multiple operations\n- remove RuneFilter and have an operation which will match a single byte only (rather than stepping through rune-by-rune)\nActually, a lot of the rest of Prog in RE2 seems to be to do with positioning, and optimising byte classes, neither of which seem incredibly urgent for a simple implementation.",
			"disapproval": false,
			"date": "2010-10-22 00:20:38.065644",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"sam.thorogood@gmail.com",
				"r@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "this looks like a good start.\nmost of my comments boil down to\n\"why isn't this like re2\"?  i know that's a\nfrustrating thing to hear, but most of the\ndecisions in re2 were made for specific\nreasons, and it will be easier to maintain\nthe two in parallel if the sources line up\nmore directly.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go\nFile sre2-review/ascii.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode3\nsre2-review/ascii.go:3: // This file describes ASCII character ranges as per \"Perl character classes\"\nwhy just ascii?  why not all of unicode?\ni would suggest generating this file using\na script like re2's make_perl_groups.pl.\nin fact maybe you should add a flag to that\nscript instead of making a copy.\n\nthen this would be perl_groups.go\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode7\nsre2-review/ascii.go:7: // Notably, Perl character classes should match the following ASCII classes:\nThey don't.  Let's not do that.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode16\nsre2-review/ascii.go:16: var _alnum = []unicode.Range{\nthe _ are unnecessary\nunicode has them because it uses uppercase letters\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode17\nsre2-review/ascii.go:17: unicode.Range{'0', '9', 1},\nrun gofmt -s -w *.go\n\nit will s/unicode.Range//\n\n(recent language change lets you do that)\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode79\nsre2-review/ascii.go:79: // [:whitespace:] matches Perl's definition of '\\s'.\nno non-standard extensions please\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode92\nsre2-review/ascii.go:92: var ASCII = map[string][]unicode.Range{\nwhy is this exported?\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/data.go\nFile sre2-review/data.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/data.go#newcode3\nsre2-review/data.go:3: // Describes rune matchers/filters. While the RuneFilter definition is currently\ndoc comment should begin with complete sentence.\nsee documentation section of effective go.\napplies to all data structure comments in this CL\n\nnot clear why this is exported or why it's in its\nown file.  move into match.go or prog.go for now\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go\nFile sre2-review/regexp.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode23\nsre2-review/regexp.go:23: // sregexp struct. Just a list of states and a number of subexpressions.\ncan we drop the s's throughout, please?\nalso this is not a regexp, it's the program.\nit would help keep things uniform if we\nused the same names as in re2.\n\nso type prog, type inst, not type sregexp, type instr.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode27\nsre2-review/regexp.go:27: // Number of paired subexpressions [()'s], including the outermost brackets\ns/paired/parenthesized/\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode33\nsre2-review/regexp.go:33: func (r *sregexp) DebugOut() {\nweird to hard-code standard error.\nbetter to return a multiline string\nand call it String()\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode39\nsre2-review/regexp.go:39: // NumSubexps returns the number of paired subexpressions [()'s] in this regexp.\ns/paired/parenthesized/.  Please feel free to copy doc comments\nfrom package regexp verbatim when the functionality is the same.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode47\nsre2-review/regexp.go:47: type instrMode byte\ncan we use the RE2 names?\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode51\nsre2-review/regexp.go:51: iSplit        instrMode = iota // proceed down out & out1\ncan we use the RE2 names?\netc\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode62\nsre2-review/regexp.go:62: // Enum-style definitions for the the boundaryMode type.\ns/Enum-stlye d/D/\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode170\nsre2-review/regexp.go:170: type Re interface {\nprobably should be type Regexp struct\nlike package regexp\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode200\nsre2-review/regexp.go:200: src = \".*?(\" + src + \").*?\"\nthis mangling will make error reporting difficult.\nit would be better to add them in the program form.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp_test.go\nFile sre2-review/regexp_test.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp_test.go#newcode12\nsre2-review/regexp_test.go:12: func TestConstructRe(t *testing.T) {\nthis is really TestManualMatch\nor something like that.  go style is\nto capitalize abbreviations by the way\nso this would be TestConstructRE.\nbut let's just say Regexp.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/simple.go\nFile sre2-review/simple.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/simple.go#newcode8\nsre2-review/simple.go:8: func (r *sregexp) Match(src string) bool {\nseems like this file should be match.go, not simple.go\nor maybe nfa.go\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/simple.go#newcode44\nsre2-review/simple.go:44: bits   []int64\nbits should almost always be uint64.\n\ni suggest using a sparse array instead,\nwhich will scale better because of the\nO(1) everything operations.  \nsee sparse_array.h in the re2 distribution.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/simple.go#newcode50\nsre2-review/simple.go:50: func make_obitset(m_state, m_size int) *obitset {\nthis would be makeObitset not make_obitset\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/simple.go#newcode57\nsre2-review/simple.go:57: func (o *obitset) addstate(p *SafeReader, st *instr) {\nthis is an abstraction violation.  the obitset/sparse array\nshould be concerned with having a list of stuff.\naddstate is about the program.  it shouldn't be a method\nof the obitset, unless the obitset is called something like\nstateList.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/sparser.go\nFile sre2-review/sparser.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/sparser.go#newcode3\nsre2-review/sparser.go:3: // Describes a string parser type. Notably, allows users to examine the current\nthis should be parse.go\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/sparser.go#newcode11\nsre2-review/sparser.go:11: // useful for identifying conditions between runes, such as '\\W', '\\w' or '$'\nthis shouldn't be necessary.  instead, you can walk through the \nappropriate empty states in during addState.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/sparser.go#newcode19\nsre2-review/sparser.go:19: type SafeReader struct {\nshouldn't be exported\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/sparser.go#newcode26\nsre2-review/sparser.go:26: func NewSafeReader(str string) SafeReader {\ni'm skeptical that this is necessary.  go's strings seem\nlike they should be enough.  maybe leave out until we\nget to the parser?\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/submatch.go\nFile sre2-review/submatch.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/submatch.go#newcode3\nsre2-review/submatch.go:3: // MatchIndex is the top-level complex matcher used in sre2, where submatches\ncan probably delete this file from this CL",
			"disapproval": false,
			"date": "2010-10-26 15:20:13.979479",
			"approval": false
		},
		{
			"sender": "sam.thorogood@gmail.com",
			"recipients": [
				"sam.thorogood@gmail.com",
				"r@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "So @r: I'd forgotten how much I have to change to bring this in-line with RE2. I don't mind doing that. If anything, writing SRE2 (let's call my public google-code and designed my own way that) has given me enough background in the whole field to be helpful enough if that is what you guys think is best.\n\n@rsc: I've addressed some of your comments and I'll have some more time over the next few days.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go\nFile sre2-review/ascii.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode3\nsre2-review/ascii.go:3: // This file describes ASCII character ranges as per \"Perl character classes\"\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> why just ascii?  why not all of unicode?\n\nWell, Go already has definitions for unicode ranges, in the Categories/Properties/Scripts definitions in the unicode package.\n\n> i would suggest generating this file using\n> a script like re2's make_perl_groups.pl.\n> in fact maybe you should add a flag to that\n> script instead of making a copy.\n> \n> then this would be perl_groups.go\n> \n\nI've changed this file to have:\nperl_groups\nposix_groups\n(so: are posix groups also perl groups? isn't ascii.go or ascii_groups more appropriate)?\n\nI did write a modification to make_perl_groups.pl, but I'm not really sure you want lots of if statements clogging up the code, but I'm happy to send that to you too if you like. The parser I have in mind for re2 in go will also determine whether to negate a group (i.e. does the posix group start with '^', is the character class an upper-case letter) so I don't want to store as much information here. (I suppose you might say here 'yes, but be more like RE2', which is probably an acceptable response).\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode7\nsre2-review/ascii.go:7: // Notably, Perl character classes should match the following ASCII classes:\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> They don't.  Let's not do that.\n\nDone.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode16\nsre2-review/ascii.go:16: var _alnum = []unicode.Range{\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> the _ are unnecessary\n> unicode has them because it uses uppercase letters\n\nDone/irrelevant. Incidentally, I almost miss 'static' for hiding work-in-progress stuff. I suppose the right alternative is to put it inside init().\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode17\nsre2-review/ascii.go:17: unicode.Range{'0', '9', 1},\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> run gofmt -s -w *.go\n> \n> it will s/unicode.Range//\n> \n> (recent language change lets you do that)\n> \n\nDone.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode79\nsre2-review/ascii.go:79: // [:whitespace:] matches Perl's definition of '\\s'.\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> no non-standard extensions please\n\nremoved\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/ascii.go#newcode92\nsre2-review/ascii.go:92: var ASCII = map[string][]unicode.Range{\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> why is this exported?\n\nSeemed neater at the time.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/data.go\nFile sre2-review/data.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/data.go#newcode3\nsre2-review/data.go:3: // Describes rune matchers/filters. While the RuneFilter definition is currently\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> doc comment should begin with complete sentence.\n> see documentation section of effective go.\n> applies to all data structure comments in this CL\n> \n> not clear why this is exported or why it's in its\n> own file.  move into match.go or prog.go for now\n\nremoved for now\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go\nFile sre2-review/regexp.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode23\nsre2-review/regexp.go:23: // sregexp struct. Just a list of states and a number of subexpressions.\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> can we drop the s's throughout, please?\n> also this is not a regexp, it's the program.\n> it would help keep things uniform if we\n> used the same names as in re2.\n> \n> so type prog, type inst, not type sregexp, type instr.\n\nDone.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode27\nsre2-review/regexp.go:27: // Number of paired subexpressions [()'s], including the outermost brackets\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> s/paired/parenthesized/\n\nDone.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode62\nsre2-review/regexp.go:62: // Enum-style definitions for the the boundaryMode type.\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> s/Enum-stlye d/D/\n\nDone.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode170\nsre2-review/regexp.go:170: type Re interface {\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> probably should be type Regexp struct\n> like package regexp\n\nSo, I'm happy to defer to experience on this, but this came out of a slightly different point of view.\n\nI feel like as a struct, callers have the ability to explicitly copy it, rather than always referring to it by reference. However, the compiled re is immutable; thus, why would copying the object be important? By providing an interface type to callers, it's explicit that you always want it to be referred to by reference.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp.go#newcode200\nsre2-review/regexp.go:200: src = \".*?(\" + src + \").*?\"\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> this mangling will make error reporting difficult.\n> it would be better to add them in the program form.\n\nFair point. I've just removed this here for now and added a comment.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp_test.go\nFile sre2-review/regexp_test.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/regexp_test.go#newcode12\nsre2-review/regexp_test.go:12: func TestConstructRe(t *testing.T) {\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> this is really TestManualMatch\n> or something like that.  go style is\n> to capitalize abbreviations by the way\n> so this would be TestConstructRE.\n> but let's just say Regexp.\n\nchanged to TestManualMatch\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/simple.go\nFile sre2-review/simple.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/simple.go#newcode8\nsre2-review/simple.go:8: func (r *sregexp) Match(src string) bool {\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> seems like this file should be match.go, not simple.go\n> or maybe nfa.go\n\nprog-nfa.go ?\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/simple.go#newcode50\nsre2-review/simple.go:50: func make_obitset(m_state, m_size int) *obitset {\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> this would be makeObitset not make_obitset\n\ndone, although I suppose if I wrote the sparse array implementation this name would change again, at least still being properly cased.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/simple.go#newcode57\nsre2-review/simple.go:57: func (o *obitset) addstate(p *SafeReader, st *instr) {\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> this is an abstraction violation.  the obitset/sparse array\n> should be concerned with having a list of stuff.\n> addstate is about the program.  it shouldn't be a method\n> of the obitset, unless the obitset is called something like\n> stateList.\n\nDone. This was originally more generic, but I wanted to simplify this matcher type, and I don't even have a get() method anyway. Changed to stateList.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/sparser.go\nFile sre2-review/sparser.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/sparser.go#newcode11\nsre2-review/sparser.go:11: // useful for identifying conditions between runes, such as '\\W', '\\w' or '$'\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> this shouldn't be necessary.  instead, you can walk through the \n> appropriate empty states in during addState.  \n> \n\nso, this is where I currently use curr()/peek().\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/sparser.go#newcode26\nsre2-review/sparser.go:26: func NewSafeReader(str string) SafeReader {\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> i'm skeptical that this is necessary.  go's strings seem\n> like they should be enough.  maybe leave out until we\n> get to the parser?\n> \n\nSo, I'm trying to agree with you and this is probably over-engineering to solve a relatively simple problem.\n\nBasically this came out of needing to look at current/peek-next characters in some nice way. Range over a string doesn't give you notice that you've hit the end. I suppose however I could go back to doing this with lots of the code point helper methods to make sure I'm examining each point properly.\n\nnb: there's also the \"literal\" method which is more a helper for my current parser than anything else. I suppose it could be replaced with a helper method that takes a string, requirements, and returns both the new string (minus the parsed bit) and the parsed bit, panicing otherwise.\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/submatch.go\nFile sre2-review/submatch.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/20001/sre2-review/submatch.go#newcode3\nsre2-review/submatch.go:3: // MatchIndex is the top-level complex matcher used in sre2, where submatches\nOn 2010/10/26 15:20:14, rsc1 wrote:\n> can probably delete this file from this CL\n\nDone.",
			"disapproval": false,
			"date": "2011-01-21 08:44:01.507588",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 21 January 2011 08:44,  <sam.thorogood@gmail.com> wrote:\n>> probably should be type Regexp struct\n>> like package regexp\n>\n> So, I'm happy to defer to experience on this, but this came out of a\n> slightly different point of view.\n>\n> I feel like as a struct, callers have the ability to explicitly copy it,\n> rather than always referring to it by reference. However, the compiled\n> re is immutable; thus, why would copying the object be important? By\n> providing an interface type to callers, it's explicit that you always\n> want it to be referred to by reference.\n\ncallers can only copy a struct if it has no private fields.\nusing the concrete type means that the compiler\ndoesn't need to use an indirect call, and even has\nthe potential to inline it.\n\ngenerally in Go, an interface type is used only when there\nare going to be multiple implementers of the interface.\n",
			"disapproval": false,
			"date": "2011-01-21 09:09:02.427776",
			"approval": false
		},
		{
			"sender": "sam.thorogood@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> callers can only copy a struct if it has no private fields.\n\nI didn't know about that language restriction. Thanks.\n",
			"disapproval": false,
			"date": "2011-01-21 16:06:20.845493",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"sam.thorogood@gmail.com",
				"r@golang.org",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "I started to look at this again as requested but\nmost of these comments were in my last review,\nso I stopped.\n\nPlease take a look through the last set of comments\nand make sure you've addressed them.\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/Makefile\nFile sre2-review/Makefile (right):\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/Makefile#newcode4\nsre2-review/Makefile:4: GOFILES=ascii.go regexp.go prog-nfa.go sparser.go\nwhy is it sparser and not parser?\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/ascii.go\nFile sre2-review/ascii.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/ascii.go#newcode3\nsre2-review/ascii.go:3: // This file describes ASCII character ranges as per \"Perl character classes\"\nshould be auto-generated, as in RE2.\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/ascii.go#newcode9\nsre2-review/ascii.go:9: var posix_groups = map[string][]unicode.Range{\nmixedCase not under_scores\nsee Effective Go.\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/ascii.go#newcode11\nsre2-review/ascii.go:11: unicode.Range{'0', '9', 1},\nshould be able to drop the Unicode.Range throughout\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/data.go\nFile sre2-review/data.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/data.go#newcode3\nsre2-review/data.go:3: // Describes rune matchers/filters. While the RuneFilter definition is currently\nsee Effective Go for comment style.\nfull sentences.\n\n// A RuneFilter is a function that returns true if rune ...\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/regexp.go\nFile sre2-review/regexp.go (right):\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/regexp.go#newcode53\nsre2-review/regexp.go:53: iIndexCap                      // capturing start/end parenthesis\nnot sure what index means.  iCap would be fine\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/regexp.go#newcode74\nsre2-review/regexp.go:74: // instr represents a single instruction in any regexp.\ns/instr/inst/\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/regexp.go#newcode96\nsre2-review/regexp.go:96: // TODO: Build the output string using a bytes.Buffer.\njust do it; it's trivial\n\nhttp://codereview.appspot.com/2258041/diff/31001/sre2-review/regexp.go#newcode179\nsre2-review/regexp.go:179: // Generates a simple, straight-forward NFA. Matches an entire regexp from the\nnot accurate (NFA?)\nalso not clear why this is here and not in parser.go.",
			"disapproval": false,
			"date": "2011-02-23 20:14:54.123366",
			"approval": false
		}
	],
	"owner_email": "sam.thorogood@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "Sam",
	"subject": "Sre2 initial review; missing parser/tests but describes regexp structure + simple matcher",
	"created": "2010-09-21 05:22:37.989713",
	"patchsets": [
		1,
		2001,
		10001,
		17001,
		20001,
		31001
	],
	"modified": "2011-02-23 20:14:54.123366",
	"closed": false,
	"issue": 2258041
}