{
	"description": "os/user: windows implementation\n\npjmlp gets credit for initial version.\n\nFixes issue 1789.",
	"cc": [
		"paulo.jpinto@gmail.com",
		"bradfitz@golang.org",
		"remyoudompheng@gmail.com",
		"rsc@golang.org",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello paulo.jpinto@gmail.com, bradfitz@golang.org (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2012-01-17 09:01:48.974953",
			"approval": false
		},
		{
			"sender": "remyoudompheng@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/1/17  <alex.brainman@gmail.com> wrote:\n> There is a problem with my implementation.\n>\n> Windows security model is build around concept of \"domain\" (group of\n> computers that \"trust\" each other), not single computer. Therefore,\n> when we talk about \"user home directory\", the value could change from\n> one computer to the next. As far as I can tell, \"home directory\" for a\n> user on a computer is not created until user actually logs in to the\n> computer. So, for example, while user \"bob\" exists inside \"cloud\"\n> domain, he might not have \"home directory\" on computer \"pc\" (that is\n> part of domain \"cloud\") until \"bob\" actually logs in to \"pc\" to run\n> some apps.\n>\n> GetCurrent function works properly, because it acquires access token\n> of a real running process. Lookup and LookupId, on the other hand,\n> will succeed, while some User struct attributes returned (like \"home\n> directory\") are meaningless.\n\nIs that any different from what you would get from a Unix system where\nauthentication is managed remotely by LDAP or a similar thing?\n\nR\u00e9my.\n",
			"disapproval": false,
			"date": "2012-01-17 18:46:44.670397",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "There is a problem with my implementation.\n\nWindows security model is build around concept of \"domain\" (group of\ncomputers that \"trust\" each other), not single computer. Therefore,\nwhen we talk about \"user home directory\", the value could change from\none computer to the next. As far as I can tell, \"home directory\" for a\nuser on a computer is not created until user actually logs in to the\ncomputer. So, for example, while user \"bob\" exists inside \"cloud\"\ndomain, he might not have \"home directory\" on computer \"pc\" (that is\npart of domain \"cloud\") until \"bob\" actually logs in to \"pc\" to run\nsome apps.\n\nGetCurrent function works properly, because it acquires access token\nof a real running process. Lookup and LookupId, on the other hand,\nwill succeed, while some User struct attributes returned (like \"home\ndirectory\") are meaningless.\n\nI think we should proceed with what I have, until we know more about\nwhat our users really want.\n\nAlex",
			"disapproval": false,
			"date": "2012-01-17 09:05:43.908450",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "That all sounds acceptable for now.  If anything, it could just be\ndocumented which fields are valid in which cases.\n\nOn Tue, Jan 17, 2012 at 1:05 AM, <alex.brainman@gmail.com> wrote:\n\n> There is a problem with my implementation.\n>\n> Windows security model is build around concept of \"domain\" (group of\n> computers that \"trust\" each other), not single computer. Therefore,\n> when we talk about \"user home directory\", the value could change from\n> one computer to the next. As far as I can tell, \"home directory\" for a\n> user on a computer is not created until user actually logs in to the\n> computer. So, for example, while user \"bob\" exists inside \"cloud\"\n> domain, he might not have \"home directory\" on computer \"pc\" (that is\n> part of domain \"cloud\") until \"bob\" actually logs in to \"pc\" to run\n> some apps.\n>\n> GetCurrent function works properly, because it acquires access token\n> of a real running process. Lookup and LookupId, on the other hand,\n> will succeed, while some User struct attributes returned (like \"home\n> directory\") are meaningless.\n>\n> I think we should proceed with what I have, until we know more about\n> what our users really want.\n>\n> Alex\n>\n> http://codereview.appspot.com/**5543069/<http://codereview.appspot.com/5543069/>\n>\n",
			"disapproval": false,
			"date": "2012-01-17 18:37:48.806229",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Nothing major...\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_unix.go\nFile src/pkg/os/user/lookup_unix.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_unix.go#newcode32\nsrc/pkg/os/user/lookup_unix.go:32: // Find current user. If the user cannot be found,\nthis isn't in the Go documentation style.  It needs to be a complete sentence, naming the subject (\"Current\"), in the first couple words.\n\n// Current returns the current user.\n\nI don't think you need to document UnknownUserError here.  It makes more sense for the other functions, where it's quite likely that you'll be looking up an invalid user from some config file.  But getting the current user is expected to usually succeed, so it's not worth documenting how it can fail.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_unix.go#newcode34\nsrc/pkg/os/user/lookup_unix.go:34: func GetCurrent() (*User, error) {\nGo tries not to use the prefix \"Get\", unless it's necessary for some reason.  I don't think it is here.\n\nuser.Current() looks nicer than user.GetCurrent().\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go\nFile src/pkg/os/user/lookup_windows.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go#newcode14\nsrc/pkg/os/user/lookup_windows.go:14: // try domain controler first\ncontroller\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go#newcode63\nsrc/pkg/os/user/lookup_windows.go:63: // Find current user.\n// Current returns the current user.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go#newcode64\nsrc/pkg/os/user/lookup_windows.go:64: func GetCurrent() (*User, error) {\nCurrent\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go#newcode98\nsrc/pkg/os/user/lookup_windows.go:98: // Lookup looks up a user by username.\nuse same docs as posix? doesn't think return the same unknown user error types in some cases?\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go#newcode110\nsrc/pkg/os/user/lookup_windows.go:110: // LookupId looks up a user by userid.\nlikewise\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go\nFile src/pkg/os/user/user_test.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go#newcode48\nsrc/pkg/os/user/user_test.go:48: t.Errorf(\"Uids %v and %v do not match\", u.Uid, un.Uid)\nsay what was got, then what was expected.\n\n\"got Uid=%q; want %q\", got.Uid, want.Uid\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go#newcode51\nsrc/pkg/os/user/user_test.go:51: t.Errorf(\"Usernames %v and %v do not match\", u.Username, un.Username)\nlikewise.  and use %q for strings, generally, especially as a likely failure case here is empty strings, so %q will read nicer on failure.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go#newcode54\nsrc/pkg/os/user/user_test.go:54: t.Errorf(\"Names %v and %v do not match\", u.Name, un.Name)\nsame, and %q\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go#newcode62\nsrc/pkg/os/user/user_test.go:62: t.Errorf(\"Gids %v and %v do not match\", u.Gid, un.Gid)\nsame, and %q\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go#newcode65\nsrc/pkg/os/user/user_test.go:65: t.Errorf(\"HomeDirs %v and %v do not match\", u.HomeDir, un.HomeDir)\nsame, and %q\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go\nFile src/pkg/syscall/security_windows.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode32\nsrc/pkg/syscall/security_windows.go:32: // This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.\nhah, okay. :)\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode69\nsrc/pkg/syscall/security_windows.go:69: SidTypeUser = 1 << iota\nif these are constants as defined by the windows API, please list them explicitly (= 1, = 2, = 3).  Only use iota if the number assignment is an internal detail.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode90\nsrc/pkg/syscall/security_windows.go:90: type SID [1]byte // Size is not really 1, but it is not important.\nwhy not []byte then?\n\nwhy 1?\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode107\nsrc/pkg/syscall/security_windows.go:107: func LookupSid(system, account string) (sid *SID, domain string, accType uint32, err error) {\nLookupSID would be more Go style.  (Go style is not mix case of abbreviations.  It's xml or XML, never Xml).\n\nBut syscall is low-level enough that it's exempt from many rules, so I don't care strongly.\n\nIf you don't care strongly either, though, go with LookupSID\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode195\nsrc/pkg/syscall/security_windows.go:195: TOKEN_ASSIGN_PRIMARY = 1 << iota\nagain, is iota appropriate here?   these numbers seem important.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode222\nsrc/pkg/syscall/security_windows.go:222: TokenUser = 1 + iota\niota?",
			"disapproval": false,
			"date": "2012-01-19 04:36:36.892400",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I think we made a wrong turn a while back as far as the\nWindows API is concerned.  Most of the system calls should\nbe unexported and we should have wrapper versions with the\nsame names that use appropriate Go types.  For example,\nyou brought up FormatMessage expecting a pointer and size.\nOn Unix, write(2) takes a pointer and size, but syscall.Write\ntakes a []byte and from that more useful Go type derives the\npointer and size.  Similarly Unix open(2) takes a pointer to a\nNUL-terminated string, but syscall.Open takes a Go string.\n\nIf we had infinite time this is something I'd like to fix for Go 1,\ncleaning up the Windows APIs to use natural Go types instead\nof being so low-level.  On the other hand, most of the Windows\nAPIs are so ridiculously complex, with the meaning of parameters\nand changing according to other flags, that this really might\nrequire infinite time.\n\nI think it is fine to continue down the road we're on as far as\nWindows is concerned.  It's not ideal, but neither is Windows,\nand this is package syscall.\n\nFor now I think it is fine to do type SID struct{} and move on.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-01-22 03:59:20.970991",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/22 03:59:20, rsc wrote:\n> ...  Most of the system calls should\n> be unexported and we should have wrapper versions with the\n> same names that use appropriate Go types.  ...\n\nWhy? What does it buy us?\n\nEven if we hide all these, users could reconstruct them in their own packages with syscall.Syscall.\n\nAlex",
			"disapproval": false,
			"date": "2012-01-22 21:16:49.272571",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/lookup_stubs.go\nFile src/pkg/os/user/lookup_stubs.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/lookup_stubs.go#newcode5\nsrc/pkg/os/user/lookup_stubs.go:5: // +build darwin freebsd linux darwin freebsd linux\nOn 2012/01/18 18:11:05, bradfitz wrote:\n> what is going on here?\n> \n\nThis are the rules I want:\n- this file is NEVER USED on windows\n- this file is USED if CGO_ENABLED=0 on any OS except windows\n\n> in addition to being repeated twice ...\n\nFixed that.\n\n> ... we do NOT want to\n> build this file on darwin, freebsd, or linux.\n\nWhat happens if user says CGO_ENABLED=0?\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user.go\nFile src/pkg/os/user/user.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user.go#newcode16\nsrc/pkg/os/user/user.go:16: Uid      string // user id\nOn 2012/01/18 18:11:05, bradfitz wrote:\n> ... it needs to at least be\n> document that ...\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user_test.go\nFile src/pkg/os/user/user_test.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user_test.go#newcode19\nsrc/pkg/os/user/user_test.go:19: if runtime.GOOS == \"linux\" || runtime.GOOS == \"freebsd\" || runtime.GOOS == \"darwin\" || runtime.GOOS == \"windows\" {\nOn 2012/01/18 18:11:05, bradfitz wrote:\n> Might be time to do:\n> \n> switch runtime.GOOS {\n> case \"linux\", \"freebsd\", \"darwin\", \"windows\":\n>    return false\n> }\n> \n> OpenBSD and FreeBSD probably work too. I'll file a bug to test.\n\nDone.",
			"disapproval": false,
			"date": "2012-01-19 02:42:43.745458",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jan 18, 2012 at 6:42 PM, <alex.brainman@gmail.com> wrote:\n\n>\n> http://codereview.appspot.com/**5543069/diff/6001/src/pkg/os/**\n> user/lookup_stubs.go<http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/lookup_stubs.go>\n> File src/pkg/os/user/lookup_stubs.**go (right):\n>\n> http://codereview.appspot.com/**5543069/diff/6001/src/pkg/os/**\n> user/lookup_stubs.go#newcode5<http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/lookup_stubs.go#newcode5>\n> src/pkg/os/user/lookup_stubs.**go:5: // +build darwin freebsd linux darwin\n> freebsd linux\n> On 2012/01/18 18:11:05, bradfitz wrote:\n>\n>> what is going on here?\n>>\n>\n>\n> This are the rules I want:\n> - this file is NEVER USED on windows\n> - this file is USED if CGO_ENABLED=0 on any OS except windows\n>\n>  in addition to being repeated twice ...\n>>\n>\n> Fixed that.\n>\n>  ... we do NOT want to\n>>\n>> build this file on darwin, freebsd, or linux.\n>>\n>\n> What happens if user says CGO_ENABLED=0?\n\n\nSorry, it looks like this works, but I have no clue why.\n\nI don't know how to interpret this:\n\n-// +build nocgo windows\n+// +build darwin freebsd linux netbsd openbsd plan9\n+// +build nocgo\n\n... even after reading go/build/dir.go\n\nWhere are these rules documented?\n",
			"disapproval": false,
			"date": "2012-01-19 03:14:41.529475",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/19 03:14:41, bradfitz wrote:\n> I don't know how to interpret this:\n> \n> -// +build nocgo windows\n> +// +build darwin freebsd linux netbsd openbsd plan9\n> +// +build nocgo\n> \n> ... even after reading go/build/dir.go\n> \n> Where are these rules documented?\n\nI only read shouldBuild in pkg/go/build/dir.go. If you have different suggestion, I am OK with it. As long as I can build windows.\n\nALex",
			"disapproval": false,
			"date": "2012-01-19 03:18:44.137836",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello paulo.jpinto@gmail.com, bradfitz@golang.org, remyoudompheng@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-01-19 06:39:51.568735",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/19 22:12:49, rsc wrote:\n> You want\n> \n> // +build darwin freebsd linux\n> // +build nocgo\n> \n> The list is oddly duplicated right now.\n\nRuss, are you looking at my last version? I have \n\n// +build darwin freebsd linux netbsd openbsd plan9\n// +build nocgo\n\nin lookup_stubs.go now. My version has extra \"netbsd openbsd plan9\". Wouldn't we want os/user to at least build on these OSes?\n\nAlex",
			"disapproval": false,
			"date": "2012-01-19 22:36:05.586228",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Jan 19, 2012 at 17:31,  <alex.brainman@gmail.com> wrote:\n> No. SID is a \"sequence of bytes / block in memory\" of variable length.\n> Therefore *SID (that is input and output of Windows api) should point to\n> the first byte of this memory block.\n\nI don't know what to do.  Windows APIs suck.\nMaybe instead do\n\ntype SID struct{}\n\nthen at least no one can abuse the *SID pointers that\nare flying around.\n\n\nRuss\n",
			"disapproval": false,
			"date": "2012-01-20 18:17:44.109955",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello paulo.jpinto@gmail.com, bradfitz@golang.org, remyoudompheng@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-01-18 03:11:05.620840",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go\nFile src/pkg/syscall/security_windows.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode69\nsrc/pkg/syscall/security_windows.go:69: SidTypeUser = 1 << iota\nOn 2012/01/19 06:14:52, brainman wrote:\n> On 2012/01/19 04:36:37, bradfitz wrote:\n> > ..., please list them\n> > explicitly ...\n> \n> All these are defined by Windows api. There are no \"internal\" consts here.\n> \n> But, I still prefer to leave it as is. These are much easier to read. People\n> should not change line order here. \n\nBut you don't say that.  The way I read Go code with iota is that the numbers aren't important.\n\nIf the numbers are important, you need either a loud comment or explicit numbers.",
			"disapproval": false,
			"date": "2012-01-19 06:20:31.430002",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Jan 19, 2012 at 17:36,  <alex.brainman@gmail.com> wrote:\n> Russ, are you looking at my last version? I have\n>\n> // +build darwin freebsd linux netbsd openbsd plan9\n> // +build nocgo\n>\n> in lookup_stubs.go now. My version has extra \"netbsd openbsd plan9\".\n> Wouldn't we want os/user to at least build on these OSes?\n\nSure, that's fine.  The version I was replying to said\n\n// +build darwin freebsd linux darwin freebsd linux\n",
			"disapproval": false,
			"date": "2012-01-20 18:14:46.170383",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/17 18:37:48, bradfitz wrote:\n> ...  If anything, it could just be\n> documented which fields are valid in which cases.\n> \n\nI put in a BUG() comment about that.\n\nAlex",
			"disapproval": false,
			"date": "2012-01-18 03:12:04.633132",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/lookup_stubs.go\nFile src/pkg/os/user/lookup_stubs.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/lookup_stubs.go#newcode5\nsrc/pkg/os/user/lookup_stubs.go:5: // +build darwin freebsd linux darwin freebsd linux\nwhat is going on here?\n\nin addition to being repeated twice, this line is just wrong. we do NOT want to build this file on darwin, freebsd, or linux.\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user.go\nFile src/pkg/os/user/user.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user.go#newcode16\nsrc/pkg/os/user/user.go:16: Uid      string // user id\nMaybe this should be interface{}.  If it's string, it needs to at least be document that on posix systems it contains a decimal number, and in any case it should be document what forms it can take.\n\nint was obvious, this is not, but I agree it probably needs to change.\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user_test.go\nFile src/pkg/os/user/user_test.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user_test.go#newcode19\nsrc/pkg/os/user/user_test.go:19: if runtime.GOOS == \"linux\" || runtime.GOOS == \"freebsd\" || runtime.GOOS == \"darwin\" || runtime.GOOS == \"windows\" {\nMight be time to do:\n\nswitch runtime.GOOS {\ncase \"linux\", \"freebsd\", \"darwin\", \"windows\":\n   return false\n}\n\nOpenBSD and FreeBSD probably work too. I'll file a bug to test.",
			"disapproval": false,
			"date": "2012-01-18 18:11:05.811813",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/18 12:26:14, pjmlp wrote:\n> ...\n> Some user account information can only be retrieved when a domain server is\n> available.\n\nI use syscall.NetUserGetInfo to discover \"user full name\" for not-part-of-a-domain computers.\n\nAlex",
			"disapproval": false,
			"date": "2012-01-19 01:03:31.786254",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go\nFile src/pkg/syscall/security_windows.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode90\nsrc/pkg/syscall/security_windows.go:90: type SID [1]byte // Size is not really 1, but it is not important.\nOn 2012/01/19 06:14:52, brainman wrote:\n> On 2012/01/19 04:36:37, bradfitz wrote:\n> > why not []byte then?\n> \n> SID is array of bytes, not a slice.\n> \n> > why 1?\n> \n> Windows api does not tell us how many bytes long it is. For all we care, it\n> could vary. But, since we always use *SID, never SID, we shouldn't care.\n\nIn that case, I'd rather you define it like:\n\ntype SID struct {\n    unexported Whatever\n}\n\nSaying that it's a [1]byte feels wrong.",
			"disapproval": false,
			"date": "2012-01-19 06:19:13.704194",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> I can't see a problem here :-)\n> IMHO, it is not much different from C *FILE?\n\nYes.  C's *FILE is not a system call.\nAlso, when we write *C.FILE in a cgo program,\nthe Go compiler does know how big a FILE is.\n\nThis SID is a pointer to some unspecified data of\nunspecified size.\n\n>> Maybe instead do\n>> type SID struct{}\n>\n> How is it different from what we have so far?\n\nIt is different because you cannot dereference it without\nusing unsafe.  You can't write or read it.  In contrast,\nif you have type SID *byte then the client can at least\nread and write that byte, and who knows if there's even\na byte there.\n\n>> then at least no one can abuse the *SID pointers that\n>> are flying around.\n>\n> This is syscall. Low level stuff. Unless you know what you are doing,\n> you shouldn't be doing it.\n\nThe internals of syscall are low-level stuff.  In the public APIs\nwe have tried to build things that are memory safe like in Go.\nYou are going to the trouble of allocating a Go copy of the\nSID.  This is part of why I suggested using []byte for that\nGo copy of it.  To take an analogy, we write syscall.Open to\ntake a string, not a *byte, even though the underlying system\ncall does expect a *byte.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-01-21 03:08:18.648821",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/17 18:46:44, remyoudompheng wrote:\n> \n> Is that any different from what you would get from a Unix system where\n> authentication is managed remotely by LDAP or a similar thing?\n> \n\nDon't know anything about Unix authentication managed remotely by LDAP. Sorry.\n\nAlex",
			"disapproval": false,
			"date": "2012-01-18 03:13:31.986706",
			"approval": false
		},
		{
			"sender": "paulo.jpinto@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/17 09:05:43, brainman wrote:\n> There is a problem with my implementation.\n> \n> Windows security model is build around concept of \"domain\" (group of\n> computers that \"trust\" each other), not single computer. Therefore,\n> when we talk about \"user home directory\", the value could change from\n> one computer to the next. As far as I can tell, \"home directory\" for a\n> user on a computer is not created until user actually logs in to the\n> computer. So, for example, while user \"bob\" exists inside \"cloud\"\n> domain, he might not have \"home directory\" on computer \"pc\" (that is\n> part of domain \"cloud\") until \"bob\" actually logs in to \"pc\" to run\n> some apps.\n> \n> GetCurrent function works properly, because it acquires access token\n> of a real running process. Lookup and LookupId, on the other hand,\n> will succeed, while some User struct attributes returned (like \"home\n> directory\") are meaningless.\n> \n> I think we should proceed with what I have, until we know more about\n> what our users really want.\n> \n> Alex\n\nThat was exactly one of the issues I had while trying to develop the Windows solution. Many of the available APIs make a distinction between a domain server and the local accounts, also known as SAM.\n\nSome user account information can only be retrieved when a domain server is available.",
			"disapproval": false,
			"date": "2012-01-18 12:26:14.613888",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/lookup_stubs.go\nFile src/pkg/os/user/lookup_stubs.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/lookup_stubs.go#newcode5\nsrc/pkg/os/user/lookup_stubs.go:5: // +build darwin freebsd linux darwin freebsd linux\nOn 2012/01/19 02:42:43, brainman wrote:\n> On 2012/01/18 18:11:05, bradfitz wrote:\n> > what is going on here?\n> > \n> \n> This are the rules I want:\n> - this file is NEVER USED on windows\n> - this file is USED if CGO_ENABLED=0 on any OS except windows\n> \n> > in addition to being repeated twice ...\n> \n> Fixed that.\n> \n> > ... we do NOT want to\n> > build this file on darwin, freebsd, or linux.\n> \n> What happens if user says CGO_ENABLED=0?\n\nYou want\n\n// +build darwin freebsd linux\n// +build nocgo\n\nThe list is oddly duplicated right now.",
			"disapproval": false,
			"date": "2012-01-19 22:12:49.691981",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jan 18, 2012 at 7:18 PM, <alex.brainman@gmail.com> wrote:\n\n> On 2012/01/19 03:14:41, bradfitz wrote:\n>\n>> I don't know how to interpret this:\n>>\n>\n>  -// +build nocgo windows\n>> +// +build darwin freebsd linux netbsd openbsd plan9\n>> +// +build nocgo\n>>\n>\n>  ... even after reading go/build/dir.go\n>>\n>\n>  Where are these rules documented?\n>>\n>\n> I only read shouldBuild in pkg/go/build/dir.go.\n>\n>\nah!  okay, that makes sense.  I didn't know the\nmust-match-something-for-each-line rule.\n",
			"disapproval": false,
			"date": "2012-01-19 03:20:37.937369",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5543069/diff/9007/src/pkg/syscall/security_windows.go\nFile src/pkg/syscall/security_windows.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/9007/src/pkg/syscall/security_windows.go#newcode92\nsrc/pkg/syscall/security_windows.go:92: unexported byte // real structure of SID is not published\nOn 2012/01/19 18:40:09, rsc wrote:\n> This is sleazier than I would like. ...\n\nI agree. I like my original proposal \n\ntype SID [1]byte\n\nbetter. But I am not married to it.\n\n> If the SID is an\n> opaque byte sequence, can we make the Windows APIs take []byte\n\nNo. SID is a \"sequence of bytes / block in memory\" of variable length. Therefore *SID (that is input and output of Windows api) should point to the first byte of this memory block.\n\n> and then make this struct be\n> \n> type SID struct {\n>     data []byte\n> }\n> \n\nThis will not work. Because *SID will point to the first byte of SID.data slice descriptor, not to SID.data[0].\n\nIf you reject current proposal, I propose, we go back to my original. We employed similar definition before - see syscall.DNSTXTData (http://goo.gl/fDLqf for real definition) - DNSTXTData.StringArray is said 1 elements long, but in reality, DNSTXTData.StringCount tells you how many of them are there, and you just have to access them all starting from &(DNSTXTData.StringArray[0]). SID is similar, except we don't have StringCount or similar field.",
			"disapproval": false,
			"date": "2012-01-19 22:31:18.238173",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Using a \"string\" for the userid is fine (rather than interface{}).  Just\ndocument a bit.\n\n\nOn Wed, Jan 18, 2012 at 10:11 AM, <bradfitz@golang.org> wrote:\n\n>\n> http://codereview.appspot.com/**5543069/diff/6001/src/pkg/os/**\n> user/lookup_stubs.go<http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/lookup_stubs.go>\n> File src/pkg/os/user/lookup_stubs.**go (right):\n>\n> http://codereview.appspot.com/**5543069/diff/6001/src/pkg/os/**\n> user/lookup_stubs.go#newcode5<http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/lookup_stubs.go#newcode5>\n> src/pkg/os/user/lookup_stubs.**go:5: // +build darwin freebsd linux darwin\n> freebsd linux\n> what is going on here?\n>\n> in addition to being repeated twice, this line is just wrong. we do NOT\n> want to build this file on darwin, freebsd, or linux.\n>\n> http://codereview.appspot.com/**5543069/diff/6001/src/pkg/os/**\n> user/user.go<http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user.go>\n> File src/pkg/os/user/user.go (right):\n>\n> http://codereview.appspot.com/**5543069/diff/6001/src/pkg/os/**\n> user/user.go#newcode16<http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user.go#newcode16>\n> src/pkg/os/user/user.go:16: Uid      string // user id\n> Maybe this should be interface{}.  If it's string, it needs to at least\n> be document that on posix systems it contains a decimal number, and in\n> any case it should be document what forms it can take.\n>\n> int was obvious, this is not, but I agree it probably needs to change.\n>\n> http://codereview.appspot.com/**5543069/diff/6001/src/pkg/os/**\n> user/user_test.go<http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user_test.go>\n> File src/pkg/os/user/user_test.go (right):\n>\n> http://codereview.appspot.com/**5543069/diff/6001/src/pkg/os/**\n> user/user_test.go#newcode19<http://codereview.appspot.com/5543069/diff/6001/src/pkg/os/user/user_test.go#newcode19>\n> src/pkg/os/user/user_test.go:**19: if runtime.GOOS == \"linux\" ||\n> runtime.GOOS == \"freebsd\" || runtime.GOOS == \"darwin\" || runtime.GOOS ==\n> \"windows\" {\n> Might be time to do:\n>\n> switch runtime.GOOS {\n> case \"linux\", \"freebsd\", \"darwin\", \"windows\":\n>   return false\n> }\n>\n> OpenBSD and FreeBSD probably work too. I'll file a bug to test.\n>\n> http://codereview.appspot.com/**5543069/<http://codereview.appspot.com/5543069/>\n>\n",
			"disapproval": false,
			"date": "2012-01-18 18:23:58.260427",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello paulo.jpinto@gmail.com, bradfitz@golang.org, remyoudompheng@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-01-19 02:42:37.524148",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thank you for review.\n\nAlex\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_unix.go\nFile src/pkg/os/user/lookup_unix.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_unix.go#newcode32\nsrc/pkg/os/user/lookup_unix.go:32: // Find current user. If the user cannot be found,\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> this isn't in the Go documentation style.  It needs to be a complete sentence,\n> naming the subject (\"Current\"), in the first couple words.\n> \n> // Current returns the current user.\n> \n> I don't think you need to document UnknownUserError here.  It makes more sense\n> for the other functions, where it's quite likely that you'll be looking up an\n> invalid user from some config file.  But getting the current user is expected to\n> usually succeed, so it's not worth documenting how it can fail.\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_unix.go#newcode34\nsrc/pkg/os/user/lookup_unix.go:34: func GetCurrent() (*User, error) {\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> Go tries not to use the prefix \"Get\", unless it's necessary for some reason.  I\n> don't think it is here.\n> \n> user.Current() looks nicer than user.GetCurrent().\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go\nFile src/pkg/os/user/lookup_windows.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go#newcode14\nsrc/pkg/os/user/lookup_windows.go:14: // try domain controler first\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> controller\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go#newcode63\nsrc/pkg/os/user/lookup_windows.go:63: // Find current user.\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> // Current returns the current user.\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go#newcode64\nsrc/pkg/os/user/lookup_windows.go:64: func GetCurrent() (*User, error) {\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> Current\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go#newcode98\nsrc/pkg/os/user/lookup_windows.go:98: // Lookup looks up a user by username.\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> use same docs as posix? doesn't think return the same unknown user error types\n> in some cases?\n\nYes. It is not clear to me which of many errors I get will signify \"unknown user\" condition. So, different doc.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/lookup_windows.go#newcode110\nsrc/pkg/os/user/lookup_windows.go:110: // LookupId looks up a user by userid.\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> likewise\n\nSame.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go\nFile src/pkg/os/user/user_test.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go#newcode48\nsrc/pkg/os/user/user_test.go:48: t.Errorf(\"Uids %v and %v do not match\", u.Uid, un.Uid)\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> say what was got, then what was expected.\n> \n> \"got Uid=%q; want %q\", got.Uid, want.Uid\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go#newcode51\nsrc/pkg/os/user/user_test.go:51: t.Errorf(\"Usernames %v and %v do not match\", u.Username, un.Username)\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> likewise.  and use %q for strings, generally, especially as a likely failure\n> case here is empty strings, so %q will read nicer on failure.\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go#newcode54\nsrc/pkg/os/user/user_test.go:54: t.Errorf(\"Names %v and %v do not match\", u.Name, un.Name)\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> same, and %q\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go#newcode62\nsrc/pkg/os/user/user_test.go:62: t.Errorf(\"Gids %v and %v do not match\", u.Gid, un.Gid)\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> same, and %q\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/os/user/user_test.go#newcode65\nsrc/pkg/os/user/user_test.go:65: t.Errorf(\"HomeDirs %v and %v do not match\", u.HomeDir, un.HomeDir)\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> same, and %q\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go\nFile src/pkg/syscall/security_windows.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode32\nsrc/pkg/syscall/security_windows.go:32: // This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> hah, okay. :)\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode69\nsrc/pkg/syscall/security_windows.go:69: SidTypeUser = 1 << iota\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> ..., please list them\n> explicitly ...\n\nAll these are defined by Windows api. There are no \"internal\" consts here.\n\nBut, I still prefer to leave it as is. These are much easier to read. People should not change line order here. There are others in this file from the past.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode90\nsrc/pkg/syscall/security_windows.go:90: type SID [1]byte // Size is not really 1, but it is not important.\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> why not []byte then?\n\nSID is array of bytes, not a slice.\n\n> why 1?\n\nWindows api does not tell us how many bytes long it is. For all we care, it could vary. But, since we always use *SID, never SID, we shouldn't care.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode107\nsrc/pkg/syscall/security_windows.go:107: func LookupSid(system, account string) (sid *SID, domain string, accType uint32, err error) {\nOn 2012/01/19 04:36:37, bradfitz wrote:\n> LookupSID would be more Go style.  (Go style is not mix case of abbreviations. \n> It's xml or XML, never Xml).\n> \n> But syscall is low-level enough that it's exempt from many rules, so I don't\n> care strongly.\n> \n> If you don't care strongly either, though, go with LookupSID\n\nDone.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode195\nsrc/pkg/syscall/security_windows.go:195: TOKEN_ASSIGN_PRIMARY = 1 << iota\nAs above.\n\nhttp://codereview.appspot.com/5543069/diff/11002/src/pkg/syscall/security_windows.go#newcode222\nsrc/pkg/syscall/security_windows.go:222: TokenUser = 1 + iota\nAs above.",
			"disapproval": false,
			"date": "2012-01-19 06:14:52.437436",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello paulo.jpinto@gmail.com, bradfitz@golang.org, remyoudompheng@gmail.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-01-19 06:15:11.195771",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5543069/diff/9007/src/pkg/syscall/security_windows.go\nFile src/pkg/syscall/security_windows.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/9007/src/pkg/syscall/security_windows.go#newcode92\nsrc/pkg/syscall/security_windows.go:92: unexported byte // real structure of SID is not published\nThis is sleazier than I would like.  If the SID is an\nopaque byte sequence, can we make the Windows APIs take []byte\nand then make this struct be\n\ntype SID struct {\n    data []byte\n}\n\n?",
			"disapproval": false,
			"date": "2012-01-19 18:40:08.912126",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/20 18:17:44, rsc wrote:\n> \n> ...  Windows APIs suck.\n\nI can't see a problem here :-)\nIMHO, it is not much different from C *FILE?\n\n> Maybe instead do\n> \n> type SID struct{}\n> \n\nHow is it different from what we have so far?\n\n> then at least no one can abuse the *SID pointers that\n> are flying around.\n\nThis is syscall. Low level stuff. Unless you know what you are doing, you shouldn't be doing it.\n\nAlex",
			"disapproval": false,
			"date": "2012-01-20 23:02:17.048562",
			"approval": false
		},
		{
			"sender": "paulo.jpinto@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5543069/diff/9007/src/pkg/syscall/security_windows.go\nFile src/pkg/syscall/security_windows.go (right):\n\nhttp://codereview.appspot.com/5543069/diff/9007/src/pkg/syscall/security_windows.go#newcode92\nsrc/pkg/syscall/security_windows.go:92: unexported byte // real structure of SID is not published\nBut wouldn't this require the data to be allocated on the Go side?\n\nMany SID manipulation routines allocate the SID data structure on their own. So your suggestion would require a inefficient data copying on the Go side.\n\n\nOn 2012/01/19 18:40:09, rsc wrote:\n> This is sleazier than I would like.  If the SID is an\n> opaque byte sequence, can we make the Windows APIs take []byte\n> and then make this struct be\n> \n> type SID struct {\n>     data []byte\n> }\n> \n> ?",
			"disapproval": false,
			"date": "2012-01-21 11:14:47.371157",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello paulo.jpinto@gmail.com, bradfitz@golang.org, remyoudompheng@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-01-21 11:05:48.572957",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Sat, Jan 21, 2012 at 3:06 AM, <alex.brainman@gmail.com> wrote:\n\n> On 2012/01/21 03:08:18, rsc wrote:\n>\n>> ...\n>>\n>> >> Maybe instead do\n>> >> type SID struct{}\n>>\n>\n> Done.\n>\n>\n>  It is different because you cannot dereference it without\n>> using unsafe.  You can't write or read it. ...\n>>\n>\n> Fair enough.\n>\n>  You are going to the trouble of allocating a Go copy of the\n>> SID. ...\n>>\n>\n> It is simple memory management on my part. The api I use\n> (ConvertStringSidToSid) returns result in a block of memory I am\n> supposed to return. So I have to copy it to my own buffer, before\n> continuing with it.\n>\n>\n>  This is part of why I suggested using []byte for that\n>> Go copy of it.\n>>\n>\n> Slice will not work for SID. Unless you want to create something\n> different - new Go specific SID type. Then we would have two distinct\n> types to describe the same thing. I don't believe we should do that in\n> syscall. Syscall should represent OS as close as we can do.\n>\n\nWhy won't a slice represent a variable number of bytes?\n\nThis type still feels gross.\n\nI want to see something like:\n\ntype SID struct {\n     buf []byte\n}\n\nor:\n\ntype SID struct {\n    // Big comment here.\n    buf unsafe.Pointer\n}\n\nor\n\ntype SID []byte\n\n... and just do the copying where necessary.  I doubt this is a performance\nbottleneck anywhere.\n",
			"disapproval": false,
			"date": "2012-01-21 16:24:21.372819",
			"approval": false
		},
		{
			"sender": "paulo.jpinto@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This is a general problem in type safe languages, when using APIs that\nallocate\nmemory themselves.\n\nI do concede that Windows API is an example on how not to do API design,\nbut it\njust followed VMS design, which is even worse.\n\nOriginally I also used a []byte, and changed it to string after the review\ndiscussions we\nhad, as a possible more safe way to pass the SID around.\n\nOn Sat, Jan 21, 2012 at 4:08 AM, Russ Cox <rsc@golang.org> wrote:\n\n> > I can't see a problem here :-)\n> > IMHO, it is not much different from C *FILE?\n>\n> Yes.  C's *FILE is not a system call.\n> Also, when we write *C.FILE in a cgo program,\n> the Go compiler does know how big a FILE is.\n>\n> This SID is a pointer to some unspecified data of\n> unspecified size.\n>\n> >> Maybe instead do\n> >> type SID struct{}\n> >\n> > How is it different from what we have so far?\n>\n> It is different because you cannot dereference it without\n> using unsafe.  You can't write or read it.  In contrast,\n> if you have type SID *byte then the client can at least\n> read and write that byte, and who knows if there's even\n> a byte there.\n>\n> >> then at least no one can abuse the *SID pointers that\n> >> are flying around.\n> >\n> > This is syscall. Low level stuff. Unless you know what you are doing,\n> > you shouldn't be doing it.\n>\n> The internals of syscall are low-level stuff.  In the public APIs\n> we have tried to build things that are memory safe like in Go.\n> You are going to the trouble of allocating a Go copy of the\n> SID.  This is part of why I suggested using []byte for that\n> Go copy of it.  To take an analogy, we write syscall.Open to\n> take a string, not a *byte, even though the underlying system\n> call does expect a *byte.\n>\n> Russ\n>\n",
			"disapproval": false,
			"date": "2012-01-21 10:24:46.556664",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/21 03:08:18, rsc wrote:\n> ...\n> >> Maybe instead do\n> >> type SID struct{}\n\nDone.\n\n> \n> It is different because you cannot dereference it without\n> using unsafe.  You can't write or read it. ...\n\nFair enough.\n\n> You are going to the trouble of allocating a Go copy of the\n> SID. ...\n\nIt is simple memory management on my part. The api I use (ConvertStringSidToSid) returns result in a block of memory I am supposed to return. So I have to copy it to my own buffer, before continuing with it.\n\n> This is part of why I suggested using []byte for that\n> Go copy of it. \n\nSlice will not work for SID. Unless you want to create something different - new Go specific SID type. Then we would have two distinct types to describe the same thing. I don't believe we should do that in syscall. Syscall should represent OS as close as we can do.\n\nAlex",
			"disapproval": false,
			"date": "2012-01-21 11:06:14.695554",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/21 16:24:21, bradfitz wrote:\n> ...\n> \n> I want to see something like:\n> \n> type SID struct {\n>      buf []byte\n> }\n> \n\nSure. But that is not what Windows api expects. For example\n\nCopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error)\n(http://goo.gl/hjzBp)\n\nexpects destSid to point to a block of destSidLen bytes. That is not what your propsed *SID will point to. It will point to buf slice descriptor (3 pointers of addr/len/size = 12 bytes on 386).\n\nThis definition\n\ntype SID [0]byte\n\nwill work.\n\nSo, what, I think, you are really proposing, is to have two definitions:\n\ntype SID struct {\n     buf []byte\n}\n\nfor external use, and \n\ntype internalSID [0]byte\n\nto use inside syscall to communcate with Windows. Following that, all Windows api calls would have to use internalSID (not SID), therefore none of them can be exported from syscall package.\n\nAlso we would need some functions to convert from internalSID to SID and back.\n\nThat is not what we have being doing so far. At this moment windows syscall have pure windows api calls and types / const needed to call them (with small exceptions). This CL breaks a little bit with this convention, because there is some usefull code that could be used in other programs. But whatever we do, I would like to keep low level Windows api interface avalable in syscall.\n\nI still didn't get your arguments against proposed SID implementation. I hear \"I don't like it\". I can't fix that. Give me something to work with :-)\n\nRuss is conerned about memory management, and I share his concerns. But I don't see this case any different then many others we have in syscall. For example syscall.FormatMessage expects pointer to buffer and size, if these two are mismatched, we will have simple buffer overflow. I am sure, we have many like that in syscall. Windows api is designed for C, we can't use it any other way. We would have to make all these function non-exported from syscall.\n\nAlex",
			"disapproval": false,
			"date": "2012-01-22 00:12:51.275165",
			"approval": false
		},
		{
			"sender": "paulo.jpinto@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/01/22 03:59:20, rsc wrote:\n> I think we made a wrong turn a while back as far as the\n> Windows API is concerned.  Most of the system calls should\n> be unexported and we should have wrapper versions with the\n> same names that use appropriate Go types.  For example,\n> you brought up FormatMessage expecting a pointer and size.\n> On Unix, write(2) takes a pointer and size, but syscall.Write\n> takes a []byte and from that more useful Go type derives the\n> pointer and size.  Similarly Unix open(2) takes a pointer to a\n> NUL-terminated string, but syscall.Open takes a Go string.\n> \n> If we had infinite time this is something I'd like to fix for Go 1,\n> cleaning up the Windows APIs to use natural Go types instead\n> of being so low-level.  On the other hand, most of the Windows\n> APIs are so ridiculously complex, with the meaning of parameters\n> and changing according to other flags, that this really might\n> require infinite time.\n> \n> I think it is fine to continue down the road we're on as far as\n> Windows is concerned.  It's not ideal, but neither is Windows,\n> and this is package syscall.\n> \n> For now I think it is fine to do type SID struct{} and move on.\n> \n> Russ\n\nRuss, this is off topic for this code review, but as input for Go development, many Windows APIs are only available via COM, more so with Windows 8.",
			"disapproval": false,
			"date": "2012-01-22 09:55:39.461002",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Sun, Jan 22, 2012 at 16:16,  <alex.brainman@gmail.com> wrote:\n> Why? What does it buy us?\n>\n> Even if we hide all these, users could reconstruct them in their own\n> packages with syscall.Syscall.\n\nIt is just nicer to use\n\nfunc Open(path string, mode int, perm uint32) (fd int, err error)\n\nthan it is to use\n\nfunc Open(path *byte, mode int, perm uint32) (fd int, err error)\n\nRuss\n",
			"disapproval": false,
			"date": "2012-01-23 14:43:11.753680",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nI'm not happy with the Windows SID type, but it's just in syscall, and it's\nconsistent with the rest of the Windows stuff.\n\nI think in the future we'll want:\n\ntype SID struct {\n     sid internalSID  // all grossness here, not on *SID\n}\n\n... and code outside of syscall gets to use pretty APIs with sane types.\n\nBut that can come later.\n\n\nOn Sat, Jan 21, 2012 at 7:59 PM, Russ Cox <rsc@golang.org> wrote:\n\n> I think we made a wrong turn a while back as far as the\n> Windows API is concerned.  Most of the system calls should\n> be unexported and we should have wrapper versions with the\n> same names that use appropriate Go types.  For example,\n> you brought up FormatMessage expecting a pointer and size.\n> On Unix, write(2) takes a pointer and size, but syscall.Write\n> takes a []byte and from that more useful Go type derives the\n> pointer and size.  Similarly Unix open(2) takes a pointer to a\n> NUL-terminated string, but syscall.Open takes a Go string.\n>\n> If we had infinite time this is something I'd like to fix for Go 1,\n> cleaning up the Windows APIs to use natural Go types instead\n> of being so low-level.  On the other hand, most of the Windows\n> APIs are so ridiculously complex, with the meaning of parameters\n> and changing according to other flags, that this really might\n> require infinite time.\n>\n> I think it is fine to continue down the road we're on as far as\n> Windows is concerned.  It's not ideal, but neither is Windows,\n> and this is package syscall.\n>\n> For now I think it is fine to do type SID struct{} and move on.\n>\n> Russ\n>\n",
			"disapproval": false,
			"date": "2012-01-25 17:49:33.084199",
			"approval": true
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"alex.brainman@gmail.com",
				"paulo.jpinto@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=3e10f3117ecf ***\n\nos/user: windows implementation\n\npjmlp gets credit for initial version.\n\nFixes issue 1789.\n\nR=paulo.jpinto, bradfitz, remyoudompheng, rsc\nCC=golang-dev\nhttp://codereview.appspot.com/5543069",
			"disapproval": false,
			"date": "2012-01-30 11:59:21.833067",
			"approval": false
		}
	],
	"owner_email": "alex.brainman@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "brainman",
	"subject": "code review 5543069: os/user: windows implementation",
	"created": "2012-01-17 08:59:31.273962",
	"patchsets": [
		1,
		3,
		2015,
		6001,
		11002,
		6017,
		9007,
		15001,
		20001
	],
	"modified": "2012-01-30 11:59:25.087078",
	"closed": true,
	"issue": 5543069
}