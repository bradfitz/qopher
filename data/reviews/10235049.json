{
	"description": "go.tools/go/types: first cut at sorted method sets\n\n- moved single field and method lookup functionality\n  from operand.go to new file lookup.go and cleaned\n  up the lookup implementation\n\n- implemented method set computation using the same\n  basic structure as for field/method lookup, in new\n  file methodset.go\n\n- minor related changes\n\n- the method set computation ignores pointer-ness of\n  the receiver type at the moment (next CL)\n\n- fixed a couple of bugs (missing pkg info for imported\n  embedded types, wrong test for method expressions)\n\nThe method set computation is currently verified by\ncomparing a regular method lookup with a method-set\nbased method lookup.",
	"cc": [
		"adonovan@google.com",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "gri@golang.org",
			"recipients": [
				"gri@golang.org",
				"adonovan@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello adonovan@google.com (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://code.google.com/p/go.tools",
			"disapproval": false,
			"date": "2013-06-18 00:50:13.595120",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"gri@golang.org",
				"adonovan@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I'm concerned that there are two copies of the BFS algorithm here, and that both are unrolled by one level, creating four copies, all slightly different, of a certain part of the algorithm.  Can we do with just one?\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go\nFile go/types/lookup.go (right):\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode22\ngo/types/lookup.go:22: typ = typ.Deref()\nWe may want to keep the information lost in this Deref, and the one in the recursive case, when building promotion wrapper methods.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode42\ngo/types/lookup.go:42: index     []int // field index sequence\nIf you use a linked structure you can share tails across all paths found during the BFS.  It doesn't matter so much in this single-member lookup case I suppose.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode55\ngo/types/lookup.go:55: // Ignore embedded basic types - only user-defined\nThat's true, but you can still have field ambiguity I think.\n\nPlease add a testcase for:\n\ntype Pointer int\ntype T struct { unsafe.Pointer; Pointer }\nvar t T\n_ = t.Pointer  // error: ambiguous field\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode168\ngo/types/lookup.go:168: // an interface type implements T if it has no methods with conflicting signatures\nPerhaps the MissingMethod operations for isinterfaces I and concrete types C should be separated.  (You could still keep MissingMethod as a wrapper around both halves.)\n\n\"Does C implement I?\" is equivalent to \"is C assignable to I?\", which is computed by MissingMethod (and isAssignable).\n\nBut the question \"Does I1 implement I2\" has three possible answers:\n- yes, I1 <: I2\n- no, I1 and I2 conflict\n- maybe.  It depends on the dynamic types.\nIt would be nice to make this clear.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode171\ngo/types/lookup.go:171: return\n// fast path for a common case\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go\nFile go/types/methodset.go (right):\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode16\ngo/types/methodset.go:16: // A MethodSet is a sorted list of methods.\nsorted by what?\n\nPerhaps better to describe it as an ordered set, since the name includes \"set\".\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode60\ngo/types/methodset.go:60: func NewMethodSet(typ Type) *MethodSet {\nDo we want to memoize this construction?\n\n(Downside: thread-safety because an issue.)\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode61\ngo/types/methodset.go:61: isPtr := false\nPerhaps add a comment:\n// Don't use Deref because it may remove a name.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode71\ngo/types/methodset.go:71: base := make(methodSet)\nMost types have empty (nil?) method sets.  Consider allocating the map lazily.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode77\ngo/types/methodset.go:77: // (no incoming multiples) and because it's the common case.\nThat's true, but the duplication complicates the logic for no appreciable (I would guess) performance gain.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode88\ngo/types/methodset.go:88: multiples bool\ncan we call this \"conflicts\", since that's what it means?\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode104\ngo/types/methodset.go:104: // named types can have methods or have struct fields.\nCan you add a testcase for this type:\n\ntype s struct {\n  int\n}\n\nfunc (s struct) int() {}\n?\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode161\ngo/types/methodset.go:161: // named types can have methods or have struct fields.\nCould you test this with unsafe.Pointer (a basic type whose \"anonymous field name\" may conflict with other types), as in the example I gave above?\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode225\ngo/types/methodset.go:225: // If multiples is set, the same field appears multiple times.\ns/appears/may appear/?\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode243\ngo/types/methodset.go:243: // If multiples is set, every method appears multiple times.\nIs \"every method appears multiple times\" really what you mean?\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode258\ngo/types/methodset.go:258: // byKey function lists can be sorted by (key(pkg, name).\nRogue '('.",
			"disapproval": false,
			"date": "2013-06-18 18:11:58.649010",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"gri@golang.org",
				"adonovan@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go\nFile go/types/lookup.go (right):\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode55\ngo/types/lookup.go:55: // Ignore embedded basic types - only user-defined\nOn 2013/06/18 18:11:58, adonovan wrote:\n> That's true, but you can still have field ambiguity I think.\n> \n> Please add a testcase for:\n> \n> type Pointer int\n> type T struct { unsafe.Pointer; Pointer }\n> var t T\n> _ = t.Pointer  // error: ambiguous field\n\nI meant something like this---you get the picture:\n\ntype Pointer int\ntype A struct{ Pointer }\ntype B struct{ unsafe.Pointer }\ntype T struct{ A; B }\n\nvar t T\n_ = t.Pointer // error: ambiguous field",
			"disapproval": false,
			"date": "2013-06-18 18:19:11.104410",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"gri@golang.org",
				"adonovan@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL.\n\nI am aware of the duplication (quadruplication) of the \"same\" algorithm. I haven't found an obvious way to factor it yet.\n\nI prefer to continue with it as is stands until it's computing everything we need (while keeping the code as similar and symmetric as possible). A pattern may evolve in the end. Trying to factor it now in the incomplete form is not helpful. The complete form may not permit factoring - or it may.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go\nFile go/types/lookup.go (right):\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode22\ngo/types/lookup.go:22: typ = typ.Deref()\nOn 2013/06/18 18:11:58, adonovan wrote:\n> We may want to keep the information lost in this Deref, and the one in the\n> recursive case, when building promotion wrapper methods.\n\nNext CL. Added TODO.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode42\ngo/types/lookup.go:42: index     []int // field index sequence\nOn 2013/06/18 18:11:58, adonovan wrote:\n> If you use a linked structure you can share tails across all paths found during\n> the BFS.  It doesn't matter so much in this single-member lookup case I suppose.\n> \n\nyep - this is easier (otherwise I have to cache the tails somewhere)\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode55\ngo/types/lookup.go:55: // Ignore embedded basic types - only user-defined\nOn 2013/06/18 18:11:58, adonovan wrote:\n> That's true, but you can still have field ambiguity I think.\n> \n> Please add a testcase for:\n> \n> type Pointer int\n> type T struct { unsafe.Pointer; Pointer }\n> var t T\n> _ = t.Pointer  // error: ambiguous field\n\nI'm not talking about ambiguous fields here at all. Just pointing out the difference between basic types (which are also named) and named types.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode55\ngo/types/lookup.go:55: // Ignore embedded basic types - only user-defined\nOn 2013/06/18 18:11:58, adonovan wrote:\n> That's true, but you can still have field ambiguity I think.\n> \n> Please add a testcase for:\n> \n> type Pointer int\n> type T struct { unsafe.Pointer; Pointer }\n> var t T\n> _ = t.Pointer  // error: ambiguous field\n\nThere's a lot of test cases in decls3.src already. Still, added this specific one.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode168\ngo/types/lookup.go:168: // an interface type implements T if it has no methods with conflicting signatures\nOn 2013/06/18 18:11:58, adonovan wrote:\n> Perhaps the MissingMethod operations for isinterfaces I and concrete types C\n> should be separated.  (You could still keep MissingMethod as a wrapper around\n> both halves.)\n> \n> \"Does C implement I?\" is equivalent to \"is C assignable to I?\", which is\n> computed by MissingMethod (and isAssignable).\n> \n> But the question \"Does I1 implement I2\" has three possible answers:\n> - yes, I1 <: I2\n> - no, I1 and I2 conflict\n> - maybe.  It depends on the dynamic types.\n> It would be nice to make this clear.\n\nI've struggled with this originally. Hence this function MissingMethod. It just determines if there's a method from the static type of typ with respect to T. It's very clear what it does.\n\nWe will revisit probably in a cleanup CL once the other pieces fall in place.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode171\ngo/types/lookup.go:171: return\nOn 2013/06/18 18:11:58, adonovan wrote:\n> // fast path for a common case\n\nDone.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go\nFile go/types/methodset.go (right):\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode16\ngo/types/methodset.go:16: // A MethodSet is a sorted list of methods.\nOn 2013/06/18 18:11:58, adonovan wrote:\n> sorted by what?\n> \n> Perhaps better to describe it as an ordered set, since the name includes \"set\".\n\nDone.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode60\ngo/types/methodset.go:60: func NewMethodSet(typ Type) *MethodSet {\nOn 2013/06/18 18:11:58, adonovan wrote:\n> Do we want to memoize this construction?\n> \n> (Downside: thread-safety because an issue.)\n\nYes, eventually. Just the first step.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode61\ngo/types/methodset.go:61: isPtr := false\nOn 2013/06/18 18:11:58, adonovan wrote:\n> Perhaps add a comment:\n> // Don't use Deref because it may remove a name.\n\nActually, Deref is not used because we loose the ptr info.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode71\ngo/types/methodset.go:71: base := make(methodSet)\nOn 2013/06/18 18:11:58, adonovan wrote:\n> Most types have empty (nil?) method sets.  Consider allocating the map lazily.\n\nOptimization. Added TODO.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode77\ngo/types/methodset.go:77: // (no incoming multiples) and because it's the common case.\nOn 2013/06/18 18:11:58, adonovan wrote:\n> That's true, but the duplication complicates the logic for no appreciable (I\n> would guess) performance gain.\n\nIt duplicates the logic but it also simplifies the logic below: In the uncommon case, the embedded types are always named. Not the case here.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode88\ngo/types/methodset.go:88: multiples bool\nOn 2013/06/18 18:11:58, adonovan wrote:\n> can we call this \"conflicts\", since that's what it means?\n\nI went back and forth between conflict/collision/multiple. I like multiple because a) it matches the code in lookup, and b) unless one uses a member, it's not a conflict yet. True, in this code they are all \"used\" and thus conflicts, but then the code is different from lookup. Prefer to leave as is.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode104\ngo/types/methodset.go:104: // named types can have methods or have struct fields.\nOn 2013/06/18 18:11:58, adonovan wrote:\n> Can you add a testcase for this type:\n> \n> type s struct {\n>   int\n> }\n> \n> func (s struct) int() {}\n> ?\n\nThere are already test cases for fields and methods of the same name in testdata/decls2a/2b.\n\nAdded this specific case.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode161\ngo/types/methodset.go:161: // named types can have methods or have struct fields.\nOn 2013/06/18 18:11:58, adonovan wrote:\n> Could you test this with unsafe.Pointer (a basic type whose \"anonymous field\n> name\" may conflict with other types), as in the example I gave above?\n> \n\nAdded (like above).\n\nIt exposed a panic (field and method name conflict at most shallow depth: Pointer) which I removed since the type checker already reports the bug. It simply doesn't report it twice, which is what we want.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode225\ngo/types/methodset.go:225: // If multiples is set, the same field appears multiple times.\nOn 2013/06/18 18:11:58, adonovan wrote:\n> s/appears/may appear/?\n\nrephrased.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode243\ngo/types/methodset.go:243: // If multiples is set, every method appears multiple times.\nOn 2013/06/18 18:11:58, adonovan wrote:\n> Is \"every method appears multiple times\" really what you mean?\n\nyes\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode258\ngo/types/methodset.go:258: // byKey function lists can be sorted by (key(pkg, name).\nOn 2013/06/18 18:11:58, adonovan wrote:\n> Rogue '('.\n\nDone.",
			"disapproval": false,
			"date": "2013-06-18 20:19:11.294970",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"gri@golang.org",
				"adonovan@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/18 20:19:11, gri wrote:\n> PTAL.\n> \n> I am aware of the duplication (quadruplication) of the \"same\" algorithm. I\n> haven't found an obvious way to factor it yet.\n> \n> I prefer to continue with it as is stands until it's computing everything we\n> need (while keeping the code as similar and symmetric as possible). A pattern\n> may evolve in the end. Trying to factor it now in the incomplete form is not\n> helpful. The complete form may not permit factoring - or it may.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go\n> File go/types/lookup.go (right):\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode22\n> go/types/lookup.go:22: typ = typ.Deref()\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > We may want to keep the information lost in this Deref, and the one in the\n> > recursive case, when building promotion wrapper methods.\n> \n> Next CL. Added TODO.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode42\n> go/types/lookup.go:42: index     []int // field index sequence\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > If you use a linked structure you can share tails across all paths found\n> during\n> > the BFS.  It doesn't matter so much in this single-member lookup case I\n> suppose.\n> > \n> \n> yep - this is easier (otherwise I have to cache the tails somewhere)\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode55\n> go/types/lookup.go:55: // Ignore embedded basic types - only user-defined\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > That's true, but you can still have field ambiguity I think.\n> > \n> > Please add a testcase for:\n> > \n> > type Pointer int\n> > type T struct { unsafe.Pointer; Pointer }\n> > var t T\n> > _ = t.Pointer  // error: ambiguous field\n> \n> I'm not talking about ambiguous fields here at all. Just pointing out the\n> difference between basic types (which are also named) and named types.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode55\n> go/types/lookup.go:55: // Ignore embedded basic types - only user-defined\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > That's true, but you can still have field ambiguity I think.\n> > \n> > Please add a testcase for:\n> > \n> > type Pointer int\n> > type T struct { unsafe.Pointer; Pointer }\n> > var t T\n> > _ = t.Pointer  // error: ambiguous field\n> \n> There's a lot of test cases in decls3.src already. Still, added this specific\n> one.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode168\n> go/types/lookup.go:168: // an interface type implements T if it has no methods\n> with conflicting signatures\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > Perhaps the MissingMethod operations for isinterfaces I and concrete types C\n> > should be separated.  (You could still keep MissingMethod as a wrapper around\n> > both halves.)\n> > \n> > \"Does C implement I?\" is equivalent to \"is C assignable to I?\", which is\n> > computed by MissingMethod (and isAssignable).\n> > \n> > But the question \"Does I1 implement I2\" has three possible answers:\n> > - yes, I1 <: I2\n> > - no, I1 and I2 conflict\n> > - maybe.  It depends on the dynamic types.\n> > It would be nice to make this clear.\n> \n> I've struggled with this originally. Hence this function MissingMethod. It just\n> determines if there's a method from the static type of typ with respect to T.\n> It's very clear what it does.\n> \n> We will revisit probably in a cleanup CL once the other pieces fall in place.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/lookup.go#newcode171\n> go/types/lookup.go:171: return\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > // fast path for a common case\n> \n> Done.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go\n> File go/types/methodset.go (right):\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode16\n> go/types/methodset.go:16: // A MethodSet is a sorted list of methods.\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > sorted by what?\n> > \n> > Perhaps better to describe it as an ordered set, since the name includes\n> \"set\".\n> \n> Done.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode60\n> go/types/methodset.go:60: func NewMethodSet(typ Type) *MethodSet {\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > Do we want to memoize this construction?\n> > \n> > (Downside: thread-safety because an issue.)\n> \n> Yes, eventually. Just the first step.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode61\n> go/types/methodset.go:61: isPtr := false\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > Perhaps add a comment:\n> > // Don't use Deref because it may remove a name.\n> \n> Actually, Deref is not used because we loose the ptr info.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode71\n> go/types/methodset.go:71: base := make(methodSet)\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > Most types have empty (nil?) method sets.  Consider allocating the map lazily.\n> \n> Optimization. Added TODO.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode77\n> go/types/methodset.go:77: // (no incoming multiples) and because it's the common\n> case.\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > That's true, but the duplication complicates the logic for no appreciable (I\n> > would guess) performance gain.\n> \n> It duplicates the logic but it also simplifies the logic below: In the uncommon\n> case, the embedded types are always named. Not the case here.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode88\n> go/types/methodset.go:88: multiples bool\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > can we call this \"conflicts\", since that's what it means?\n> \n> I went back and forth between conflict/collision/multiple. I like multiple\n> because a) it matches the code in lookup, and b) unless one uses a member, it's\n> not a conflict yet. True, in this code they are all \"used\" and thus conflicts,\n> but then the code is different from lookup. Prefer to leave as is.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode104\n> go/types/methodset.go:104: // named types can have methods or have struct\n> fields.\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > Can you add a testcase for this type:\n> > \n> > type s struct {\n> >   int\n> > }\n> > \n> > func (s struct) int() {}\n> > ?\n> \n> There are already test cases for fields and methods of the same name in\n> testdata/decls2a/2b.\n> \n> Added this specific case.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode161\n> go/types/methodset.go:161: // named types can have methods or have struct\n> fields.\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > Could you test this with unsafe.Pointer (a basic type whose \"anonymous field\n> > name\" may conflict with other types), as in the example I gave above?\n> > \n> \n> Added (like above).\n> \n> It exposed a panic (field and method name conflict at most shallow depth:\n> Pointer) which I removed since the type checker already reports the bug. It\n> simply doesn't report it twice, which is what we want.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode225\n> go/types/methodset.go:225: // If multiples is set, the same field appears\n> multiple times.\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > s/appears/may appear/?\n> \n> rephrased.\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode243\n> go/types/methodset.go:243: // If multiples is set, every method appears multiple\n> times.\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > Is \"every method appears multiple times\" really what you mean?\n> \n> yes\n> \n> https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode258\n> go/types/methodset.go:258: // byKey function lists can be sorted by (key(pkg,\n> name).\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > Rogue '('.\n> \n> Done.\n\n\nLGTM",
			"disapproval": false,
			"date": "2013-06-18 22:48:42.962040",
			"approval": true
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"gri@golang.org",
				"adonovan@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go\nFile go/types/methodset.go (right):\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode61\ngo/types/methodset.go:61: isPtr := false\nOn 2013/06/18 20:19:11, gri wrote:\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > Perhaps add a comment:\n> > // Don't use Deref because it may remove a name.\n> \n> Actually, Deref is not used because we loose the ptr info.\n\nRight, but I meant:\n\ntyp := typ0.Deref()\nisPtr := typ != typ0\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode242\ngo/types/methodset.go:242: // Add adds all methods in list to the method set s.\ns/Add/add/\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode243\ngo/types/methodset.go:243: // If multiples is set, every method appears multiple times.\nOn 2013/06/18 20:19:11, gri wrote:\n> On 2013/06/18 18:11:58, adonovan wrote:\n> > Is \"every method appears multiple times\" really what you mean?\n> \n> yes\n\nAh, I get it now.  Perhaps:\n\n\"If multiples is set, every method in list appeared multiple times and will be removed from the method set.\"",
			"disapproval": false,
			"date": "2013-06-18 22:48:51.001660",
			"approval": true
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"gri@golang.org",
				"adonovan@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go\nFile go/types/methodset.go (right):\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode61\ngo/types/methodset.go:61: isPtr := false\nOn 2013/06/18 22:48:51, adonovan wrote:\n> On 2013/06/18 20:19:11, gri wrote:\n> > On 2013/06/18 18:11:58, adonovan wrote:\n> > > Perhaps add a comment:\n> > > // Don't use Deref because it may remove a name.\n> > \n> > Actually, Deref is not used because we loose the ptr info.\n> \n> Right, but I meant:\n> \n\nACK\n> typ := typ0.Deref()\n> isPtr := typ != typ0\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode242\ngo/types/methodset.go:242: // Add adds all methods in list to the method set s.\nOn 2013/06/18 22:48:51, adonovan wrote:\n> s/Add/add/\n\nIt's the beginning of a sentence, and thus starts with a capital letter, no matter what. The thing to do, per r. It's internal, so I am not concerned. Leaving as is.\n\nhttps://codereview.appspot.com/10235049/diff/23001/go/types/methodset.go#newcode243\ngo/types/methodset.go:243: // If multiples is set, every method appears multiple times.\nOn 2013/06/18 22:48:51, adonovan wrote:\n> On 2013/06/18 20:19:11, gri wrote:\n> > On 2013/06/18 18:11:58, adonovan wrote:\n> > > Is \"every method appears multiple times\" really what you mean?\n> > \n> > yes\n> \n> Ah, I get it now.  Perhaps:\n> \n> \"If multiples is set, every method in list appeared multiple times and will be\n> removed from the method set.\"\n\nThey are not removed if they exist at higher level. Rephrased.",
			"disapproval": false,
			"date": "2013-06-18 22:58:11.207960",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"gri@golang.org",
				"adonovan@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=4f7be25da7f7&repo=tools ***\n\ngo.tools/go/types: first cut at sorted method sets\n\n- moved single field and method lookup functionality\n  from operand.go to new file lookup.go and cleaned\n  up the lookup implementation\n\n- implemented method set computation using the same\n  basic structure as for field/method lookup, in new\n  file methodset.go\n\n- minor related changes\n\n- the method set computation ignores pointer-ness of\n  the receiver type at the moment (next CL)\n\n- fixed a couple of bugs (missing pkg info for imported\n  embedded types, wrong test for method expressions)\n\nThe method set computation is currently verified by\ncomparing a regular method lookup with a method-set\nbased method lookup.\n\nR=adonovan\nCC=golang-dev\nhttps://codereview.appspot.com/10235049",
			"disapproval": false,
			"date": "2013-06-18 22:59:20.384940",
			"approval": false
		}
	],
	"owner_email": "gri@golang.org",
	"private": false,
	"base_url": "",
	"owner": "gri",
	"subject": "code review 10235049: go.tools/go/types: first cut at sorted method sets",
	"created": "2013-06-15 00:21:18.997510",
	"patchsets": [
		1,
		2001,
		5001,
		8001,
		11001,
		14001,
		17001,
		19001,
		16009,
		16010,
		23001,
		27001,
		33001,
		36001,
		35014
	],
	"modified": "2013-06-18 22:59:21.778960",
	"closed": true,
	"issue": 10235049
}