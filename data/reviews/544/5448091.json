{
	"description": "update tree for new default type rule",
	"cc": [
		"golang-dev@googlegroups.com",
		"bradfitz@golang.org"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2011-12-09 02:50:13.485753",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n On Dec 8, 2011 6:50 PM, <rsc@golang.org> wrote:\n\n> Reviewers: golang-dev_googlegroups.com,\n>\n> Message:\n> Hello golang-dev@googlegroups.com,\n>\n> I'd like you to review this change to\n> https://go.googlecode.com/hg/\n>\n>\n> Description:\n> update tree for new default type rule\n>\n> Please review this at http://codereview.appspot.com/**5448091/<http://codereview.appspot.com/5448091/>\n>\n> Affected files:\n>  M src/cmd/cgo/gcc.go\n>  M src/cmd/godoc/dirtrees.go\n>  M src/pkg/bytes/bytes.go\n>  M src/pkg/exp/types/gcimporter.**go\n>  M src/pkg/fmt/scan_test.go\n>  M src/pkg/go/build/dir.go\n>  M src/pkg/html/escape.go\n>  M src/pkg/html/template/css.go\n>  M src/pkg/math/big/nat.go\n>  M src/pkg/regexp/syntax/parse.go\n>  M src/pkg/strings/strings.go\n>  M src/pkg/strings/strings_test.**go\n>  M src/pkg/unicode/letter.go\n>\n>\n> Index: src/cmd/cgo/gcc.go\n> ==============================**==============================**=======\n> --- a/src/cmd/cgo/gcc.go\n> +++ b/src/cmd/cgo/gcc.go\n> @@ -201,7 +201,7 @@\n>        arg := make([]rune, len(s))\n>        escaped := false\n>        quoted := false\n> -       quote := rune(0)\n> +       quote := '\\x00'\n>        i := 0\n>        for _, r := range s {\n>                switch {\n> Index: src/cmd/godoc/dirtrees.go\n> ==============================**==============================**=======\n> --- a/src/cmd/godoc/dirtrees.go\n> +++ b/src/cmd/godoc/dirtrees.go\n> @@ -47,7 +47,7 @@\n>  func firstSentence(s string) string {\n>        i := -1 // index+1 of first terminator (punctuation ending a\n> sentence)\n>        j := -1 // index+1 of first terminator followed by white space\n> -       prev := rune('A')\n> +       prev := 'A'\n>        for k, ch := range s {\n>                k1 := k + 1\n>                if ch == '.' || ch == '!' || ch == '?' {\n> Index: src/pkg/bytes/bytes.go\n> ==============================**==============================**=======\n> --- a/src/pkg/bytes/bytes.go\n> +++ b/src/pkg/bytes/bytes.go\n> @@ -470,7 +470,7 @@\n>        // Use a closure here to remember state.\n>        // Hackish but effective. Depends on Map scanning in order and\n> calling\n>        // the closure once per rune.\n> -       prev := rune(' ')\n> +       prev := ' '\n>        return Map(\n>                func(r rune) rune {\n>                        if isSeparator(prev) {\n> Index: src/pkg/exp/types/gcimporter.**go\n> ==============================**==============================**=======\n> --- a/src/pkg/exp/types/**gcimporter.go\n> +++ b/src/pkg/exp/types/**gcimporter.go\n> @@ -81,7 +81,7 @@\n>  func (p *gcParser) init(filename, id string, src io.Reader, imports\n> map[string]*ast.Object) {\n>        p.scanner.Init(src)\n>        p.scanner.Error = func(_ *scanner.Scanner, msg string) {\n> p.error(msg) }\n> -       p.scanner.Mode = scanner.ScanIdents | scanner.ScanInts |\n> scanner.ScanStrings | scanner.ScanComments | scanner.SkipComments\n> +       p.scanner.Mode = scanner.ScanIdents | scanner.ScanInts |\n> scanner.ScanChars | scanner.ScanStrings | scanner.ScanComments |\n> scanner.SkipComments\n>        p.scanner.Whitespace = 1<<'\\t' | 1<<' '\n>        p.scanner.Filename = filename // for good error messages\n>        p.next()\n> @@ -206,7 +206,7 @@\n>  }\n>\n>  func (p *gcParser) expectSpecial(tok string) {\n> -       sep := rune('x') // not white space\n> +       sep := 'x' // not white space\n>        i := 0\n>        for i < len(tok) && p.tok == rune(tok[i]) && sep > ' ' {\n>                sep = p.scanner.Peek() // if sep <= ' ', there is white\n> space before the next token\n> @@ -261,7 +261,7 @@\n>  func (p *gcParser) parseDotIdent() string {\n>        ident := \"\"\n>        if p.tok != scanner.Int {\n> -               sep := rune('x') // not white space\n> +               sep := 'x' // not white space\n>                for (p.tok == scanner.Ident || p.tok == scanner.Int ||\n> p.tok == '\u00b7') && sep > ' ' {\n>                        ident += p.lit\n>                        sep = p.scanner.Peek() // if sep <= ' ', there is\n> white space before the next token\n> @@ -645,6 +645,7 @@\n>  // Literal     = bool_lit | int_lit | float_lit | complex_lit |\n> string_lit .\n>  // bool_lit    = \"true\" | \"false\" .\n>  // complex_lit = \"(\" float_lit \"+\" float_lit \")\" .\n> +// rune_lit = \"(\" int_lit \"+\" int_lit \")\" .\n>  // string_lit  = `\"` { unicode_char } `\"` .\n>  //\n>  func (p *gcParser) parseConstDecl() {\n> @@ -674,21 +675,32 @@\n>                        typ = Float64.Underlying\n>                }\n>        case '(':\n> -               // complex_lit\n> +               // complex_lit or rune_lit\n>                p.next()\n> +               if p.tok == scanner.Char {\n> +                       p.next()\n> +                       p.expect('+')\n> +                       p.parseNumber()\n> +                       // TODO: x = ...\n> +                       break\n> +               }\n>                re := p.parseNumber()\n>                p.expect('+')\n>                im := p.parseNumber()\n>                p.expect(')')\n>                x = Const{cmplx{re.val.(*big.Rat), im.val.(*big.Rat)}}\n>                typ = Complex128.Underlying\n> +       case scanner.Char:\n> +               // TODO: x = ...\n> +               p.next()\n>        case scanner.String:\n>                // string_lit\n>                x = MakeConst(token.STRING, p.lit)\n>                p.next()\n>                typ = String.Underlying\n>        default:\n> -               p.error(\"expected literal\")\n> +               println(p.tok)\n> +               p.errorf(\"expected literal got %s\",\n> scanner.TokenString(p.tok))\n>        }\n>        if obj.Type == nil {\n>                obj.Type = typ\n> Index: src/pkg/fmt/scan_test.go\n> ==============================**==============================**=======\n> --- a/src/pkg/fmt/scan_test.go\n> +++ b/src/pkg/fmt/scan_test.go\n> @@ -56,6 +56,7 @@\n>        stringVal            string\n>        stringVal1           string\n>        bytesVal             []byte\n> +       runeVal              rune\n>        complex64Val         complex64\n>        complex128Val        complex128\n>        renamedBoolVal       renamedBool\n> @@ -225,9 +226,9 @@\n>        {\"%v\", \"0377\\n\", &intVal, 0377},\n>        {\"%v\", \"0x44\\n\", &intVal, 0x44},\n>        {\"%d\", \"72\\n\", &intVal, 72},\n> -       {\"%c\", \"a\\n\", &intVal, 'a'},\n> -       {\"%c\", \"\\u5072\\n\", &intVal, 0x5072},\n> -       {\"%c\", \"\\u1234\\n\", &intVal, '\\u1234'},\n> +       {\"%c\", \"a\\n\", &runeVal, 'a'},\n> +       {\"%c\", \"\\u5072\\n\", &runeVal, '\\u5072'},\n> +       {\"%c\", \"\\u1234\\n\", &runeVal, '\\u1234'},\n>        {\"%d\", \"73\\n\", &int8Val, int8(73)},\n>        {\"%d\", \"+74\\n\", &int16Val, int16(74)},\n>        {\"%d\", \"75\\n\", &int32Val, int32(75)},\n> @@ -322,6 +323,7 @@\n>  var c complex128\n>  var x, y Xs\n>  var z IntString\n> +var r1, r2, r3 rune\n>\n>  var multiTests = []ScanfMultiTest{\n>        {\"\", \"\", []interface{}{}, []interface{}{}, \"\"},\n> @@ -333,7 +335,7 @@\n>        {\"%3d22%3d\", \"33322333\", args(&i, &j), args(333, 333), \"\"},\n>        {\"%6vX=%3fY\", \"3+2iX=2.5Y\", args(&c, &f), args((3 + 2i), 2.5), \"\"},\n>        {\"%d%s\", \"123abc\", args(&i, &s), args(123, \"abc\"), \"\"},\n> -       {\"%c%c%c\", \"2\\u50c2X\", args(&i, &j, &k), args('2', '\\u50c2', 'X'),\n> \"\"},\n> +       {\"%c%c%c\", \"2\\u50c2X\", args(&r1, &r2, &r3), args('2', '\\u50c2',\n> 'X'), \"\"},\n>\n>        // Custom scanners.\n>        {\"%e%f\", \"eefffff\", args(&x, &y), args(Xs(\"ee\"), Xs(\"fffff\")), \"\"},\n> @@ -347,7 +349,7 @@\n>        {\"X%d\", \"10X\", args(&intVal), nil, \"input does not match format\"},\n>\n>        // Bad UTF-8: should see every byte.\n> -       {\"%c%c%c\", \"\\xc2X\\xc2\", args(&i, &j, &k), args(utf8.RuneError,\n> 'X', utf8.RuneError), \"\"},\n> +       {\"%c%c%c\", \"\\xc2X\\xc2\", args(&r1, &r2, &r3), args(utf8.RuneError,\n> 'X', utf8.RuneError), \"\"},\n>  }\n>\n>  func testScan(name string, t *testing.T, scan func(r io.Reader, a\n> ...interface{}) (int, error)) {\n> Index: src/pkg/go/build/dir.go\n> ==============================**==============================**=======\n> --- a/src/pkg/go/build/dir.go\n> +++ b/src/pkg/go/build/dir.go\n> @@ -466,7 +466,7 @@\n>        arg := make([]rune, len(s))\n>        escaped := false\n>        quoted := false\n> -       quote := rune(0)\n> +       quote := '\\x00'\n>        i := 0\n>        for _, rune := range s {\n>                switch {\n> @@ -475,9 +475,9 @@\n>                case rune == '\\\\':\n>                        escaped = true\n>                        continue\n> -               case quote != 0:\n> +               case quote != '\\x00':\n>                        if rune == quote {\n> -                               quote = 0\n> +                               quote = '\\x00'\n>                                continue\n>                        }\n>                case rune == '\"' || rune == '\\'':\n> Index: src/pkg/html/escape.go\n> ==============================**==============================**=======\n> --- a/src/pkg/html/escape.go\n> +++ b/src/pkg/html/escape.go\n> @@ -78,7 +78,7 @@\n>                        i++\n>                }\n>\n> -               x := rune(0)\n> +               x := '\\x00'\n>                for i < len(s) {\n>                        c = s[i]\n>                        i++\n> Index: src/pkg/html/template/css.go\n> ==============================**==============================**=======\n> --- a/src/pkg/html/template/css.go\n> +++ b/src/pkg/html/template/css.go\n> @@ -106,7 +106,7 @@\n>\n>  // hexDecode decodes a short hex digit sequence: \"10\" -> 16.\n>  func hexDecode(s []byte) rune {\n> -       n := rune(0)\n> +       n := '\\x00'\n>        for _, c := range s {\n>                n <<= 4\n>                switch {\n> Index: src/pkg/math/big/nat.go\n> ==============================**==============================**=======\n> --- a/src/pkg/math/big/nat.go\n> +++ b/src/pkg/math/big/nat.go\n> @@ -592,7 +592,7 @@\n>  const MaxBase = 'z' - 'a' + 10 + 1 // = hexValue('z') + 1\n>\n>  func hexValue(ch rune) Word {\n> -       d := MaxBase + 1 // illegal base\n> +       d := int(MaxBase + 1) // illegal base\n>        switch {\n>        case '0' <= ch && ch <= '9':\n>                d = int(ch - '0')\n> Index: src/pkg/regexp/syntax/parse.go\n> ==============================**==============================**=======\n> --- a/src/pkg/regexp/syntax/parse.**go\n> +++ b/src/pkg/regexp/syntax/parse.**go\n> @@ -1694,7 +1694,7 @@\n>  // appendNegatedClass returns the result of appending the negation of the\n> class x to the class r.\n>  // It assumes x is clean.\n>  func appendNegatedClass(r []rune, x []rune) []rune {\n> -       nextLo := rune('\\u0000')\n> +       nextLo := '\\u0000'\n>        for i := 0; i < len(x); i += 2 {\n>                lo, hi := x[i], x[i+1]\n>                if nextLo <= lo-1 {\n> @@ -1735,7 +1735,7 @@\n>\n>  // appendNegatedTable returns the result of appending the negation of x\n> to the class r.\n>  func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune {\n> -       nextLo := rune('\\u0000') // lo end of next class to add\n> +       nextLo := '\\u0000' // lo end of next class to add\n>        for _, xr := range x.R16 {\n>                lo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)\n>                if stride == 1 {\n> @@ -1777,8 +1777,8 @@\n>  // negateClass overwrites r and returns r's negation.\n>  // It assumes the class r is already clean.\n>  func negateClass(r []rune) []rune {\n> -       nextLo := rune('\\u0000') // lo end of next class to add\n> -       w := 0                   // write index\n> +       nextLo := '\\u0000' // lo end of next class to add\n> +       w := 0             // write index\n>        for i := 0; i < len(r); i += 2 {\n>                lo, hi := r[i], r[i+1]\n>                if nextLo <= lo-1 {\n> Index: src/pkg/strings/strings.go\n> ==============================**==============================**=======\n> --- a/src/pkg/strings/strings.go\n> +++ b/src/pkg/strings/strings.go\n> @@ -434,7 +434,7 @@\n>        // Use a closure here to remember state.\n>        // Hackish but effective. Depends on Map scanning in order and\n> calling\n>        // the closure once per rune.\n> -       prev := rune(' ')\n> +       prev := ' '\n>        return Map(\n>                func(r rune) rune {\n>                        if isSeparator(prev) {\n> Index: src/pkg/strings/strings_test.**go\n> ==============================**==============================**=======\n> --- a/src/pkg/strings/strings_**test.go\n> +++ b/src/pkg/strings/strings_**test.go\n> @@ -642,7 +642,7 @@\n>\n>  func TestCaseConsistency(t *testing.T) {\n>        // Make a string of all the runes.\n> -       numRunes := unicode.MaxRune + 1\n> +       numRunes := int(unicode.MaxRune + 1)\n>        if testing.Short() {\n>                numRunes = 1000\n>        }\n> Index: src/pkg/unicode/letter.go\n> ==============================**==============================**=======\n> --- a/src/pkg/unicode/letter.go\n> +++ b/src/pkg/unicode/letter.go\n> @@ -7,10 +7,10 @@\n>  package unicode\n>\n>  const (\n> -       MaxRune         = 0x10FFFF // Maximum valid Unicode code point.\n> -       ReplacementChar = 0xFFFD   // Represents invalid code points.\n> -       MaxASCII        = 0x7F     // maximum ASCII value.\n> -       MaxLatin1       = 0xFF     // maximum Latin-1 value.\n> +       MaxRune         = '\\U0010FFFF' // Maximum valid Unicode code point.\n> +       ReplacementChar = '\\uFFFD'     // Represents invalid code points.\n> +       MaxASCII        = '\\u007F'     // maximum ASCII value.\n> +       MaxLatin1       = '\\u00FF'     // maximum Latin-1 value.\n>  )\n>\n>  // RangeTable defines a set of Unicode code points by listing the ranges\n> of\n>\n>\n>\n",
			"disapproval": false,
			"date": "2011-12-09 02:55:08.346807",
			"approval": true
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=c0f7c53dcfce ***\n\nupdate tree for new default type rule\n\nR=golang-dev, bradfitz\nCC=golang-dev\nhttp://codereview.appspot.com/5448091",
			"disapproval": false,
			"date": "2011-12-09 03:08:06.021537",
			"approval": false
		}
	],
	"owner_email": "rsc@golang.org",
	"private": false,
	"base_url": "",
	"owner": "rsc",
	"subject": "code review 5448091: update tree for new default type rule",
	"created": "2011-12-02 21:53:03.075866",
	"patchsets": [
		1,
		2001,
		4001,
		5001,
		7002
	],
	"modified": "2011-12-09 03:08:06.955964",
	"closed": true,
	"issue": 5448091
}