{
	"description": "go.text/transform: new package.\n\nThis CL only provides the Reader type; Writer will be in a follow-up.",
	"cc": [
		"mpvl@golang.org",
		"mpvl@google.com",
		"andybalholm@gmail.com",
		"golang-dev@googlegroups.com",
		"rogpeppe@gmail.com"
	],
	"reviewers": [
		"r@golang.org"
	],
	"messages": [
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"mpvl@golang.org",
				"r@golang.org",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello mpvl@golang.org, r@golang.org (cc: andybalholm@gmail.com, golang-dev@googlegroups.com, rogpeppe@gmail.com),\n\nI'd like you to review this change to\nhttps://code.google.com/p/go.text",
			"disapproval": false,
			"date": "2013-06-25 10:14:03.922620",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"mpvl@golang.org",
				"r@golang.org",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10538043/diff/4001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode28\ntransform/transform.go:28: // returns the number of dst bytes written and src bytes read. atEOF\ns/atEOF/AtEOF/ or rewrite to avoid the capital.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode29\ntransform/transform.go:29: // is whether there is no more source data after this call. Both dst\ns/is/tells/\n\nbut you're writing in the negative true sense, which is confusing. how about:\n\nThe atEOF argument tells whether src represents the last bytes of the input.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode30\ntransform/transform.go:30: // and src will have non-zero length.\nwhat if they don't? i don't know what 'will' means\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode33\ntransform/transform.go:33: // made (i.e. at least one of nDst and nSrc is non-zero), and non-nil\ns/i.e. /that is,/ or even //\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode65\ntransform/transform.go:65: // read via t. dstSize and srcSize are the size in bytes of the Transformer's\ns/dstSize/DstSize/\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode67\ntransform/transform.go:67: func NewReaderSize(r io.Reader, t Transformer, dstSize, srcSize int) *Reader {\ni think it's silly to specify distinct sizes for dst and src. just have one. for any realistic transformation, that's fine.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode83\ntransform/transform.go:83: // Pass on any transformed bytes.\n\"pass on\" is ambiguous: could mean ignore, could mean move.\n\ns/Pass on/Copy out/\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode90\ntransform/transform.go:90: // Try to transform any source bytes. We do this even if we got a\ns/any/some/",
			"disapproval": false,
			"date": "2013-06-25 17:52:10.526000",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"mpvl@golang.org",
				"r@golang.org",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I changed NewReaderSize to return (*Reader, error) instead of just *Reader. NewReader still returns just *Reader.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode28\ntransform/transform.go:28: // returns the number of dst bytes written and src bytes read. atEOF\nOn 2013/06/25 17:52:10, r wrote:\n> s/atEOF/AtEOF/ or rewrite to avoid the capital.\n\nDone.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode29\ntransform/transform.go:29: // is whether there is no more source data after this call. Both dst\nOn 2013/06/25 17:52:10, r wrote:\n> s/is/tells/\n> \n> but you're writing in the negative true sense, which is confusing. how about:\n> \n> The atEOF argument tells whether src represents the last bytes of the input.\n\nDone.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode30\ntransform/transform.go:30: // and src will have non-zero length.\nOn 2013/06/25 17:52:10, r wrote:\n> what if they don't? i don't know what 'will' means\n\nI dropped this condition.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode33\ntransform/transform.go:33: // made (i.e. at least one of nDst and nSrc is non-zero), and non-nil\nOn 2013/06/25 17:52:10, r wrote:\n> s/i.e. /that is,/ or even //\n\nI used \"when\".\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode65\ntransform/transform.go:65: // read via t. dstSize and srcSize are the size in bytes of the Transformer's\nOn 2013/06/25 17:52:10, r wrote:\n> s/dstSize/DstSize/\n\nDone.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode67\ntransform/transform.go:67: func NewReaderSize(r io.Reader, t Transformer, dstSize, srcSize int) *Reader {\nOn 2013/06/25 17:52:10, r wrote:\n> i think it's silly to specify distinct sizes for dst and src. just have one. for\n> any realistic transformation, that's fine.\n\nDone.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode83\ntransform/transform.go:83: // Pass on any transformed bytes.\nOn 2013/06/25 17:52:10, r wrote:\n> \"pass on\" is ambiguous: could mean ignore, could mean move.\n> \n> s/Pass on/Copy out/\n\nDone.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode90\ntransform/transform.go:90: // Try to transform any source bytes. We do this even if we got a\nOn 2013/06/25 17:52:10, r wrote:\n> s/any/some/\n\nDone.",
			"disapproval": false,
			"date": "2013-06-26 06:56:44.613590",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"mpvl@golang.org",
				"r@golang.org",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Nice.  See the comments for a suggestion on a small change to the API.\n\nI have an elaborate testing and benchmarking suite for transformers I will add as well. I also have an implementation of a Writer and Chain.  Will add them after this checkin.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode38\ntransform/transform.go:38: Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error)\nI really like the addition of returning the error.  Please not a few more subtleties that may need to be documented for clarity:\nThe following may be true for Transformers:\n- Transformers may have state/buffers (some implementations will need this). So even if src has been exhausted, the users should call Transform with eof == true and src == nil until nDst == ErrShortDst. (Maybe use io.EOF for this.)\n- A Transformer that completes (makes no progress with eof == true and err == nil) can be reused as a newly initialized Transformer.\n\nOverall, using the fixed buffer variant of the Transformer interface is much trickier than the append variant.  (It believe it to be the better choice, though.)  Now I think about it, I think we should require Transformers to return io.EOF if they're done processing (in addition to the errors you are using).  This way the user could simply be instructed to keep processing until err == io.EOF, very much like with Readers. io.EOF would only be returned if atEOF is true.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode135\ntransform/transform.go:135: // TODO: type Writer.\nI have an implementation of Writer I can add.",
			"disapproval": false,
			"date": "2013-06-26 08:16:58.584570",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"mpvl@golang.org",
				"r@golang.org",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I like the idea that Transform should return io.EOF to signify completion, and you're right that Transform should be called repeatedly when atEOF is true, to flush any buffers. I wasn't intending for Transformer implementations to require their own buffers, since that's what dst and src are, but I guess implementations are free to do their own buffering.\n\nI certainly need to write more tests, especially for the error handling, but let's first agree on what the Transformer contract exactly is. PTAL at the doc comments on the Transform method.\n\nFor example, I've decided that of Transform's return values, progress being made (nDst != 0 || nSrc != 0) is mutually exclusive with an error being returned. This is different from the io.Reader interface, which explicitly allows n > 0 && err != nil when returning (n, err), but I believe that in hindsight the io.Reader design pushed too much responsibility from callee (io.Reader implementations) to caller (users of io.Reader). Across our codebase, we're not good at *using* the io.Reader interface correctly when n > 0 && err != nil.\n\nI'm also not completely sold on \"A Transformer that completes... can be reused as a newly initialized Transformer\", but I haven't sketched out as many Transformer implementations as you have. In this package, a Reader or Writer is constructed with a Transformer and never tries to re-use it. Can you give an example of re-use? Also, instead of convention, can resetting a Transformer be done via an explicit but optional Reset() method?\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode135\ntransform/transform.go:135: // TODO: type Writer.\nOn 2013/06/26 08:16:58, mpvl wrote:\n> I have an implementation of Writer I can add.\n\nYeah, I also have on in my previous proof-of-concept CL at https://codereview.appspot.com/10085049/diff/22001/unicode/transform/transform.go\n\nI'm sure we can work out something once we agree on the Transformer interface.",
			"disapproval": false,
			"date": "2013-06-27 08:11:27.004010",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"mpvl@golang.org",
				"r@golang.org",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "The package still needs to mention something about a minimum buffer size.  Taking 128 probably covers most of the instances that are planned right now.  Transformers which require more should do internal buffering. Also, this number can always be increased later.\n\nI did some tests and benchmarks using variant of the API using io.EOF.  It improved the performance for various benchmarks, especially for small strings, as it simplified checking the exit cases on each iteration.\n\nSee\nhttps://codereview.appspot.com/10633043\nfor an implementation of a Writer and the Chain function.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode67\ntransform/transform.go:67: func NewReaderSize(r io.Reader, t Transformer, dstSize, srcSize int) *Reader {\nWhy is this function in the API at all?  In the general case, the buffer needs to be of a certain minimum size.  This should be checked/ documented as well.  It may be easier to not have this function at all.\n\nhttps://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode98\ntransform/transform.go:98: } else if err != nil {\nTo support returning io.EOF, add the following check here.\n\t\t\t} else if err != nil && err != io.EOF {",
			"disapproval": false,
			"date": "2013-06-27 09:15:20.648690",
			"approval": false
		},
		{
			"sender": "mpvl@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Jun 27, 2013 at 10:11 AM, <nigeltao@golang.org> wrote:\r\n\r\n> I like the idea that Transform should return io.EOF to signify\r\n> completion, and you're right that Transform should be called repeatedly\r\n> when atEOF is true, to flush any buffers. I wasn't intending for\r\n> Transformer implementations to require their own buffers, since that's\r\n> what dst and src are, but I guess implementations are free to do their\r\n> own buffering.\r\n>\r\nIt is indeed somewhat rare that this is needed, but it is needed for Chain\r\nand some more advanced title case algorithms, for example.\r\nIn many cases Transformers will not require to have any internal state at\r\nall. For example, all forms of normalization, upper case, lower case, as\r\nlong as the output buffer has a certain small minimum size (128 bytes is\r\nmore than sufficient for most cases.)  The user could still call Transform\r\nwith a smaller buffer and check for ErrShortDst, of course.\r\n\r\n\r\n> I certainly need to write more tests, especially for the error handling,\r\n> but let's first agree on what the Transformer contract exactly is. PTAL\r\n> at the doc comments on the Transform method.\r\n>\r\nI think we're getting close.\r\n\r\nI would suggest adding a MinBufferSize (128, with an option to increase it\r\nin the future) that users can use to avoid an ErrShortDst error and\r\nTransformers implementations have to take into account if they need to use\r\nlarger segments.\r\n\r\n\r\n> For example, I've decided that of Transform's return values, progress\r\n> being made (nDst != 0 || nSrc != 0) is mutually exclusive with an error\r\n> being returned.\r\n\r\nI see your point.  I uploaded the wrong version of Writer, for example,\r\nthat did not handle this correctly (fixed now). However,\r\n\r\n   - Not allowing io.EOF with n > 0 means that you always need to make at\r\n   least 2 calls.  This can be expensive for small strings. In my benchmarks\r\n   the extra iteration makes it noticeably slower than using the append\r\n   variant for small strings. Without the extra iteration it is noticeably\r\n   faster.\r\n   - A case where this is particularly annoying is when someone wants to do\r\n   1 call to Transform and fill dst to its max size, does not care about\r\n   additional transformations, but wants to check if what was transformed so\r\n   far is the whole thing.\r\n   - It may be cumbersome to have the two semantics if we have code that\r\n   uses both io and transform interfaces.\r\n\r\nThis is different from the io.Reader interface, which\r\n> explicitly allows n > 0 && err != nil when returning (n, err), but I\r\n> believe that in hindsight the io.Reader design pushed too much\r\n> responsibility from callee (io.Reader implementations) to caller (users\r\n> of io.Reader). Across our codebase, we're not good at *using* the\r\n> io.Reader interface correctly when n > 0 && err != nil.\r\n>\r\nAs a compromise I would allow io.EOF with n > 0, but no other errors if\r\nprogress is made.  Code that does not handle output when err == io.EOF will\r\nbe obviously incorrect, as it will never produce the correct results.  So I\r\ndon't think supporting that case would result in faulty code much.  It\r\nwould still avoid the case you're worried about where input is not\r\nprocessed with an arbitrary other error.\r\n\r\n\r\n> I'm also not completely sold on \"A Transformer that completes... can be\r\n> reused as a newly initialized Transformer\", but I haven't sketched out\r\n> as many Transformer implementations as you have.\r\n\r\nIn this package, a\r\n> Reader or Writer is constructed with a Transformer and never tries to\r\n> re-use it. Can you give an example of re-use?\r\n\r\nIf I want to repeatedly want to convert smaller buffers, it would be nice\r\nto be able to reuse the Transformer.  Transformers are likely to be used\r\nfor small strings as well.\r\nMore concretely:\r\n\r\n   - Normalize or encode individual strings for storage in a database.\r\n   - Normalize a filename to OS X's proprietary normalization form before\r\n   lookup.\r\n   - Put section headers in title case.\r\n   - Convert individual strings from a database stored in encoding X, for\r\n   example using the Transformer returned by\r\n      - Chain(encoding.UTF16BE.NewDecoder(), norm.NFKC) or\r\n      - Chain(encoding.ShiftJIS.NewDecoder(), cases.Get(locale.Jp).Narrow,\r\n      norm.NFC)\r\n   - Transliterate a list of names (e.g. transliterate individual Chinese\r\n   names to pinyin, after which the results are parenthesized and appended\r\n   after the original names before presenting them to the user).\r\n\r\nIn all these cases it is unlikely a user will want to use a Reader.  The\r\noverhead of repeatedly creating a new Transformer, may be significant in\r\nsuch cases, especially when it involves allocating buffers.\r\n\r\nMoreover, things get really interesting if you apply a Transformer to a\r\nstream of text segments.  The transformer would need to be reused after\r\neach segment.  A specific example of this is title-casing a stream of\r\nsegments (words, sentences, specific words). The TitleCase Transformer\r\nwould simply put the first character it is passed to upper case.  The\r\nTransformer would then need to be reset after the completion of each\r\nsegment.  ICU uses this method.  The cool thing is that this method allows\r\nthe Transformer to be very simple and reusable.  It does require it to be\r\nreusable, though.\r\n\r\nFinally, so far, for each implementation I've considered, the state is\r\nautomatically such that it is ready for reuse after completion.  This may\r\nbe different for encoding.\r\n\r\n\r\n> Also, instead of convention, can resetting a Transformer be done via an\r\n> explicit but\r\n> optional Reset() method?\r\n\r\nPossibly, although I would prefer not to make it optional.  Can you give an\r\nexample of how it can be difficult or expensive to do the reset?\r\n\r\nPlease note that most Transformers can probably already be reused for free\r\nafter io.EOF is returned (or even before that when they're stateless).  A\r\ndanger of having an optional Reset is that users will probably get\r\naccustomed to reusing them and then not call Reset when needed.\r\n\r\n\r\n\r\n\r\n>\r\n>\r\n> https://codereview.appspot.**com/10538043/diff/4001/**\r\n> transform/transform.go<https://codereview.appspot.com/10538043/diff/4001/transform/transform.go>\r\n> File transform/transform.go (right):\r\n>\r\n> https://codereview.appspot.**com/10538043/diff/4001/**\r\n> transform/transform.go#**newcode135<https://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode135>\r\n> transform/transform.go:135: // TODO: type Writer.\r\n> On 2013/06/26 08:16:58, mpvl wrote:\r\n>\r\n>> I have an implementation of Writer I can add.\r\n>>\r\n>\r\n> Yeah, I also have on in my previous proof-of-concept CL at\r\n> https://codereview.appspot.**com/10085049/diff/22001/**\r\n> unicode/transform/transform.go<https://codereview.appspot.com/10085049/diff/22001/unicode/transform/transform.go>\r\n>\r\n> I'm sure we can work out something once we agree on the Transformer\r\n> interface.\r\n>\r\n> https://codereview.appspot.**com/10538043/<https://codereview.appspot.com/10538043/>\r\n>\r\n\r\n\r\n\r\n-- \r\nTrying this for a while: http://go/OnlyCheckEmailTwiceADay.\r\nMarcel van Lohuizen -- Google Switzerland GmbH -- Identifikationsnummer:\r\nCH-020.4.028.116-1\r\n",
			"disapproval": false,
			"date": "2013-06-27 12:30:39.226270",
			"approval": false
		},
		{
			"sender": "mpvl@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Jun 27, 2013 at 2:30 PM, Marcel van Lohuizen <mpvl@google.com>wrote:\r\n\r\n>\r\n>\r\n>\r\n> On Thu, Jun 27, 2013 at 10:11 AM, <nigeltao@golang.org> wrote:\r\n>\r\n>> I like the idea that Transform should return io.EOF to signify\r\n>> completion, and you're right that Transform should be called repeatedly\r\n>> when atEOF is true, to flush any buffers. I wasn't intending for\r\n>> Transformer implementations to require their own buffers, since that's\r\n>> what dst and src are, but I guess implementations are free to do their\r\n>> own buffering.\r\n>>\r\n> It is indeed somewhat rare that this is needed, but it is needed for Chain\r\n> and some more advanced title case algorithms, for example.\r\n> In many cases Transformers will not require to have any internal state at\r\n> all. For example, all forms of normalization, upper case, lower case, as\r\n> long as the output buffer has a certain small minimum size (128 bytes is\r\n> more than sufficient for most cases.)  The user could still call Transform\r\n> with a smaller buffer and check for ErrShortDst, of course.\r\n>\r\n>\r\n>> I certainly need to write more tests, especially for the error handling,\r\n>> but let's first agree on what the Transformer contract exactly is. PTAL\r\n>> at the doc comments on the Transform method.\r\n>>\r\n> I think we're getting close.\r\n>\r\n> I would suggest adding a MinBufferSize (128, with an option to increase it\r\n> in the future) that users can use to avoid an ErrShortDst error and\r\n> Transformers implementations have to take into account if they need to use\r\n> larger segments.\r\n>\r\nAlthough we could postpone adding this until a later stage.\r\n\r\n\r\n>\r\n>\r\n>> For example, I've decided that of Transform's return values, progress\r\n>> being made (nDst != 0 || nSrc != 0) is mutually exclusive with an error\r\n>> being returned.\r\n>\r\n> I see your point.  I uploaded the wrong version of Writer, for example,\r\n> that did not handle this correctly (fixed now). However,\r\n>\r\n>    - Not allowing io.EOF with n > 0 means that you always need to make at\r\n>    least 2 calls.  This can be expensive for small strings. In my benchmarks\r\n>    the extra iteration makes it noticeably slower than using the append\r\n>    variant for small strings. Without the extra iteration it is noticeably\r\n>    faster.\r\n>    - A case where this is particularly annoying is when someone wants to\r\n>    do 1 call to Transform and fill dst to its max size, does not care about\r\n>    additional transformations, but wants to check if what was transformed so\r\n>    far is the whole thing.\r\n>    - It may be cumbersome to have the two semantics if we have code that\r\n>    uses both io and transform interfaces.\r\n>\r\n> This is different from the io.Reader interface, which\r\n>> explicitly allows n > 0 && err != nil when returning (n, err), but I\r\n>> believe that in hindsight the io.Reader design pushed too much\r\n>> responsibility from callee (io.Reader implementations) to caller (users\r\n>> of io.Reader). Across our codebase, we're not good at *using* the\r\n>> io.Reader interface correctly when n > 0 && err != nil.\r\n>>\r\n> As a compromise I would allow io.EOF with n > 0, but no other errors if\r\n> progress is made.  Code that does not handle output when err == io.EOF will\r\n> be obviously incorrect, as it will never produce the correct results.  So I\r\n> don't think supporting that case would result in faulty code much.  It\r\n> would still avoid the case you're worried about where input is not\r\n> processed with an arbitrary other error.\r\n>\r\n>\r\n>> I'm also not completely sold on \"A Transformer that completes... can be\r\n>> reused as a newly initialized Transformer\", but I haven't sketched out\r\n>> as many Transformer implementations as you have.\r\n>\r\n> In this package, a\r\n>> Reader or Writer is constructed with a Transformer and never tries to\r\n>> re-use it. Can you give an example of re-use?\r\n>\r\n> If I want to repeatedly want to convert smaller buffers, it would be nice\r\n> to be able to reuse the Transformer.  Transformers are likely to be used\r\n> for small strings as well.\r\n> More concretely:\r\n>\r\n>    - Normalize or encode individual strings for storage in a database.\r\n>    - Normalize a filename to OS X's proprietary normalization form before\r\n>    lookup.\r\n>    - Put section headers in title case.\r\n>    - Convert individual strings from a database stored in encoding X, for\r\n>    example using the Transformer returned by\r\n>       - Chain(encoding.UTF16BE.NewDecoder(), norm.NFKC) or\r\n>       - Chain(encoding.ShiftJIS.NewDecoder(),\r\n>       cases.Get(locale.Jp).Narrow, norm.NFC)\r\n>    - Transliterate a list of names (e.g. transliterate individual Chinese\r\n>    names to pinyin, after which the results are parenthesized and appended\r\n>    after the original names before presenting them to the user).\r\n>\r\n> In all these cases it is unlikely a user will want to use a Reader.  The\r\n> overhead of repeatedly creating a new Transformer, may be significant in\r\n> such cases, especially when it involves allocating buffers.\r\n>\r\n> Moreover, things get really interesting if you apply a Transformer to a\r\n> stream of text segments.  The transformer would need to be reused after\r\n> each segment.  A specific example of this is title-casing a stream of\r\n> segments (words, sentences, specific words). The TitleCase Transformer\r\n> would simply put the first character it is passed to upper case.  The\r\n> Transformer would then need to be reset after the completion of each\r\n> segment.  ICU uses this method.  The cool thing is that this method allows\r\n> the Transformer to be very simple and reusable.  It does require it to be\r\n> reusable, though.\r\n>\r\n> Finally, so far, for each implementation I've considered, the state is\r\n> automatically such that it is ready for reuse after completion.  This may\r\n> be different for encoding.\r\n>\r\n>\r\n>> Also, instead of convention, can resetting a Transformer be done via an\r\n>> explicit but\r\n>> optional Reset() method?\r\n>\r\n> Possibly, although I would prefer not to make it optional.  Can you give\r\n> an example of how it can be difficult or expensive to do the reset?\r\n>\r\n> Please note that most Transformers can probably already be reused for free\r\n> after io.EOF is returned (or even before that when they're stateless).  A\r\n> danger of having an optional Reset is that users will probably get\r\n> accustomed to reusing them and then not call Reset when needed.\r\n>\r\n>\r\n>\r\n>\r\n>>\r\n>>\r\n>> https://codereview.appspot.**com/10538043/diff/4001/**\r\n>> transform/transform.go<https://codereview.appspot.com/10538043/diff/4001/transform/transform.go>\r\n>> File transform/transform.go (right):\r\n>>\r\n>> https://codereview.appspot.**com/10538043/diff/4001/**\r\n>> transform/transform.go#**newcode135<https://codereview.appspot.com/10538043/diff/4001/transform/transform.go#newcode135>\r\n>> transform/transform.go:135: // TODO: type Writer.\r\n>> On 2013/06/26 08:16:58, mpvl wrote:\r\n>>\r\n>>> I have an implementation of Writer I can add.\r\n>>>\r\n>>\r\n>> Yeah, I also have on in my previous proof-of-concept CL at\r\n>> https://codereview.appspot.**com/10085049/diff/22001/**\r\n>> unicode/transform/transform.go<https://codereview.appspot.com/10085049/diff/22001/unicode/transform/transform.go>\r\n>>\r\n>> I'm sure we can work out something once we agree on the Transformer\r\n>> interface.\r\n>>\r\n>> https://codereview.appspot.**com/10538043/<https://codereview.appspot.com/10538043/>\r\n>>\r\n>\r\n>\r\n>\r\n> --\r\n> Trying this for a while: http://go/OnlyCheckEmailTwiceADay.\r\n> Marcel van Lohuizen -- Google Switzerland GmbH -- Identifikationsnummer:\r\n> CH-020.4.028.116-1\r\n>\r\n>\r\n\r\n\r\n-- \r\nTrying this for a while: http://go/OnlyCheckEmailTwiceADay.\r\nMarcel van Lohuizen -- Google Switzerland GmbH -- Identifikationsnummer:\r\nCH-020.4.028.116-1\r\n",
			"disapproval": false,
			"date": "2013-06-27 14:07:50.592390",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I dropped NewReaderSize. I made it for the same reason that\r\nbufio.NewReaderSize exists, but we can leave it out until we need it.\r\n\r\nTransform can now return positive n and non-nil error (any error, not\r\njust io.EOF). Reader.Read looks different, with an explicit\r\ntransformComplete field, but I think it's ended up nicer. The\r\nTransform implementations are also simpler.\r\n\r\nI added an explicit Reset method. I still prefer being explicit than\r\nstate reset magically happenning by convention.\r\n\r\nPTAL.\r\n",
			"disapproval": false,
			"date": "2013-06-28 08:17:28.522240",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Jun 28, 2013 at 10:17 AM, Nigel Tao <nigeltao@golang.org> wrote:\r\n\r\n> I dropped NewReaderSize. I made it for the same reason that\r\n> bufio.NewReaderSize exists, but we can leave it out until we need it.\r\n>\r\nok\r\n\r\n\r\n> Transform can now return positive n and non-nil error (any error, not\r\n> just io.EOF). Reader.Read looks different, with an explicit\r\n> transformComplete field, but I think it's ended up nicer. The\r\n> Transform implementations are also simpler.\r\n>\r\nI agree the reader looks simpler by using the extra field.\r\n\r\nI added an explicit Reset method. I still prefer being explicit than\r\n> state reset magically happenning by convention.\r\n>\r\nI'm okay with this, although I find it a bit awkward for stateless\r\ntransformers, which are fairly common.  This would be especially a pity if\r\nGo were to allow a function to implement a one-method interface (which I\r\nbelieve is being considered).\r\n\r\nI notice that some place in your code you seem to assume that Transformers\r\nmay now return ErrShortDst or ErrShortSrc if there was progress (see\r\ncomment in code). Not all comments have been updated, but judging from your\r\nchanges to the Transformers, this was intentional.  Did you intend to make\r\nthis optional or required?\r\n\r\nI hadn't thought of *requiring* errors as long as there is no completion,\r\nbut it is an interesting angle.  I like the idea that the user can always\r\ntell *why* Transform did not complete.  It even makes the use of io.EOF\r\nunnecessary (sorry for saying this after first having suggested it, but\r\nwith this approach the original problem I wanted to solve is gone. :).\r\n\r\nI'm not sure which semantics you had in mind here, but I see a few\r\npossibilities:\r\n\r\nOption A (I think this is what you meant)\r\n- Returning any error is optional so long as progress is made. Previous\r\nsemantics apply when no progress is made. io.EOF is returned when completed\r\nand atEOF is true.\r\n\r\nA bunch of variants on this:\r\nOption B\r\n- Error definitions:\r\n// ErrShortDst means that the destination buffer was too short\r\n// to receive all transformed bytes.\r\n\r\n// ErrShortSrc means that the source buffer has insufficient data\r\n// to complete complete the Transform operation.\r\n\r\n- Whenever there are any unprocessed bytes left in any buffer (src or\r\ninternal), Transform must return an error.\r\n\r\n- When Transform returns nil, it means src was fully exhausted and all\r\nconverted bytes were successfully written to dst.\r\n\r\nOption C\r\nSame as Option A, but:\r\n- when atEOF is false, it will always return an error (ErrShortDst whenever\r\nit would have returned nil).  nil now takes the role of io.EOF.\r\n\r\nOption D/E:\r\nSame as Option B/C, but:\r\n- If atEOF is true, it will return io.EOF instead of nil on completion.\r\n- Note that for Option E it never returns a nil error.\r\n\r\nI think Option A, allowing both no error or ErrShortDst/Src if not all\r\nbytes are transformed leads to inconsistent usage .  For example, for your\r\nrun-lenght encoding Transformer, the user could check for the ErrShort*\r\nerrors to see if progress halted because of a depleted src or dst.  For the\r\nupper/lowercase it could know by checking nDst < len(dst) and nSrc <\r\nlen(src).  For other Transforms the only way to determine it could be to do\r\nanother call to Transform. It would be good for all Transformers to have\r\nthe same way to do or not do something. I don't think it is too much of a\r\nburden for the Transform implementation to require returning an error when\r\nnot all bytes are converted, as the bound checks need to be done anyway.\r\n\r\nI do see the code is getting simpler with your changes, though. So between\r\nkeeping the previous semantics of only errors when no progress and\r\nrequiring an error if any unprocessed bytes remain, I see the benefits of\r\nthe latter.\r\n\r\nIf I judge it from your Transformer examples, the simplest code would\r\nresult from Option B.  It would eliminate all the \"if atEOF && n ==\r\nlen(src) { ... }\" blocks.  For the casing transforms, one extra line is\r\nrequired to set err to ErrShortDst at the start, when applicable.  I think\r\nRead will stay as is.  At first glance, Chain and my experimental norm\r\ntransformer seems to get simpler as well.\r\n\r\nOption B has the following additional properties:\r\n- Transform implementations can safely ignore atEOF if they don't need it\r\nto make any distinction.\r\n- A nil error always identifies a \"completed\" state, independent of the\r\nvalue of atEOF.  That is, src has been completely processed and written to\r\ndst.\r\n- Whenever nil is returned, nSrc must be len(src). (the converse is not\r\ntrue)\r\n- The user can always determine why a Transform result is not in a\r\ncompleted state from the returned errors without making another call.\r\n\r\nOverall, I like Option B the best.  Together with Option D, it is the only\r\noption we have considered for which from the return values can be concluded\r\n- if there was any progress,\r\n- if all bytes were converted successfully, and\r\n- if not, why not all bytes were converted.\r\n\r\nFurthermore:\r\n- in each case, there is only one way to determine these conditions\r\n- it does so with only two special error codes\r\n- the resulting Transformer code seems to be the simplest of all variants\r\n- the documentation is simple.\r\n\r\nThe Transform doc comment could be:\r\n\r\n// Transform writes to dst the transformed bytes read from src, and\r\n// returns the number of dst bytes written and src bytes read. The\r\n// atEOF argument tells whether src represents the last bytes of the\r\n// input. Implementations should only return a nil error if all bytes\r\n// from src were successfully transformed and written to dst.\r\n\r\n// Implementations should return ErrShortDst if dst is too short to\r\n// receive all transformed bytes, and return ErrShortSrc if src has\r\n// insufficient data to complete the transformation. They may also\r\n// return any other sort of error.\r\n\r\n// Transformers may contain state such as their own buffers. Even if // the\r\nsource is exhausted, callers should continue to call Transform // until no\r\nerror is returned and check for progress while doing so.\r\n\r\n// Similarly to io.Reader, callers should always process\r\n// the n > 0 bytes before considering the error.\r\n\r\nThe disadvantage compared to only having an error when progress is made is\r\nthat the user should explicitly check for progress in addition to checking\r\nthe errors. Some error conditions may be rare (such as ErrShortSrc with\r\natEnd==true) and the user might not check for them properly.\r\n\r\nWe could also consider to discourage or forbid ErrShortSrc with atEnd==true\r\n(this is arguably an encoding error and not a Transformer error).\r\n\r\n\r\n> PTAL.\r\n>\r\n\r\n\r\n\r\n\r\n-- \r\nTrying this for a while: http://go/OnlyCheckEmailTwiceADay.\r\nMarcel van Lohuizen -- Google Switzerland GmbH -- Identifikationsnummer:\r\nCH-020.4.028.116-1\r\n\r\n\r\n\r\nOn Fri, Jun 28, 2013 at 10:17 AM, Nigel Tao <nigeltao@golang.org> wrote:\r\n\r\n> I dropped NewReaderSize. I made it for the same reason that\r\n> bufio.NewReaderSize exists, but we can leave it out until we need it.\r\n>\r\n> Transform can now return positive n and non-nil error (any error, not\r\n> just io.EOF). Reader.Read looks different, with an explicit\r\n> transformComplete field, but I think it's ended up nicer. The\r\n> Transform implementations are also simpler.\r\n>\r\n> I added an explicit Reset method. I still prefer being explicit than\r\n> state reset magically happenning by convention.\r\n>\r\n> PTAL.\r\n>\r\n",
			"disapproval": false,
			"date": "2013-06-30 11:50:06.162580",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL.\r\n\r\n\r\nOn Sun, Jun 30, 2013 at 9:50 PM, Marcel van Lohuizen <mpvl@golang.org> wrote:\r\n> On Fri, Jun 28, 2013 at 10:17 AM, Nigel Tao <nigeltao@golang.org> wrote:\r\n>> I added an explicit Reset method. I still prefer being explicit than\r\n>> state reset magically happenning by convention.\r\n>\r\n> I'm okay with this, although I find it a bit awkward for stateless\r\n> transformers, which are fairly common.  This would be especially a pity if\r\n> Go were to allow a function to implement a one-method interface (which I\r\n> believe is being considered).\r\n\r\nWell, I still think the best option is for Transformer to be a\r\none-method interface and Resetter to be a one-method interface that\r\nTransformers can optionally implement.\r\n\r\nBut I still haven't put much thought into this. Maybe seeing some code\r\nthat needs to reset transformers will help focus the mind. I've taken\r\nthe Reset method out for now and left a TODO. Can we punt this to a\r\nfuture CL?\r\n\r\n\r\n\r\n> Option B\r\n\r\nLet's go with this one (Option B). Here's my take on the doc comment:\r\n\r\n// Transform writes to dst the transformed bytes read from src, and\r\n// returns the number of dst bytes written and src bytes read. The\r\n// atEOF argument tells whether src represents the last bytes of the\r\n// input.\r\n//\r\n// Implementations should return nil error if and only if all of the\r\n// transformed bytes (whether freshly transformed from src or state\r\n// left over from previous Transform calls) were written to dst. They\r\n// may return nil regardless of whether atEOF is true. If err is nil\r\n// then nSrc must equal len(src); the converse is not necessarily true.\r\n//\r\n// They should return ErrShortDst if dst is too short to receive all\r\n// of the transformed bytes, and ErrShortSrc if src has insufficient\r\n// data to complete the transformation. If both conditions apply, then\r\n// either may be returned. They may also return any other sort of error.\r\n//\r\n// Transformers may contain state such as their own buffers. Even if\r\n// the source is exhausted, callers should continue to call Transform\r\n// until the transformation is successful (err == nil) or no more\r\n// progress is made (nDst == 0).\r\n//\r\n// Implementations may return non-zero nDst and/or non-zero nSrc as\r\n// well as a non-nil error. Similarly to io.Reader, callers should\r\n// always process the n > 0 bytes before considering the error.\r\nTransform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error)\r\n\r\n\r\n> We could also consider to discourage or forbid ErrShortSrc with atEnd==true\r\n> (this is arguably an encoding error and not a Transformer error).\r\n\r\nYou may be right in a semantic sense, but \"the source buffer has\r\ninsufficient data to complete the transformation\" also possibly\r\napplies even if atEOF, and it also seems harmless to let this happen.\r\nLet me think about this one.\r\n",
			"disapproval": false,
			"date": "2013-07-01 06:19:30.733660",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"mpvl@golang.org",
				"r@golang.org",
				"mpvl@google.com",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> Well, I still think the best option is for Transformer to be a\n> one-method interface and Resetter to be a one-method interface that\n> Transformers can optionally implement.\n> \n> But I still haven't put much thought into this. Maybe seeing some code\n> that needs to reset transformers will help focus the mind. I've taken\n> the Reset method out for now and left a TODO. Can we punt this to a\n> future CL?\n Sounds good.  I'm open to it optional, but it would be good to first see what exactly is needed.\n\n> > We could also consider to discourage or forbid ErrShortSrc with atEnd==true\n> > (this is arguably an encoding error and not a Transformer error).\n> \n> You may be right in a semantic sense, but \"the source buffer has\n> insufficient data to complete the transformation\" also possibly\n> applies even if atEOF, and it also seems harmless to let this happen.\n> Let me think about this one.\nI'm fine with leaving this out.  We can always add this later. It is fairly harmless, as you said.",
			"disapproval": false,
			"date": "2013-07-01 08:29:37.402360",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"mpvl@golang.org",
				"r@golang.org",
				"mpvl@google.com",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nhttps://codereview.appspot.com/10538043/diff/38001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10538043/diff/38001/transform/transform.go#newcode91\ntransform/transform.go:91: func (r *Reader) Read(p []byte) (int, error) {\nSweet!  Looks very good overall.\n\nhttps://codereview.appspot.com/10538043/diff/38001/transform/transform.go#newcode118\ntransform/transform.go:118: r.err = errors.New(\"transform: Transform returned success but nSrc != len(src)\")\nMake this a (private) global variable?",
			"disapproval": false,
			"date": "2013-07-01 08:29:57.539730",
			"approval": true
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"r@golang.org",
				"mpvl@golang.org",
				"mpvl@google.com",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I've started https://codereview.appspot.com/10996043 to address these comments.",
			"disapproval": false,
			"date": "2013-07-08 06:05:37.021680",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"mpvl@golang.org",
				"r@golang.org",
				"mpvl@google.com",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I'm taking Rob, Andy and Roger's silence as consent. Submitting...\n\nShall we get your Writer and Chain in next?\n\nConcurrently, I'll bring the encoding package up for review.\n\nhttps://codereview.appspot.com/10538043/diff/38001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10538043/diff/38001/transform/transform.go#newcode118\ntransform/transform.go:118: r.err = errors.New(\"transform: Transform returned success but nSrc != len(src)\")\nOn 2013/07/01 08:29:58, mpvl wrote:\n> Make this a (private) global variable?\n\nDone.",
			"disapproval": false,
			"date": "2013-07-01 23:55:43.951250",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Jul 2, 2013 at 10:04 AM, Rob Pike <r@golang.org> wrote:\r\n> I plan to review this soon. I was waiting for some dust to settle.\r\n\r\nOops. OK, I'll take further comments on this CL, and will send out a\r\nfollow-up CL to address them.\r\n",
			"disapproval": false,
			"date": "2013-07-02 00:08:22.551490",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"mpvl@golang.org",
				"r@golang.org",
				"mpvl@google.com",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=56dd1c6fc30c&repo=text ***\n\ngo.text/transform: new package.\n\nThis CL only provides the Reader type; Writer will be in a follow-up.\n\nR=mpvl, r, mpvl\nCC=andybalholm, golang-dev, rogpeppe\nhttps://codereview.appspot.com/10538043",
			"disapproval": false,
			"date": "2013-07-01 23:57:11.807810",
			"approval": false
		},
		{
			"sender": "mpvl@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I will start updating Chain and writer to reflect the semantics, but will\r\nwait to send it out till Rob's review.\r\n\r\nOn Tuesday, July 2, 2013, wrote:\r\n\r\n> I'm taking Rob, Andy and Roger's silence as consent. Submitting...\r\n>\r\n> Shall we get your Writer and Chain in next?\r\n>\r\n> Concurrently, I'll bring the encoding package up for review.\r\n>\r\n>\r\n> https://codereview.appspot.**com/10538043/diff/38001/**\r\n> transform/transform.go<https://codereview.appspot.com/10538043/diff/38001/transform/transform.go>\r\n> File transform/transform.go (right):\r\n>\r\n> https://codereview.appspot.**com/10538043/diff/38001/**\r\n> transform/transform.go#**newcode118<https://codereview.appspot.com/10538043/diff/38001/transform/transform.go#newcode118>\r\n> transform/transform.go:118: r.err = errors.New(\"transform: Transform\r\n> returned success but nSrc != len(src)\")\r\n> On 2013/07/01 08:29:58, mpvl wrote:\r\n>\r\n>> Make this a (private) global variable?\r\n>>\r\n>\r\n> Done.\r\n>\r\n> https://codereview.appspot.**com/10538043/<https://codereview.appspot.com/10538043/>\r\n>\r\n\r\n\r\n-- \r\nTrying this for a while: http://go/OnlyCheckEmailTwiceADay.\r\nMarcel van Lohuizen -- Google Switzerland GmbH -- Identifikationsnummer:\r\nCH-020.4.028.116-1\r\n",
			"disapproval": false,
			"date": "2013-07-02 07:57:44.708140",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"nigeltao@golang.org",
				"r@golang.org",
				"mpvl@golang.org",
				"mpvl@google.com",
				"andybalholm@gmail.com",
				"golang-dev@googlegroups.com",
				"rogpeppe@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/10538043/diff/49001/transform/transform.go\nFile transform/transform.go (right):\n\nhttps://codereview.appspot.com/10538043/diff/49001/transform/transform.go#newcode7\ntransform/transform.go:7: // include text collation, normalization and charset decoding.\ns/charset decoding/conversions between character sets/\n\nhttps://codereview.appspot.com/10538043/diff/49001/transform/transform.go#newcode30\ntransform/transform.go:30: errInconsistentNSrc = errors.New(\"transform: Transform returned success but nSrc != len(src)\")\nerror messages are for people, not programmers. they should not contain code snippets. this case is so odd that the person who wants to investigate it will end up in the code anyway, so short and cryptic is fine:\n\n\"transform: inconsistent byte count returned\"\n\nhttps://codereview.appspot.com/10538043/diff/49001/transform/transform.go#newcode40\ntransform/transform.go:40: // Implementations should return nil error if and only if all of the\ns/nil/a nil/\n\nhttps://codereview.appspot.com/10538043/diff/49001/transform/transform.go#newcode41\ntransform/transform.go:41: // transformed bytes (whether freshly transformed from src or state\ns/ state//\n\nhttps://codereview.appspot.com/10538043/diff/49001/transform/transform.go#newcode46\ntransform/transform.go:46: // They should return ErrShortDst if dst is too short to receive all\ns/They/Implementations/\n\nhttps://codereview.appspot.com/10538043/diff/49001/transform/transform.go#newcode49\ntransform/transform.go:49: // either may be returned. They may also return any other sort of error.\nthat last sentence is just weird. maybe\n\nOther than the error conditions listed here, implementations are free to report other errors that arise.\n\nhttps://codereview.appspot.com/10538043/diff/49001/transform/transform.go#newcode51\ntransform/transform.go:51: // Transformers may contain state such as their own buffers. Even if\nTransformers may hold hidden state such as internal buffers.\n\n\nbut i don't see why this is relevant or what it has to do with the following sentence.\n\nhttps://codereview.appspot.com/10538043/diff/49001/transform/transform.go#newcode58\ntransform/transform.go:58: // always process the n > 0 bytes before considering the error.\ni think this whole comment just needs a rewrite to explain the rules in a more pedantic way. the current description mixes what the caller expects and what the implementation must do. that's fine, but the separation needs to be clearer.\n\nTranformer is ...  Errors mean ... you must ...\n\nImplementations must adhere to the following rules: ...\n\nhttps://codereview.appspot.com/10538043/diff/49001/transform/transform.go#newcode98\ntransform/transform.go:98: // Copy out any transformed bytes, and the final error if we are done.\ns/, and/ and return/\n\nhttps://codereview.appspot.com/10538043/diff/49001/transform/transform.go#newcode144\ntransform/transform.go:144: // Read more bytes into src, after moving any untransformed source\nMove any untransformed source bytes to the start of the buffer and read more bytes.",
			"disapproval": false,
			"date": "2013-07-08 03:01:02.471150",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I plan to review this soon. I was waiting for some dust to settle.\r\n\r\n\r\n-rob\r\n",
			"disapproval": false,
			"date": "2013-07-02 00:04:58.495730",
			"approval": false
		}
	],
	"owner_email": "nigeltao@golang.org",
	"private": false,
	"base_url": "",
	"owner": "nigeltao",
	"subject": "code review 10538043: go.text/transform: new package.",
	"created": "2013-06-25 10:13:36.823060",
	"patchsets": [
		1,
		2001,
		4001,
		15001,
		22001,
		22002,
		34001,
		25002,
		38001,
		49001
	],
	"modified": "2013-07-08 06:05:38.680680",
	"closed": true,
	"issue": 10538043
}