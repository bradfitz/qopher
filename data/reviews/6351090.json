{
	"description": "cmd/gc: Inline pointer sized T2I interface conversions\n\nThis CL also adds support for marking the likelyness of IF nodes in the AST being true. This feature is being used here to mark the slow path as unlikely.\n\nsrc/pkg/runtime:\nbenchmark                  old ns/op    new ns/op    delta\nBenchmarkConvT2IUintptr           16            1  -91.63%\n\ntest/bench/go1:\nbenchmark                 old ns/op    new ns/op    delta\nBenchmarkBinaryTree17    5416917000   5461355000   +0.82%\nBenchmarkFannkuch11      3810355000   3842609000   +0.85%\nBenchmarkGobDecode         19950950     19855420   -0.48%\nBenchmarkGobEncode         11301220     11308530   +0.06%\nBenchmarkGzip             548119600    546869200   -0.23%\nBenchmarkGunzip           176145400    180208300   +2.31%\nBenchmarkJSONEncode        93117400     70163100  -24.65%\nBenchmarkJSONDecode       406626800    409999200   +0.83%\nBenchmarkMandelbrot200      6300992      6317866   +0.27%\nBenchmarkParse              7664396      7451625   -2.78%\nBenchmarkRevcomp         1189424000   1412332000  +18.74%\nBenchmarkTemplate         491308400    458654200   -6.65%\n\nbenchmark                  old MB/s     new MB/s  speedup\nBenchmarkGobDecode            38.47        38.66    1.00x\nBenchmarkGobEncode            67.92        67.87    1.00x\nBenchmarkGzip                 35.40        35.48    1.00x\nBenchmarkGunzip              110.16       107.68    0.98x\nBenchmarkJSONEncode           20.84        27.66    1.33x\nBenchmarkJSONDecode            4.77         4.73    0.99x\nBenchmarkParse                 7.56         7.77    1.03x\nBenchmarkRevcomp             213.69       179.96    0.84x\nBenchmarkTemplate              3.95         4.23    1.07x",
	"cc": [
		"rsc@golang.org",
		"dave@cheney.net",
		"nigeltao@golang.org",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"r@golang.org"
	],
	"messages": [
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"daniel.morsing@gmail.com",
				"golang-dev@googlegroups.com",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "linux/arm pandaboard\n\npando(~/go/test/bench/go1) % ~/go/misc/benchcmp {old,new}.txt  \nbenchmark                 old ns/op    new ns/op    delta\nBenchmarkBinaryTree17   37124725000  37525849000   +1.08%\nBenchmarkFannkuch11     36154999000  34552552000   -4.43%\nBenchmarkGobDecode        124050900    123104800   -0.76%\nBenchmarkGobEncode         62636720     61475220   -1.85%\nBenchmarkGzip            5584015000   5551667000   -0.58%\nBenchmarkGunzip          1197876000   1183319000   -1.22%\nBenchmarkJSONEncode       758874600    755590800   -0.43%\nBenchmarkJSONDecode      2393341000   2969239000  +24.06%\nBenchmarkMandelbrot200     45813000     45698840   -0.25%\nBenchmarkParse             59043580     57451780   -2.70%\nBenchmarkRevcomp          144458100    138739000   -3.96%\nBenchmarkTemplate        5426147000   5195496000   -4.25%\n\nbenchmark                  old MB/s     new MB/s  speedup\nBenchmarkGobDecode             6.19         6.23    1.01x\nBenchmarkGobEncode            12.25        12.49    1.02x\nBenchmarkGzip                  3.48         3.50    1.01x\nBenchmarkGunzip               16.20        16.40    1.01x\nBenchmarkJSONEncode            2.56         2.57    1.00x\nBenchmarkJSONDecode            0.81         0.65    0.80x\nBenchmarkParse                 0.98         1.01    1.03x\nBenchmarkRevcomp              17.60        18.32    1.04x\nBenchmarkTemplate              0.36         0.37    1.03x",
			"disapproval": false,
			"date": "2012-07-14 00:40:30.367340",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"golang-dev@googlegroups.com",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/07/14 00:40:30, dfc wrote:\n> linux/arm pandaboard\n> \n> pando(~/go/test/bench/go1) % ~/go/misc/benchcmp {old,new}.txt  \n> benchmark                 old ns/op    new ns/op    delta\n> BenchmarkBinaryTree17   37124725000  37525849000   +1.08%\n> BenchmarkFannkuch11     36154999000  34552552000   -4.43%\n> BenchmarkGobDecode        124050900    123104800   -0.76%\n> BenchmarkGobEncode         62636720     61475220   -1.85%\n> BenchmarkGzip            5584015000   5551667000   -0.58%\n> BenchmarkGunzip          1197876000   1183319000   -1.22%\n> BenchmarkJSONEncode       758874600    755590800   -0.43%\n> BenchmarkJSONDecode      2393341000   2969239000  +24.06%\n> BenchmarkMandelbrot200     45813000     45698840   -0.25%\n> BenchmarkParse             59043580     57451780   -2.70%\n> BenchmarkRevcomp          144458100    138739000   -3.96%\n> BenchmarkTemplate        5426147000   5195496000   -4.25%\n> \n> benchmark                  old MB/s     new MB/s  speedup\n> BenchmarkGobDecode             6.19         6.23    1.01x\n> BenchmarkGobEncode            12.25        12.49    1.02x\n> BenchmarkGzip                  3.48         3.50    1.01x\n> BenchmarkGunzip               16.20        16.40    1.01x\n> BenchmarkJSONEncode            2.56         2.57    1.00x\n> BenchmarkJSONDecode            0.81         0.65    0.80x\n> BenchmarkParse                 0.98         1.01    1.03x\n> BenchmarkRevcomp              17.60        18.32    1.04x\n> BenchmarkTemplate              0.36         0.37    1.03x\n\nHuh, I didn't know codereview would send out comments on unpublished CLs.\n\nFor those not in the know, I sent this CL to Dave on IRC to get some benchmark figures on arm. I'll have the proper review mail sent out later today.",
			"disapproval": false,
			"date": "2012-07-14 06:22:23.358860",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"golang-dev@googlegroups.com",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Ok, didn't know codereview would send out the CL along with the reply I just wrote.\n\nOnly thing that's missing from the mail is to mention that the benchmarks were done on an linux/amd64 machine.",
			"disapproval": false,
			"date": "2012-07-14 06:25:56.302830",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 14 July 2012 16:25,  <daniel.morsing@gmail.com> wrote:\r\n> Ok, didn't know codereview would send out the CL along with the reply I\r\n> just wrote.\r\n\r\nIs this change ready for review or not?\r\n",
			"disapproval": false,
			"date": "2012-07-16 02:03:31.258290",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Jul 16, 2012 at 4:03 AM, Nigel Tao <nigeltao@golang.org> wrote:\r\n> On 14 July 2012 16:25,  <daniel.morsing@gmail.com> wrote:\r\n>> Ok, didn't know codereview would send out the CL along with the reply I\r\n>> just wrote.\r\n>\r\n> Is this change ready for review or not?\r\n\r\nYes it is. Sorry for not making that clear\r\n",
			"disapproval": false,
			"date": "2012-07-16 07:11:00.986140",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"golang-dev@googlegroups.com",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "ping?",
			"disapproval": false,
			"date": "2012-07-23 07:04:32.327380",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, dave@cheney.net, nigeltao@golang.org (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://code.google.com/p/go/",
			"disapproval": false,
			"date": "2012-07-23 19:31:42.958360",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/07/23 08:02:28, nigeltao wrote:\n> Also, can you paste what the before/after of a disassembly of what the line\n> \"ifaceValue = concreteValue\" looks like? I think that will help me understand\n> the walk.c change.\n\nThis is the assembly after the patch\n\n--- prog list \"main\" ---\n0000 (main.go:3) TEXT    main+0(SB),$32-0\n0001 (main.go:4) MOVQ    $go.itab.\"\".T.\"\".I+0(SB),(SP)\n0002 (main.go:4) CALL    ,runtime.atomicloadtype+0(SB)\n0003 (main.go:4) MOVQ    8(SP),AX\n0004 (main.go:4) MOVQ    $0,BP\n0005 (main.go:4) CMPQ    AX,BP\n0006 (main.go:4) JNE     $1,12\n0007 (main.go:4) MOVQ    $type.\"\".T+0(SB),(SP)\n0008 (main.go:4) MOVQ    $type.\"\".I+0(SB),8(SP)\n0009 (main.go:4) MOVQ    $go.itab.\"\".T.\"\".I+0(SB),16(SP)\n0010 (main.go:4) CALL    ,runtime.typ2Itab+0(SB)\n0011 (main.go:4) MOVQ    24(SP),AX\n0012 (main.go:4) MOVQ    AX,i+0(SB)\n0013 (main.go:4) MOVQ    t+0(SB),BX\n0014 (main.go:4) MOVQ    BX,i+8(SB)\n0015 (main.go:5) RET     ,\n\nNote that the linker will move the typ2Itab branch to the end of the function.",
			"disapproval": false,
			"date": "2012-07-23 19:02:11.954950",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I'm not sure if introducing atomicloadtype and typ2Itab is the right way to cut it. I'll defer to what rsc thinks.\n\nI'm not sure what I learned from the benchmarks. amd64 gets dramatically better on JSONEncode. arm gets dramatically worse on JSONDecode. Do we have any idea why? Is it stack flapping again?\n\nIt may be worth (as a hack) replacing the atomicloadtype call with a simple assignment for now, just to get some numbers on how fast it gets if we can avoid function calls entirely. Doing this properly might require introducing an AATOMICLOAD virtual op, but I'm still too new to 6g/6l to know if that's the right thing to do, and not familiar enough with arm to know if that's even feasible. Again, I'll defer to rsc.\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/6g/cgen.c\nFile src/cmd/6g/cgen.c (right):\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/6g/cgen.c#newcode47\nsrc/cmd/6g/cgen.c:47: case OEFACE:\nIf the op is no longer just for empty-interface values, then it's probably worth doing s/OEFACE/OIFACE/. Let's see what rsc says.\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/gc/go.h#newcode260\nsrc/cmd/gc/go.h:260: uchar\tlikely; // likeliness of if statement\nDoes unsignedness work if -1 is supposed to mean unlikely?\n\nHow much difference does the likeliness make on the benchmarks?\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/gc/walk.c\nFile src/cmd/gc/walk.c (right):\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/gc/walk.c#newcode777\nsrc/cmd/gc/walk.c:777: r = l;\nSome commentary on the C equivalent of what this generated AST does would be nice.\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/gc/walk.c#newcode1199\nsrc/cmd/gc/walk.c:1199: walkexpr(&r, init);\nUnrelated? Or an existing bug? What broke without it?\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/pkg/runtime/iface.c\nFile src/pkg/runtime/iface.c (right):\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/pkg/runtime/iface.c#newcode186\nsrc/pkg/runtime/iface.c:186: void\nI think that this and runtime\u00b7typ2Itab should have a\n#pragma textflag 7\nbefore them to pick up NOSPLIT.",
			"disapproval": false,
			"date": "2012-07-23 07:52:56.772460",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Also, can you paste what the before/after of a disassembly of what the line \"ifaceValue = concreteValue\" looks like? I think that will help me understand the walk.c change. For example, the before is:\n\n\n$ cat main.go\npackage main\n\nfunc main() {\n\ti = t\n}\n\ntype I interface {\n\tMethod()\n}\n\ntype T uintptr\n\nfunc (T) Method() {}\n\nvar (\n\ti I\n\tt T\n)\n$ go tool 6g -S -o /dev/null main.go | sed -e '/Method/q'\n\n--- prog list \"main\" ---\n0000 (main.go:3) TEXT    main+0(SB),$48-0\n0001 (main.go:4) MOVQ    $type.\"\".T+0(SB),(SP)\n0002 (main.go:4) MOVQ    $type.\"\".I+0(SB),8(SP)\n0003 (main.go:4) MOVQ    $go.itab.\"\".T.\"\".I+0(SB),16(SP)\n0004 (main.go:4) MOVQ    t+0(SB),BX\n0005 (main.go:4) MOVQ    BX,24(SP)\n0006 (main.go:4) CALL    ,runtime.convT2I+0(SB)\n0007 (main.go:4) MOVQ    32(SP),BX\n0008 (main.go:4) MOVQ    BX,i+0(SB)\n0009 (main.go:4) MOVQ    40(SP),BX\n0010 (main.go:4) MOVQ    BX,i+8(SB)\n0011 (main.go:5) RET     ,\n\n--- prog list \"T.Method\" ---\ngo tool 6g: signal 13",
			"disapproval": false,
			"date": "2012-07-23 08:02:28.971120",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/07/23 07:52:56, nigeltao wrote:\n> I'm not sure if introducing atomicloadtype and typ2Itab is the right way to cut\n> it. I'll defer to what rsc thinks.\n> \n> I'm not sure what I learned from the benchmarks. amd64 gets dramatically better\n> on JSONEncode. arm gets dramatically worse on JSONDecode. Do we have any idea\n> why? Is it stack flapping again?\n> \n> It may be worth (as a hack) replacing the atomicloadtype call with a simple\n> assignment for now, just to get some numbers on how fast it gets if we can avoid\n> function calls entirely. Doing this properly might require introducing an\n> AATOMICLOAD virtual op, but I'm still too new to 6g/6l to know if that's the\n> right thing to do, and not familiar enough with arm to know if that's even\n> feasible. Again, I'll defer to rsc.\n\nI've done testing where I relied on amd64 loading the pointer atomically. The conversion time was reduced to around 1 ns per op. On arm, the atomic loading isn't that straightforward. It involves loading an instruction from memory and executing it, and it's complicated enough to make it a pain to emit inline.\n\nAs for typ2Itab, The only way I can see how to get rid of it, would be making the codegen emit it. I havn't looked too hard at this possibility since I'm not well versed in how the codegen works.",
			"disapproval": false,
			"date": "2012-07-23 11:10:09.832780",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6351090/diff/2001/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/gc/go.h#newcode260\nsrc/cmd/gc/go.h:260: uchar\tlikely; // likeliness of if statement\nOn 2012/07/23 07:52:56, nigeltao wrote:\n> Does unsignedness work if -1 is supposed to mean unlikely?\n> \n> How much difference does the likeliness make on the benchmarks?\n\nWhoops. I think this may have worked solely by luck.\n\nThe performance impact of not having likely is small. IIRC, it's about 1 ns. In this version of the patch, this gain isn't that significant. However I made a version, where the pointer loading was done inline (relying on amd64 implicitly loading the pointer atomically). There the gain was about half the time spent per conversion. This optimization is a relic from that version, but I kept it in since it's still beneficial to benchmark.\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/gc/walk.c\nFile src/cmd/gc/walk.c (right):\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/gc/walk.c#newcode777\nsrc/cmd/gc/walk.c:777: r = l;\nOn 2012/07/23 07:52:56, nigeltao wrote:\n> Some commentary on the C equivalent of what this generated AST does would be\n> nice.\n\nI'll include the some variant of the pseudocode from my initial design posting.\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/cmd/gc/walk.c#newcode1199\nsrc/cmd/gc/walk.c:1199: walkexpr(&r, init);\nOn 2012/07/23 07:52:56, nigeltao wrote:\n> Unrelated? Or an existing bug? What broke without it?\n\nThe gc compiler will segfault without this. Apparently, whoever wrote this code assumed that the r expression couldn't generate any init statements, which was true before this change.\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/pkg/runtime/iface.c\nFile src/pkg/runtime/iface.c (right):\n\nhttp://codereview.appspot.com/6351090/diff/2001/src/pkg/runtime/iface.c#newcode186\nsrc/pkg/runtime/iface.c:186: void\nOn 2012/07/23 07:52:56, nigeltao wrote:\n> I think that this and runtime\u00b7typ2Itab should have a\n> #pragma textflag 7\n> before them to pick up NOSPLIT.\n\nI was a bit unsure as to what exactly \"#pragma textflag 7\" did. I could only see it on functions with ... arguments, so I thought it was related. I'll add this to the next version.",
			"disapproval": false,
			"date": "2012-07-23 11:10:36.292230",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 23 July 2012 21:10,  <daniel.morsing@gmail.com> wrote:\r\n> As for typ2Itab, The only way I can see how to get rid of it, would be\r\n> making the codegen emit it. I havn't looked too hard at this possibility\r\n> since I'm not well versed in how the codegen works.\r\n\r\nWell, an alternative is to call convT2I if the itab cache misses,\r\ninstead of calling a new function typ2Itab. It might lead to simpler\r\ncode. Sure, it adds a tiny amount of redundant computation, but cache\r\nmisses should be rare.\r\n\r\nI'm not saying we should do that; it's just an idea.\r\n",
			"disapproval": false,
			"date": "2012-07-24 08:43:12.943390",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Jul 24, 2012 at 10:51 AM, Nigel Tao <nigeltao@golang.org> wrote:\r\n> On 23 July 2012 21:10,  <daniel.morsing@gmail.com> wrote:\r\n>> However I made a version, where the pointer loading was done inline\r\n>> (relying on amd64 implicitly loading the pointer atomically). There the\r\n>> gain was about half the time spent per conversion.\r\n>\r\n> I'm not sure how to interpret that paragraph. What are the benchmark\r\n> numbers if you use a plain assignment instead of a\r\n> runtime\u00b7atomicloadtype call? It won't be correct (on arm), but it\r\n> would give me a better idea of the potential impact of this change. As\r\n> it is, you're trying to avoid a convT2I function call, but always call\r\n> runtime\u00b7atomicloadtype instead, so it's not an obvious win. Ideally,\r\n> there'd be no function calls on the common path.\r\n\r\nSorry for being inadvertently obtuse. When doing plain assignment, the\r\nbenchmark takes around 1 ns per op in BenchmarkConvT2IUintptr.\r\n\r\nI've tried making a version of this change that does the following:\r\n\r\n    Itab tab = typ2Itab(type, Itype, &cache);\r\n    EFACE{tab, ptr}\r\n\r\nwhere the typ2Itab function does the check on cache and returns it if\r\nset. That version had benchmarks around 8 ns per op. Apparently, the\r\npath for interface conversion is getting so fast that pushing 2 words\r\nonto the stack makes a significant difference.\r\n\r\nAs for using convT2I instead of typ2Itab, there's a problem with that.\r\nWe would have to evaluate the data being converted in the init list,\r\nbut where the init list is inserted, that data might be uninitialized.\r\n\r\nConsider:\r\n\r\n    //begin init list\r\n    Itab tab = cache //atomically\r\n    if tab == nil {\r\n        tmpiface = convT2I(type, itype, &cache, data)\r\n    } else {\r\n        tmpiface = EFACE{tab, data}\r\n    }\r\n    //end init list\r\n    data = realValue\r\n    //the expression we were evaluating. tmpiface will be wrong\r\n    foo(tmpiface)\r\n\r\nThis situation arises when evaluating AS2FUNC nodes.\r\n",
			"disapproval": false,
			"date": "2012-07-24 10:30:36.398670",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 23 July 2012 21:10,  <daniel.morsing@gmail.com> wrote:\r\n> However I made a version, where the pointer loading was done inline\r\n> (relying on amd64 implicitly loading the pointer atomically). There the\r\n> gain was about half the time spent per conversion.\r\n\r\nI'm not sure how to interpret that paragraph. What are the benchmark\r\nnumbers if you use a plain assignment instead of a\r\nruntime\u00b7atomicloadtype call? It won't be correct (on arm), but it\r\nwould give me a better idea of the potential impact of this change. As\r\nit is, you're trying to avoid a convT2I function call, but always call\r\nruntime\u00b7atomicloadtype instead, so it's not an obvious win. Ideally,\r\nthere'd be no function calls on the common path.\r\n",
			"disapproval": false,
			"date": "2012-07-24 08:51:22.507100",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Sorry that this one is taking so long...\r\n\r\n\r\nOn 24 July 2012 20:30, Daniel Morsing <daniel.morsing@gmail.com> wrote:\r\n> Sorry for being inadvertently obtuse. When doing plain assignment, the\r\n> benchmark takes around 1 ns per op in BenchmarkConvT2IUintptr.\r\n\r\nWhat about the test/bench/go1 numbers?\r\n\r\n\r\n> As for using convT2I instead of typ2Itab, there's a problem with that.\r\n> We would have to evaluate the data being converted in the init list,\r\n> but where the init list is inserted, that data might be uninitialized.\r\n>\r\n> Consider:\r\n>\r\n>     //begin init list\r\n>     Itab tab = cache //atomically\r\n>     if tab == nil {\r\n>         tmpiface = convT2I(type, itype, &cache, data)\r\n>     } else {\r\n>         tmpiface = EFACE{tab, data}\r\n>     }\r\n>     //end init list\r\n>     data = realValue\r\n>     //the expression we were evaluating. tmpiface will be wrong\r\n>     foo(tmpiface)\r\n>\r\n> This situation arises when evaluating AS2FUNC nodes.\r\n\r\nSorry, I'm probably being dumb, but I don't understand how tmpiface\r\nwill be wrong with OAS2FUNC. Can you give a small example.go program\r\nthat fails in this way?\r\n\r\nIIUC, the proposal is to do\r\n\r\nItab tab = cache //atomically\r\nif tab == nil {\r\n  tmpiface = convT2I(type, itype, &cache, data)\r\n} else {\r\n  tmpiface = EFACE{tab, data}\r\n}\r\n\r\nwhere we currently do\r\n\r\ntmpiface = convT2I(type, itype, &cache, data)\r\n\r\nWhy are we also generating init code? I didn't notice that in my\r\nprevious readings. It's true that you could conceivably initialize the\r\nitab caches eagerly instead of lazily, but I would want that to be a\r\nseparate change to this one. I wouldn't expect it to be trivial if you\r\nwant to also preserve dead code elimination for unused types.\r\n",
			"disapproval": false,
			"date": "2012-07-25 07:47:32.014790",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thanks for looking into this. If I understand correctly, this replaces 1 function call with 1 or 2 function calls depending on the path taken. The only win is avoiding the generality of arbitrary-sized convT2I.\n\nOne possibility is to write a convT2Ip like convT2I and use that, which is then 1 function call always. That's a simpler function than convT2I so it would be faster.\n\nThe other possibility is to keep the current conditional but make the atomic load be generated with real instructions. On the x86 an ordinary load is fine. On the ARM I think if you do a write flush before the store of the cache pointer then you can do an ordinary load on the lookup path too. Let's move forward under the assumption that an ordinary load is fine on all architectures.\n\nhttp://codereview.appspot.com/6351090/diff/19001/src/cmd/5g/cgen.c\nFile src/cmd/5g/cgen.c (right):\n\nhttp://codereview.appspot.com/6351090/diff/19001/src/cmd/5g/cgen.c#newcode46\nsrc/cmd/5g/cgen.c:46: !n->left->addable || !n->right->addable) {\nWhat condition is this trying to handle?\n\nhttp://codereview.appspot.com/6351090/diff/19001/src/cmd/6g/cgen.c\nFile src/cmd/6g/cgen.c (right):\n\nhttp://codereview.appspot.com/6351090/diff/19001/src/cmd/6g/cgen.c#newcode49\nsrc/cmd/6g/cgen.c:49: !n->left->addable || !n->right->addable) {\nWhat condition is this trying to handle?\n\nhttp://codereview.appspot.com/6351090/diff/19001/src/cmd/8g/cgen.c\nFile src/cmd/8g/cgen.c (right):\n\nhttp://codereview.appspot.com/6351090/diff/19001/src/cmd/8g/cgen.c#newcode79\nsrc/cmd/8g/cgen.c:79: !n->left->addable || !n->right->addable) {\nWhat condition is this trying to handle?\n\nhttp://codereview.appspot.com/6351090/diff/19001/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttp://codereview.appspot.com/6351090/diff/19001/src/cmd/gc/go.h#newcode260\nsrc/cmd/gc/go.h:260: int\tlikely; // likeliness of if statement\nschar please",
			"disapproval": false,
			"date": "2012-08-05 22:26:32.116580",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Aug 6, 2012 at 12:26 AM,  <rsc@golang.org> wrote:\r\n> Thanks for looking into this. If I understand correctly, this replaces 1\r\n> function call with 1 or 2 function calls depending on the path taken.\r\n> The only win is avoiding the generality of arbitrary-sized convT2I.\r\n>\r\n> One possibility is to write a convT2Ip like convT2I and use that, which\r\n> is then 1 function call always. That's a simpler function than convT2I\r\n> so it would be faster.\r\n\r\nI'm not at a computer where I can test this, but I think this would be\r\nslower than the current solution, since there would be a call for\r\nconvT2Ip and a call to atomicloadp within that function.\r\n\r\n>\r\n> The other possibility is to keep the current conditional but make the\r\n> atomic load be generated with real instructions. On the x86 an ordinary\r\n> load is fine. On the ARM I think if you do a write flush before the\r\n> store of the cache pointer then you can do an ordinary load on the\r\n> lookup path too. Let's move forward under the assumption that an\r\n> ordinary load is fine on all architectures.\r\n>\r\n\r\nThe amount of code that's there for arm atomics frightens me into\r\nthinking that a ordinary load has subtle ways of breaking atomicity.\r\n\r\nI've had some time to think about this CL, and I think there is some\r\nvalue in re-spinning it to have the logic happen in the codegen. It\r\nhas a couple of advantages:\r\n\r\n- Having the atomic logic be emitted inline would be easier.\r\n- It would get rid of the 2 new functions that I added, since I could\r\nuse convT2I, and emit the atomic load inline\r\n- No need to add the likely field to node.\r\n\r\nHowever, I'm not very familiar with the codegen part of gc, and I'm\r\nnot sure if it's a good idea to handle the interface conversion in\r\ncodegen. The current CL will work fine, but I think it can be done\r\ncleaner. How does this re-spin sound to you?\r\n\r\n>\r\n> http://codereview.appspot.com/6351090/diff/19001/src/cmd/5g/cgen.c\r\n> File src/cmd/5g/cgen.c (right):\r\n>\r\n> http://codereview.appspot.com/6351090/diff/19001/src/cmd/5g/cgen.c#newcode46\r\n> src/cmd/5g/cgen.c:46: !n->left->addable || !n->right->addable) {\r\n> What condition is this trying to handle?\r\n\r\nI ran into a problem with compiling the go/ast package. That package\r\nhas a compilation AST similar to this:\r\n\r\nAS\r\n\\-- NAME: iface\r\n\\-- EFACE\r\n    \\-- NAME: go.type.itab\r\n    \\-- CALLFUNC\r\n        \\-- LIST\r\n            \\-- NAME: iface\r\n\r\nIn that case, the interface type word would be assigned first and the\r\nhalf assigned interface would then be used as an argument. Spilling to\r\na tempname solves this problem.\r\n\r\n>\r\n> http://codereview.appspot.com/6351090/diff/19001/src/cmd/6g/cgen.c\r\n> File src/cmd/6g/cgen.c (right):\r\n>\r\n> http://codereview.appspot.com/6351090/diff/19001/src/cmd/6g/cgen.c#newcode49\r\n> src/cmd/6g/cgen.c:49: !n->left->addable || !n->right->addable) {\r\n> What condition is this trying to handle?\r\n>\r\n> http://codereview.appspot.com/6351090/diff/19001/src/cmd/8g/cgen.c\r\n> File src/cmd/8g/cgen.c (right):\r\n>\r\n> http://codereview.appspot.com/6351090/diff/19001/src/cmd/8g/cgen.c#newcode79\r\n> src/cmd/8g/cgen.c:79: !n->left->addable || !n->right->addable) {\r\n> What condition is this trying to handle?\r\n>\r\n> http://codereview.appspot.com/6351090/diff/19001/src/cmd/gc/go.h\r\n> File src/cmd/gc/go.h (right):\r\n>\r\n> http://codereview.appspot.com/6351090/diff/19001/src/cmd/gc/go.h#newcode260\r\n> src/cmd/gc/go.h:260: int        likely; // likeliness of if statement\r\n> schar please\r\n>\r\n> http://codereview.appspot.com/6351090/\r\n",
			"disapproval": false,
			"date": "2012-08-06 07:51:22.732360",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jul 25, 2012 at 9:47 AM, Nigel Tao <nigeltao@golang.org> wrote:\r\n> Sorry that this one is taking so long...\r\n>\r\n>\r\n> On 24 July 2012 20:30, Daniel Morsing <daniel.morsing@gmail.com> wrote:\r\n>> Sorry for being inadvertently obtuse. When doing plain assignment, the\r\n>> benchmark takes around 1 ns per op in BenchmarkConvT2IUintptr.\r\n>\r\n> What about the test/bench/go1 numbers?\r\n\r\nI don't have those numbers written down anywhere. I'll go get these\r\nnumbers when I get to a PC where I have my stuff.\r\n\r\n>\r\n>\r\n>> As for using convT2I instead of typ2Itab, there's a problem with that.\r\n>> We would have to evaluate the data being converted in the init list,\r\n>> but where the init list is inserted, that data might be uninitialized.\r\n>>\r\n>> Consider:\r\n>>\r\n>>     //begin init list\r\n>>     Itab tab = cache //atomically\r\n>>     if tab == nil {\r\n>>         tmpiface = convT2I(type, itype, &cache, data)\r\n>>     } else {\r\n>>         tmpiface = EFACE{tab, data}\r\n>>     }\r\n>>     //end init list\r\n>>     data = realValue\r\n>>     //the expression we were evaluating. tmpiface will be wrong\r\n>>     foo(tmpiface)\r\n>>\r\n>> This situation arises when evaluating AS2FUNC nodes.\r\n>\r\n> Sorry, I'm probably being dumb, but I don't understand how tmpiface\r\n> will be wrong with OAS2FUNC. Can you give a small example.go program\r\n> that fails in this way?\r\n>\r\n> IIUC, the proposal is to do\r\n>\r\n> Itab tab = cache //atomically\r\n> if tab == nil {\r\n>   tmpiface = convT2I(type, itype, &cache, data)\r\n> } else {\r\n>   tmpiface = EFACE{tab, data}\r\n> }\r\n>\r\n> where we currently do\r\n>\r\n> tmpiface = convT2I(type, itype, &cache, data)\r\n>\r\n> Why are we also generating init code? I didn't notice that in my\r\n> previous readings. It's true that you could conceivably initialize the\r\n> itab caches eagerly instead of lazily, but I would want that to be a\r\n> separate change to this one. I wouldn't expect it to be trivial if you\r\n> want to also preserve dead code elimination for unused types.\r\n\r\nI think you have the init list misunderstood. It's a list for taking\r\nstuff that must be run in statement context and inserting it\r\nimmediately before the expression is evaluated.\r\n\r\nThe CONVIFACE node occurs as a part of an expression. The convT2I call\r\nis also an expression, so there is no problem with inserting it at a\r\nplace where the interface conversion was originally, but the If\r\nstatement is a statement. We can't just insert it into the AST at the\r\nCONVIFACE node. We have to put it onto the init list, so it's executed\r\njust before the expression is evaluated.\r\n\r\nIf we use convT2I, we have to evaluate the data being converted in the\r\ninit list. The value of the data may change between the init list is\r\ninserted and the conversion expression.\r\n",
			"disapproval": false,
			"date": "2012-07-25 08:34:16.358990",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, dave@cheney.net, nigeltao@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-08-08 18:59:25.896640",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Here is the atomic load version benchmark, compared to the\r\natomicloadtype() version\r\n\r\nsrc/pkg/runtime:\r\nbenchmark                  old ns/op    new ns/op    delta\r\nBenchmarkConvT2ESmall             11           11   +1.79%\r\nBenchmarkConvT2EUintptr            0            0   +1.43%\r\nBenchmarkConvT2ELarge             75           76   +0.93%\r\nBenchmarkConvT2ISmall             17           13  -19.41%\r\nBenchmarkConvT2IUintptr            5            1  -74.32%\r\nBenchmarkConvT2ILarge             77           78   +0.90%\r\nBenchmarkConvI2E                   4            5  +14.79%\r\nBenchmarkConvI2I                  17           17   +0.00%\r\n\r\ntest/bench/go1:\r\nbenchmark                 old ns/op    new ns/op    delta\r\nBenchmarkBinaryTree17    5528479000   5526532000   -0.04%\r\nBenchmarkFannkuch11      3920745000   3755168000   -4.22%\r\nBenchmarkGobDecode         20638900     20096130   -2.63%\r\nBenchmarkGobEncode         11270940     11592350   +2.85%\r\nBenchmarkGzip             559168200    553892000   -0.94%\r\nBenchmarkGunzip           182290200    180607000   -0.92%\r\nBenchmarkJSONEncode        70364760     72977700   +3.71%\r\nBenchmarkJSONDecode       418688000    407103000   -2.77%\r\nBenchmarkMandelbrot200      6324712      6407060   +1.30%\r\nBenchmarkParse              8040630      7889790   -1.88%\r\nBenchmarkRevcomp         1693365000   1792351000   +5.85%\r\nBenchmarkTemplate         465117000    456074200   -1.94%\r\n\r\nbenchmark                  old MB/s     new MB/s  speedup\r\nBenchmarkGobDecode            37.19        38.19    1.03x\r\nBenchmarkGobEncode            68.10        66.21    0.97x\r\nBenchmarkGzip                 34.70        35.03    1.01x\r\nBenchmarkGunzip              106.45       107.44    1.01x\r\nBenchmarkJSONEncode           27.58        26.59    0.96x\r\nBenchmarkJSONDecode            4.63         4.77    1.03x\r\nBenchmarkParse                 7.20         7.34    1.02x\r\nBenchmarkRevcomp             150.10       141.81    0.94x\r\nBenchmarkTemplate              4.17         4.25    1.02x\r\n",
			"disapproval": false,
			"date": "2012-07-25 17:22:53.252920",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "2012/7/26 Daniel Morsing <daniel.morsing@gmail.com>:\r\n> test/bench/go1:\r\n> benchmark                 old ns/op    new ns/op    delta\r\n> BenchmarkBinaryTree17    5528479000   5526532000   -0.04%\r\n> BenchmarkFannkuch11      3920745000   3755168000   -4.22%\r\n> BenchmarkGobDecode         20638900     20096130   -2.63%\r\n> BenchmarkGobEncode         11270940     11592350   +2.85%\r\n> BenchmarkGzip             559168200    553892000   -0.94%\r\n> BenchmarkGunzip           182290200    180607000   -0.92%\r\n> BenchmarkJSONEncode        70364760     72977700   +3.71%\r\n> BenchmarkJSONDecode       418688000    407103000   -2.77%\r\n> BenchmarkMandelbrot200      6324712      6407060   +1.30%\r\n> BenchmarkParse              8040630      7889790   -1.88%\r\n> BenchmarkRevcomp         1693365000   1792351000   +5.85%\r\n> BenchmarkTemplate         465117000    456074200   -1.94%\r\n\r\nSo, some wins, some losses, but no clear trend. Even if you compare\r\nthis to tip instead of to atomicloadtype, I don't think it's\r\nconclusive. Hmm...\r\n\r\n\r\nAs an extra data point, here are the bench numbers comparing tip (old)\r\nto the current atomicloadtype-using patch (new) on my linux, amd64\r\ndesktop:\r\n\r\nbenchmark                  old ns/op    new ns/op    delta\r\nBenchmarkConvT2ESmall             10           10   +0.00%\r\nBenchmarkConvT2EUintptr            0            0   -1.45%\r\nBenchmarkConvT2ELarge             74           70   -4.96%\r\nBenchmarkConvT2ISmall             12           12   +0.78%\r\nBenchmarkConvT2IUintptr           12            4  -62.23%\r\nBenchmarkConvT2ILarge             76           75   -0.91%\r\nBenchmarkConvI2E                   4            5  +14.61%\r\nBenchmarkConvI2I                  20           19   -2.99%\r\n\r\nbenchmark                 old ns/op    new ns/op    delta\r\nBenchmarkBinaryTree17    5920179000   5953817000   +0.57%\r\nBenchmarkFannkuch11      4019578000   3860152000   -3.97%\r\nBenchmarkGobDecode         21358690     21715730   +1.67%\r\nBenchmarkGobEncode         12917560     12678230   -1.85%\r\nBenchmarkGzip             574320000    569419400   -0.85%\r\nBenchmarkGunzip           179199300    178863100   -0.19%\r\nBenchmarkJSONEncode        95139100     71945500  -24.38%\r\nBenchmarkJSONDecode       422837000    406048200   -3.97%\r\nBenchmarkMandelbrot200      7043688      7047108   +0.05%\r\nBenchmarkParse              7893900      8311090   +5.28%\r\nBenchmarkRevcomp         1257351000   1280234000   +1.82%\r\nBenchmarkTemplate         509244200    475117200   -6.70%\r\n\r\n\r\nI'll poke at the BenchmarkJSONEncode case some more tomorrow.\r\n",
			"disapproval": false,
			"date": "2012-07-26 07:59:59.275470",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 25 July 2012 18:34, Daniel Morsing <daniel.morsing@gmail.com> wrote:\r\n> I think you have the init list misunderstood. It's a list for taking\r\n> stuff that must be run in statement context and inserting it\r\n> immediately before the expression is evaluated.\r\n\r\nAh, I see. I'm still relatively new to the gc code. I don't feel\r\nqualified to give an LGTM on this one yet. I'll wait for rsc's\r\nopinion.\r\n",
			"disapproval": false,
			"date": "2012-07-26 08:05:50.627230",
			"approval": true
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": ">> One possibility is to write a convT2Ip like convT2I and use that, which\r\n>> is then 1 function call always. That's a simpler function than convT2I\r\n>> so it would be faster.\r\n>\r\n> I'm not at a computer where I can test this, but I think this would be\r\n> slower than the current solution, since there would be a call for\r\n> convT2Ip and a call to atomicloadp within that function.\r\n\r\nGiven the choice between '1 call always' or '1 call always and\r\nsometimes 2', I will always choose '1 call always'. It is strictly\r\nless expensive in generated code, and you're unlikely to be able to\r\nmeasure a significant difference caused by pushing the optional\r\nfunction call down a bit. It's a very important point, because\r\notherwise we'd just inline everything and never make function calls.\r\nThis is a real problem in C++ compilers.\r\n\r\nOn the other hand, if you can make the fast path 0 function calls\r\ninstead of 1 function call, then the increased speed may justify the\r\nlarger generated code. Not making a function call cuts not just the\r\noverhead of the function call but also the overhead of having to spill\r\nany registers to the stack and then reload them after the call. It\r\nalso makes the computation being done instead of the call available to\r\nthe optimizer to understand and possibly rewrite. That's definitely\r\nthe goal, and the second approach should get us there.\r\n\r\n> I've had some time to think about this CL, and I think there is some\r\n> value in re-spinning it to have the logic happen in the codegen. It\r\n> has a couple of advantages:\r\n>\r\n> - Having the atomic logic be emitted inline would be easier.\r\n> - It would get rid of the 2 new functions that I added, since I could\r\n> use convT2I, and emit the atomic load inline\r\n> - No need to add the likely field to node.\r\n>\r\n> However, I'm not very familiar with the codegen part of gc, and I'm\r\n> not sure if it's a good idea to handle the interface conversion in\r\n> codegen. The current CL will work fine, but I think it can be done\r\n> cleaner. How does this re-spin sound to you?\r\n\r\nPlease do as much in the front end as possible. Otherwise we end up\r\nwith three copies of everything, which is a significant maintenance\r\nburden. I've been working to move as much of the logic duplication as\r\npossible back into the front ends. The back end should have whatever\r\nprimitive is needed (like cgen_eface for the T2E optimization) but\r\nlittle else. It's fine to have a cgen_iface and OIFACE that has\r\nbasically the same implementation as cgen_eface but takes a cached\r\nitab value.\r\n\r\nAlso, please just make the ARM do a plain load for now instead of\r\nadding complexity we're not sure is necessary. We can worry about the\r\nARM later, once the rest of the code is good. I still believe we can\r\narrange to use a plain load, and even if not we can fix it once we're\r\nhappy with the x86 code.\r\n\r\n>> http://codereview.appspot.com/6351090/diff/19001/src/cmd/5g/cgen.c#newcode46\r\n>> src/cmd/5g/cgen.c:46: !n->left->addable || !n->right->addable) {\r\n>> What condition is this trying to handle?\r\n>\r\n> I ran into a problem with compiling the go/ast package. That package\r\n> has a compilation AST similar to this:\r\n>\r\n> AS\r\n> \\-- NAME: iface\r\n> \\-- EFACE\r\n>     \\-- NAME: go.type.itab\r\n>     \\-- CALLFUNC\r\n>         \\-- LIST\r\n>             \\-- NAME: iface\r\n\r\nDo you know about the dump function? I am not sure how you generated\r\nthat, but the dump function already does dumps like that, with more\r\ninformation than you're showing.\r\n\r\n> In that case, the interface type word would be assigned first and the\r\n> half assigned interface would then be used as an argument. Spilling to\r\n> a tempname solves this problem.\r\n\r\nOkay. But then the problem being solved is that a function call has to\r\nbe made. That's not really a condition of addressability of the n\r\nside. Probably you want if n->ullman >= UINF or something like that.\r\n\r\nIn this code:\r\n\r\n\tcase OEFACE:\r\n\t\tif (res->op != ONAME || !res->addable) {\r\n\t\t\ttempname(&n1, n->type);\r\n\t\t\tcgen_eface(n, &n1);\r\n\t\t\tcgen(&n1, res);\r\n\t\t} else\r\n\t\t\tcgen_eface(n, res);\r\n\t\tgoto ret;\r\n\r\nIt says \"if res is inappropriate, call cgen_eface with a different res\r\nthat is appropriate\".\r\nBut when you add the conditions about n->left and n->right, it looks\r\nlike a check for an inappropriate n, but the cgen_eface still gets\r\ncalled with the same n, which looks suspicious. I think cgen_eface is\r\nat fault here if anything is: it should avoid writing to res until it\r\nhas all the pieces it needs.\r\n\r\nRight now it is:\r\n\r\nvoid\r\ncgen_eface(Node *n, Node *res)\r\n{\r\n\tNode dst;\r\n\tdst = *res;\r\n\tdst.type = types[tptr];\r\n\tcgen(n->left, &dst);\r\n\tdst.xoffset += widthptr;\r\n\tcgen(n->right, &dst);\r\n}\r\n\r\nOne fix is to make cgen_eface check for n->left->ullman >= UINF and\r\ngenerate into temporaries here. But I don't think that's necessary\r\neither. Since n->left is always a constant (a type pointer known at\r\ncompile time), it should work well enough to swap the order of the\r\ngeneration:\r\n\r\n\tdst.type = types[tptr];\r\n\tdst.xoffset += widthptr;\r\n\tcgen(n->right, &dst); // might be difficult\r\n\tdst.xoffset -= widthptr;\r\n\tcgen(n->left, &dst); // always a constant\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2012-08-06 20:16:41.570260",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Aug 6, 2012 at 10:16 PM, Russ Cox <rsc@golang.org> wrote:\r\n>>> One possibility is to write a convT2Ip like convT2I and use that, which\r\n>>> is then 1 function call always. That's a simpler function than convT2I\r\n>>> so it would be faster.\r\n>>\r\n>> I'm not at a computer where I can test this, but I think this would be\r\n>> slower than the current solution, since there would be a call for\r\n>> convT2Ip and a call to atomicloadp within that function.\r\n>\r\n> Given the choice between '1 call always' or '1 call always and\r\n> sometimes 2', I will always choose '1 call always'. It is strictly\r\n> less expensive in generated code, and you're unlikely to be able to\r\n> measure a significant difference caused by pushing the optional\r\n> function call down a bit. It's a very important point, because\r\n> otherwise we'd just inline everything and never make function calls.\r\n> This is a real problem in C++ compilers.\r\n>\r\n> On the other hand, if you can make the fast path 0 function calls\r\n> instead of 1 function call, then the increased speed may justify the\r\n> larger generated code. Not making a function call cuts not just the\r\n> overhead of the function call but also the overhead of having to spill\r\n> any registers to the stack and then reload them after the call. It\r\n> also makes the computation being done instead of the call available to\r\n> the optimizer to understand and possibly rewrite. That's definitely\r\n> the goal, and the second approach should get us there.\r\n\r\nI've done the zero call fastpath solution before, and it's a trivial\r\namount of code that needs to be changed. I'll do that for the next\r\npatchset.\r\n\r\n>\r\n>> I've had some time to think about this CL, and I think there is some\r\n>> value in re-spinning it to have the logic happen in the codegen. It\r\n>> has a couple of advantages:\r\n>>\r\n>> - Having the atomic logic be emitted inline would be easier.\r\n>> - It would get rid of the 2 new functions that I added, since I could\r\n>> use convT2I, and emit the atomic load inline\r\n>> - No need to add the likely field to node.\r\n>>\r\n>> However, I'm not very familiar with the codegen part of gc, and I'm\r\n>> not sure if it's a good idea to handle the interface conversion in\r\n>> codegen. The current CL will work fine, but I think it can be done\r\n>> cleaner. How does this re-spin sound to you?\r\n>\r\n> Please do as much in the front end as possible. Otherwise we end up\r\n> with three copies of everything, which is a significant maintenance\r\n> burden. I've been working to move as much of the logic duplication as\r\n> possible back into the front ends. The back end should have whatever\r\n> primitive is needed (like cgen_eface for the T2E optimization) but\r\n> little else. It's fine to have a cgen_iface and OIFACE that has\r\n> basically the same implementation as cgen_eface but takes a cached\r\n> itab value.\r\n>\r\n> Also, please just make the ARM do a plain load for now instead of\r\n> adding complexity we're not sure is necessary. We can worry about the\r\n> ARM later, once the rest of the code is good. I still believe we can\r\n> arrange to use a plain load, and even if not we can fix it once we're\r\n> happy with the x86 code.\r\n>\r\n>>> http://codereview.appspot.com/6351090/diff/19001/src/cmd/5g/cgen.c#newcode46\r\n>>> src/cmd/5g/cgen.c:46: !n->left->addable || !n->right->addable) {\r\n>>> What condition is this trying to handle?\r\n>>\r\n>> I ran into a problem with compiling the go/ast package. That package\r\n>> has a compilation AST similar to this:\r\n>>\r\n>> AS\r\n>> \\-- NAME: iface\r\n>> \\-- EFACE\r\n>>     \\-- NAME: go.type.itab\r\n>>     \\-- CALLFUNC\r\n>>         \\-- LIST\r\n>>             \\-- NAME: iface\r\n>\r\n> Do you know about the dump function? I am not sure how you generated\r\n> that, but the dump function already does dumps like that, with more\r\n> information than you're showing.\r\n\r\nThis was transcribed by hand from memory. I was at my laptop when I\r\nwrote this mail, and couldn't get a proper dump.\r\n\r\n>\r\n>> In that case, the interface type word would be assigned first and the\r\n>> half assigned interface would then be used as an argument. Spilling to\r\n>> a tempname solves this problem.\r\n>\r\n> Okay. But then the problem being solved is that a function call has to\r\n> be made. That's not really a condition of addressability of the n\r\n> side. Probably you want if n->ullman >= UINF or something like that.\r\n>\r\n> In this code:\r\n>\r\n>         case OEFACE:\r\n>                 if (res->op != ONAME || !res->addable) {\r\n>                         tempname(&n1, n->type);\r\n>                         cgen_eface(n, &n1);\r\n>                         cgen(&n1, res);\r\n>                 } else\r\n>                         cgen_eface(n, res);\r\n>                 goto ret;\r\n>\r\n> It says \"if res is inappropriate, call cgen_eface with a different res\r\n> that is appropriate\".\r\n> But when you add the conditions about n->left and n->right, it looks\r\n> like a check for an inappropriate n, but the cgen_eface still gets\r\n> called with the same n, which looks suspicious. I think cgen_eface is\r\n> at fault here if anything is: it should avoid writing to res until it\r\n> has all the pieces it needs.\r\n>\r\n> Right now it is:\r\n>\r\n> void\r\n> cgen_eface(Node *n, Node *res)\r\n> {\r\n>         Node dst;\r\n>         dst = *res;\r\n>         dst.type = types[tptr];\r\n>         cgen(n->left, &dst);\r\n>         dst.xoffset += widthptr;\r\n>         cgen(n->right, &dst);\r\n> }\r\n>\r\n> One fix is to make cgen_eface check for n->left->ullman >= UINF and\r\n> generate into temporaries here. But I don't think that's necessary\r\n> either. Since n->left is always a constant (a type pointer known at\r\n> compile time), it should work well enough to swap the order of the\r\n> generation:\r\n>\r\n>         dst.type = types[tptr];\r\n>         dst.xoffset += widthptr;\r\n>         cgen(n->right, &dst); // might be difficult\r\n>         dst.xoffset -= widthptr;\r\n>         cgen(n->left, &dst); // always a constant\r\n>\r\nWill do this for next patch set.\r\n\r\n> Russ\r\n",
			"disapproval": false,
			"date": "2012-08-06 21:13:42.686290",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Note that I've updated the description of the CL to include benchmarks for a plain assignment as the atomic load",
			"disapproval": false,
			"date": "2012-08-08 19:03:37.451430",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "ping.",
			"disapproval": false,
			"date": "2012-08-23 15:43:22.530290",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I think that this is in rsc's court, but out of curiousity, what does \"6g -S\" give for this program:\n\n--------\npackage main\n\ntype T uintptr\n\nfunc (T) Method() {}\n\ntype I interface {\n    Method()\n}\n\nvar t T\nvar i I\n\nfunc main() {\n    i = t\n}\n--------\n\nFor example, 6g tip gives:\n\n--- prog list \"main\" ---\n0002 (main.go:14) TEXT    main+0(SB),$48-0\n0003 (main.go:15) MOVQ    $type.\"\".T+0(SB),(SP)\n0004 (main.go:15) MOVQ    $type.\"\".I+0(SB),8(SP)\n0005 (main.go:15) MOVQ    $go.itab.\"\".T.\"\".I+0(SB),16(SP)\n0006 (main.go:15) MOVQ    t+0(SB),BX\n0007 (main.go:15) MOVQ    BX,24(SP)\n0008 (main.go:15) CALL    ,runtime.convT2I+0(SB)\n0009 (main.go:15) MOVQ    32(SP),BX\n0010 (main.go:15) MOVQ    BX,i+0(SB)\n0011 (main.go:15) MOVQ    40(SP),BX\n0012 (main.go:15) MOVQ    BX,i+8(SB)\n0013 (main.go:16) RET     ,\n\nhttps://codereview.appspot.com/6351090/diff/26002/src/cmd/gc/walk.c\nFile src/cmd/gc/walk.c (right):\n\nhttps://codereview.appspot.com/6351090/diff/26002/src/cmd/gc/walk.c#newcode787\nsrc/cmd/gc/walk.c:787: r = l->left;\nJust use \"sym->def\" a few lines below instead of assigning to r?",
			"disapproval": false,
			"date": "2012-08-24 05:02:51.214930",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/08/24 05:02:51, nigeltao wrote:\n> I think that this is in rsc's court, but out of curiousity, what does \"6g -S\"\n> give for this program:\n> \n> For example, 6g tip gives:\n> \n> --- prog list \"main\" ---\n> 0002 (main.go:14) TEXT    main+0(SB),$48-0\n> 0003 (main.go:15) MOVQ    $type.\"\".T+0(SB),(SP)\n> 0004 (main.go:15) MOVQ    $type.\"\".I+0(SB),8(SP)\n> 0005 (main.go:15) MOVQ    $go.itab.\"\".T.\"\".I+0(SB),16(SP)\n> 0006 (main.go:15) MOVQ    t+0(SB),BX\n> 0007 (main.go:15) MOVQ    BX,24(SP)\n> 0008 (main.go:15) CALL    ,runtime.convT2I+0(SB)\n> 0009 (main.go:15) MOVQ    32(SP),BX\n> 0010 (main.go:15) MOVQ    BX,i+0(SB)\n> 0011 (main.go:15) MOVQ    40(SP),BX\n> 0012 (main.go:15) MOVQ    BX,i+8(SB)\n> 0013 (main.go:16) RET     ,\n> \n\nThis is the 6g -S output\n\n--- prog list \"main\" ---\n0002 (main.go:14) TEXT    main+0(SB),$32-0\n0003 (main.go:15) MOVQ    go.itab.\"\".T.\"\".I+0(SB),AX\n0004 (main.go:15) MOVQ    $0,BP\n0005 (main.go:15) CMPQ    AX,BP\n0006 (main.go:15) JNE     $1,12\n0007 (main.go:15) MOVQ    $type.\"\".T+0(SB),(SP)\n0008 (main.go:15) MOVQ    $type.\"\".I+0(SB),8(SP)\n0009 (main.go:15) MOVQ    $go.itab.\"\".T.\"\".I+0(SB),16(SP)\n0010 (main.go:15) CALL    ,runtime.typ2Itab+0(SB)\n0011 (main.go:15) MOVQ    24(SP),AX\n0012 (main.go:15) MOVQ    t+0(SB),BX\n0013 (main.go:15) MOVQ    BX,i+8(SB)\n0014 (main.go:15) MOVQ    AX,i+0(SB)\n0015 (main.go:16) RET     ,\n\nHowever, the linker will move the unlikely typ2Itab branch to the end of the function for better pipelining.",
			"disapproval": false,
			"date": "2012-08-24 16:58:04.453650",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, dave@cheney.net, nigeltao@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-08-25 07:22:24.244640",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Huh, thought hg mail would publish draft comments...\n\nAnyway, Nigel suggestion has been added.",
			"disapproval": false,
			"date": "2012-08-25 07:24:12.343910",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Sat, Aug 25, 2012 at 3:24 AM,  <daniel.morsing@gmail.com> wrote:\r\n> Huh, thought hg mail would publish draft comments...\r\n\r\nIt only does that if your user name is agl. I don't understand it either.\r\n",
			"disapproval": false,
			"date": "2012-08-31 17:09:56.942850",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nI expected a win in code that uses interfaces as \"unions\", so you get lots of T2I conversions. The parser and template speedups reflect that, so great. I am a little surprised by the minor slowdowns in the other benchmarks but that can be code motion and cache lines. It's hard to believe they are actually executing T2I conversions in any serious amount.\n\nOne thing that might be interesting in a separate CL: now that we have likely bits on the if, if there is a loop with an if inside, and the if branches out of the loop (return, break), mark it unlikely so that the loop body stays as tight as possible.\n\nhttp://codereview.appspot.com/6351090/diff/41001/src/pkg/runtime/iface.c\nFile src/pkg/runtime/iface.c (right):\n\nhttp://codereview.appspot.com/6351090/diff/41001/src/pkg/runtime/iface.c#newcode186\nsrc/pkg/runtime/iface.c:186: #pragma textflag 7\nThis is fine to mark as textflag 7. I just want to point out that it doesn't have to be for any particular reason.",
			"disapproval": false,
			"date": "2012-09-11 02:45:14.693030",
			"approval": true
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/11 02:45:14, rsc wrote:\n> LGTM\n> http://codereview.appspot.com/6351090/diff/41001/src/pkg/runtime/iface.c#newcode186\n> src/pkg/runtime/iface.c:186: #pragma textflag 7\n> This is fine to mark as textflag 7. I just want to point out that it doesn't\n> have to be for any particular reason.\n\nI'm submitting as is, but if there are any set in stone rules about when to use textflag 7, i'd love to hear them.",
			"disapproval": false,
			"date": "2012-09-11 19:40:52.147690",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"daniel.morsing@gmail.com",
				"rsc@golang.org",
				"dave@cheney.net",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=6d4707371015 ***\n\ncmd/gc: Inline pointer sized T2I interface conversions\n\nThis CL also adds support for marking the likelyness of IF nodes in the AST being true. This feature is being used here to mark the slow path as unlikely.\n\nsrc/pkg/runtime:\nbenchmark                  old ns/op    new ns/op    delta\nBenchmarkConvT2IUintptr           16            1  -91.63%\n\ntest/bench/go1:\nbenchmark                 old ns/op    new ns/op    delta\nBenchmarkBinaryTree17    5416917000   5461355000   +0.82%\nBenchmarkFannkuch11      3810355000   3842609000   +0.85%\nBenchmarkGobDecode         19950950     19855420   -0.48%\nBenchmarkGobEncode         11301220     11308530   +0.06%\nBenchmarkGzip             548119600    546869200   -0.23%\nBenchmarkGunzip           176145400    180208300   +2.31%\nBenchmarkJSONEncode        93117400     70163100  -24.65%\nBenchmarkJSONDecode       406626800    409999200   +0.83%\nBenchmarkMandelbrot200      6300992      6317866   +0.27%\nBenchmarkParse              7664396      7451625   -2.78%\nBenchmarkRevcomp         1189424000   1412332000  +18.74%\nBenchmarkTemplate         491308400    458654200   -6.65%\n\nbenchmark                  old MB/s     new MB/s  speedup\nBenchmarkGobDecode            38.47        38.66    1.00x\nBenchmarkGobEncode            67.92        67.87    1.00x\nBenchmarkGzip                 35.40        35.48    1.00x\nBenchmarkGunzip              110.16       107.68    0.98x\nBenchmarkJSONEncode           20.84        27.66    1.33x\nBenchmarkJSONDecode            4.77         4.73    0.99x\nBenchmarkParse                 7.56         7.77    1.03x\nBenchmarkRevcomp             213.69       179.96    0.84x\nBenchmarkTemplate              3.95         4.23    1.07x\n\nR=rsc, dave, nigeltao\nCC=golang-dev\nhttp://codereview.appspot.com/6351090",
			"disapproval": false,
			"date": "2012-09-11 19:42:34.916760",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Use $7 when the function is a leaf: that is, it never calls another\r\nfunction. Setting textflag to 7 is necessary when it's a function\r\ninvolved in the stack-splitting code: splitting stacks inside the\r\nstack-splitting code would be a disaster.  Other than that, it's\r\noptional and affects only performance, not correctness.\r\n\r\n-rob\r\n",
			"disapproval": false,
			"date": "2012-09-11 21:15:15.457060",
			"approval": false
		}
	],
	"owner_email": "daniel.morsing@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "DMorsing",
	"subject": "code review 6351090: cmd/gc: Inline pointer sized T2I interface conversions",
	"created": "2012-07-12 17:14:08.783840",
	"patchsets": [
		1,
		2001,
		16001,
		19001,
		29001,
		26002,
		41001,
		49001
	],
	"modified": "2012-09-11 21:15:15.550540",
	"closed": true,
	"issue": 6351090
}