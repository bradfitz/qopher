{
	"description": "exp/ssh: new package.\n\nThe typical UNIX method for controlling long running process is to\nsend the process signals. Since this doesn't get you very far, various\nad-hoc, remote-control protocols have been used over time by programs\nlike Apache and BIND.\n\nImplementing an SSH server means that Go code will have a standard,\nsecure way to do this in the future.",
	"cc": [
		"bradfitz@golang.org",
		"borman@google.com",
		"dave@cheney.net",
		"gustavo@niemeyer.net",
		"dsymonds@golang.org",
		"r@golang.org",
		"adg@golang.org",
		"rsc@golang.org",
		"rogpeppe@gmail.com",
		"lvd@google.com",
		"kevlar@google.com",
		"raul.san@sent.com",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I'm sure the client code isn't far behind.\n\nOn Fri, Sep 9, 2011 at 9:39 AM,  <borman@google.com> wrote:\n> The package name \"ssh\" is misleading as this package does not implement\n> an ssh client, only the server.\n>\n> http://codereview.appspot.com/4962064/\n>\n",
			"disapproval": false,
			"date": "2011-09-08 23:42:50.403195",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> The package name \"ssh\" is misleading as this package does not implement\n> an ssh client, only the server.\n\nIsn't it just a matter of time?  There's a difference for sure, but\nthe protocol is pretty symmetric overall.\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I never filed a patent.\n",
			"disapproval": false,
			"date": "2011-09-08 23:43:45.307448",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I don't think this belongs in the standard library. It should live in\nan external repo that can be goinstalled.\n",
			"disapproval": false,
			"date": "2011-09-08 23:47:44.211947",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Sep 8, 2011 at 7:43 PM, Gustavo Niemeyer <gustavo@niemeyer.net> wrote:\n> Isn't it just a matter of time? \u00a0There's a difference for sure, but\n> the protocol is pretty symmetric overall.\n\nI seems that the only time that I can get for Go these days is on\nplanes and I don't have any more flights planned for the rest of the\nyear :)\n\nBut, assuming that Rob doesn't decide that I've bloated the standard\nlibrary too much with this, I'm happy to review changes. The code is\npretty basic as is.\n\n\nCheers\n\nAGL\n",
			"disapproval": false,
			"date": "2011-09-08 23:47:55.638149",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I think that having an integrated ssh facility in the standard library\nwould be a unique* feature for Go and integrates well with the current\ncrop of crypto libraries and the exec facility.\n\nYes, it could just as easily be supported in an external package, but\nI feel that ssh, tls and http are fundamental protocols, and that\nshould justify their inclusion in the standard library.\n\nCheers\n\nDave\n\n* I'm pretty sure this is true for languages like Ruby, Python, Java,\nC; well written 3rd party libraries exist to provide ssh (usually\nwrapping openssh).\n\nOn Fri, Sep 9, 2011 at 1:25 PM, Brad Fitzpatrick <bradfitz@golang.org> wrote:\n> I'm torn.\n> I like goinstall but the fact that this is crypto makes me nervous about\n> having it off somewhere else.\n> I think as a user I'd be much more comfortable using standard library\n> 'blessed' crypto code, rather than one of potentially n maybe incomplete\n> implementations hosted elsewhere. \u00a0By having crypto in the standard library\n> it focuses usage and (security) eyeballs on one canonical implementation,\n> rather than letting people compete elsewhere.\n> Witness, for example, how many people avoid using GnuTLS (despite having a\n> nicer API) because of the fear that it's not as audited as OpenSSL. \u00a0I\n> suppose that's an argument in either direction, but I think I'm leaning\n> slightly towards it being in the standard library, along with the rest of\n> the crypto.\n> *shrug*\n>\n> On Thu, Sep 8, 2011 at 8:18 PM, Rob 'Commander' Pike <r@golang.org> wrote:\n>>\n>> I would favor doing this in a goinstallable repository. It seems a\n>> perfect candidate.\n>>\n>> That is not in any way a criticism of the package - I think it would\n>> be great to have - but it's so self-contained and well-defined I don't\n>> see why it needs to be put into every Go installation. \u00a0Goinstall is\n>> there and we should use it.\n>>\n>> -rob\n>\n>\n",
			"disapproval": false,
			"date": "2011-09-09 03:46:23.321884",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 9 September 2011 13:25, Brad Fitzpatrick <bradfitz@golang.org> wrote:\n> I'm torn.\n> I like goinstall but the fact that this is crypto makes me nervous about\n> having it off somewhere else.\n> I think as a user I'd be much more comfortable using standard library\n> 'blessed' crypto code, rather than one of potentially n maybe incomplete\n> implementations hosted elsewhere. \u00a0By having crypto in the standard library\n> it focuses usage and (security) eyeballs on one canonical implementation,\n> rather than letting people compete elsewhere.\n> Witness, for example, how many people avoid using GnuTLS (despite having a\n> nicer API) because of the fear that it's not as audited as OpenSSL. \u00a0I\n> suppose that's an argument in either direction, but I think I'm leaning\n> slightly towards it being in the standard library, along with the rest of\n> the crypto.\n> *shrug*\n\nA while back we talked about moving many of the crypto packages into a\nseparate repository. That way they could still have the well-respected\nGo (and agl) seal of approval, but not bloat up the Go standard\nlibrary.\n\nOf course, we'd have to keep the ones used by standard library packages around.\n\nWhat are those?\n\nadg:~/go/src$ grep -r '\"crypto' . | grep -v \"^./pkg/crypto\" | awk '{\nprint $2 }' | sort | uniq -c\n   4 \"crypto/md5\"\n   6 \"crypto/rand\"\n   3 \"crypto/sha1\"\n   9 \"crypto/tls\"\n\nHmm. And what are their dependencies?\n\nadg:~/go/src$ grep -r '\"crypto' pkg/crypto/{md5,rand,sha1,tls} | awk\n'{ print $2 }' | sort | uniq\n\"crypto\"\n\"crypto/aes\"\n\"crypto/cipher\"\n\"crypto/elliptic\"\n\"crypto/hmac\"\n\"crypto/md5\"\n\"crypto/rand\"\n\"crypto/rc4\"\n\"crypto/rsa\"\n\"crypto/sha1\"\n\"crypto/subtle\"\n\"crypto/x509\"\n\"crypto/x509/pkix\"\n\nHmm... And theirs?\n\nadg:~/go/src$ grep -r '\"crypto' pkg/crypto/{md5,rand,sha1,tls} | awk\n'{ print $2 }' | sort | uniq | xargs -Ifn grep -r '\"crypto' pkg/fn |\nawk '{ print $2 }' | sort | uniq\n\"crypto\"\n\"crypto/aes\"\n\"crypto/cast5\"\n\"crypto/cipher\"\n\"crypto/dsa\"\n\"crypto/elliptic\"\n\"crypto/hmac\"\n\"crypto/md5\"\n\"crypto/openpgp/armor\"\n\"crypto/openpgp/elgamal\"\n\"crypto/openpgp/error\"\n\"crypto/openpgp/packet\"\n\"crypto/openpgp/s2k\"\n\"crypto/rand\"\n\"crypto/rc4\"\n\"crypto/rsa\"\n\"crypto/sha1\"\n\"crypto/sha256\"\n\"crypto/subtle\"\n\"crypto/x509\"\n\"crypto/x509/pkix\"\n\nDoes it go deeper? Maybe. The crypto packages _not_ mentioned so far:\n\ncrypto/blowfish\ncrypto/des\ncrypto/dsa\ncrypto/ecdsa\ncrypto/md4\ncrypto/ocsp\ncrypto/rc4\ncrypto/rsa\ncrypto/sha512\ncrypto/twofish\ncrypto/xtea\n\nShould those be in a separate repo? Maybe. Is it worth the extra\nmaintenance burden, though?\n\nUnless other parts of the standard library will depend on SSH for\nsomething, I don't see why it should be included in the standard\nlibrary. If users have trust issues with external repositories, we\nshould fix that problem. (A \"gopher of approval\" icon on the\ndashboard?)\n\nAndrew\n",
			"disapproval": false,
			"date": "2011-09-09 03:54:59.867011",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> I think that having an integrated ssh facility in the standard library\n> would be a unique* feature for Go and integrates well with the current\n> crop of crypto libraries and the exec facility.\n\nI agree.. but I know I also don't have a good argument about this.\nMaybe it's just that standard packages tend to be well maintained and\nstay up-to-date more often.. but I agree with Andrew that this is a\nperception (or reality) to be fixed.\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I never filed a patent.\n",
			"disapproval": false,
			"date": "2011-09-09 03:57:35.912315",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"dave@cheney.net",
				"gustavo@niemeyer.net",
				"dsymonds@golang.org",
				"r@golang.org",
				"adg@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/channel.go\nFile src/pkg/net/ssh/channel.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/channel.go#newcode12\nsrc/pkg/net/ssh/channel.go:12: // A Channel is an ordered, reliable, duplux stream that is multiplexed over an\ns/plux/plex/\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/channel.go#newcode16\nsrc/pkg/net/ssh/channel.go:16: Confirm() os.Error\ns/Confirm/Accept/ ?\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server.go\nFile src/pkg/net/ssh/server.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server.go#newcode41\nsrc/pkg/net/ssh/server.go:41: // PubKeyCallback, if non-nil, is called when a client attempts public\nWhy use callbacks here instead of interface values? It's a little awkward using the boolean to give the function two uses.\n\nWhat about\n\nPubKeyAuth KeyAuthenticator\n\ntype KeyAuthenticator interface {\n    AuthenticateKey(user, algo string, pubkey []byte) bool\n    CanAuthenticateKey(algo string) bool\n}\n\n?\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server.go#newcode42\nsrc/pkg/net/ssh/server.go:42: // key authentication. It must return true iff the given public key is\ns/iff/if/\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server_shell.go\nFile src/pkg/net/ssh/server_shell.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server_shell.go#newcode11\nsrc/pkg/net/ssh/server_shell.go:11: // ServerShell contains the state for running a VT100 terminal that is capable\nI wonder if this should be in a separate package, and take an io.ReadWriter instead of an ssh.Channel ?\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server_shell.go#newcode372\nsrc/pkg/net/ssh/server_shell.go:372: switch req := err.(type) {\nThis might as well be\n\nif req, ok := err.(ChannelRequest); ok {\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server_shell.go#newcode392\nsrc/pkg/net/ssh/server_shell.go:392: ss.c.AckRequest(ok)\nIf you made c an io.ReadWriter, this could be\n\n  ss.c.(ssh.Channel).AckRequest(ok)",
			"disapproval": false,
			"date": "2011-09-09 05:38:14.723271",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Given Brad's argument, if it is in the standard library I would like to see\nit the crypto subdirectory.  Do we have any crypto code that is not in the\ncrypto directory?\n\nBut I am on the side of having it external.  Ideally it would be\nvetted/audited by some known organization.  Putting it in the standard\nlibrary does really resolve the auditing situation, just gives you warm\nfuzzies.\n\nOn Thu, Sep 8, 2011 at 8:25 PM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\n\n> I'm torn.\n>\n> I like goinstall but the fact that this is crypto makes me nervous about\n> having it off somewhere else.\n>\n> I think as a user I'd be much more comfortable using standard library\n> 'blessed' crypto code, rather than one of potentially n maybe incomplete\n> implementations hosted elsewhere.  By having crypto in the standard library\n> it focuses usage and (security) eyeballs on one canonical implementation,\n> rather than letting people compete elsewhere.\n>\n> Witness, for example, how many people avoid using GnuTLS (despite having a\n> nicer API) because of the fear that it's not as audited as OpenSSL.  I\n> suppose that's an argument in either direction, but I think I'm leaning\n> slightly towards it being in the standard library, along with the rest of\n> the crypto.\n>\n> *shrug*\n>\n>\n> On Thu, Sep 8, 2011 at 8:18 PM, Rob 'Commander' Pike <r@golang.org> wrote:\n>\n>> I would favor doing this in a goinstallable repository. It seems a\n>> perfect candidate.\n>>\n>> That is not in any way a criticism of the package - I think it would\n>> be great to have - but it's so self-contained and well-defined I don't\n>> see why it needs to be put into every Go installation.  Goinstall is\n>> there and we should use it.\n>>\n>> -rob\n>>\n>\n>\n",
			"disapproval": false,
			"date": "2011-09-09 03:44:37.037857",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I don't think that holding up Adam's code while we\nfigure out whether or not to build another repository\nis fair to Adam or to us.  At some point we will have\nto start splitting up the library, but I don't think we're there\nyet, and I think the costs involved are usually overlooked\nor at least underestimated when suggesting it.\nGoinstall the reality is not yet goinstall the ideal.\nWe can discuss that under a different subject line,\nnot attached to this CL.\n\nI think that Adam's suggested use for this is exciting:\nit would be a significant boon for exactly the kinds of\nprograms - network servers - that Go is intended for.\nIt could easily be as important as a template system\nor xml.  I'd like to see this move forward rather than\nget bogged down in discussions about placement.\n\nI propose to put this in exp/ssh for now, and we can\nfigure out final placement once we have more experience\nabout how important it is, just like we did with exp/draw\nand exp/eval.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-09-09 04:24:43.467576",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "The package name \"ssh\" is misleading as this package does not implement an ssh client, only the server.",
			"disapproval": false,
			"date": "2011-09-08 23:39:39.083612",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 9 September 2011 14:24, Russ Cox <rsc@golang.org> wrote:\n> I propose to put this in exp/ssh for now, and we can\n> figure out final placement once we have more experience\n> about how important it is, just like we did with exp/draw\n> and exp/eval.\n\nSGTM. I never intended to hold up the progress\u00a0of this CL.\n",
			"disapproval": false,
			"date": "2011-09-09 04:35:36.131673",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello bradfitz@golang.org (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2011-09-08 23:33:32.348859",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Awesome! I was looking at the old (broken) ssh.go package last night.\nI would be highly supportive of this package being integrated into the\nstd lib\n\n\nOn Fri, Sep 9, 2011 at 9:33 AM,  <agl@golang.org> wrote:\n> Reviewers: bradfitz,\n>\n> Message:\n> Hello bradfitz@golang.org (cc: golang-dev@googlegroups.com),\n>\n> I'd like you to review this change to\n> https://go.googlecode.com/hg/\n>\n>\n> Description:\n> net/ssh: new package.\n>\n> The typical UNIX method for controlling long running process is to\n> send the process signals. Since this doesn't get you very far, various\n> ad-hoc, remote-control protocols have been used over time by programs\n> like Apache and BIND.\n>\n> Implementing an SSH server means that Go code will have a standard,\n> secure way to do this in the future.\n>\n> Please review this at http://codereview.appspot.com/4962064/\n>\n> Affected files:\n> \u00a0A src/pkg/net/ssh/Makefile\n> \u00a0A src/pkg/net/ssh/channel.go\n> \u00a0A src/pkg/net/ssh/common.go\n> \u00a0A src/pkg/net/ssh/doc.go\n> \u00a0A src/pkg/net/ssh/messages.go\n> \u00a0A src/pkg/net/ssh/messages_test.go\n> \u00a0A src/pkg/net/ssh/server.go\n> \u00a0A src/pkg/net/ssh/server_shell.go\n> \u00a0A src/pkg/net/ssh/server_shell_test.go\n> \u00a0A src/pkg/net/ssh/transport.go\n>\n>\n>\n",
			"disapproval": false,
			"date": "2011-09-08 23:41:08.701758",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": ">> Isn't it just a matter of time? \u00a0There's a difference for sure, but\n>> the protocol is pretty symmetric overall.\n>\n> I seems that the only time that I can get for Go these days is on\n> planes and I don't have any more flights planned for the rest of the\n> year :)\n\nHey, I can easily fix that for you.  Do you want to present Go at the\nUbuntu Developer Summit in November? :-)\n\n> But, assuming that Rob doesn't decide that I've bloated the standard\n> library too much with this, I'm happy to review changes. The code is\n> pretty basic as is.\n\nIt'd indeed be fantastic to have a reasonable ssh client/server\nimplementation integrated.\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I never filed a patent.\n",
			"disapproval": false,
			"date": "2011-09-08 23:56:19.046720",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "+1 achievement unlocked: reasonable compromise.\n\n> I propose to put this in exp/ssh for now, and we can\n> figure out final placement once we have more experience\n> about how important it is, just like we did with exp/draw\n> and exp/eval.\n>\n> Russ\n>\n",
			"disapproval": false,
			"date": "2011-09-09 04:31:49.629397",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I would favor doing this in a goinstallable repository. It seems a\nperfect candidate.\n\nThat is not in any way a criticism of the package - I think it would\nbe great to have - but it's so self-contained and well-defined I don't\nsee why it needs to be put into every Go installation.  Goinstall is\nthere and we should use it.\n\n-rob\n",
			"disapproval": false,
			"date": "2011-09-09 03:18:22.418076",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I'm torn.\n\nI like goinstall but the fact that this is crypto makes me nervous about\nhaving it off somewhere else.\n\nI think as a user I'd be much more comfortable using standard library\n'blessed' crypto code, rather than one of potentially n maybe incomplete\nimplementations hosted elsewhere.  By having crypto in the standard library\nit focuses usage and (security) eyeballs on one canonical implementation,\nrather than letting people compete elsewhere.\n\nWitness, for example, how many people avoid using GnuTLS (despite having a\nnicer API) because of the fear that it's not as audited as OpenSSL.  I\nsuppose that's an argument in either direction, but I think I'm leaning\nslightly towards it being in the standard library, along with the rest of\nthe crypto.\n\n*shrug*\n\n\nOn Thu, Sep 8, 2011 at 8:18 PM, Rob 'Commander' Pike <r@golang.org> wrote:\n\n> I would favor doing this in a goinstallable repository. It seems a\n> perfect candidate.\n>\n> That is not in any way a criticism of the package - I think it would\n> be great to have - but it's so self-contained and well-defined I don't\n> see why it needs to be put into every Go installation.  Goinstall is\n> there and we should use it.\n>\n> -rob\n>\n",
			"disapproval": false,
			"date": "2011-09-09 03:25:15.698869",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 9 September 2011 13:18, Rob 'Commander' Pike <r@golang.org> wrote:\n> I would favor doing this in a goinstallable repository. It seems a\n> perfect candidate.\n>\n> That is not in any way a criticism of the package - I think it would\n> be great to have - but it's so self-contained and well-defined I don't\n> see why it needs to be put into every Go installation. \u00a0Goinstall is\n> there and we should use it.\n\n+1\n\nThe community needs more high-quality external libraries, and this is\na great candidate. Can't wait to start using it.\n\nI'm sure golang-dev is still be happy to review the code - just set up\nthe code review extension for a separate hg repository at googlecode\nthe same way we have done for various other external libraries.\n\nAndrew\n",
			"disapproval": false,
			"date": "2011-09-09 03:25:17.546351",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"dave@cheney.net",
				"gustavo@niemeyer.net",
				"dsymonds@golang.org",
				"r@golang.org",
				"adg@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Moved to exp/ssh and have replied to comments.\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/channel.go\nFile src/pkg/net/ssh/channel.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/channel.go#newcode12\nsrc/pkg/net/ssh/channel.go:12: // A Channel is an ordered, reliable, duplux stream that is multiplexed over an\nOn 2011/09/09 05:38:15, adg wrote:\n> s/plux/plex/\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/channel.go#newcode16\nsrc/pkg/net/ssh/channel.go:16: Confirm() os.Error\nOn 2011/09/09 05:38:15, adg wrote:\n> s/Confirm/Accept/ ?\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server.go\nFile src/pkg/net/ssh/server.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server.go#newcode41\nsrc/pkg/net/ssh/server.go:41: // PubKeyCallback, if non-nil, is called when a client attempts public\nOn 2011/09/09 05:38:15, adg wrote:\n> Why use callbacks here instead of interface values?\n\nI don't feel too strongly here, but your example doesn't quite work. Both AuthenticateKey and CanAuthenticateKey would need to take the same arguments. It's not testing for algorithm compat, it's the full acceptance test, twice.\n\nWhich, actually, is probably silly. It shouldn't be the package user's job to deal with this quirk of SSH. So I've rewritten it so that the Server code caches the answers to PubKeyCallback and eliminated |isQuery|\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server.go#newcode42\nsrc/pkg/net/ssh/server.go:42: // key authentication. It must return true iff the given public key is\nOn 2011/09/09 05:38:15, adg wrote:\n> s/iff/if/\n\niff isn't a typo: http://en.wikipedia.org/wiki/If_and_only_if\n\nHowever, if iff is confusing people, I should remove it.\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server_shell.go\nFile src/pkg/net/ssh/server_shell.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server_shell.go#newcode11\nsrc/pkg/net/ssh/server_shell.go:11: // ServerShell contains the state for running a VT100 terminal that is capable\nOn 2011/09/09 05:38:15, adg wrote:\n> I wonder if this should be in a separate package, and take an io.ReadWriter\n> instead of an ssh.Channel ?\n\nIn time it might be the basis for a readline package. However, it wouldn't ever be able to cope with just a ReadWriter. A terminal needs to be able to get metadata, like the terminal size.\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server_shell.go#newcode372\nsrc/pkg/net/ssh/server_shell.go:372: switch req := err.(type) {\nOn 2011/09/09 05:38:15, adg wrote:\n> This might as well be\n> \n> if req, ok := err.(ChannelRequest); ok {\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server_shell.go#newcode392\nsrc/pkg/net/ssh/server_shell.go:392: ss.c.AckRequest(ok)\nOn 2011/09/09 05:38:15, adg wrote:\n> If you made c an io.ReadWriter, this could be\n> \n>   ss.c.(ssh.Channel).AckRequest(ok)\n\nI think the API cut should be different; such that this code can be a readline like package. I'd like to leave that for the future however.",
			"disapproval": false,
			"date": "2011-09-13 13:04:33.767829",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Sep 14, 2011 at 11:40, Rob 'Commander' Pike <r@golang.org> wrote:\n> Can you explain why the ssh secure network protocol has to understand\n> cursor up and cursor down? \u00a0I wasn't just complaining about its\n> existence; I simply cannot understand how it's possible. I don't use a\n> VT-100 and ssh works fine for me.\n\nYes, but you are an ssh client, not an ssh server.\n\nIdeas like the size of your terminal window are\npart of the ssh protocol, because it started as\nthe telnet protocol; the server has to process those\nmessages somehow.  It may be possible - I haven't\nthought enough about it - that we can arrange an\ninterface that the ssh server can ask of things that\nare trying to use the exp/ssh package to be a server\nand let those details be processed by the importing\ncode, not exp/ssh itself.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-09-14 15:46:46.177927",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Why is this done by the ssh server?  Normally programs do this by using\ntermcap, terminfo, or some other database (and they can support more than\njust ANSI).  There should be a different package which is not tied to ssh\nthat handles terminal specific stuff (and probably one that is not hard\ncoded).  I am sure virtually every program that uses the SSH protocol will\nalso need some sort of formatted print, but that doesn't mean we should roll\nfmt into ssh.\n\nOn Wed, Sep 14, 2011 at 9:10 AM, Adam Langley <agl@golang.org> wrote:\n\n> On Wed, Sep 14, 2011 at 11:40 AM, Rob 'Commander' Pike <r@golang.org>\n> wrote:\n> > Can you explain why the ssh secure network protocol has to understand\n> > cursor up and cursor down?  I wasn't just complaining about its\n> > existence; I simply cannot understand how it's possible. I don't use a\n> > VT-100 and ssh works fine for me.\n>\n> But you do use a VT-100. Terminal emulators (xterm, etc) still send\n> cursor movements etc as VT-100 escape sequences. SSH itself just reads\n> from the terminal and, normally, the SSH server on the other end\n> forwards them on to bash, which handles them.\n>\n> In this code we don't have bash as we're not aiming to replace sshd,\n> but to provide a way of interacting with Go programs. But we're still\n> going to be getting VT-100 codes over the wire.\n>\n> As Russ mentions, it might be a plan in the future to split to\n> server_shell.go out of ssh and make it a separate package. It could be\n> used for interactions directly with a local terminal with a bit of\n> work. But just having the SSH protocol without some code to handle the\n> terminal interactions means that everyone will have to try and\n> implement VT-100 themselves.\n>\n>\n> Cheers\n>\n> AGL\n>\n",
			"disapproval": false,
			"date": "2011-09-14 16:26:13.994318",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"dave@cheney.net",
				"gustavo@niemeyer.net",
				"dsymonds@golang.org",
				"r@golang.org",
				"adg@golang.org",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go\nFile src/pkg/exp/ssh/messages.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go#newcode563\nsrc/pkg/exp/ssh/messages.go:563: }\nthat's interesting. the second form is clearer, but i don't see how the compiler can avoid allocating lengthBytes on the heap - it can't know that w.Write doesn't store its buffer somewhere else.\nBTW what do the -s and -m flags do? flags to 6g or 6l?",
			"disapproval": false,
			"date": "2011-09-14 11:46:16.872641",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Sep 14, 2011 at 12:33 PM, Paul Borman <borman@google.com> wrote:\n> I can see that the ssh server may need to expose WINCH signals, but that is\n> unrelated to keyboard handling. \u00a0Just let the keystrokes flow. \u00a0The terminal\n> handling package will take care of it.\n\nWe don't *have* a terminal handling package. One may grow out of this\nand split off from ssh. That would be a good thing. The code, as is,\nis just about sufficient to make a nice demo from which people can\nwork, and that's all I was aiming for in a first version.\n\n\nCheers\n\nAGL\n",
			"disapproval": false,
			"date": "2011-09-14 16:56:14.514542",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Then I would suggest writing a separate terminal package to be used in\nconjunction with the ssh server package.  fmt and log are also separate\npackages.\n\nOn Wed, Sep 14, 2011 at 9:56 AM, Adam Langley <agl@golang.org> wrote:\n\n> On Wed, Sep 14, 2011 at 12:33 PM, Paul Borman <borman@google.com> wrote:\n> > I can see that the ssh server may need to expose WINCH signals, but that\n> is\n> > unrelated to keyboard handling.  Just let the keystrokes flow.  The\n> terminal\n> > handling package will take care of it.\n>\n> We don't *have* a terminal handling package. One may grow out of this\n> and split off from ssh. That would be a good thing. The code, as is,\n> is just about sufficient to make a nice demo from which people can\n> work, and that's all I was aiming for in a first version.\n>\n>\n> Cheers\n>\n> AGL\n>\n",
			"disapproval": false,
			"date": "2011-09-14 17:12:53.939108",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Sep 14, 2011 at 10:10,  <agl@golang.org> wrote:\n> It's not ssh specifically: I'm afraid that basically all terminals are\n> VT100 these days; xterm, OS X Terminal etc. Without dirtying oneself\n> with VT100 we can't even have programs that take input from the\n> terminal. (Unless you accept the default behaviour which doesn't even\n> handle left and right keys.)\n\nI think this is okay.\n\nWe already have XML and ASN.1 packages.  Knowing the\nde facto standard encoding of left/right/up/down arrow keys\nseems okay to me.  It's not like this code is implementing\nblinking text or even colored output.  Also, this is on *input*,\nnot output: we have to deal with what's going to be sent.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-09-14 15:09:34.151987",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"dave@cheney.net",
				"gustavo@niemeyer.net",
				"dsymonds@golang.org",
				"r@golang.org",
				"adg@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go\nFile src/pkg/exp/ssh/channel.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode18\nsrc/pkg/exp/ssh/channel.go:18: // other methods on the Channel may be called.\nworth saying what happens? error? panic? stone silence?\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode27\nsrc/pkg/exp/ssh/channel.go:27: // nack is sent, no other methods on the Channel may be called.\nditto\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode58\nsrc/pkg/exp/ssh/channel.go:58: RejectResourceShortage           RejectionReason = 4\nas these names come from the RFC, OK. but they're fiendishly long.\nsince you have the type to protect you, you could consider dropping or at least shortening the Reject part. (this is a detail in which Go improves over C: you can't pass integer type Foo to a function expecting integer type Bar)\n\n\nyou can improve the const layout using iota and elide all but the first type and value.\n\nRejectAdministrativelyProhibited RejectionReason = iota+1\nRejectConnectionFailed\n\n(or make value 0 something useful, if that make sense)\n\netc.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode91\nsrc/pkg/exp/ssh/channel.go:91: return nil\nnil? not the error?\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode108\nsrc/pkg/exp/ssh/channel.go:108: return nil\nditto\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode151\nsrc/pkg/exp/ssh/channel.go:151: println(\"window overrun\")\navoid println. how about log? perhaps a custom logger that tells you it's ssh that's complaining, since the output is sure to arise in scripts if anywhere\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode274\nsrc/pkg/exp/ssh/channel.go:274: return nil\nnil error again. please look at them all, or explain why this is what you want.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/doc.go\nFile src/pkg/exp/ssh/doc.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/doc.go#newcode14\nsrc/pkg/exp/ssh/doc.go:14: An SSH server is represented by a Server, which handles manages a number\ns/handles //\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/doc.go#newcode30\nsrc/pkg/exp/ssh/doc.go:30: Once a Server has been setup, connections can be attached.\ns/setup/set up/\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/doc.go#newcode52\nsrc/pkg/exp/ssh/doc.go:52: be calling it otherwise no messages will forwarded to the channels.\nrewrite but at least s/it/it; /\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/doc.go#newcode55\nsrc/pkg/exp/ssh/doc.go:55: the case of a shell, the type is 'session' and ServerShell may be used to\ns/'/\"/g\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go\nFile src/pkg/exp/ssh/messages.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go#newcode384\nsrc/pkg/exp/ssh/messages.go:384: func ensure(out, o []byte, needed int) ([]byte, []byte) {\nexperience has taught us that with recent compiler optimizations this sort of thing is roundly defeated by calls to append\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/server_shell.go\nFile src/pkg/exp/ssh/server_shell.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/server_shell.go#newcode70\nsrc/pkg/exp/ssh/server_shell.go:70: if b[0] != 27 {\n27 deserves a name. it's an esc, right?\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/server_shell.go#newcode74\nsrc/pkg/exp/ssh/server_shell.go:74: if len(b) >= 3 && b[0] == 27 && b[1] == '[' {\nreally? we need to implement VT-100 escapes? i didn't realize this was 1971. not sure i can stomach this being in our standard repo. i'm serious",
			"disapproval": false,
			"date": "2011-09-13 17:47:25.985445",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"dave@cheney.net",
				"gustavo@niemeyer.net",
				"dsymonds@golang.org",
				"r@golang.org",
				"adg@golang.org",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go\nFile src/pkg/exp/ssh/messages.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go#newcode563\nsrc/pkg/exp/ssh/messages.go:563: }\nOn 2011/09/14 11:46:17, rog wrote:\n> that's interesting. the second form is clearer, but i don't see how the compiler\n> can avoid allocating lengthBytes on the heap - it can't know that w.Write\n> doesn't store its buffer somewhere else.\n\nWrite's output buffer is probably heap allocated, but there is no reason for the source that you pass to Write to be heap allocated. I think by making a slice literal, the compiler can avoid allocating, then zeroing the slice on the heap only to pass it to Write.\n\n> BTW what do the -s and -m flags do? flags to 6g or 6l?\n\n-s turns off (I think) escape analysis, -m turns on debugging for the things which _do_ escape onto the heap. rsc can probably correct me.",
			"disapproval": false,
			"date": "2011-09-14 11:52:53.687380",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 13 September 2011 23:04,  <agl@golang.org> wrote:\n> Which, actually, is probably silly. It shouldn't be the package user's\n> job to deal with this quirk of SSH. So I've rewritten it so that the\n> Server code caches the answers to PubKeyCallback and eliminated\n> |isQuery|\n\nEven better! :-)\n\nhttp://codereview.appspot.com/4962064/diff/8001/src/pkg/net/ssh/server.go#newcode42\n> src/pkg/net/ssh/server.go:42: // key authentication. It must return true\n> iff the given public key is\n> On 2011/09/09 05:38:15, adg wrote:\n>>\n>> s/iff/if/\n>\n> iff isn't a typo: http://en.wikipedia.org/wiki/If_and_only_if\n>\n> However, if iff is confusing people, I should remove it.\n\nLeave it. I just learned something. Thanks.\n",
			"disapproval": false,
			"date": "2011-09-13 23:28:25.152848",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"dave@cheney.net",
				"gustavo@niemeyer.net",
				"dsymonds@golang.org",
				"r@golang.org",
				"adg@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Looks good. A few suggestions based on the output of 8g -s -m\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go\nFile src/pkg/exp/ssh/messages.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go#newcode563\nsrc/pkg/exp/ssh/messages.go:563: }\n-s -m says that lengthBytes leaks onto the heap. \n\n\nfunc writeString(w io.Writer, s []byte) {\n        lengthBytes := []byte{\n                byte(len(s) >> 24), \n                byte(len(s) >> 16), \n                byte(len(s) >> 8), \n                byte(len(s)),\n        }\n        w.Write(lengthBytes)\n        w.Write(s)\n}\n\navoids the leak\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/transport.go\nFile src/pkg/exp/ssh/transport.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/transport.go#newcode41\nsrc/pkg/exp/ssh/transport.go:41: \nvar lengthBytes = make([]byte, 5) can avoid heap allocation\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/transport.go#newcode60\nsrc/pkg/exp/ssh/transport.go:60: hc.mac.Write(lengthBytes[:])\n                var seqNumBytes = []byte{\n                        byte(hc.seqNum >> 24),\n                        byte(hc.seqNum >> 16),\n                        byte(hc.seqNum >> 8),\n                        byte(hc.seqNum),\n                }\n                hc.mac.Write(seqNumBytes)\n\ncan avoid heap allocation",
			"disapproval": false,
			"date": "2011-09-14 11:15:46.838674",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Sep 14, 2011 at 13:15, <dave@cheney.net> wrote:\n\n> Looks good. A few suggestions based on the output of 8g -s -m\n>\n>\n>\n> http://codereview.appspot.com/**4962064/diff/13001/src/pkg/**\n> exp/ssh/messages.go<http://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go>\n> File src/pkg/exp/ssh/messages.go (right):\n>\n> http://codereview.appspot.com/**4962064/diff/13001/src/pkg/**\n> exp/ssh/messages.go#newcode563<http://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go#newcode563>\n> src/pkg/exp/ssh/messages.go:**563: }\n> -s -m says that lengthBytes leaks onto the heap.\n>\n>\n-s /disables/ escape analysis and falls back to the older logic, which\nshould cause /more/ heap allocations.  check with just -m.\n\n\n> func writeString(w io.Writer, s []byte) {\n>        lengthBytes := []byte{\n>                byte(len(s) >> 24),\n>                byte(len(s) >> 16),\n>                byte(len(s) >> 8),\n>                byte(len(s)),\n>        }\n>        w.Write(lengthBytes)\n>        w.Write(s)\n> }\n>\n> avoids the leak\n>\n> http://codereview.appspot.com/**4962064/diff/13001/src/pkg/**\n> exp/ssh/transport.go<http://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/transport.go>\n> File src/pkg/exp/ssh/transport.go (right):\n>\n> http://codereview.appspot.com/**4962064/diff/13001/src/pkg/**\n> exp/ssh/transport.go#newcode41<http://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/transport.go#newcode41>\n> src/pkg/exp/ssh/transport.go:**41:\n> var lengthBytes = make([]byte, 5) can avoid heap allocation\n>\n> http://codereview.appspot.com/**4962064/diff/13001/src/pkg/**\n> exp/ssh/transport.go#newcode60<http://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/transport.go#newcode60>\n> src/pkg/exp/ssh/transport.go:**60: hc.mac.Write(lengthBytes[:])\n>                var seqNumBytes = []byte{\n>                        byte(hc.seqNum >> 24),\n>                        byte(hc.seqNum >> 16),\n>                        byte(hc.seqNum >> 8),\n>                        byte(hc.seqNum),\n>                }\n>                hc.mac.Write(seqNumBytes)\n>\n> can avoid heap allocation\n>\n>\n> http://codereview.appspot.com/**4962064/<http://codereview.appspot.com/4962064/>\n>\n",
			"disapproval": false,
			"date": "2011-09-14 12:00:58.064489",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Are you trying to tell me that ssh must be a combination TTY driver\nand cursor-addressing handler? And is this because bash runs in raw\nmode now?\n\nI cry myself to sleep.\n\n-rob\n",
			"disapproval": false,
			"date": "2011-09-14 16:28:21.271498",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Can you explain why the ssh secure network protocol has to understand\ncursor up and cursor down?  I wasn't just complaining about its\nexistence; I simply cannot understand how it's possible. I don't use a\nVT-100 and ssh works fine for me.\n\n-rob\n",
			"disapproval": false,
			"date": "2011-09-14 15:40:13.401245",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"dave@cheney.net",
				"gustavo@niemeyer.net",
				"dsymonds@golang.org",
				"r@golang.org",
				"adg@golang.org",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"lvd@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go\nFile src/pkg/exp/ssh/channel.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode18\nsrc/pkg/exp/ssh/channel.go:18: // other methods on the Channel may be called.\nOn 2011/09/13 17:47:26, r wrote:\n> worth saying what happens? error? panic? stone silence?\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode27\nsrc/pkg/exp/ssh/channel.go:27: // nack is sent, no other methods on the Channel may be called.\nOn 2011/09/13 17:47:26, r wrote:\n> ditto\n\nThis was actually a confusion on my part. Other channel messages can be sent after nacking a request.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode58\nsrc/pkg/exp/ssh/channel.go:58: RejectResourceShortage           RejectionReason = 4\nOn 2011/09/13 17:47:26, r wrote:\n> RejectAdministrativelyProhibited RejectionReason = iota+1\n> RejectConnectionFailed\n\nDone, and have given the names a haircut too.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode91\nsrc/pkg/exp/ssh/channel.go:91: return nil\nOn 2011/09/13 17:47:26, r wrote:\n> nil? not the error?\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode108\nsrc/pkg/exp/ssh/channel.go:108: return nil\nOn 2011/09/13 17:47:26, r wrote:\n> ditto\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode151\nsrc/pkg/exp/ssh/channel.go:151: println(\"window overrun\")\nOn 2011/09/13 17:47:26, r wrote:\n> avoid println. how about log? perhaps a custom logger that tells you it's ssh\n> that's complaining, since the output is sure to arise in scripts if anywhere\n\nThe println was debugging that I've left in. I've replaced it with a TODO for now since the best behaviour is to tear down the connection with a protocol error. That's what other servers will do and so we don't have to worry about gracefully handling buggy clients.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/channel.go#newcode274\nsrc/pkg/exp/ssh/channel.go:274: return nil\nOn 2011/09/13 17:47:26, r wrote:\n> nil error again. please look at them all, or explain why this is what you want.\n\nThe thought at the time was that the user will find out when they loop around and Read in any case. But, if that was what I was aiming for then these functions shouldn't return an os.Error at all. I've kept them returning os.Error and replaced all instances of \"return nil\" in this file with returning actual errors.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/doc.go\nFile src/pkg/exp/ssh/doc.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/doc.go#newcode14\nsrc/pkg/exp/ssh/doc.go:14: An SSH server is represented by a Server, which handles manages a number\nOn 2011/09/13 17:47:26, r wrote:\n> s/handles //\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/doc.go#newcode30\nsrc/pkg/exp/ssh/doc.go:30: Once a Server has been setup, connections can be attached.\nOn 2011/09/13 17:47:26, r wrote:\n> s/setup/set up/\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/doc.go#newcode52\nsrc/pkg/exp/ssh/doc.go:52: be calling it otherwise no messages will forwarded to the channels.\nOn 2011/09/13 17:47:26, r wrote:\n> rewrite but at least s/it/it; /\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/doc.go#newcode55\nsrc/pkg/exp/ssh/doc.go:55: the case of a shell, the type is 'session' and ServerShell may be used to\nOn 2011/09/13 17:47:26, r wrote:\n> s/'/\"/g\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go\nFile src/pkg/exp/ssh/messages.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go#newcode384\nsrc/pkg/exp/ssh/messages.go:384: func ensure(out, o []byte, needed int) ([]byte, []byte) {\nOn 2011/09/13 17:47:26, r wrote:\n> experience has taught us that with recent compiler optimizations this sort of\n> thing is roundly defeated by calls to append\n\nHave removed this and used append() throughout.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/messages.go#newcode563\nsrc/pkg/exp/ssh/messages.go:563: }\nOn 2011/09/14 11:52:53, dfc wrote:\n> Write's output buffer is probably heap allocated, but there is no reason for the\n> source that you pass to Write to be heap allocated. I think by making a slice\n> literal, the compiler can avoid allocating, then zeroing the slice on the heap\n> only to pass it to Write.\n\n(Ignoring this for now. If someone can assertively say that form $x is better I'll change it)\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/server_shell.go\nFile src/pkg/exp/ssh/server_shell.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/server_shell.go#newcode70\nsrc/pkg/exp/ssh/server_shell.go:70: if b[0] != 27 {\nOn 2011/09/13 17:47:26, r wrote:\n> 27 deserves a name. it's an esc, right?\n\nDone.\n\nhttp://codereview.appspot.com/4962064/diff/13001/src/pkg/exp/ssh/server_shell.go#newcode74\nsrc/pkg/exp/ssh/server_shell.go:74: if len(b) >= 3 && b[0] == 27 && b[1] == '[' {\nOn 2011/09/13 17:47:26, r wrote:\n> really? we need to implement VT-100 escapes? i didn't realize this was 1971. not\n> sure i can stomach this being in our standard repo. i'm serious\n\nIt's not ssh specifically: I'm afraid that basically all terminals are VT100 these days; xterm, OS X Terminal etc. Without dirtying oneself with VT100 we can't even have programs that take input from the terminal. (Unless you accept the default behaviour which doesn't even handle left and right keys.)\n\nIf this makes Gopher cry then I can keep ssh in a separate repo.",
			"disapproval": false,
			"date": "2011-09-14 14:10:14.397298",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Sep 14, 2011 at 11:40 AM, Rob 'Commander' Pike <r@golang.org> wrote:\n> Can you explain why the ssh secure network protocol has to understand\n> cursor up and cursor down? \u00a0I wasn't just complaining about its\n> existence; I simply cannot understand how it's possible. I don't use a\n> VT-100 and ssh works fine for me.\n\nBut you do use a VT-100. Terminal emulators (xterm, etc) still send\ncursor movements etc as VT-100 escape sequences. SSH itself just reads\nfrom the terminal and, normally, the SSH server on the other end\nforwards them on to bash, which handles them.\n\nIn this code we don't have bash as we're not aiming to replace sshd,\nbut to provide a way of interacting with Go programs. But we're still\ngoing to be getting VT-100 codes over the wire.\n\nAs Russ mentions, it might be a plan in the future to split to\nserver_shell.go out of ssh and make it a separate package. It could be\nused for interactions directly with a local terminal with a bit of\nwork. But just having the SSH protocol without some code to handle the\nterminal interactions means that everyone will have to try and\nimplement VT-100 themselves.\n\n\nCheers\n\nAGL\n",
			"disapproval": false,
			"date": "2011-09-14 16:10:56.601544",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I can see that the ssh server may need to expose WINCH signals, but that is\nunrelated to keyboard handling.  Just let the keystrokes flow.  The terminal\nhandling package will take care of it.\n\nOn Wed, Sep 14, 2011 at 8:46 AM, Russ Cox <rsc@golang.org> wrote:\n\n> On Wed, Sep 14, 2011 at 11:40, Rob 'Commander' Pike <r@golang.org> wrote:\n> > Can you explain why the ssh secure network protocol has to understand\n> > cursor up and cursor down?  I wasn't just complaining about its\n> > existence; I simply cannot understand how it's possible. I don't use a\n> > VT-100 and ssh works fine for me.\n>\n> Yes, but you are an ssh client, not an ssh server.\n>\n> Ideas like the size of your terminal window are\n> part of the ssh protocol, because it started as\n> the telnet protocol; the server has to process those\n> messages somehow.  It may be possible - I haven't\n> thought enough about it - that we can arrange an\n> interface that the ssh server can ask of things that\n> are trying to use the exp/ssh package to be a server\n> and let those details be processed by the importing\n> code, not exp/ssh itself.\n>\n> Russ\n>\n",
			"disapproval": false,
			"date": "2011-09-14 16:33:55.424145",
			"approval": false
		},
		{
			"sender": "raul.san@sent.com",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"dave@cheney.net",
				"gustavo@niemeyer.net",
				"dsymonds@golang.org",
				"r@golang.org",
				"adg@golang.org",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"lvd@google.com",
				"kevlar@google.com",
				"raul.san@sent.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2011/09/14 17:12:53, borman wrote:\n> Then I would suggest writing a separate terminal package to be used in\n> conjunction with the ssh server package.  fmt and log are also separate\n> packages.\n> \n> On Wed, Sep 14, 2011 at 9:56 AM, Adam Langley <mailto:agl@golang.org> wrote:\n> \n> > On Wed, Sep 14, 2011 at 12:33 PM, Paul Borman <mailto:borman@google.com> wrote:\n> > > I can see that the ssh server may need to expose WINCH signals, but that\n> > is\n> > > unrelated to keyboard handling.  Just let the keystrokes flow.  The\n> > terminal\n> > > handling package will take care of it.\n> >\n> > We don't *have* a terminal handling package. One may grow out of this\n> > and split off from ssh. That would be a good thing. The code, as is,\n> > is just about sufficient to make a nice demo from which people can\n> > work, and that's all I was aiming for in a first version.\n> >\n> >\n> > Cheers\n> >\n> > AGL\n> >\n\nTo have low level access at terminal in Unix, it could be used this package, Go-Term[1].\n\n[1]: https://github.com/kless/Go-Term",
			"disapproval": false,
			"date": "2011-09-17 09:07:55.047019",
			"approval": false
		},
		{
			"sender": "kevlar@google.com",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"dave@cheney.net",
				"gustavo@niemeyer.net",
				"dsymonds@golang.org",
				"r@golang.org",
				"adg@golang.org",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"lvd@google.com",
				"kevlar@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/4962064/diff/24001/src/pkg/exp/ssh/channel.go\nFile src/pkg/exp/ssh/channel.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/24001/src/pkg/exp/ssh/channel.go#newcode23\nsrc/pkg/exp/ssh/channel.go:23: Read(data []byte) (int, os.Error)\nI would suggest that Read ignore out-of-band data.  If you had a server goroutine that was handling data, it could queue up OOB data separately.  In this case, you could have something like:\nReadSSH(data []byte) (n int, oob_waiting bool, err os.Error)\n\nwhich would be called by clients who know that they want out-of-band data and can distinguish what it is.  If there was OOB data, you could return 0, true, nil, or you could return data along with it if there is some.\n\nhttp://codereview.appspot.com/4962064/diff/24001/src/pkg/exp/ssh/doc.go\nFile src/pkg/exp/ssh/doc.go (right):\n\nhttp://codereview.appspot.com/4962064/diff/24001/src/pkg/exp/ssh/doc.go#newcode54\nsrc/pkg/exp/ssh/doc.go:54: channels.\nThis seems like odd behavior.  Couldn't the server have a goroutine that's doing this in the background and queueing up data or something?  It seems to me that small bugs could accidentally hang up this accepting goroutine and stall *every* channel.",
			"disapproval": false,
			"date": "2011-09-17 04:23:17.656735",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"bradfitz@golang.org",
				"borman@google.com",
				"dave@cheney.net",
				"gustavo@niemeyer.net",
				"dsymonds@golang.org",
				"r@golang.org",
				"adg@golang.org",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"lvd@google.com",
				"kevlar@google.com",
				"raul.san@sent.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=2c36e4180313 ***\n\nexp/ssh: new package.\n\nThe typical UNIX method for controlling long running process is to\nsend the process signals. Since this doesn't get you very far, various\nad-hoc, remote-control protocols have been used over time by programs\nlike Apache and BIND.\n\nImplementing an SSH server means that Go code will have a standard,\nsecure way to do this in the future.\n\nR=bradfitz, borman, dave, gustavo, dsymonds, r, adg, rsc, rogpeppe, lvd, kevlar, raul.san\nCC=golang-dev\nhttp://codereview.appspot.com/4962064",
			"disapproval": false,
			"date": "2011-09-17 19:57:35.449348",
			"approval": false
		}
	],
	"owner_email": "agl@golang.org",
	"private": false,
	"base_url": "",
	"owner": "agl1",
	"subject": "code review 4962064: net/ssh: new package.",
	"created": "2011-09-08 23:21:18.963607",
	"patchsets": [
		1,
		1001,
		5001,
		8001,
		13001,
		24001,
		32001
	],
	"modified": "2011-09-17 19:57:38.060989",
	"closed": true,
	"issue": 4962064
}