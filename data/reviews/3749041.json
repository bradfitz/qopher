{
	"description": "os/signal: selective signal handling\n\nRestore package os/signal, with new API:\nNotify replaces Incoming, allowing clients\nto ask for certain signals only.  Also, signals\ngo to everyone who asks, not just one client.\n\nThis could plausibly move into package os now\nthat there are no magic side effects as a result\nof the import.\n\nUpdate runtime for new API: move common Unix\nsignal handling code into signal_unix.c.\n(It's so easy to do this now that we don't have\nto edit Makefiles!)\n\nTested on darwin,linux 386,amd64.\n\nFixes issue 1266.",
	"cc": [
		"r@golang.org",
		"dsymonds@golang.org",
		"bradfitz@golang.org",
		"iant@golang.org",
		"borman@google.com",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This touches a lot of files, but almost all trivially.\n\nDon't worry about the large diffs in a few of the z files.\nI will regenerate them on the correct machines.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-08 23:14:41.511594",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"rsc@golang.org",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"iant@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go\nFile src/pkg/os/signal/signal.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go#newcode64\nsrc/pkg/os/signal/signal.go:64: default:\nI almost feel like there should be a bit mask of dropped signals that can be returned. \n\ncase h.c <- sig: dropped &= ^(1<<sig)\ndefault: dropped |= (1<<sig)\n\nand a routine to return them.  I just feel a little uncomfortable with having a solution that can totally miss a signal with no way to know it happened.  Perhaps this is my OS vending background peeking through.\n\nI guess the other argument is if you application is taking that many signals then you really should redesign your application rather than make the infrastructure support it.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/signals_linux.h\nFile src/pkg/runtime/signals_linux.h (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/signals_linux.h#newcode42\nsrc/pkg/runtime/signals_linux.h:42: /* 31 */\tN, \"SIGSYS: bad system call\",\nShouldn't this be N+T?",
			"disapproval": false,
			"date": "2012-02-13 17:24:14.305490",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"iant@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=daf22f371d51 ***\n\nos/signal: selective signal handling\n\nRestore package os/signal, with new API:\nNotify replaces Incoming, allowing clients\nto ask for certain signals only.  Also, signals\ngo to everyone who asks, not just one client.\n\nThis could plausibly move into package os now\nthat there are no magic side effects as a result\nof the import.\n\nUpdate runtime for new API: move common Unix\nsignal handling code into signal_unix.c.\n(It's so easy to do this now that we don't have\nto edit Makefiles!)\n\nTested on darwin,linux 386,amd64.\n\nFixes issue 1266.\n\nR=r, dsymonds, bradfitz, iant, borman\nCC=golang-dev\nhttp://codereview.appspot.com/3749041",
			"disapproval": false,
			"date": "2012-02-13 18:52:44.056039",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2012-02-08 23:13:41.992985",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "doc/go1 updates too please\n\n",
			"disapproval": false,
			"date": "2012-02-09 00:07:16.610284",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"r@google.com",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec.go\nFile src/pkg/os/exec.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec.go#newcode52\nsrc/pkg/os/exec.go:52: type Signal interface {\nOn 2012/02/09 00:11:57, r wrote:\n> this is OK, but i wonder if we want to add a unique method so this is\n> discriminated from other Stringers, for safety\n\nOr just change this from String() to Signal(), like we did for the error interface and Error().\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec.go#newcode59\nsrc/pkg/os/exec.go:59: SIGINT  Signal = syscall.SIGINT\nis this all caps thing just legacy?  These are starting to look odd.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec_unix.go\nFile src/pkg/os/exec_unix.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec_unix.go#newcode60\nsrc/pkg/os/exec_unix.go:60: if e := syscall.Kill(p.Pid, sig.(syscall.Signal)); e != nil {\ncan we comma-ok assert the type and return an error rather than exploding here?",
			"disapproval": false,
			"date": "2012-02-09 00:23:35.842681",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"r@google.com",
				"r@golang.org",
				"dsymonds@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal.go\nFile src/pkg/os/signal/signal.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal.go#newcode17\nsrc/pkg/os/signal/signal.go:17: l []handler\nI assume \"l\" means \"list\", but it's not obvious to me, and the single \"l\" is too close to \"1\" in many fonts. Can you call this \"handlers\" or \"hs\" or something?\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal.go#newcode34\nsrc/pkg/os/signal/signal.go:34: func Notify(c chan<- os.Signal, sig os.Signal) {\nThis could even be variadic, which would avoid the whole \"sig == nil\" vs. \"sig != nil\" business. Plus, if you are selective, it's reasonably common to want more than one on the same channel anyway, so it would be a neat shortcut.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/sig.go\nFile src/pkg/runtime/sig.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/sig.go#newcode7\nsrc/pkg/runtime/sig.go:7: // Sigrecv returns a bitmask of signals that have arrived since the last call to Sigrecv.\nfix doc names too",
			"disapproval": false,
			"date": "2012-02-09 00:12:46.461517",
			"approval": false
		},
		{
			"sender": "iant@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"r@google.com",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec.go\nFile src/pkg/os/exec.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec.go#newcode59\nsrc/pkg/os/exec.go:59: SIGINT  Signal = syscall.SIGINT\nOn 2012/02/09 00:23:35, bradfitz wrote:\n> is this all caps thing just legacy?  These are starting to look odd.\n\nI think if we keep the name SIGINT it should be all-caps.  For this purpose I could imagine os.Interrupt and os.Kill, except that those sound like function names, not constants.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal_unix.go\nFile src/pkg/os/signal/signal_unix.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal_unix.go#newcode22\nsrc/pkg/os/signal/signal_unix.go:22: for sig := uint(0); sig < 32; sig++ {\nThe real time signals have values > 32.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/signal_unix.c\nFile src/pkg/runtime/signal_unix.c (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/signal_unix.c#newcode25\nsrc/pkg/runtime/signal_unix.c:25: runtime\u00b7sigignore(int32, Siginfo*, void*, G*)\nWhat is the advantage of using this function rather than SIG_IGN?\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/signal_unix.c#newcode41\nsrc/pkg/runtime/signal_unix.c:41: restart = (t->flags & SigRestart) != 0;\nWhy handle SigRestart separately?  In the current code, SigRestart and SigQueue always appear together.  In Go I can not imagine a case when we would want SigQueue without SigRestart.  And SigRestart without SigQueue doesn't make much sense either, since it would mean that the signal was dropped.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/signal_unix.c#newcode60\nsrc/pkg/runtime/signal_unix.c:60: t->flags |= SigEnabled;\nCould use a comment here explaining why this data structure is locked.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/sigqueue.goc\nFile src/pkg/runtime/sigqueue.goc (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/sigqueue.goc#newcode88\nsrc/pkg/runtime/sigqueue.goc:88: if(!sig.inuse) {\nHere I think you are assuming that the first call is at initialization time with m == 0.  Worth at least a comment.",
			"disapproval": false,
			"date": "2012-02-09 01:20:58.524301",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Feb 8, 2012 at 20:20,  <iant@golang.org> wrote:\n> runtime\u00b7sigignore(int32, Siginfo*, void*, G*)\n> What is the advantage of using this function rather than SIG_IGN?\n\nSIG_IGN is inherited by child processes, while if I use my own\nignoring handler the child process will get SIG_DFL instead.\nThis is problematic if you, say, ignore SIGPIPE and then run a\nprogram that expects the default SIGPIPE behavior because it\nisn't doing anything special.  The same is true but worse for SIGCHLD.\nIf you use your own ignoring handler, what happens is what you expect:\nyou ignore SIGCHLD signals.  If you set SIGCHLD's handler to SIG_IGN,\nthen wait(2) stops working: all child processes that exit are immediately\nreclaimed instead of turning into zombies that can be waited for.\n\nThat's just a long way of saying that every time I've used SIG_IGN\nit has turned out to hurt, so I instinctively shy away from it now.\nI decided it was probably okay for SIGPROF.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-09 03:08:50.628405",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"r@google.com",
				"r@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "i'm happy with it staying a separate package but could be talked into merging it with os\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec.go\nFile src/pkg/os/exec.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec.go#newcode52\nsrc/pkg/os/exec.go:52: type Signal interface {\nthis is OK, but i wonder if we want to add a unique method so this is discriminated from other Stringers, for safety\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal.go\nFile src/pkg/os/signal/signal.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal.go#newcode8\nsrc/pkg/os/signal/signal.go:8: // BUG(rsc): This package is not implemented on Plan 9 and Windows.\ns/not/not yet/",
			"disapproval": false,
			"date": "2012-02-09 00:11:56.911618",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"r@google.com",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"iant@golang.org",
				"borman@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This solution does not address the issue of the static runtime\u00b7sigtab table and its use.  The application has no way to catch many of the signals, including SIGQUIT.  An application should be able to catch any signal the OS will deliver to the running program.",
			"disapproval": false,
			"date": "2012-02-09 16:43:27.012154",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This brings up an issue with Unix signals.  All signals can be interrupts\n(excepting SIGKILL) while some signals can also be faults.  The potential\nfaults (in the linux table) are:\n\nILL, TRAP, BUS, FPE, SEGV, STKFLT, SYS (sort of)\n\nIt is possible for an application to handle all of these.  Using panic\nmeans you must have the recover in the exact same go routine the fault is\ntriggered.  For an application to try and be robust it can handle all of\nthese.  That handler reverts the signal to default (to prevent recursion)\nand then attempts cleanup.  If what are saying is that if any of these\nfaults happen it is always impossible for the go runtime to continue then\nthere is no reason to provide handlers.\n\nBut as a middle ground, I can accept that these are the only signals\n(+KILL) that are not handleable by the application (FPE is probably the\nmost likely to be handleable, but recover is probably sufficient in that\ncase.)\n\nOn Thu, Feb 9, 2012 at 10:10 AM, Russ Cox <rsc@golang.org> wrote:\n\n> On Thu, Feb 9, 2012 at 11:43,  <borman@google.com> wrote:\n> > This solution does not address the issue of the static runtime\u00b7sigtab\n> > table and its use.  The application has no way to catch many of the\n> > signals, including SIGQUIT.  An application should be able to catch any\n> > signal the OS will deliver to the running program.\n>\n> Thanks for the feedback.\n>\n> If there are specific signals that an application should be able to handle,\n> please point them out and I will adjust the table.  I will fix SIGQUIT.\n> It is, however, not true that an application should be able to catch\n> any signal that could be delivered.  Some signals are a direct result\n> of execution behaviors and cannot be handled asynchronously.\n> These signals are translated into panics in Go when appropriate\n> and can be handled that way.  I am thinking of things like SIGTRAP,\n> SIGFPE, SIGSEGV.\n>\n> Russ\n>\n",
			"disapproval": false,
			"date": "2012-02-09 20:20:02.114248",
			"approval": false
		},
		{
			"sender": "borman@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "In linux you can use the si_code in the siginfo_t structure passed to your\nhandler if you register for SA_SIGINFO.\n\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid h(int s, siginfo_t *info, void *v) {\n        printf(\"h1: %d %d\\n\", s, info->si_code);\n        exit(0);\n}\n\nmain(int ac, char **av) {\n        struct sigaction act;\n\n        memset(&act, 0, sizeof(act));\n        act.sa_sigaction = h;\n        act.sa_flags = SA_SIGINFO;\n        sigaction(SIGSEGV, &act, NULL);\n        if (ac > 1) {\n                kill(0, SIGSEGV);\n        } else {\n                printf(\"%s\\n\", (char *)0);\n        }\n}\n\nsi_code == 0 on a kill and != 0 on a fault.\n\nI tried to test it with FPE but divide by zero doesn't fault.\n max_float*max_float doesn't fault...\n\nOn Thu, Feb 9, 2012 at 12:49 PM, Russ Cox <rsc@golang.org> wrote:\n\n> On Thu, Feb 9, 2012 at 15:20, Paul Borman <borman@google.com> wrote:\n> > This brings up an issue with Unix signals.  All signals can be interrupts\n> > (excepting SIGKILL) while some signals can also be faults.  The potential\n> > faults (in the linux table) are:\n> >\n> > ILL, TRAP, BUS, FPE, SEGV, STKFLT, SYS (sort of)\n> >\n> > It is possible for an application to handle all of these.\n>\n> Not with this API.  We are not going to make signal handlers\n> trigger extra code in whatever goroutine happens to be running.\n> The point of the channel is to turn what amounts to an external\n> attempt at communication into an actual communication.\n> But that means that signals that must be handled synchronously\n> (or else they'll just keep coming in), like ILL or TRAP or BUS\n> or FPE cannot be handled this way.  They must be panics.\n>\n> Do you happen to know how to distinguish\n> signals generated by the kernel due to program execution from\n> signals of the same kind generated by kill(2)?  I don't mind\n> handing the latter off to handlers.\n>\n> Russ\n>\n",
			"disapproval": false,
			"date": "2012-02-09 21:49:13.080108",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"rsc@golang.org",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"iant@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec.go\nFile src/pkg/os/exec.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec.go#newcode52\nsrc/pkg/os/exec.go:52: type Signal interface {\nOn 2012/02/09 00:23:35, bradfitz wrote:\n> On 2012/02/09 00:11:57, r wrote:\n> > this is OK, but i wonder if we want to add a unique method so this is\n> > discriminated from other Stringers, for safety\n> \n> Or just change this from String() to Signal(), like we did for the error\n> interface and Error().\n\nThe difference is that after we did that, we taught fmt about the error interface.\nI don't want to teach fmt about Signal, but I want Signals to be printable.\nI added a dummy Signal() method.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec.go#newcode59\nsrc/pkg/os/exec.go:59: SIGINT  Signal = syscall.SIGINT\nI renamed these to Interrupt and Kill.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec_unix.go\nFile src/pkg/os/exec_unix.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/exec_unix.go#newcode60\nsrc/pkg/os/exec_unix.go:60: if e := syscall.Kill(p.Pid, sig.(syscall.Signal)); e != nil {\nOn 2012/02/09 00:23:35, bradfitz wrote:\n> can we comma-ok assert the type and return an error rather than exploding here?\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal.go\nFile src/pkg/os/signal/signal.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal.go#newcode8\nsrc/pkg/os/signal/signal.go:8: // BUG(rsc): This package is not implemented on Plan 9 and Windows.\nOn 2012/02/09 00:11:57, r wrote:\n> s/not/not yet/\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal.go#newcode17\nsrc/pkg/os/signal/signal.go:17: l []handler\nOn 2012/02/09 00:12:46, dsymonds wrote:\n> I assume \"l\" means \"list\", but it's not obvious to me, and the single \"l\" is too\n> close to \"1\" in many fonts. Can you call this \"handlers\" or \"hs\" or something?\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal.go#newcode34\nsrc/pkg/os/signal/signal.go:34: func Notify(c chan<- os.Signal, sig os.Signal) {\nOn 2012/02/09 00:12:46, dsymonds wrote:\n> This could even be variadic, which would avoid the whole \"sig == nil\" vs. \"sig\n> != nil\" business. Plus, if you are selective, it's reasonably common to want\n> more than one on the same channel anyway, so it would be a neat shortcut.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal_unix.go\nFile src/pkg/os/signal/signal_unix.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/os/signal/signal_unix.go#newcode22\nsrc/pkg/os/signal/signal_unix.go:22: for sig := uint(0); sig < 32; sig++ {\nOn 2012/02/09 01:20:58, iant wrote:\n> The real time signals have values > 32.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/sig.go\nFile src/pkg/runtime/sig.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/sig.go#newcode7\nsrc/pkg/runtime/sig.go:7: // Sigrecv returns a bitmask of signals that have arrived since the last call to Sigrecv.\nOn 2012/02/09 00:12:46, dsymonds wrote:\n> fix doc names too\n\nFile is deleted.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/signal_unix.c\nFile src/pkg/runtime/signal_unix.c (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/signal_unix.c#newcode25\nsrc/pkg/runtime/signal_unix.c:25: runtime\u00b7sigignore(int32, Siginfo*, void*, G*)\nOn 2012/02/09 01:20:58, iant wrote:\n> What is the advantage of using this function rather than SIG_IGN?\n\nGone (in favor of the general handler).\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/signal_unix.c#newcode41\nsrc/pkg/runtime/signal_unix.c:41: restart = (t->flags & SigRestart) != 0;\nOn 2012/02/09 01:20:58, iant wrote:\n> Why handle SigRestart separately?  In the current code, SigRestart and SigQueue\n> always appear together.  In Go I can not imagine a case when we would want\n> SigQueue without SigRestart.  And SigRestart without SigQueue doesn't make much\n> sense either, since it would mean that the signal was dropped.\n\nAgreed.  I made everything restart.  I can't think of any cases where\nwe want to interrupt the system call, actually.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/signal_unix.c#newcode60\nsrc/pkg/runtime/signal_unix.c:60: t->flags |= SigEnabled;\nOn 2012/02/09 01:20:58, iant wrote:\n> Could use a comment here explaining why this data structure is locked.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/sigqueue.goc\nFile src/pkg/runtime/sigqueue.goc (right):\n\nhttp://codereview.appspot.com/3749041/diff/4007/src/pkg/runtime/sigqueue.goc#newcode88\nsrc/pkg/runtime/sigqueue.goc:88: if(!sig.inuse) {\nOn 2012/02/09 01:20:58, iant wrote:\n> Here I think you are assuming that the first call is at initialization time with\n> m == 0.  Worth at least a comment.\n\nDone.",
			"disapproval": false,
			"date": "2012-02-10 23:08:44.106310",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"iant@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go\nFile src/pkg/os/signal/signal.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go#newcode64\nsrc/pkg/os/signal/signal.go:64: default:\nOn 2012/02/13 17:24:14, borman wrote:\n> I almost feel like there should be a bit mask of dropped signals that can be\n> returned. \n> \n> case h.c <- sig: dropped &= ^(1<<sig)\n> default: dropped |= (1<<sig)\n> \n> and a routine to return them.  I just feel a little uncomfortable with having a\n> solution that can totally miss a signal with no way to know it happened. \n> Perhaps this is my OS vending background peeking through.\n\nUse a separate channel for each signal and give it a buffer size >= 1.\nThen you cannot miss any signals, although two SIGHUPs might get\ncoalesced to one.  The comment on Notify points this out.\n\n> I guess the other argument is if you application is taking that many signals\n> then you really should redesign your application rather than make the\n> infrastructure support it.\n\nUse a channel with a big enough buffer size.",
			"disapproval": false,
			"date": "2012-02-13 17:26:56.243151",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Feb 9, 2012 at 11:43,  <borman@google.com> wrote:\n> This solution does not address the issue of the static runtime\u00b7sigtab\n> table and its use. \u00a0The application has no way to catch many of the\n> signals, including SIGQUIT. \u00a0An application should be able to catch any\n> signal the OS will deliver to the running program.\n\nThanks for the feedback.\n\nIf there are specific signals that an application should be able to handle,\nplease point them out and I will adjust the table.  I will fix SIGQUIT.\nIt is, however, not true that an application should be able to catch\nany signal that could be delivered.  Some signals are a direct result\nof execution behaviors and cannot be handled asynchronously.\nThese signals are translated into panics in Go when appropriate\nand can be handled that way.  I am thinking of things like SIGTRAP,\nSIGFPE, SIGSEGV.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-09 18:10:17.610140",
			"approval": false
		},
		{
			"sender": "iant@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Russ Cox <rsc@golang.org> writes:\n\n> Do you happen to know how to distinguish\n> signals generated by the kernel due to program execution from\n> signals of the same kind generated by kill(2)?  I don't mind\n> handing the latter off to handlers.\n\nA signal sent by kill(2) will set the si_code field of the siginfo_t\nstructure to SI_USER.\n\nIan\n",
			"disapproval": false,
			"date": "2012-02-09 21:41:57.017205",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"iant@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello r@golang.org, dsymonds@golang.org, bradfitz@golang.org, iant@golang.org, borman@google.com (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-02-10 23:14:07.342205",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Feb 10, 2012 at 20:47,  <iant@golang.org> wrote:\n> Looks you can get rid of the restart parameter of runtime\u00b7setsig.\n\nThat is probably true, but those are in the OS-specific API,\nand just in case I need to have a non-restarting handler\nat some point, I'd rather leave it in so I don't have to go\nback and edit all those copies again later.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-13 17:09:57.277289",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Feb 9, 2012 at 15:20, Paul Borman <borman@google.com> wrote:\n> This brings up an issue with Unix signals. \u00a0All signals can be interrupts\n> (excepting SIGKILL) while some signals can also be faults. \u00a0The potential\n> faults (in the linux table) are:\n>\n> ILL, TRAP, BUS, FPE, SEGV, STKFLT, SYS (sort of)\n>\n> It is possible for an application to handle all of these.\n\nNot with this API.  We are not going to make signal handlers\ntrigger extra code in whatever goroutine happens to be running.\nThe point of the channel is to turn what amounts to an external\nattempt at communication into an actual communication.\nBut that means that signals that must be handled synchronously\n(or else they'll just keep coming in), like ILL or TRAP or BUS\nor FPE cannot be handled this way.  They must be panics.\n\nDo you happen to know how to distinguish\nsignals generated by the kernel due to program execution from\nsignals of the same kind generated by kill(2)?  I don't mind\nhanding the latter off to handlers.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-09 20:49:53.817975",
			"approval": false
		},
		{
			"sender": "iant@golang.org",
			"recipients": [
				"rsc@golang.org",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"iant@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nLooks you can get rid of the restart parameter of runtime\u00b7setsig.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/exec_posix.go\nFile src/pkg/os/exec_posix.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/exec_posix.go#newcode42\nsrc/pkg/os/exec_posix.go:42: return p.Signal(syscall.SIGKILL)\ns/syscall.SIGKILL/Kill/ ?\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/exec_windows.go\nFile src/pkg/os/exec_windows.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/exec_windows.go#newcode40\nsrc/pkg/os/exec_windows.go:40: if sig == syscall.SIGKILL {\ns/syscall.SIGKILL/Kill/ ?\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go\nFile src/pkg/os/signal/signal.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go#newcode47\nsrc/pkg/os/signal/signal.go:47: if s != nil {\nWhy are you checking for nil here?  Should that be documented?\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_darwin.h\nFile src/pkg/runtime/os_darwin.h (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_darwin.h#newcode26\nsrc/pkg/runtime/os_darwin.h:26: void runtime\u00b7sighandler(int32 sig, Siginfo *info, void *context, G *gp);\nIndentation of function names looks wrong.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_linux.h\nFile src/pkg/runtime/os_linux.h (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_linux.h#newcode15\nsrc/pkg/runtime/os_linux.h:15: void runtime\u00b7sighandler(int32 sig, Siginfo *info, void *context, G *gp);\nIndentation of function name looks wrong.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_netbsd.h\nFile src/pkg/runtime/os_netbsd.h (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_netbsd.h#newcode14\nsrc/pkg/runtime/os_netbsd.h:14: void runtime\u00b7sighandler(int32 sig, Siginfo *info, void *context, G *gp);\nIndentation of function name looks wrong.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_openbsd.h\nFile src/pkg/runtime/os_openbsd.h (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_openbsd.h#newcode14\nsrc/pkg/runtime/os_openbsd.h:14: void runtime\u00b7sighandler(int32 sig, Siginfo *info, void *context, G *gp);\nIndentation of function name looks wrong.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/signal_unix.c\nFile src/pkg/runtime/signal_unix.c (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/signal_unix.c#newcode27\nsrc/pkg/runtime/signal_unix.c:27: if(mask == 0) {\nDo you still need this test?  Do you need the mask parameter at all?\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/signal_unix.c#newcode35\nsrc/pkg/runtime/signal_unix.c:35: return;\nThis return statement is kind of useless.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc\nFile src/pkg/runtime/sigqueue.goc (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode58\nsrc/pkg/runtime/sigqueue.goc:58: if(!sig.inuse || s < 0 || s >= 32*nelem(sig.wanted) || !(sig.wanted[s/32]&(1<<(s&31))))\ns/1<</1U<</\n(signed 1 << 31 is undefined in ISO C if int is 32 bits)\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode60\nsrc/pkg/runtime/sigqueue.goc:60: bit = 1 << (s&31);\ns/1 <</1U <</\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode85\nsrc/pkg/runtime/sigqueue.goc:85: if(recv[i/32]&(1<<(i&31))) {\ns/1<</1U<</\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode86\nsrc/pkg/runtime/sigqueue.goc:86: recv[i/32] ^= 1<<(i&31);\ns/1<</1U<</\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode105\nsrc/pkg/runtime/sigqueue.goc:105: recv[i] = m;\nI think this code would be clearer if you did only a break; if the runtime\u00b7cas returns true.  Then the other lines would move after the for(;;) loop.  That would make it clear that the for(;;) is just a cas loop.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode149\nsrc/pkg/runtime/sigqueue.goc:149: sig.wanted[s/32] |= 1<<(s&31);\ns/1<</1U<</\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/mkerrors.sh\nFile src/pkg/syscall/mkerrors.sh (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/mkerrors.sh#newcode223\nsrc/pkg/syscall/mkerrors.sh:223: egrep -v '(SIGSTKSIZE|SIGRT)' |\nYou don't like SIGSTKSIZE?\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/mkerrors.sh#newcode231\nsrc/pkg/syscall/mkerrors.sh:231: echo '#include <sys/signal.h>' | $GCC -x c - -E -dM $ccflags |\ns|<sys/signal.h>|<signal.h>| ?\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/mkerrors.sh#newcode260\nsrc/pkg/syscall/mkerrors.sh:260: #include <sys/signal.h>\nSeems like should be <signal.h>, not <sys/signal.h>.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_darwin_386.go\nFile src/pkg/syscall/zerrors_darwin_386.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_darwin_386.go#newcode1324\nsrc/pkg/syscall/zerrors_darwin_386.go:1324: 131072: \"unknown signal\",\nHow did this 131072 entry get in there?  We definitely don't want that.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_darwin_amd64.go\nFile src/pkg/syscall/zerrors_darwin_amd64.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_darwin_amd64.go#newcode1324\nsrc/pkg/syscall/zerrors_darwin_amd64.go:1324: 131072: \"unknown signal\",\nAnother 131072.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_linux_386.go\nFile src/pkg/syscall/zerrors_linux_386.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_linux_386.go#newcode1514\nsrc/pkg/syscall/zerrors_linux_386.go:1514: 8192: \"unknown signal 8192\",\nThis one has an 8192.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_linux_amd64.go\nFile src/pkg/syscall/zerrors_linux_amd64.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_linux_amd64.go#newcode1515\nsrc/pkg/syscall/zerrors_linux_amd64.go:1515: 8192: \"unknown signal 8192\",\nAnother undesired 8192.",
			"disapproval": false,
			"date": "2012-02-11 01:47:29.503132",
			"approval": true
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n\nI changed the code to handle an arbitrary number of signals\nand to distinguish signals sent by the kernel from signals\nsent using the kill(2) system call.  The Go runtime only tries\nto handle the signals it cares about when they have been\nsent by the kernel.\n\nRuss\n",
			"disapproval": false,
			"date": "2012-02-10 23:18:03.379943",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"rsc@golang.org",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"iant@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go\nFile src/pkg/os/signal/signal.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go#newcode42\nsrc/pkg/os/signal/signal.go:42: if len(sig) == 0 {\nI was imagining something slightly different: using a nil os.Signal to mean all signals. The code ends up a bit more subtle, but shorter. I'm not fussed either way, but thought I'd sketch out my original idea.\n\nif len(sig) == 0 {\n  sig = []os.Signal{nil}\n}\nfor _, s := range sig {\n  enableSignal(s)\n  handlers.list = append(handlers.list, handler{c: c, sig: s})\n}\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go#newcode60\nsrc/pkg/os/signal/signal.go:60: if h.all || h.sig == sig {\n... and then this is just\n  if h.sig == nil || h.sig == sig {",
			"disapproval": false,
			"date": "2012-02-11 02:10:28.910035",
			"approval": true
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"r@golang.org",
				"dsymonds@golang.org",
				"bradfitz@golang.org",
				"iant@golang.org",
				"borman@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "(Not uploaded yet.)\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/exec_posix.go\nFile src/pkg/os/exec_posix.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/exec_posix.go#newcode42\nsrc/pkg/os/exec_posix.go:42: return p.Signal(syscall.SIGKILL)\nOn 2012/02/11 01:47:29, iant wrote:\n> s/syscall.SIGKILL/Kill/ ?\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/exec_windows.go\nFile src/pkg/os/exec_windows.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/exec_windows.go#newcode40\nsrc/pkg/os/exec_windows.go:40: if sig == syscall.SIGKILL {\nOn 2012/02/11 01:47:29, iant wrote:\n> s/syscall.SIGKILL/Kill/ ?\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go\nFile src/pkg/os/signal/signal.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go#newcode42\nsrc/pkg/os/signal/signal.go:42: if len(sig) == 0 {\nOn 2012/02/11 02:10:29, dsymonds wrote:\n> I was imagining something slightly different: using a nil os.Signal to mean all\n> signals. The code ends up a bit more subtle, but shorter. I'm not fussed either\n> way, but thought I'd sketch out my original idea.\n> \n> if len(sig) == 0 {\n>   sig = []os.Signal{nil}\n> }\n> for _, s := range sig {\n>   enableSignal(s)\n>   handlers.list = append(handlers.list, handler{c: c, sig: s})\n> }\n\nIf you allow the \"Notify(c) means everything\", then\nI don't think you should also make Notify(c, nil) mean\nthe same thing.  There should be only one way to do it.\nThat's why this code is explicitly ignoring the nil\n(you'll never get that signal).\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go#newcode47\nsrc/pkg/os/signal/signal.go:47: if s != nil {\nOn 2012/02/11 01:47:29, iant wrote:\n> Why are you checking for nil here?  Should that be documented?\n\nCommented.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/os/signal/signal.go#newcode60\nsrc/pkg/os/signal/signal.go:60: if h.all || h.sig == sig {\nOn 2012/02/11 02:10:29, dsymonds wrote:\n> ... and then this is just\n>   if h.sig == nil || h.sig == sig {\n\nSee above.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_darwin.h\nFile src/pkg/runtime/os_darwin.h (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_darwin.h#newcode26\nsrc/pkg/runtime/os_darwin.h:26: void runtime\u00b7sighandler(int32 sig, Siginfo *info, void *context, G *gp);\nOn 2012/02/11 01:47:29, iant wrote:\n> Indentation of function names looks wrong.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_linux.h\nFile src/pkg/runtime/os_linux.h (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_linux.h#newcode15\nsrc/pkg/runtime/os_linux.h:15: void runtime\u00b7sighandler(int32 sig, Siginfo *info, void *context, G *gp);\nOn 2012/02/11 01:47:29, iant wrote:\n> Indentation of function name looks wrong.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_openbsd.h\nFile src/pkg/runtime/os_openbsd.h (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/os_openbsd.h#newcode14\nsrc/pkg/runtime/os_openbsd.h:14: void runtime\u00b7sighandler(int32 sig, Siginfo *info, void *context, G *gp);\nOn 2012/02/11 01:47:29, iant wrote:\n> Indentation of function name looks wrong.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/signal_unix.c\nFile src/pkg/runtime/signal_unix.c (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/signal_unix.c#newcode27\nsrc/pkg/runtime/signal_unix.c:27: if(mask == 0) {\nOn 2012/02/11 01:47:29, iant wrote:\n> Do you still need this test?  Do you need the mask parameter at all?\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/signal_unix.c#newcode27\nsrc/pkg/runtime/signal_unix.c:27: if(mask == 0) {\nOn 2012/02/11 01:47:29, iant wrote:\n> Do you still need this test?  Do you need the mask parameter at all?\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/signal_unix.c#newcode35\nsrc/pkg/runtime/signal_unix.c:35: return;\nOn 2012/02/11 01:47:29, iant wrote:\n> This return statement is kind of useless.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc\nFile src/pkg/runtime/sigqueue.goc (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode58\nsrc/pkg/runtime/sigqueue.goc:58: if(!sig.inuse || s < 0 || s >= 32*nelem(sig.wanted) || !(sig.wanted[s/32]&(1<<(s&31))))\nOn 2012/02/11 01:47:29, iant wrote:\n> s/1<</1U<</\n> (signed 1 << 31 is undefined in ISO C if int is 32 bits)\n\n!!!!!!!!!!!!!!!!!!!?! WTF.  Wow.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode60\nsrc/pkg/runtime/sigqueue.goc:60: bit = 1 << (s&31);\nOn 2012/02/11 01:47:29, iant wrote:\n> s/1 <</1U <</\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode85\nsrc/pkg/runtime/sigqueue.goc:85: if(recv[i/32]&(1<<(i&31))) {\nOn 2012/02/11 01:47:29, iant wrote:\n> s/1<</1U<</\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode86\nsrc/pkg/runtime/sigqueue.goc:86: recv[i/32] ^= 1<<(i&31);\nOn 2012/02/11 01:47:29, iant wrote:\n> s/1<</1U<</\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode105\nsrc/pkg/runtime/sigqueue.goc:105: recv[i] = m;\nOn 2012/02/11 01:47:29, iant wrote:\n> I think this code would be clearer if you did only a break; if the runtime\u00b7cas\n> returns true.  Then the other lines would move after the for(;;) loop.  That\n> would make it clear that the for(;;) is just a cas loop.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/runtime/sigqueue.goc#newcode149\nsrc/pkg/runtime/sigqueue.goc:149: sig.wanted[s/32] |= 1<<(s&31);\nOn 2012/02/11 01:47:29, iant wrote:\n> s/1<</1U<</\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/mkerrors.sh\nFile src/pkg/syscall/mkerrors.sh (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/mkerrors.sh#newcode223\nsrc/pkg/syscall/mkerrors.sh:223: egrep -v '(SIGSTKSIZE|SIGRT)' |\nOn 2012/02/11 01:47:29, iant wrote:\n> You don't like SIGSTKSIZE?\n\nIt's kind of big.  :-)\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/mkerrors.sh#newcode231\nsrc/pkg/syscall/mkerrors.sh:231: echo '#include <sys/signal.h>' | $GCC -x c - -E -dM $ccflags |\nOn 2012/02/11 01:47:29, iant wrote:\n> s|<sys/signal.h>|<signal.h>| ?\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/mkerrors.sh#newcode260\nsrc/pkg/syscall/mkerrors.sh:260: #include <sys/signal.h>\nOn 2012/02/11 01:47:29, iant wrote:\n> Seems like should be <signal.h>, not <sys/signal.h>.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_darwin_386.go\nFile src/pkg/syscall/zerrors_darwin_386.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_darwin_386.go#newcode1324\nsrc/pkg/syscall/zerrors_darwin_386.go:1324: 131072: \"unknown signal\",\nOn 2012/02/11 01:47:29, iant wrote:\n> How did this 131072 entry get in there?  We definitely don't want that.\n\nThat's SIGSTKSZ, not to be confused with Linux's SIGSTKSIZE.\nFixed.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_darwin_amd64.go\nFile src/pkg/syscall/zerrors_darwin_amd64.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_darwin_amd64.go#newcode1324\nsrc/pkg/syscall/zerrors_darwin_amd64.go:1324: 131072: \"unknown signal\",\nOn 2012/02/11 01:47:29, iant wrote:\n> Another 131072.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_linux_386.go\nFile src/pkg/syscall/zerrors_linux_386.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_linux_386.go#newcode1514\nsrc/pkg/syscall/zerrors_linux_386.go:1514: 8192: \"unknown signal 8192\",\nOn 2012/02/11 01:47:29, iant wrote:\n> This one has an 8192.\n\nDone.\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_linux_amd64.go\nFile src/pkg/syscall/zerrors_linux_amd64.go (right):\n\nhttp://codereview.appspot.com/3749041/diff/2056/src/pkg/syscall/zerrors_linux_amd64.go#newcode1515\nsrc/pkg/syscall/zerrors_linux_amd64.go:1515: 8192: \"unknown signal 8192\",\nOn 2012/02/11 01:47:29, iant wrote:\n> Another undesired 8192.\n\nDone.",
			"disapproval": false,
			"date": "2012-02-13 17:03:26.996226",
			"approval": false
		}
	],
	"owner_email": "rsc@golang.org",
	"private": false,
	"base_url": "",
	"owner": "rsc",
	"subject": "code review 3749041: os/signal: selective signal handling",
	"created": "2010-12-17 21:17:09.181224",
	"patchsets": [
		1,
		1006,
		4006,
		4007,
		2056,
		12009,
		9071
	],
	"modified": "2012-02-13 18:52:46.479330",
	"closed": true,
	"issue": 3749041
}