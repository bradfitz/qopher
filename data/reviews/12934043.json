{
	"description": "runtime: remove old preemption checks\nruntime.gcwaiting checks are not needed anymore",
	"cc": [
		"golang-dev@googlegroups.com",
		"khr@google.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://dvyukov%40google.com@code.google.com/p/go/",
			"disapproval": false,
			"date": "2013-08-14 16:36:26.338470",
			"approval": false
		},
		{
			"sender": "khr@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM.\r\n\r\n\r\nOn Wed, Aug 14, 2013 at 9:36 AM, <dvyukov@google.com> wrote:\r\n\r\n> Reviewers: golang-dev1,\r\n>\r\n> Message:\r\n> Hello golang-dev@googlegroups.com,\r\n>\r\n> I'd like you to review this change to\r\n> https://dvyukov%40google.com@**code.google.com/p/go/<http://40google.com@code.google.com/p/go/>\r\n>\r\n>\r\n> Description:\r\n> runtime: remove old preemption checks\r\n> runtime.gcwaiting checks are not needed anymore\r\n>\r\n> Please review this at https://codereview.appspot.**com/12934043/<https://codereview.appspot.com/12934043/>\r\n>\r\n> Affected files:\r\n>   M src/pkg/runtime/chan.c\r\n>   M src/pkg/runtime/hashmap.c\r\n>   M src/pkg/runtime/malloc.goc\r\n>   M src/pkg/runtime/proc.c\r\n>   M src/pkg/runtime/runtime.h\r\n>\r\n>\r\n> Index: src/pkg/runtime/chan.c\r\n> ==============================**==============================**=======\r\n> --- a/src/pkg/runtime/chan.c\r\n> +++ b/src/pkg/runtime/chan.c\r\n> @@ -169,9 +169,6 @@\r\n>                 return;  // not reached\r\n>         }\r\n>\r\n> -       if(runtime\u00b7gcwaiting)\r\n> -               runtime\u00b7gosched();\r\n> -\r\n>         if(debug) {\r\n>                 runtime\u00b7printf(\"chansend: chan=%p; elem=\", c);\r\n>                 c->elemalg->print(c->elemsize, ep);\r\n> @@ -295,9 +292,6 @@\r\n>         G *gp;\r\n>         int64 t0;\r\n>\r\n> -       if(runtime\u00b7gcwaiting)\r\n> -               runtime\u00b7gosched();\r\n> -\r\n>         if(debug)\r\n>                 runtime\u00b7printf(\"chanrecv: chan=%p\\n\", c);\r\n>\r\n> @@ -860,8 +854,6 @@\r\n>         void *pc;\r\n>\r\n>         sel = *selp;\r\n> -       if(runtime\u00b7gcwaiting)\r\n> -               runtime\u00b7gosched();\r\n>\r\n>         if(debug)\r\n>                 runtime\u00b7printf(\"select: sel=%p\\n\", sel);\r\n> @@ -1260,9 +1252,6 @@\r\n>         if(c == nil)\r\n>                 runtime\u00b7panicstring(\"close of nil channel\");\r\n>\r\n> -       if(runtime\u00b7gcwaiting)\r\n> -               runtime\u00b7gosched();\r\n> -\r\n>         runtime\u00b7lock(c);\r\n>         if(c->closed) {\r\n>                 runtime\u00b7unlock(c);\r\n> Index: src/pkg/runtime/hashmap.c\r\n> ==============================**==============================**=======\r\n> --- a/src/pkg/runtime/hashmap.c\r\n> +++ b/src/pkg/runtime/hashmap.c\r\n> @@ -1167,9 +1167,6 @@\r\n>                 return;\r\n>         }\r\n>\r\n> -       if(runtime\u00b7gcwaiting)\r\n> -               runtime\u00b7gosched();\r\n> -\r\n>         res = hash_lookup(t, h, &ak);\r\n>\r\n>         if(res != nil) {\r\n> @@ -1277,9 +1274,6 @@\r\n>         if(h == nil)\r\n>                 runtime\u00b7panicstring(\"**assignment to entry in nil map\");\r\n>\r\n> -       if(runtime\u00b7gcwaiting)\r\n> -               runtime\u00b7gosched();\r\n> -\r\n>         if(av == nil) {\r\n>                 hash_remove(t, h, ak);\r\n>         } else {\r\n> @@ -1424,8 +1418,6 @@\r\n>  {\r\n>         if(raceenabled)\r\n>                 runtime\u00b7racereadpc(it->h, runtime\u00b7getcallerpc(&it),\r\n> runtime\u00b7mapiternext);\r\n> -       if(runtime\u00b7gcwaiting)\r\n> -               runtime\u00b7gosched();\r\n>\r\n>         hash_next(it);\r\n>         if(debug) {\r\n> Index: src/pkg/runtime/malloc.goc\r\n> ==============================**==============================**=======\r\n> --- a/src/pkg/runtime/malloc.goc\r\n> +++ b/src/pkg/runtime/malloc.goc\r\n> @@ -41,8 +41,6 @@\r\n>         MSpan *s;\r\n>         MLink *v;\r\n>\r\n> -       if(runtime\u00b7gcwaiting && g != m->g0 && m->locks == 0 && !(flag &\r\n> FlagNoInvokeGC))\r\n> -               runtime\u00b7gosched();\r\n>         if(size == 0) {\r\n>                 // All 0-length allocations use this pointer.\r\n>                 // The language does not require the allocations to\r\n> Index: src/pkg/runtime/proc.c\r\n> ==============================**==============================**=======\r\n> --- a/src/pkg/runtime/proc.c\r\n> +++ b/src/pkg/runtime/proc.c\r\n> @@ -46,6 +46,7 @@\r\n>         Lock    gflock;\r\n>         G*      gfree;\r\n>\r\n> +       uint32  gcwaiting;      // gc is waiting to run\r\n>         int32   stopwait;\r\n>         Note    stopnote;\r\n>         uint32  sysmonwait;\r\n> @@ -63,7 +64,6 @@\r\n>  int32  runtime\u00b7gomaxprocs;\r\n>  uint32 runtime\u00b7needextram;\r\n>  bool   runtime\u00b7iscgo;\r\n> -uint32 runtime\u00b7gcwaiting;\r\n>  M      runtime\u00b7m0;\r\n>  G      runtime\u00b7g0;      // idle goroutine for m0\r\n>  G*     runtime\u00b7allg;\r\n> @@ -391,7 +391,7 @@\r\n>         for(i = 0; i < 5; i++) {\r\n>                 // this should tell the scheduler to not start any new\r\n> goroutines\r\n>                 runtime\u00b7sched.stopwait = 0x7fffffff;\r\n> -               runtime\u00b7atomicstore((uint32*)&**runtime\u00b7gcwaiting, 1);\r\n> +               runtime\u00b7atomicstore((uint32*)&**runtime\u00b7sched.gcwaiting,\r\n> 1);\r\n>                 // this should stop running goroutines\r\n>                 if(!preemptall())\r\n>                         break;  // no running goroutines\r\n> @@ -413,7 +413,7 @@\r\n>\r\n>         runtime\u00b7lock(&runtime\u00b7sched);\r\n>         runtime\u00b7sched.stopwait = runtime\u00b7gomaxprocs;\r\n> -       runtime\u00b7atomicstore((uint32*)&**runtime\u00b7gcwaiting, 1);\r\n> +       runtime\u00b7atomicstore((uint32*)&**runtime\u00b7sched.gcwaiting, 1);\r\n>         preemptall();\r\n>         // stop current P\r\n>         m->p->status = Pgcstop;\r\n> @@ -477,7 +477,7 @@\r\n>                 newprocs = 0;\r\n>         } else\r\n>                 procresize(runtime\u00b7gomaxprocs)**;\r\n> -       runtime\u00b7gcwaiting = 0;\r\n> +       runtime\u00b7sched.gcwaiting = 0;\r\n>\r\n>         p1 = nil;\r\n>         while(p = pidleget()) {\r\n> @@ -971,7 +971,7 @@\r\n>                 return;\r\n>         }\r\n>         runtime\u00b7lock(&runtime\u00b7sched);\r\n> -       if(runtime\u00b7gcwaiting) {\r\n> +       if(runtime\u00b7sched.gcwaiting) {\r\n>                 p->status = Pgcstop;\r\n>                 if(--runtime\u00b7sched.stopwait == 0)\r\n>                         runtime\u00b7notewakeup(&runtime\u00b7**sched.stopnote);\r\n> @@ -1056,7 +1056,7 @@\r\n>  {\r\n>         P *p;\r\n>\r\n> -       if(!runtime\u00b7gcwaiting)\r\n> +       if(!runtime\u00b7sched.gcwaiting)\r\n>                 runtime\u00b7throw(\"gcstopm: not waiting for gc\");\r\n>         if(m->spinning) {\r\n>                 m->spinning = false;\r\n> @@ -1107,7 +1107,7 @@\r\n>         int32 i;\r\n>\r\n>  top:\r\n> -       if(runtime\u00b7gcwaiting) {\r\n> +       if(runtime\u00b7sched.gcwaiting) {\r\n>                 gcstopm();\r\n>                 goto top;\r\n>         }\r\n> @@ -1141,7 +1141,7 @@\r\n>         }\r\n>         // random steal from other P's\r\n>         for(i = 0; i < 2*runtime\u00b7gomaxprocs; i++) {\r\n> -               if(runtime\u00b7gcwaiting)\r\n> +               if(runtime\u00b7sched.gcwaiting)\r\n>                         goto top;\r\n>                 p = runtime\u00b7allp[runtime\u00b7**fastrand1()%runtime\u00b7**\r\n> gomaxprocs];\r\n>                 if(p == m->p)\r\n> @@ -1154,7 +1154,7 @@\r\n>  stop:\r\n>         // return P and block\r\n>         runtime\u00b7lock(&runtime\u00b7sched);\r\n> -       if(runtime\u00b7gcwaiting) {\r\n> +       if(runtime\u00b7sched.gcwaiting) {\r\n>                 runtime\u00b7unlock(&runtime\u00b7sched)**;\r\n>                 goto top;\r\n>         }\r\n> @@ -1263,7 +1263,7 @@\r\n>                 runtime\u00b7throw(\"schedule: holding locks\");\r\n>\r\n>  top:\r\n> -       if(runtime\u00b7gcwaiting) {\r\n> +       if(runtime\u00b7sched.gcwaiting) {\r\n>                 gcstopm();\r\n>                 goto top;\r\n>         }\r\n> @@ -1442,7 +1442,7 @@\r\n>         m->mcache = nil;\r\n>         m->p->m = nil;\r\n>         runtime\u00b7atomicstore(&m->p->**status, Psyscall);\r\n> -       if(runtime\u00b7gcwaiting) {\r\n> +       if(runtime\u00b7sched.gcwaiting) {\r\n>                 runtime\u00b7lock(&runtime\u00b7sched);\r\n>                 if (runtime\u00b7sched.stopwait > 0 &&\r\n> runtime\u00b7cas(&m->p->status, Psyscall, Pgcstop)) {\r\n>                         if(--runtime\u00b7sched.stopwait == 0)\r\n> @@ -2251,9 +2251,9 @@\r\n>                         delay = 10*1000;\r\n>                 runtime\u00b7usleep(delay);\r\n>                 if(runtime\u00b7debug.schedtrace <= 0 &&\r\n> -                       (runtime\u00b7gcwaiting || runtime\u00b7atomicload(&runtime\u00b7\r\n> **sched.npidle) == runtime\u00b7gomaxprocs)) {  // TODO: fast atomic\r\n> +                       (runtime\u00b7sched.gcwaiting ||\r\n> runtime\u00b7atomicload(&runtime\u00b7**sched.npidle) == runtime\u00b7gomaxprocs)) {  //\r\n> TODO: fast atomic\r\n>                         runtime\u00b7lock(&runtime\u00b7sched);\r\n> -                       if(runtime\u00b7atomicload(&**runtime\u00b7gcwaiting) ||\r\n> runtime\u00b7atomicload(&runtime\u00b7**sched.npidle) == runtime\u00b7gomaxprocs) {\r\n> +                       if(runtime\u00b7atomicload(&**runtime\u00b7sched.gcwaiting)\r\n> || runtime\u00b7atomicload(&runtime\u00b7**sched.npidle) == runtime\u00b7gomaxprocs) {\r\n>                                 runtime\u00b7atomicstore(&runtime\u00b7**sched.sysmonwait,\r\n> 1);\r\n>                                 runtime\u00b7unlock(&runtime\u00b7sched)**;\r\n>                                 runtime\u00b7notesleep(&runtime\u00b7**\r\n> sched.sysmonnote);\r\n> @@ -2427,7 +2427,7 @@\r\n>                 runtime\u00b7sched.nmidle, runtime\u00b7sched.runqsize);\r\n>         if(detailed) {\r\n>                 runtime\u00b7printf(\" gcwaiting=%d nmidlelocked=%d\r\n> nmspinning=%d stopwait=%d sysmonwait=%d\\n\",\r\n> -                       runtime\u00b7gcwaiting, runtime\u00b7sched.nmidlelocked,\r\n> runtime\u00b7sched.nmspinning,\r\n> +                       runtime\u00b7sched.gcwaiting,\r\n> runtime\u00b7sched.nmidlelocked, runtime\u00b7sched.nmspinning,\r\n>                         runtime\u00b7sched.stopwait, runtime\u00b7sched.sysmonwait);\r\n>         }\r\n>         // We must be careful while reading data from P's, M's and G's.\r\n> Index: src/pkg/runtime/runtime.h\r\n> ==============================**==============================**=======\r\n> --- a/src/pkg/runtime/runtime.h\r\n> +++ b/src/pkg/runtime/runtime.h\r\n> @@ -704,7 +704,6 @@\r\n>  extern int32   runtime\u00b7gomaxprocs;\r\n>  extern uint32  runtime\u00b7needextram;\r\n>  extern uint32  runtime\u00b7panicking;\r\n> -extern uint32  runtime\u00b7gcwaiting;              // gc is waiting to run\r\n>  extern int8*   runtime\u00b7goos;\r\n>  extern int32   runtime\u00b7ncpu;\r\n>  extern bool    runtime\u00b7iscgo;\r\n>\r\n>\r\n> --\r\n>\r\n> ---You received this message because you are subscribed to the Google\r\n> Groups \"golang-dev\" group.\r\n> To unsubscribe from this group and stop receiving emails from it, send an\r\n> email to golang-dev+unsubscribe@**googlegroups.com<golang-dev%2Bunsubscribe@googlegroups.com>\r\n> .\r\n> For more options, visit https://groups.google.com/**groups/opt_out<https://groups.google.com/groups/opt_out>\r\n> .\r\n>\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-08-15 06:39:36.605140",
			"approval": true
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"khr@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=77efceddaa87 ***\n\nruntime: remove old preemption checks\nruntime.gcwaiting checks are not needed anymore\n\nR=golang-dev, khr\nCC=golang-dev\nhttps://codereview.appspot.com/12934043",
			"disapproval": false,
			"date": "2013-08-15 10:32:24.726080",
			"approval": false
		}
	],
	"owner_email": "dvyukov@google.com",
	"private": false,
	"base_url": "",
	"owner": "dvyukov",
	"subject": "code review 12934043: runtime: remove old preemption checks",
	"created": "2013-08-14 16:24:39.502680",
	"patchsets": [
		1,
		3001,
		6001,
		11001
	],
	"modified": "2013-08-15 10:32:26.843610",
	"closed": true,
	"issue": 12934043
}