{
	"description": "runtime: restrict stack root scan to locals and arguments",
	"cc": [
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"rsc@golang.org",
		"devon.odell@gmail.com",
		"minux.ma@gmail.com"
	],
	"messages": [
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"cshapiro@golang.org",
				"golang-dev@googlegroups.com",
				"cshapiro@google.com",
				"dave@cheney.net",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello,\n\nThank you for this proposal.\n\nHow does this change interact with the ongoing work by atom, and the outstanding change to the arm traceback code by minux https://codereview.appspot.com/7299055/ ?\n\nCheers\n\nDave",
			"disapproval": false,
			"date": "2013-02-07 23:19:25.273310",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "That is excellent news. Welcome Carl!\r\n\r\nOn Fri, Feb 8, 2013 at 10:52 AM, Russ Cox <rsc@golang.org> wrote:\r\n> For the most part this CL's changes to the stack trace code are trying to\r\n> refactor things so that it is a bit easier to use from different contexts.\r\n> Until now we've just kept adding flags for every mode we need. Probably it\r\n> needs to incorporate Minux's last change or two.\r\n>\r\n> Carl has just started working on Go, and for the most part he's been working\r\n> on getting familiar with the code base. The short-term plan is to make stack\r\n> collections precise, so that only live pointer slots are considered. (That\r\n> should obsolete the -Z linker option.) Atom is working on making heap\r\n> collections precise, so that data structures are walked correctly. The two\r\n> efforts should complement each other nicely. Now that he's mostly up to\r\n> speed, Carl's going to circulate a design sketch for his planned work soon.\r\n> (The long-term plan is to make the garbage collector somewhat incremental,\r\n> but that's still a ways off.)\r\n>\r\n> For what it's worth, we also have someone working on getting up to speed on\r\n> scheduling, so that maybe we can eliminate the difference between blocking\r\n> and non-blocking. But there's nothing even approaching a design for that\r\n> yet.\r\n>\r\n> Russ\r\n",
			"disapproval": false,
			"date": "2013-02-07 23:56:46.378420",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://code.google.com/p/go/",
			"disapproval": false,
			"date": "2013-02-07 23:01:42.327640",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@golang.org",
				"golang-dev@googlegroups.com",
				"cshapiro@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This change causes the garbage collector to scan somewhat more of the open frame than is needed.  A forthcoming change will populate the locals information in the Func structure, allowing the scan to be truly limited to the locals area.",
			"disapproval": false,
			"date": "2013-02-07 23:04:07.864620",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "For the most part this CL's changes to the stack trace code are trying to\r\nrefactor things so that it is a bit easier to use from different contexts.\r\nUntil now we've just kept adding flags for every mode we need. Probably it\r\nneeds to incorporate Minux's last change or two.\r\n\r\nCarl has just started working on Go, and for the most part he's been\r\nworking on getting familiar with the code base. The short-term plan is to\r\nmake stack collections precise, so that only live pointer slots are\r\nconsidered. (That should obsolete the -Z linker option.) Atom is working on\r\nmaking heap collections precise, so that data structures are walked\r\ncorrectly. The two efforts should complement each other nicely. Now that\r\nhe's mostly up to speed, Carl's going to circulate a design sketch for his\r\nplanned work soon. (The long-term plan is to make the garbage collector\r\nsomewhat incremental, but that's still a ways off.)\r\n\r\nFor what it's worth, we also have someone working on getting up to speed on\r\nscheduling, so that maybe we can eliminate the difference between blocking\r\nand non-blocking. But there's nothing even approaching a design for that\r\nyet.\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2013-02-07 23:53:00.908980",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/proc.c\nFile src/pkg/runtime/proc.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/proc.c#newcode1006\nsrc/pkg/runtime/proc.c:1006: entersyscall(int32 dummy)\nName this\nvoid\n\u00b7entersyscall(int32 dummy)\n\nThis takes advantage of the fact that a leading \u00b7 is shorthand for \"the current package\". The C compiler doesn't know this, though, so it won't complain about the prototype not matching the function, which is all we care about.\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/proc.c#newcode1062\nsrc/pkg/runtime/proc.c:1062: runtime\u00b7entersyscall()\nand then you can delete this function. Not having the extra call is important: we want to save the information for runtime.entersyscall's caller. The extra frame makes the new code not different from the old code.\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_arm.c\nFile src/pkg/runtime/traceback_arm.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_arm.c#newcode209\nsrc/pkg/runtime/traceback_arm.c:209: runtime\u00b7walkstack(byte *pc0, byte *sp, byte *lr0, G *gp, void (*fn)(Func*, byte*, byte*, void*), void *arg)\nCan you make gentraceback use this? It would be good not to have two copies.\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_arm.c#newcode291\nsrc/pkg/runtime/traceback_arm.c:291: runtime\u00b7printf(\"Unknown PC %p\\n\", pc);\nThis seems to me quite likely to happen, so it should be runtime.throw. \nUsing throw will also take care of putting a good prefix on the message so that it is clear where the error is coming from. Right now, if a program just prints\n\nUnknown PC 0x1234\n\nand then dies with whatever signal a breakpoint generates, it will be very confusing to end users.\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_x86.c\nFile src/pkg/runtime/traceback_x86.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_x86.c#newcode208\nsrc/pkg/runtime/traceback_x86.c:208: runtime\u00b7walkstack(byte *pc0, byte *sp, byte *lr0, G *gp, void (*fn)(Func*, byte*, byte*, void*), void *arg)\nSame comment about making gentraceback use this.\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_x86.c#newcode278\nsrc/pkg/runtime/traceback_x86.c:278: runtime\u00b7printf(\"Unknown PC %p\\n\", pc);\nSame comment.",
			"disapproval": false,
			"date": "2013-02-14 20:59:59.807290",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_arm.c\nFile src/pkg/runtime/traceback_arm.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_arm.c#newcode209\nsrc/pkg/runtime/traceback_arm.c:209: runtime\u00b7walkstack(byte *pc0, byte *sp, byte *lr0, G *gp, void (*fn)(Func*, byte*, byte*, void*), void *arg)\nwalkstack assumes the stack is parse-able.  gentraceback is best effort.  I am concerned that walkstack might not be right for producing stack traces when the stack is corrupt or during the sigprof handler.\n\nIf you think this is okay, I will merge the two functions.  I think we can use \"fn == nil\" as a hint to behave more like genstacktrace.  I am not sure about sigprof (a \"pcbuf != nil\" case).",
			"disapproval": false,
			"date": "2013-02-15 19:35:01.575950",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I agree that walkstack needs to not crash during a crash just because it\r\ncan't understand the stack, but that should be easy to do with a flag.\r\n",
			"disapproval": false,
			"date": "2013-02-15 19:41:54.634460",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Of course.  Is it safe to assume the stack is parse-able during a sigprof handler?",
			"disapproval": false,
			"date": "2013-02-15 19:55:35.103390",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Feb 15, 2013 at 2:55 PM, <cshapiro@golang.org> wrote:\r\n\r\n> Of course.  Is it safe to assume the stack is parse-able during a\r\n> sigprof handler?\r\n>\r\n\r\nI think all the stack traversals should be best effort (not abort, just\r\nstop) unless there is a very good reason they need to complete. Garbage\r\ncollection is a very good reason, but I can't think of any others. Dropping\r\na profiling entry is not a big deal.\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2013-02-15 20:11:53.447080",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/asm_amd64.s\nFile src/pkg/runtime/asm_amd64.s (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/asm_amd64.s#newcode716\nsrc/pkg/runtime/asm_amd64.s:716: TEXT runtime\u00b7abort(SB),7,$0\nOkay.  I think this is generally useful and makes the error handling facilities more symmetric across all of the targets.  \n\nI can provide this feature in a separate change.\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/mgc0.c#newcode1266\nsrc/pkg/runtime/mgc0.c:1266: pc = (byte*)*((uintptr*)sp - 1);\nRight.  Done.\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/runtime.h\nFile src/pkg/runtime/runtime.h (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/runtime.h#newcode708\nsrc/pkg/runtime/runtime.h:708: void\truntime\u00b7abort(void);\nDone.\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/traceback_arm.c\nFile src/pkg/runtime/traceback_arm.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/traceback_arm.c#newcode144\nsrc/pkg/runtime/traceback_arm.c:144: if (fn != nil && pc == (uintptr)runtime\u00b7goexit)\nOkay.",
			"disapproval": false,
			"date": "2013-02-27 21:56:20.571840",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/proc.c\nFile src/pkg/runtime/proc.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/proc.c#newcode1006\nsrc/pkg/runtime/proc.c:1006: entersyscall(int32 dummy)\nOn 2013/02/14 20:59:59, rsc wrote:\n> Name this\n> void\n> \u00b7entersyscall(int32 dummy)\n> \n> This takes advantage of the fact that a leading \u00b7 is shorthand for \"the current\n> package\". The C compiler doesn't know this, though, so it won't complain about\n> the prototype not matching the function, which is all we care about.\n> \n\nDone.\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/proc.c#newcode1062\nsrc/pkg/runtime/proc.c:1062: runtime\u00b7entersyscall()\nOn 2013/02/14 20:59:59, rsc wrote:\n> and then you can delete this function. Not having the extra call is important:\n> we want to save the information for runtime.entersyscall's caller. The extra\n> frame makes the new code not different from the old code.\n> \n\nDone.\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_arm.c\nFile src/pkg/runtime/traceback_arm.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_arm.c#newcode209\nsrc/pkg/runtime/traceback_arm.c:209: runtime\u00b7walkstack(byte *pc0, byte *sp, byte *lr0, G *gp, void (*fn)(Func*, byte*, byte*, void*), void *arg)\nDone.\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_arm.c#newcode291\nsrc/pkg/runtime/traceback_arm.c:291: runtime\u00b7printf(\"Unknown PC %p\\n\", pc);\nI have replaced the abort with a throw.\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_x86.c\nFile src/pkg/runtime/traceback_x86.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_x86.c#newcode208\nsrc/pkg/runtime/traceback_x86.c:208: runtime\u00b7walkstack(byte *pc0, byte *sp, byte *lr0, G *gp, void (*fn)(Func*, byte*, byte*, void*), void *arg)\nDone.\n\nhttps://codereview.appspot.com/7301062/diff/5001/src/pkg/runtime/traceback_x86.c#newcode278\nsrc/pkg/runtime/traceback_x86.c:278: runtime\u00b7printf(\"Unknown PC %p\\n\", pc);\nDone.",
			"disapproval": false,
			"date": "2013-02-27 00:10:20.545660",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM after fixes\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/asm_amd64.s\nFile src/pkg/runtime/asm_amd64.s (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/asm_amd64.s#newcode716\nsrc/pkg/runtime/asm_amd64.s:716: TEXT runtime\u00b7abort(SB),7,$0\nshould be able to revert this file now.\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/mgc0.c#newcode1266\nsrc/pkg/runtime/mgc0.c:1266: pc = (byte*)*((uintptr*)sp - 1);\nI believe this is wrong for ARM (it's one frame off).\nBetter to add a gcpc field to the G and then set it wherever gcsp is set.\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/runtime.h\nFile src/pkg/runtime/runtime.h (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/runtime.h#newcode708\nsrc/pkg/runtime/runtime.h:708: void\truntime\u00b7abort(void);\ndelete\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/softfloat_arm.c\nFile src/pkg/runtime/softfloat_arm.c (left):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/softfloat_arm.c#oldcode17\nsrc/pkg/runtime/softfloat_arm.c:17: void\truntime\u00b7abort(void);\nshould be able to revert this file now.\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/traceback_arm.c\nFile src/pkg/runtime/traceback_arm.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/traceback_arm.c#newcode144\nsrc/pkg/runtime/traceback_arm.c:144: if (fn != nil && pc == (uintptr)runtime\u00b7goexit)\ns/fn != nil && //\n?\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/vlrt_386.c\nFile src/pkg/runtime/vlrt_386.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/vlrt_386.c#newcode33\nsrc/pkg/runtime/vlrt_386.c:33: // declared here to avoid include of runtime.h\ncan revert this file.\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/vlrt_arm.c\nFile src/pkg/runtime/vlrt_arm.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/vlrt_arm.c#newcode27\nsrc/pkg/runtime/vlrt_arm.c:27: void\truntime\u00b7abort(void);\ncan revert this file.",
			"disapproval": false,
			"date": "2013-02-27 16:35:18.223860",
			"approval": true
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/asm_amd64.s\nFile src/pkg/runtime/asm_amd64.s (right):\n\nhttps://codereview.appspot.com/7301062/diff/16001/src/pkg/runtime/asm_amd64.s#newcode716\nsrc/pkg/runtime/asm_amd64.s:716: TEXT runtime\u00b7abort(SB),7,$0\nOn 2013/02/27 21:56:20, cshapiro wrote:\n> Okay.  I think this is generally useful and makes the error handling facilities\n> more symmetric across all of the targets.  \n\nThe use of abort at all is only in leftover C library support code from Plan 9. Go runtime code should not be calling abort, so it should not exist where not needed. In particular, it must not be used for shipped code that users might trip over.\n\nIf you are debugging and want to make the code stop for a breakpoint, you can already call runtime.breakpoint().",
			"disapproval": false,
			"date": "2013-02-28 16:23:48.109740",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Mar 5, 2013 at 3:02 PM, Carl Shapiro <cshapiro@golang.org> wrote:\r\n\r\n> On Tue, Mar 5, 2013 at 2:35 PM, Russ Cox <rsc@golang.org> wrote:\r\n>\r\n>> Another possibility is that this fails because only functions that can\r\n>> split the stack have valid f->args counts.\r\n>> Functions that don't split the stack often have no recorded argument\r\n>> size, because only the stack split\r\n>> code used to care.\r\n>>\r\n>\r\n> This is an interesting observation.\r\n>\r\n> The change I submitted scans (f->frame - sizeof(uintptr)) bytes above the\r\n> SP plus f->args bytes above the return address.  The arguments area is\r\n> effectively scanned twice, once in the callee and again in the caller.  If,\r\n> instead of using f->frame, I use f->locals so the arguments are only\r\n> scanned in the callee I can induce a free-list corruption on 386 and amd64.\r\n>\r\n\r\nI wonder why this still broke on arm, then. There must still be something\r\nwrong even when using f->frame.\r\n\r\nI was unaware of the invalid f->args issue.  I would like to correct that.\r\n>  What needs to be done to emit valid .args information for all functions?\r\n>\r\n\r\nYou can run the go build command with -ldflags to pass flags to the linker.\r\nThe -a flag will make the linker print the full assembly for the binary\r\nbeing put together. If you grep the assembly for TEXT lines with ,7, you\r\nwill find the ones that have been flagged by hand as no stack split. (The\r\nlinker flags some other automatically, but those will say ,2,.) Of those,\r\nyou only care about the ones with no argument information ($0). Some of\r\nthem really have no arguments; others might be lazy or special in some way.\r\nThose are the ones that need to be considered and possibly fixed.\r\n\r\ngo build -ldflags -a cmd/godoc |grep 'TEXT.*,7,\\$0$'\r\n\r\nIf you run that you'll find that one big offender is automatically\r\ngenerated method wrappers. Those should be easy to fix in cmd/gc.\r\n\r\ngo build -ldflags -a cmd/godoc |grep 'TEXT.*,7,\\$0$' |grep -v '\\.(\\*'\r\n\r\nThe remaining ones are mostly things written in assembly, and they could be\r\nfixed by hand. You could probably make the linker reject a function if it\r\nsays the args size is n but refers to m(FP) for m >= n, and you'd find\r\nthese pretty fast.\r\n\r\nThere are always exceptions. The runtime.morestack family of functions\r\nreally has no arguments, but you shouldn't need to consider it in\r\ntracebacks either. runtime.printf has arguments but you don't know how\r\nmany. Polymorphic functions such as runtime.chansend have arguments that\r\nvary in size according to the initial type parameter.\r\n\r\nI suppose all of these need to be addressed in some way before this change\r\nis safe to apply. Apologies for not noticing that earlier in the review.\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2013-03-06 02:53:03.529930",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I found the first problem for this CL with ARM, but that just led to a second problem. Rolling back in CL 7493044 so that we can get back to a working ARM toolchain. Please try to debug on ARM.",
			"disapproval": false,
			"date": "2013-03-05 20:33:48.908120",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=9742f722b558 ***\n\nruntime: restrict stack root scan to locals and arguments\n\nR=rsc\nCC=golang-dev\nhttps://codereview.appspot.com/7301062",
			"disapproval": false,
			"date": "2013-03-05 03:50:59.234610",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Mar 4, 2013 at 7:50 PM, <cshapiro@golang.org> wrote:\r\n\r\n> *** Submitted as\r\n> https://code.google.com/p/go/**source/detail?r=9742f722b558<https://code.google.com/p/go/source/detail?r=9742f722b558>***\r\n>\r\n> runtime: restrict stack root scan to locals and arguments\r\n>\r\n\r\nDid you find the 386 bug you were running into? What did it turn out to be?\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2013-03-05 04:52:16.022440",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Seems to break arm:\r\n\r\nfatal error: unknown pc\r\n\r\ngoroutine 1 [running]:\r\n[fp=0x1045d1f8] runtime.throw(0x2ff8a4)\r\n\t/usr/local/go/src/pkg/runtime/panic.c:465 +0x50\r\n[fp=0x1045d238] runtime.gentraceback(0x6098c, 0x1045d29c, 0x0,\r\n0x1043f090, 0x0, ...)\r\n\t/usr/local/go/src/pkg/runtime/traceback_arm.c:71 +0x16c\r\n[fp=0x1045d270] addstackroots(0x1043f090)\r\n\t/usr/local/go/src/pkg/runtime/mgc0.c:1348 +0x80\r\n[fp=0x1045d298] addroots()\r\n\t/usr/local/go/src/pkg/runtime/mgc0.c:1409 +0x258\r\n[fp=0x1045d3d8] gc(0xb6b50dec)\r\n\t/usr/local/go/src/pkg/runtime/mgc0.c:1851 +0x1e8\r\n----- stack segment boundary -----\r\n[fp=0xb6b50df4] runtime.gc(0x0)\r\n\t/usr/local/go/src/pkg/runtime/mgc0.c:1789 +0xf0\r\n[fp=0xb6b50e24] runtime.mallocgc(0x20, 0x0, 0x1, 0x1)\r\n\t/usr/local/go/src/pkg/runtime/zmalloc_linux_arm.c:101 +0x1c4\r\n[fp=0xb6b50e38] runtime.mal(0x14)\r\n\t/usr/local/go/src/pkg/runtime/zmalloc_linux_arm.c:611 +0x3c\r\n[fp=0xb6b50e6c] runtime.makemap_c(0x18e674, 0x0, 0x0)\r\n\t/usr/local/go/src/pkg/runtime/hashmap.c:826 +0xe8\r\n[fp=0xb6b50e7c] runtime.makemap(0x18e674, 0x0, 0x0, 0xb6fb528c)\r\n\t/usr/local/go/src/pkg/runtime/hashmap.c:873 +0x38\r\n[fp=0xb6b50e94] unicode.init()\r\n\t/usr/local/go/src/pkg/unicode/tables.go:48 +0x88\r\n[fp=0xb6b50ea0] go/parser.init()\r\n\t/usr/local/go/src/pkg/go/parser/parser.go:2410 +0x70\r\n[fp=0xb6b50fb8] main.init()\r\n\t/usr/local/go/src/cmd/go/vet.go:37 +0x78\r\n[fp=0xb6b50fd0] runtime.main()\r\n\t/usr/local/go/src/pkg/runtime/proc.c:179 +0x80\r\n[fp=0xb6b50fd0] runtime.goexit()\r\n\t/usr/local/go/src/pkg/runtime/proc.c:1151\r\n",
			"disapproval": false,
			"date": "2013-03-05 05:10:07.072660",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Mar 5, 2013 at 2:35 PM, Russ Cox <rsc@golang.org> wrote:\r\n\r\n> Another possibility is that this fails because only functions that can\r\n> split the stack have valid f->args counts.\r\n> Functions that don't split the stack often have no recorded argument size,\r\n> because only the stack split\r\n> code used to care.\r\n>\r\n\r\nThis is an interesting observation.\r\n\r\nThe change I submitted scans (f->frame - sizeof(uintptr)) bytes above the\r\nSP plus f->args bytes above the return address.  The arguments area is\r\neffectively scanned twice, once in the callee and again in the caller.  If,\r\ninstead of using f->frame, I use f->locals so the arguments are only\r\nscanned in the callee I can induce a free-list corruption on 386 and amd64.\r\n\r\nI was unaware of the invalid f->args issue.  I would like to correct that.\r\n What needs to be done to emit valid .args information for all functions?\r\n",
			"disapproval": false,
			"date": "2013-03-05 23:02:25.329560",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/7301062/diff/37001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/37001/src/pkg/runtime/mgc0.c#newcode1320\nsrc/pkg/runtime/mgc0.c:1320: sp = (byte*)&gp;\nThis should be sp = runtime.getcallersp(&gp) in order to work on ARM.\n\nHowever, this is not the only thing wrong with this CL on ARM, and I don't know what the other problems are.",
			"disapproval": false,
			"date": "2013-03-05 20:37:40.484700",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Mon, Mar 4, 2013 at 8:52 PM, Russ Cox <rsc@golang.org> wrote:\r\n\r\n> Did you find the 386 bug you were running into? What did it turn out to be?\r\n>\r\n\r\nYes.\r\n\r\nWhen a goroutine has been created but has not been started, gentrackback\r\npretends that gp->fnstart->fn is the PC for the topmost frame and uses the\r\nSP of the fake goexit frame.  This can cause the garbage collector to\r\nover-scan the stack as it assumes the PC corresponds to a function which\r\nhas executed its prologue and adjusted the SP down some number of frame\r\nbytes.\r\n\r\nThe resolution is to not unwind the stack in this case and only scan the\r\nincoming arguments area for the un-started goroutine.  I added a comment\r\nthat describes this condition.\r\n",
			"disapproval": false,
			"date": "2013-03-05 21:38:33.441760",
			"approval": false
		},
		{
			"sender": "devon.odell@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "2013/3/5 Russ Cox <rsc@golang.org>:\r\n> On Tue, Mar 5, 2013 at 3:02 PM, Carl Shapiro <cshapiro@golang.org> wrote:\r\n>>\r\n>> On Tue, Mar 5, 2013 at 2:35 PM, Russ Cox <rsc@golang.org> wrote:\r\n>>>\r\n>>> Another possibility is that this fails because only functions that can\r\n>>> split the stack have valid f->args counts.\r\n>>> Functions that don't split the stack often have no recorded argument\r\n>>> size, because only the stack split\r\n>>> code used to care.\r\n>>\r\n>>\r\n>> This is an interesting observation.\r\n>>\r\n>> The change I submitted scans (f->frame - sizeof(uintptr)) bytes above the\r\n>> SP plus f->args bytes above the return address.  The arguments area is\r\n>> effectively scanned twice, once in the callee and again in the caller.  If,\r\n>> instead of using f->frame, I use f->locals so the arguments are only scanned\r\n>> in the callee I can induce a free-list corruption on 386 and amd64.\r\n>\r\n>\r\n> I wonder why this still broke on arm, then. There must still be something\r\n> wrong even when using f->frame.\r\n\r\nI'm very skeptical of the runtime on ARM. Are there any lock-free\r\ndatastructures in runtime or \"missed\" atomics (i.e. atomics that\r\naren't using atomicload/atomicstore on ARM)? If so, I expect breakage,\r\n5a/5l cannot generate memory fences (and ARM has a relaxed memory\r\nordering, like Alpha). These will be necessary for the scheduler work\r\nI did, but I suspect they may be necessary elsewhere. It would cause\r\ninconsistent, unpredictable breakage.\r\n\r\n(Sorry Russ, I'm terrible at reply-all)\r\n\r\n--dho\r\n",
			"disapproval": false,
			"date": "2013-03-06 02:59:39.948860",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Mar 5, 2013 at 1:38 PM, Carl Shapiro <cshapiro@golang.org> wrote:\r\n\r\n> On Mon, Mar 4, 2013 at 8:52 PM, Russ Cox <rsc@golang.org> wrote:\r\n>\r\n>> Did you find the 386 bug you were running into? What did it turn out to\r\n>> be?\r\n>>\r\n>\r\n> Yes.\r\n>\r\n> When a goroutine has been created but has not been started, gentrackback\r\n> pretends that gp->fnstart->fn is the PC for the topmost frame and uses the\r\n> SP of the fake goexit frame.  This can cause the garbage collector to\r\n> over-scan the stack as it assumes the PC corresponds to a function which\r\n> has executed its prologue and adjusted the SP down some number of frame\r\n> bytes.\r\n>\r\n\r\nGreat. I found the place you handle this in the garbage collector, but I\r\ndon't understand why the traceback routines don't work (and perhaps that's\r\nrelevant to ARM, since writing special case code like this will work on x86\r\nbut be one word off on ARM).\r\n\r\nThe traceback_x86.c code says:\r\n\r\n    79\t\t\t// Found an actual function.    80\t\t\tif(fp == nil) {\r\n81\t\t\t\tfp = sp;    82\t\t\t\tif(pc > f->entry && f->frame >=\r\nsizeof(uintptr))    83\t\t\t\t\tfp += f->frame - sizeof(uintptr);\r\n84\t\t\t\tif(lr == 0)    85\t\t\t\t\tlr = *(uintptr*)fp;    86\t\t\t\tfp +=\r\nsizeof(uintptr);    87\t\t\t} else if(lr == 0)    88\t\t\t\tlr =\r\n*(uintptr*)fp;\r\n\r\nThe pc > f->entry test should handle the case where the function has not\r\nyet started executing. That is, the traceback does not assume that the PC\r\ncorresponds to a function which has executed its prologue and adjusted the\r\nSP down some number of frame bytes.\r\n\r\nIf at all possible I think we should try to eliminate the special case in\r\nthe garbage collector, make sure the traceback routine is correct, and use\r\nit.\r\n\r\nRuss\r\n\r\n>\r\n",
			"disapproval": false,
			"date": "2013-03-05 22:04:57.022200",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"cshapiro@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "After your pointer to the argument calculations, I made the changes below on my ARM machine. I believe they are required for correctness on ARM, but they are not sufficient: I still get the \"invalid freelist\" crash.\n\nhttps://codereview.appspot.com/7301062/diff/37001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/7301062/diff/37001/src/pkg/runtime/mgc0.c#newcode1308\nsrc/pkg/runtime/mgc0.c:1308: addroot((Obj){sp + f->frame, f->args, 0});\nI changed this to sp + 4 + f->frame for ARM.\n\nhttps://codereview.appspot.com/7301062/diff/37001/src/pkg/runtime/mgc0.c#newcode1344\nsrc/pkg/runtime/mgc0.c:1344: addroot((Obj){sp, f->args, 0});\nI changed this to sp+4 for ARM.",
			"disapproval": false,
			"date": "2013-03-05 22:29:11.427010",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Another possibility is that this fails because only functions that can\r\nsplit the stack have valid f->args counts.\r\nFunctions that don't split the stack often have no recorded argument size,\r\nbecause only the stack split\r\ncode used to care.\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2013-03-05 22:35:42.823200",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Mar 5, 2013 at 6:59 PM, Devon H. O'Dell <devon.odell@gmail.com>wrote:\r\n\r\n> > I wonder why this still broke on arm, then. There must still be something\r\n> > wrong even when using f->frame.\r\n>\r\n> I'm very skeptical of the runtime on ARM. Are there any lock-free\r\n> datastructures in runtime or \"missed\" atomics (i.e. atomics that\r\n> aren't using atomicload/atomicstore on ARM)? If so, I expect breakage,\r\n> 5a/5l cannot generate memory fences (and ARM has a relaxed memory\r\n> ordering, like Alpha). These will be necessary for the scheduler work\r\n> I did, but I suspect they may be necessary elsewhere. It would cause\r\n> inconsistent, unpredictable breakage.\r\n>\r\n\r\nThere are certainly no atomics needed in this CL, and ARM seems pretty\r\nstable without this CL.\r\nThat doesn't mean you're wrong, but I feel like we'd have seen other signs.\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2013-03-06 20:13:12.992440",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Mar 6, 2013 at 10:59 AM, Devon H. O'Dell <devon.odell@gmail.com> wrote:\r\n> I'm very skeptical of the runtime on ARM. Are there any lock-free\r\n> datastructures in runtime or \"missed\" atomics (i.e. atomics that\r\n> aren't using atomicload/atomicstore on ARM)? If so, I expect breakage,\r\n> 5a/5l cannot generate memory fences (and ARM has a relaxed memory\r\n> ordering, like Alpha). These will be necessary for the scheduler work\r\n> I did, but I suspect they may be necessary elsewhere. It would cause\r\n> inconsistent, unpredictable breakage.\r\nin theory, we need DMB even after cas, but note that we always call\r\ncas as a function and not as inline code. perhaps this fact makes\r\nthe data race window very small and so we haven't encounter them (yet).\r\n\r\ni just got a somewhat powerful ARM machine with quad Cortex-A9 and\r\n2GiB memory, I can run some extensive multithreaded tests like what\r\nfullung did for amd64 to see if this will cause any real problems.\r\n",
			"disapproval": false,
			"date": "2013-03-06 20:26:23.532860",
			"approval": false
		},
		{
			"sender": "devon.odell@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "2013/3/6 minux <minux.ma@gmail.com>:\r\n> On Wed, Mar 6, 2013 at 10:59 AM, Devon H. O'Dell <devon.odell@gmail.com> wrote:\r\n>> I'm very skeptical of the runtime on ARM. Are there any lock-free\r\n>> datastructures in runtime or \"missed\" atomics (i.e. atomics that\r\n>> aren't using atomicload/atomicstore on ARM)? If so, I expect breakage,\r\n>> 5a/5l cannot generate memory fences (and ARM has a relaxed memory\r\n>> ordering, like Alpha). These will be necessary for the scheduler work\r\n>> I did, but I suspect they may be necessary elsewhere. It would cause\r\n>> inconsistent, unpredictable breakage.\r\n> in theory, we need DMB even after cas, but note that we always call\r\n> cas as a function and not as inline code. perhaps this fact makes\r\n> the data race window very small and so we haven't encounter them (yet).\r\n>\r\n> i just got a somewhat powerful ARM machine with quad Cortex-A9 and\r\n> 2GiB memory, I can run some extensive multithreaded tests like what\r\n> fullung did for amd64 to see if this will cause any real problems.\r\n\r\nWhat machine is this? I have two different dual-core Cortex A9 boards\r\nrunning Android, so I should be able to get some testing going on as\r\nwell. I wouldn't mind adding something more powerful to that mix since\r\nI'm also using them for Concurrency Kit.\r\n\r\nI think we have evidence that it causes problems already. The retry\r\nafter the kernel-supplied CAS in the linux runtime\u00b7cas implementation\r\nI think is a bug that would be explained by this.\r\n\r\n--dho\r\n",
			"disapproval": false,
			"date": "2013-03-06 20:34:12.194200",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Mar 7, 2013 at 4:34 AM, Devon H. O'Dell <devon.odell@gmail.com> wrote:\r\n> 2013/3/6 minux <minux.ma@gmail.com>:\r\n>> i just got a somewhat powerful ARM machine with quad Cortex-A9 and\r\n>> 2GiB memory, I can run some extensive multithreaded tests like what\r\n>> fullung did for amd64 to see if this will cause any real problems.\r\n>\r\n> What machine is this? I have two different dual-core Cortex A9 boards\r\n> running Android, so I should be able to get some testing going on as\r\n> well. I wouldn't mind adding something more powerful to that mix since\r\n> I'm also using them for Concurrency Kit.\r\nodroid-u2 (note the power socket is very unusual, and i took me quite some\r\ntime to find one suitable plug, and in the end i gave up and soldered the cord\r\nto the board directly; if you don't want to take the trouble, buy the official\r\npower adapter).\r\n> I think we have evidence that it causes problems already. The retry\r\n> after the kernel-supplied CAS in the linux runtime\u00b7cas implementation\r\n> I think is a bug that would be explained by this.\r\ni will take a closer look (i thought it's caused by kernel bug).\r\n",
			"disapproval": false,
			"date": "2013-03-06 20:43:30.774570",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Mar 6, 2013 at 3:34 PM, Devon H. O'Dell <devon.odell@gmail.com>wrote:\r\n\r\n> I think we have evidence that it causes problems already. The retry\r\n> after the kernel-supplied CAS in the linux runtime\u00b7cas implementation\r\n> I think is a bug that would be explained by this.\r\n>\r\n\r\nWhat evidence? What is \"it\"?\r\n\r\nThe retry after the kernel-supplied CAS works around a kernel bug that was\r\nfixed in Linux 2.6.24.\r\nSee the comment at the top of $GOROOT/src/pkg/sync/atomic/asm_linux_arm.s.\r\nhttp://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/arch/arm/kernel/entry-armv.S?id=b49c0f24cf6744a3f4fd09289fe7cade349dead5\r\n",
			"disapproval": false,
			"date": "2013-03-06 20:45:46.649400",
			"approval": false
		},
		{
			"sender": "devon.odell@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "2013/3/6 Russ Cox <rsc@golang.org>:\r\n> On Wed, Mar 6, 2013 at 3:34 PM, Devon H. O'Dell <devon.odell@gmail.com>\r\n> wrote:\r\n>>\r\n>> I think we have evidence that it causes problems already. The retry\r\n>> after the kernel-supplied CAS in the linux runtime\u00b7cas implementation\r\n>> I think is a bug that would be explained by this.\r\n>\r\n>\r\n> What evidence? What is \"it\"?\r\n>\r\n> The retry after the kernel-supplied CAS works around a kernel bug that was\r\n> fixed in Linux 2.6.24.\r\n> See the comment at the top of $GOROOT/src/pkg/sync/atomic/asm_linux_arm.s.\r\n> http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/arch/arm/kernel/entry-armv.S?id=b49c0f24cf6744a3f4fd09289fe7cade349dead5\r\n\r\nSorry, my misunderstanding.\r\n\r\n--dho\r\n",
			"disapproval": false,
			"date": "2013-03-06 20:47:26.401630",
			"approval": false
		}
	],
	"owner_email": "cshapiro@golang.org",
	"private": false,
	"base_url": "",
	"owner": "cshapiro",
	"subject": "code review 7301062: runtime: restrict stack root scan to locals and arguments",
	"created": "2013-02-07 22:54:37.809520",
	"patchsets": [
		1,
		2001,
		5001,
		16001,
		24001,
		24002,
		34001,
		37001
	],
	"modified": "2013-03-06 20:26:23.711710",
	"closed": true,
	"issue": 7301062
}