{
	"description": "go/ast, parser: remember short variable decls. w/ correspoding ident objects\n\nThe ast.Object's Decl field pointed back to the corresponding declaration for\nall but short variable declarations. Now remember corresponding assignment\nstatement in the Decl field.\n\nAlso: simplified some code for parsing select statements.",
	"cc": [
		"golang-dev@googlegroups.com",
		"r@golang.org",
		"bradfitz@golang.org"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "gri@golang.org",
			"recipients": [
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2011-12-19 22:02:02.251381",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"r@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM",
			"disapproval": false,
			"date": "2011-12-20 16:40:12.296015",
			"approval": true
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I don't claim to understand this code, but sure looks tricky for no new\ntests.  :-)\n\nOn Mon, Dec 19, 2011 at 2:02 PM, <gri@golang.org> wrote:\n\n> Reviewers: golang-dev_googlegroups.com,\n>\n> Message:\n> Hello golang-dev@googlegroups.com,\n>\n> I'd like you to review this change to\n> https://go.googlecode.com/hg/\n>\n>\n> Description:\n> go/ast, parser: remember short variable decls. w/ correspoding ident\n> objects\n>\n> The ast.Object's Decl field pointed back to the corresponding\n> declaration for\n> all but short variable declarations. Now remember corresponding\n> assignment\n> statement in the Decl field.\n>\n> Also: simplified some code for parsing select statements.\n>\n> Please review this at http://codereview.appspot.com/**5492072/<http://codereview.appspot.com/5492072/>\n>\n> Affected files:\n>  M src/pkg/go/ast/scope.go\n>  M src/pkg/go/parser/parser.go\n>\n>\n> Index: src/pkg/go/ast/scope.go\n> ==============================**==============================**=======\n> --- a/src/pkg/go/ast/scope.go\n> +++ b/src/pkg/go/ast/scope.go\n> @@ -80,7 +80,7 @@\n>  type Object struct {\n>        Kind ObjKind\n>        Name string      // declared name\n> -       Decl interface{} // corresponding Field, XxxSpec, FuncDecl, or\n> LabeledStmt; or nil\n> +       Decl interface{} // corresponding Field, XxxSpec, FuncDecl,\n> LabeledStmt, or AssignStmt; or nil\n>        Data interface{} // object-specific data; or nil\n>        Type interface{} // place holder for type information; may be nil\n>  }\n> @@ -125,6 +125,12 @@\n>                if d.Label.Name == name {\n>                        return d.Label.Pos()\n>                }\n> +       case *AssignStmt:\n> +               for _, x := range d.Lhs {\n> +                       if ident, isIdent := x.(*Ident); isIdent &&\n> ident.Name == name {\n> +                               return ident.Pos()\n> +                       }\n> +               }\n>        }\n>        return token.NoPos\n>  }\n> Index: src/pkg/go/parser/parser.go\n> ==============================**==============================**=======\n> --- a/src/pkg/go/parser/parser.go\n> +++ b/src/pkg/go/parser/parser.go\n> @@ -144,28 +144,31 @@\n>        }\n>  }\n>\n> -func (p *parser) shortVarDecl(idents []*ast.Ident) {\n> +func (p *parser) shortVarDecl(decl interface{}, list []ast.Expr) {\n>        // Go spec: A short variable declaration may redeclare variables\n>        // provided they were originally declared in the same block with\n>        // the same type, and at least one of the non-blank variables is\n> new.\n>        n := 0 // number of new variables\n> -       for _, ident := range idents {\n> -               assert(ident.Obj == nil, \"identifier already declared or\n> resolved\")\n> -               obj := ast.NewObj(ast.Var, ident.Name)\n> -               // short var declarations cannot have redeclaration errors\n> -               // and are not global => no need to remember the respective\n> -               // declaration\n> -               ident.Obj = obj\n> -               if ident.Name != \"_\" {\n> -                       if alt := p.topScope.Insert(obj); alt != nil {\n> -                               ident.Obj = alt // redeclaration\n> -                       } else {\n> -                               n++ // new declaration\n> +       for _, x := range list {\n> +               if ident, isIdent := x.(*ast.Ident); isIdent {\n> +                       assert(ident.Obj == nil, \"identifier already\n> declared or resolved\")\n> +                       obj := ast.NewObj(ast.Var, ident.Name)\n> +                       // remember corresponding assignment for other\n> tools\n> +                       obj.Decl = decl\n> +                       ident.Obj = obj\n> +                       if ident.Name != \"_\" {\n> +                               if alt := p.topScope.Insert(obj); alt !=\n> nil {\n> +                                       ident.Obj = alt // redeclaration\n> +                               } else {\n> +                                       n++ // new declaration\n> +                               }\n>                        }\n> +               } else {\n> +                       p.errorExpected(x.Pos(), \"identifier\")\n>                }\n>        }\n>        if n == 0 && p.mode&DeclarationErrors != 0 {\n> -               p.error(idents[0].Pos(), \"no new variables on left side of\n> :=\")\n> +               p.error(list[0].Pos(), \"no new variables on left side of\n> :=\")\n>        }\n>  }\n>\n> @@ -522,7 +525,7 @@\n>        for i, x := range list {\n>                ident, isIdent := x.(*ast.Ident)\n>                if !isIdent {\n> -                       pos := x.(ast.Expr).Pos()\n> +                       pos := x.Pos()\n>                        p.errorExpected(pos, \"identifier\")\n>                        ident = &ast.Ident{pos, \"_\", nil}\n>                }\n> @@ -1400,10 +1403,11 @@\n>                } else {\n>                        y = p.parseRhsList()\n>                }\n> +               as := &ast.AssignStmt{x, pos, tok, y}\n>                if tok == token.DEFINE {\n> -                       p.shortVarDecl(p.**makeIdentList(x))\n> +                       p.shortVarDecl(as, x)\n>                }\n> -               return &ast.AssignStmt{x, pos, tok, y}, isRange\n> +               return as, isRange\n>        }\n>\n>        if len(x) > 1 {\n> @@ -1715,34 +1719,28 @@\n>                        comm = &ast.SendStmt{lhs[0], arrow, rhs}\n>                } else {\n>                        // RecvStmt\n> -                       pos := p.pos\n> -                       tok := p.tok\n> -                       var rhs ast.Expr\n> -                       if tok == token.ASSIGN || tok == token.DEFINE {\n> +                       if tok := p.tok; tok == token.ASSIGN || tok ==\n> token.DEFINE {\n>                                // RecvStmt with assignment\n>                                if len(lhs) > 2 {\n>                                        p.errorExpected(lhs[0].Pos(), \"1 or\n> 2 expressions\")\n>                                        // continue with first two\n> expressions\n>                                        lhs = lhs[0:2]\n>                                }\n> +                               pos := p.pos\n>                                p.next()\n> -                               rhs = p.parseRhs()\n> -                               if tok == token.DEFINE && lhs != nil {\n> -                                       p.shortVarDecl(p.**\n> makeIdentList(lhs))\n> +                               rhs := p.parseRhs()\n> +                               as := &ast.AssignStmt{lhs, pos, tok,\n> []ast.Expr{rhs}}\n> +                               if tok == token.DEFINE {\n> +                                       p.shortVarDecl(as, lhs)\n>                                }\n> +                               comm = as\n>                        } else {\n> -                               // rhs must be single receive operation\n> +                               // lhs must be single receive operation\n>                                if len(lhs) > 1 {\n>                                        p.errorExpected(lhs[0].Pos(), \"1\n> expression\")\n>                                        // continue with first expression\n>                                }\n> -                               rhs = lhs[0]\n> -                               lhs = nil // there is no lhs\n> -                       }\n> -                       if lhs != nil {\n> -                               comm = &ast.AssignStmt{lhs, pos, tok,\n> []ast.Expr{rhs}}\n> -                       } else {\n> -                               comm = &ast.ExprStmt{rhs}\n> +                               comm = &ast.ExprStmt{lhs[0]}\n>                        }\n>                }\n>        } else {\n>\n>\n>\n",
			"disapproval": false,
			"date": "2011-12-20 16:49:11.623327",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Yes, agreed. The effect of it can be seen when running gotype -ast\n<some program>, and there are some tests in the gotype test suite, but\nthere should be more. On the list.\n- Robert\n\nOn Tue, Dec 20, 2011 at 8:49 AM, Brad Fitzpatrick <bradfitz@golang.org> wrote:\n> I don't claim to understand this code, but sure looks tricky for no new\n> tests. \u00a0:-)\n>\n>\n> On Mon, Dec 19, 2011 at 2:02 PM, <gri@golang.org> wrote:\n>>\n>> Reviewers: golang-dev_googlegroups.com,\n>>\n>> Message:\n>> Hello golang-dev@googlegroups.com,\n>>\n>> I'd like you to review this change to\n>> https://go.googlecode.com/hg/\n>>\n>>\n>> Description:\n>> go/ast, parser: remember short variable decls. w/ correspoding ident\n>> objects\n>>\n>> The ast.Object's Decl field pointed back to the corresponding\n>> declaration for\n>> all but short variable declarations. Now remember corresponding\n>> assignment\n>> statement in the Decl field.\n>>\n>> Also: simplified some code for parsing select statements.\n>>\n>> Please review this at http://codereview.appspot.com/5492072/\n>>\n>> Affected files:\n>> \u00a0M src/pkg/go/ast/scope.go\n>> \u00a0M src/pkg/go/parser/parser.go\n>>\n>>\n>> Index: src/pkg/go/ast/scope.go\n>> ===================================================================\n>> --- a/src/pkg/go/ast/scope.go\n>> +++ b/src/pkg/go/ast/scope.go\n>> @@ -80,7 +80,7 @@\n>> \u00a0type Object struct {\n>> \u00a0 \u00a0 \u00a0 \u00a0Kind ObjKind\n>> \u00a0 \u00a0 \u00a0 \u00a0Name string \u00a0 \u00a0 \u00a0// declared name\n>> - \u00a0 \u00a0 \u00a0 Decl interface{} // corresponding Field, XxxSpec, FuncDecl, or\n>> LabeledStmt; or nil\n>> + \u00a0 \u00a0 \u00a0 Decl interface{} // corresponding Field, XxxSpec, FuncDecl,\n>> LabeledStmt, or AssignStmt; or nil\n>> \u00a0 \u00a0 \u00a0 \u00a0Data interface{} // object-specific data; or nil\n>> \u00a0 \u00a0 \u00a0 \u00a0Type interface{} // place holder for type information; may be nil\n>> \u00a0}\n>> @@ -125,6 +125,12 @@\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if d.Label.Name == name {\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return d.Label.Pos()\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> + \u00a0 \u00a0 \u00a0 case *AssignStmt:\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for _, x := range d.Lhs {\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if ident, isIdent := x.(*Ident); isIdent &&\n>> ident.Name == name {\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return ident.Pos()\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n>> \u00a0 \u00a0 \u00a0 \u00a0}\n>> \u00a0 \u00a0 \u00a0 \u00a0return token.NoPos\n>> \u00a0}\n>> Index: src/pkg/go/parser/parser.go\n>> ===================================================================\n>> --- a/src/pkg/go/parser/parser.go\n>> +++ b/src/pkg/go/parser/parser.go\n>> @@ -144,28 +144,31 @@\n>> \u00a0 \u00a0 \u00a0 \u00a0}\n>> \u00a0}\n>>\n>> -func (p *parser) shortVarDecl(idents []*ast.Ident) {\n>> +func (p *parser) shortVarDecl(decl interface{}, list []ast.Expr) {\n>> \u00a0 \u00a0 \u00a0 \u00a0// Go spec: A short variable declaration may redeclare variables\n>> \u00a0 \u00a0 \u00a0 \u00a0// provided they were originally declared in the same block with\n>> \u00a0 \u00a0 \u00a0 \u00a0// the same type, and at least one of the non-blank variables is\n>> new.\n>> \u00a0 \u00a0 \u00a0 \u00a0n := 0 // number of new variables\n>> - \u00a0 \u00a0 \u00a0 for _, ident := range idents {\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 assert(ident.Obj == nil, \"identifier already declared or\n>> resolved\")\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 obj := ast.NewObj(ast.Var, ident.Name)\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // short var declarations cannot have redeclaration errors\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // and are not global => no need to remember the\n>> respective\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // declaration\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ident.Obj = obj\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if ident.Name != \"_\" {\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if alt := p.topScope.Insert(obj); alt != nil {\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ident.Obj = alt // redeclaration\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } else {\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 n++ // new declaration\n>> + \u00a0 \u00a0 \u00a0 for _, x := range list {\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if ident, isIdent := x.(*ast.Ident); isIdent {\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 assert(ident.Obj == nil, \"identifier already\n>> declared or resolved\")\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 obj := ast.NewObj(ast.Var, ident.Name)\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // remember corresponding assignment for other\n>> tools\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 obj.Decl = decl\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ident.Obj = obj\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if ident.Name != \"_\" {\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if alt := p.topScope.Insert(obj); alt !=\n>> nil {\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ident.Obj = alt // redeclaration\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } else {\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 n++ // new declaration\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } else {\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p.errorExpected(x.Pos(), \"identifier\")\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> \u00a0 \u00a0 \u00a0 \u00a0}\n>> \u00a0 \u00a0 \u00a0 \u00a0if n == 0 && p.mode&DeclarationErrors != 0 {\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p.error(idents[0].Pos(), \"no new variables on left side of\n>> :=\")\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p.error(list[0].Pos(), \"no new variables on left side of\n>> :=\")\n>> \u00a0 \u00a0 \u00a0 \u00a0}\n>> \u00a0}\n>>\n>> @@ -522,7 +525,7 @@\n>> \u00a0 \u00a0 \u00a0 \u00a0for i, x := range list {\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ident, isIdent := x.(*ast.Ident)\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if !isIdent {\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pos := x.(ast.Expr).Pos()\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pos := x.Pos()\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0p.errorExpected(pos, \"identifier\")\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ident = &ast.Ident{pos, \"_\", nil}\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> @@ -1400,10 +1403,11 @@\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0} else {\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0y = p.parseRhsList()\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 as := &ast.AssignStmt{x, pos, tok, y}\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if tok == token.DEFINE {\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p.shortVarDecl(p.makeIdentList(x))\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p.shortVarDecl(as, x)\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return &ast.AssignStmt{x, pos, tok, y}, isRange\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return as, isRange\n>> \u00a0 \u00a0 \u00a0 \u00a0}\n>>\n>> \u00a0 \u00a0 \u00a0 \u00a0if len(x) > 1 {\n>> @@ -1715,34 +1719,28 @@\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0comm = &ast.SendStmt{lhs[0], arrow, rhs}\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0} else {\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// RecvStmt\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pos := p.pos\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 tok := p.tok\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var rhs ast.Expr\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if tok == token.ASSIGN || tok == token.DEFINE {\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if tok := p.tok; tok == token.ASSIGN || tok ==\n>> token.DEFINE {\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// RecvStmt with assignment\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if len(lhs) > 2 {\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0p.errorExpected(lhs[0].Pos(), \"1 or\n>> 2 expressions\")\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// continue with first two\n>> expressions\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0lhs = lhs[0:2]\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pos := p.pos\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0p.next()\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 rhs = p.parseRhs()\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if tok == token.DEFINE && lhs != nil {\n>> -\n>> p.shortVarDecl(p.makeIdentList(lhs))\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 rhs := p.parseRhs()\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 as := &ast.AssignStmt{lhs, pos, tok,\n>> []ast.Expr{rhs}}\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if tok == token.DEFINE {\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p.shortVarDecl(as, lhs)\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 comm = as\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0} else {\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // rhs must be single receive operation\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // lhs must be single receive operation\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if len(lhs) > 1 {\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0p.errorExpected(lhs[0].Pos(), \"1\n>> expression\")\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// continue with first expression\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 rhs = lhs[0]\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 lhs = nil // there is no lhs\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if lhs != nil {\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 comm = &ast.AssignStmt{lhs, pos, tok,\n>> []ast.Expr{rhs}}\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } else {\n>> - \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 comm = &ast.ExprStmt{rhs}\n>> + \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 comm = &ast.ExprStmt{lhs[0]}\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n>> \u00a0 \u00a0 \u00a0 \u00a0} else {\n>>\n>>\n>\n",
			"disapproval": false,
			"date": "2011-12-20 16:54:40.210693",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"r@golang.org",
				"bradfitz@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=94fea4e3fa40 ***\n\ngo/ast, parser: remember short variable decls. w/ correspoding ident objects\n\nThe ast.Object's Decl field pointed back to the corresponding declaration for\nall but short variable declarations. Now remember corresponding assignment\nstatement in the Decl field.\n\nAlso: simplified some code for parsing select statements.\n\nR=golang-dev, r, bradfitz\nCC=golang-dev\nhttp://codereview.appspot.com/5492072",
			"disapproval": false,
			"date": "2011-12-20 17:59:14.313588",
			"approval": false
		}
	],
	"owner_email": "gri@golang.org",
	"private": false,
	"base_url": "",
	"owner": "gri",
	"subject": "code review 5492072: go/ast, parser: remember short variable decls. w/ corre...",
	"created": "2011-12-19 21:58:27.733250",
	"patchsets": [
		1,
		2001,
		4003,
		2002,
		2005,
		5003
	],
	"modified": "2011-12-20 17:59:15.876260",
	"closed": true,
	"issue": 5492072
}