{
	"description": "strings: implement a faster generic Replacer\n\nThis also fixes the semantics of some corner cases with the empty\nmatch. TODOs for genericReplacer in the tests are fixed.\n\nbenchmark                  old ns/op    new ns/op    delta\nBenchmarkGenericNoMatch        71395         3132  -95.61%\nBenchmarkGenericMatch1         75610        20280  -73.18%\nBenchmarkGenericMatch2        837995        86725  -89.65%",
	"cc": [
		"nigeltao@golang.org",
		"rsc@golang.org",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go#newcode143\nsrc/pkg/strings/replace.go:143: if len(key) == 0 {\nif key == \"\" {\nis more idiomatic, and should be just as efficient. Similarly below for len(r.emptyMatch).\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go#newcode144\nsrc/pkg/strings/replace.go:144: r.emptyMatch = val\nA TestReplacer test case with more than one empty old string would be nice: NewReplacer(\"\", \"foo\", \"\", \"bar\").\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go#newcode166\nsrc/pkg/strings/replace.go:166: i += keylen - 1 // looping adds another 1\nThe artificial -1 looks awkward. It might read better as\nfor i := 0; i < len(s); {\n  val, etc\n  if match {\n    etc\n    i += keylen\n    last = i\n    continue\n  }\n  if r.emptyMatch != \"\" {\n    buf = append(buf, s[i])\n  }\n  i++\n}\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go#newcode168\nsrc/pkg/strings/replace.go:168: buf = append(buf, s[i])\nShould the\nbuf = append(buf, r.emptyMatch...)\na few lines above be done here instead? Can you add a TestReplacer test case that is:\n{blankToXReplacer, \"op\", \"XOXpX\"},\nI suspect that you erroneously get \"XOpX\".\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go#newcode183\nsrc/pkg/strings/replace.go:183: // Same logic as Replace, so if you want to avoid potentially a lot of small\nGo doc comments should be complete sentences (i.e. end with a full stop), and start with the name of the thing being declared.\n\nhttp://golang.org/doc/effective_go.html#commentary\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace_test.go\nFile src/pkg/strings/replace_test.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace_test.go#newcode117\nsrc/pkg/strings/replace_test.go:117: var html = Repeat(\"It&apos;s &lt;b&gt;HTML&lt;/b&gt;!\", 10)\nMake this a local variable in BenchmarkGenericMatch, like line 110.",
			"disapproval": false,
			"date": "2012-09-04 04:29:59.425960",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/04 09:29:16, remyoudompheng wrote:\n> Can you compare the allocation pattern before and after? (allocation count +\n> bytes per iteration)\n\nBenchmarkGenericNoMatch:\ninitial call to NewReplacer:\nbefore   4912B   9 allocs\nafter   16224B  11 allocs\nReplace per iteration:\nbefore  3632B  403 allocs\nafter      0B    0 allocs\n\nBenchmarkGenericMatch:\ninitial call to NewReplacer:\nbefore  5152B   8 allocs\nafter  53072B  25 allocs\nReplace per iteration:\nbefore  3088B  343 allcs\nafter    696B    9 allocs",
			"disapproval": false,
			"date": "2012-09-04 16:18:02.177630",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, rogpeppe@gmail.com, remyoudompheng@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-05 17:42:27.057440",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "You can add exported helpers to export_test.go and they will be\r\navailable during testing.\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2012-09-11 20:40:35.606700",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/12 12:23:57, nigeltao wrote:\n> http://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/export_test.go\n> File src/pkg/strings/export_test.go (right):\n> \n> http://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/export_test.go#newcode29\n> src/pkg/strings/export_test.go:29: index := int(m)\n> You don't really need this variable. The next line could be\n> if int(m) != r.tableSize && t.table[m] != nil {\n\nDone.\n> \n> http://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/replace_test.go\n> File src/pkg/strings/replace_test.go (right):\n> \n> http://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/replace_test.go#newcode317\n> src/pkg/strings/replace_test.go:317: .bra-\n> I'm surprised that \"abra\" is broken over two tries. Similarly with \"c/adabra\",\n> \"h/am\" and \"s/ion\". Do you know if the opening \"a\" in \"abra\" is a prefix or a\n> table entry? Either way, it seems sub-optimal.\n\nI added an explicit table marker in PrintTrie to make it more clear where the lookup tables are. Note there is always one node for each line.\n\nFor the a/bra split, there's a line in makeGenericReplacer that says \"Ensure root node uses a lookup table.\" This is purely for performance reasons, and it gives BenchmarkGenericMatch2 a 15% speedup (probably from being able to skip over unmatched regions faster).\n\nFor the h/am and s/ion splits the lookup table after \"abra\" can only cover one byte of the key before pointing to the next node. In this data structure, each node can have multiple children or have multiple byte prefixes, but not both.\n> \n> http://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/replace_test.go#newcode342\n> src/pkg/strings/replace_test.go:342: spaceRemover := NewReplacer(\" \", \"\", \"\\t\",\n> \"\")\n> Are there any spaces? Isn't the leading white space all tabs?\n> \n> Also, it's a little worrying that this test uses a NewReplacer that is a generic\n> replacer that relies on the trie that this test is testing. Instead, I'd write\n> the replacer by hand:\n\nIt was using a byteStringReplacer, but I swapped it out for a call to strings.Replace.\n> \n> stripTabs := func(s string) string {\n>   b := make([]byte, 0, len(s))\n>   for i := 0; i < len(s); i++ {\n>     if s[i] != '\\t' {\n>       b = append(b, s[i])\n>     }\n>   }\n>   return string(b)\n> }\n> \n> http://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/replace_test.go#newcode350\n> src/pkg/strings/replace_test.go:350: gen := NewReplacer(args...)\n> You could roll this into the next line:\n> in := NewReplacer(args...).PrintTrie()\n> \n> More idiomatic would be to rename in and out to got and want:\n> \n> got := NewReplacer(args...).PrintTrie()\n> want := stripTabs(tc.out)\n> if got != want {\n>   etc\n> }\n\nDone.\n> \n> http://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/replace_test.go#newcode356\n> src/pkg/strings/replace_test.go:356: t.Errorf(\"PrintTrie(%q) = %s, want %s\",\n> tc.in, in, out)\n> Given that in and out (or got and want) have new-lines in them, it might be\n> better to format it as\n> \n> t.Errorf(\"input=%q\\ngot  %s\\nwant %s\\n\", tc.in, got, want)\n\nDone.",
			"disapproval": false,
			"date": "2012-09-12 15:33:14.475640",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go#newcode143\nsrc/pkg/strings/replace.go:143: if len(key) == 0 {\nOn 2012/09/04 04:29:59, nigeltao wrote:\n> if key == \"\" {\n> is more idiomatic, and should be just as efficient. Similarly below for\n> len(r.emptyMatch).\n\nDone.\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go#newcode144\nsrc/pkg/strings/replace.go:144: r.emptyMatch = val\nOn 2012/09/04 04:29:59, nigeltao wrote:\n> A TestReplacer test case with more than one empty old string would be nice:\n> NewReplacer(\"\", \"foo\", \"\", \"bar\").\n\nSome of the other implementations currently overwrite initial keys when they encounter duplicates. The doc does say that earlier ones should have precedence though. Fixed here.\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go#newcode166\nsrc/pkg/strings/replace.go:166: i += keylen - 1 // looping adds another 1\nOn 2012/09/04 04:29:59, nigeltao wrote:\n> The artificial -1 looks awkward. It might read better as\n> for i := 0; i < len(s); {\n>   val, etc\n>   if match {\n>     etc\n>     i += keylen\n>     last = i\n>     continue\n>   }\n>   if r.emptyMatch != \"\" {\n>     buf = append(buf, s[i])\n>   }\n>   i++\n> }\n\nDone.\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go#newcode168\nsrc/pkg/strings/replace.go:168: buf = append(buf, s[i])\nOn 2012/09/04 04:29:59, nigeltao wrote:\n> Should the\n> buf = append(buf, r.emptyMatch...)\n> a few lines above be done here instead? Can you add a TestReplacer test case\n> that is:\n> {blankToXReplacer, \"op\", \"XOXpX\"},\n> I suspect that you erroneously get \"XOpX\".\n\nDone.\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace.go#newcode183\nsrc/pkg/strings/replace.go:183: // Same logic as Replace, so if you want to avoid potentially a lot of small\nOn 2012/09/04 04:29:59, nigeltao wrote:\n> Go doc comments should be complete sentences (i.e. end with a full stop), and\n> start with the name of the thing being declared.\n> \n> http://golang.org/doc/effective_go.html#commentary\n\nDone.\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace_test.go\nFile src/pkg/strings/replace_test.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/5001/src/pkg/strings/replace_test.go#newcode117\nsrc/pkg/strings/replace_test.go:117: var html = Repeat(\"It&apos;s &lt;b&gt;HTML&lt;/b&gt;!\", 10)\nOn 2012/09/04 04:29:59, nigeltao wrote:\n> Make this a local variable in BenchmarkGenericMatch, like line 110.\n\nDone.",
			"disapproval": false,
			"date": "2012-09-04 06:27:52.088450",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Sep 6, 2012 at 5:53 PM,  <eric.d.eisner@gmail.com> wrote:\r\n\r\n> Quick question: what tool/option generates these benchmark deltas?\r\n\r\n$GOROOT/misc/benchcmp\r\n",
			"disapproval": false,
			"date": "2012-09-06 08:21:08.516560",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace_test.go\nFile src/pkg/strings/replace_test.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace_test.go#newcode305\nsrc/pkg/strings/replace_test.go:305: testCases := []struct{ in, out string }{\nOn 2012/09/13 08:05:58, nigeltao wrote:\n> It's worth testing \"foo;foo\" and \"foo;foo;foo1\" as inputs. It's probably also\n> worth testing those in TestReplacer.\n\nOh, I'd also like to see a \"foo;;bar\" TestGenericTrieBuilding test. Note the double-semi-colon, meaning an empty key.",
			"disapproval": false,
			"date": "2012-09-13 09:06:42.793640",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/04 20:59:23, rsc wrote:\n> I am concerned about the amount of memory this will consume.\n> [256]*trie is 2 kB per node on a typical 64-bit machine. Is there\n> something more compact we could do, like something based on a simple\n> sorted slice of \"before\" strings?\n> \n> Russ\n\nI agree that the current implementation's use of memory is unnecessarily large. A different strategy to reduce unnecessary memory usage while still keeping the performance benefits of a table would be to compress chains of nodes with one entry into a string. I'll tinker around with this option and see how the memory footprint looks.\n\nA sorted slice of prefixes in the trie would use even less memory, but may be slower when there are a lot of keys to match.",
			"disapproval": false,
			"date": "2012-09-04 21:11:18.698780",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, rogpeppe@gmail.com, remyoudompheng@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-06 00:03:02.635840",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> I think that the data structure is generally OK, but the code could be\n> re-written to be more obviously correct. I'll take a closer look tomorrow.\n\nI assume the code you're referring to is the add method, which I agree is large and complex. I've made it as simple as I can, given that it's mangling and unmangling a somewhat convoluted data structure. I'll gladly accept any ideas to restructure it to make it clearer.\n\n> \n> Also, it might be nice to have some tests that adds things to a trie and then\n> dumps it out as ASCII art. I'm thinking of something like\n> \n> testCases := []struct{ in, out }string{\n>   {\n>     \"abc;abdef;abdefgh;xx;xy;z\", `\n>     -ab\n>     +.c\n>     +.def\n>     +..gh\n>     -x\n>     +.x\n>     +.y\n>     +z`,\n>   },\n>   // etc\n> }\n> \n> The +/- prefix means has/has-not a value.\n\nThe ASCII dumping would need to be shoved into the main strings package (and exported), as the tests are in an external package.\n\n> \n> https://codereview.appspot.com/6492076/diff/4014/src/pkg/strings/replace.go\n> File src/pkg/strings/replace.go (right):\n> \n> https://codereview.appspot.com/6492076/diff/4014/src/pkg/strings/replace.go#newcode217\n> src/pkg/strings/replace.go:217: for i := range r.mapping {\n> for _, x := range mapping {\n>   r.tableSize += int(x)\n> }\n> \n> https://codereview.appspot.com/6492076/diff/4014/src/pkg/strings/replace.go#newcode222\n> src/pkg/strings/replace.go:222: for i := range r.mapping {\n> for i, x := range r.mapping {\n>   if x == 0 {\n>     r.mapping[i] = etc\n>   } else {\n>     // etc\n>   }\n> }",
			"disapproval": false,
			"date": "2012-09-11 20:08:31.339280",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-11 21:57:29.079780",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This is getting pretty close.\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode128\nsrc/pkg/strings/replace.go:128: // 'y', which remap to 0, 1, 2, 3 and 4. All other bytes map to 5, and\nMy fault, but changing the second \"map\" to \"remap\" would be more consistent.\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode156\nsrc/pkg/strings/replace.go:156: // The current prefixed node ends up in prefixnode,\nMaybe\n// Looking up what is currently t.prefix[0] will lead to prefixnode, and\n// looking up key[0] will lead to keynode.\n\nAlso, s/prefixnode/prefixNode/ and s/keynode/keyNode/.\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode190\nsrc/pkg/strings/replace.go:190: next := t.table[m]\nYou could just write\nt.table[m].add(etc)\non the next line.\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode240\nsrc/pkg/strings/replace.go:240: // The size of a trie node's lookup table: the number of unique key bytes.\n// tableSize is the size of a trie node's lookup table. It is the number of\n// unique key bytes.\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode242\nsrc/pkg/strings/replace.go:242: // At the index of each byte found anywhere in any key, this will contain\n// mapping maps from key bytes to a dense index for trieNode.table.\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode249\nsrc/pkg/strings/replace.go:249: t := &r.root\nJust use r.root below:\nr.root.table = make(etc)\nr.root.add(etc)\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode275\nsrc/pkg/strings/replace.go:275: key, val := oldnew[i], oldnew[i+1]\nI'm not sure if the key and val variables add much. I'd make the next line\nr.root.add(oldnew[i], oldnew[i+1], len(oldnew)-i, r)\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode309\nsrc/pkg/strings/replace.go:309: // WriteString writes the replaced version of s to w, using the same logic as\nI'd just use the same comment as the one on Replacer.WriteString\n// WriteString writes s to w with all replacements performed.\nand drop the parts about (1) using the same logic, and (2) avoiding small writes.\n\nOr just drop the doc comment entirely. It's not an exported type, and I don't think it adds much.\n\nSorry for the busywork if I've asked you to add these comments before.\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode343\nsrc/pkg/strings/replace.go:343: wn, err = sw.WriteString(s[last:])\nWrapping this line and the next with a\nif last != len(s)\nmight save a few unnecessary writes.\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode490\nsrc/pkg/strings/replace.go:490: var discard io.Writer = devNull(0)\nDelete discard and devNull (lines 488-496).\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace_test.go\nFile src/pkg/strings/replace_test.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace_test.go#newcode226\nsrc/pkg/strings/replace_test.go:226: blankLowPriority := NewReplacer(\"a\", \"A\", \"\", \"X\")\nRename blankToXOToO as blankHighPriority? Use the same inputs for both: \"oo\", \"ii\", \"iooi\", \"oiio\" and \"\"?\n\nhttps://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace_test.go#newcode363\nsrc/pkg/strings/replace_test.go:363: var wantbuf []byte\nwantbuf := make([]byte, 0, len(tc.out))\nmight save a few re-allocations.",
			"disapproval": false,
			"date": "2012-09-14 04:10:28.879070",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"dsymonds@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6492076/diff/13004/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/13004/src/pkg/strings/replace.go#newcode244\nsrc/pkg/strings/replace.go:244: // Write wrights to the buffer to satisfy io.Writer.\ns/wrights/writes/",
			"disapproval": false,
			"date": "2012-09-07 00:05:08.151150",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg",
			"disapproval": false,
			"date": "2012-09-03 23:15:49.195830",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I am concerned about the amount of memory this will consume.\r\n[256]*trie is 2 kB per node on a typical 64-bit machine. Is there\r\nsomething more compact we could do, like something based on a simple\r\nsorted slice of \"before\" strings?\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2012-09-04 20:59:23.577790",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"dsymonds@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, rogpeppe@gmail.com, remyoudompheng@gmail.com, rsc@golang.org, dsymonds@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-07 18:03:48.500430",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-12 01:11:41.487030",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode83\nsrc/pkg/strings/replace.go:83: type trie struct {\ns/trie/trieNode/ might be a better name.\n\nAlso, I think that future maintainers (including you or me six months from now) will be helped by a worked example. It took me a while to figure out how it all works. In my example below, it wasn't obvious to me that the \"cbc\" prefix was part of node n4, not n5.\n\nI've pasted a proposal below. WDYT?\n\n\n// trieNode is a node in a lookup trie for prioritized key/value pairs. Keys\n// and values may be empty. For example, the trie containing keys \"ax\", \"ay\",\n// \"bcbc\", \"x\" and \"xy\" could have eight nodes:\n//\n//  n0  -\n//  n1  a-\n//  n2  .x+\n//  n3  .y+\n//  n4  b-\n//  n5  .cbc+\n//  n6  x+\n//  n7  .y+\n//\n// n0 is the root node, and its children are n1, n4 and n6; n1's children are\n// n2 and n3; n4's child is n5; n6's child is n7. Nodes n0, n1 and n4 (marked\n// with a trailing \"-\") are partial keys, and nodes n2, n3, n5, n6 and n7\n// (marked with a trailing \"+\") are complete keys.\ntype trieNode struct {\n    // value is the value of the trie node's key/value pair. It is empty if\n    // this node is not a complete key.\n    value string\n    // priority is the priority (higher is more important) of the trie node's\n    // key/value pair; keys are not necessarily matched shortest- or longest-\n    // first. Priority is positive if this node is a complete key, and zero\n    // otherwise. In the example above, positive/zero priorities are marked\n    // with a trailing \"+\" or \"-\".\n    priority int\n\n    // A trie node may have zero, one or more child nodes:\n    //  * if zero, the remaining fields are zero.\n    //  * if one, prefix and next are non-zero.\n    //  * if more, table is non-zero.\n    //\n    // For lookup efficiency, the root node is an exception, and will never\n    // use its prefix or next fields. It will always use the table field,\n    // unless the only key is empty.\n\n    // prefix is the difference in keys between this trie node and the next.\n    // In the example above, node n4 has prefix \"cbc\" and n4's next node is n5.\n    // Node n5 has no children and so has zero prefix, next and table fields.\n    prefix string\n    next   *trieNode\n\n    // table is a lookup table indexed by the next byte in the key, after\n    // remapping that byte through genericReplacer.mapping to create a dense\n    // index. In the example above, the keys only use 'a', 'b', 'c', 'x' and\n    // 'y', which remap to 0, 1, 2, 3 and 4. All other bytes map to 5, so that\n    // genericReplacer.tableSize will be 6. Node n0's table will be\n    // []*trieNode{ 0:n1, 1:n4, 3:n6 }, where the 0, 1 and 3 are the remapped\n    // 'a', 'b' and 'x'.\n    table []*trieNode\n}\n\nhttps://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode86\nsrc/pkg/strings/replace.go:86: // Priority of this match vs superstrings. Higher is better, and 0 means\nWhat is a superstring?\n\nhttps://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode89\nsrc/pkg/strings/replace.go:89: // If this node has multiple children (and thus with multiple different\nhttp://golang.org/doc/effective_go.html#commentary says that \"The first sentence [of a documentation comment] should be a one-sentence summary that starts with the name being declared.\" Thus, we usually say something like \"table is ...\" instead of \"If this node ...\".\n\nhttps://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode93\nsrc/pkg/strings/replace.go:93: // If this node has exactly one child, this will be nonempty.\nAh, \"a/bra\" means that this comment isn't true for the root node, right?\n\nhttps://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode151\nsrc/pkg/strings/replace.go:151: b := key[0]\nThe next few lines simplify if this is\nm := r.mapping[key[0]]\n\nhttps://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace_test.go\nFile src/pkg/strings/replace_test.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace_test.go#newcode305\nsrc/pkg/strings/replace_test.go:305: testCases := []struct{ in, out string }{\nIt's worth testing \"foo;foo\" and \"foo;foo;foo1\" as inputs. It's probably also worth testing those in TestReplacer.\n\nhttps://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace_test.go#newcode306\nsrc/pkg/strings/replace_test.go:306: {\"abc;abdef;abdefgh;xx;xy;z\", `- table:\nNow that I understand how it works, the \"table:\" strings are kind of ugly, and I'd rather leave them out.\n\nhttps://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace_test.go#newcode353\nsrc/pkg/strings/replace_test.go:353: want := Replace(tc.out, \"\\t\", \"\", -1)\nI would still do this by hand. A future refactoring could implement strings.Replace using strings.NewReplacer, and then this test might give false positives.",
			"disapproval": false,
			"date": "2012-09-13 08:05:58.281130",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "The original post says\n\n> BenchmarkGenericNoMatch  2482 ns/op  -96.36%\n> BenchmarkGenericMatch    6995 ns/op  -90.42%\n\nbut that is against a baseline that is a poor implementation of a simple algorithm.\n\nFor comparison, https://codereview.appspot.com/6495094 is a better implementation of that same algorithm, unlike this CL which uses a different algorithm, with different memory requirements. Compared to tip, that CL gets:\n\nbenchmark                  old ns/op    new ns/op    delta\nBenchmarkGenericNoMatch        76550        18709  -75.56%\nBenchmarkGenericMatch          88093        29899  -66.06%\n\nand the number of mallocs per iteration drop from 403 and 343 before to 3 and 3 after.\n\nI'm not saying that this CL should be abandoned. I'm just providing another reference point on how much this CL improves performance.\n\nEric, is it possible to get a fresh set of numbers for this CL?\n\nhttps://codereview.appspot.com/6492076/diff/6/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/6/src/pkg/strings/replace.go#newcode232\nsrc/pkg/strings/replace.go:232: if r.emptyMatch == \"\" {\nDoes this work if I say NewReplacer(\"\", \"\", \"\", \"foo\")?\n\nhttps://codereview.appspot.com/6492076/diff/6/src/pkg/strings/replace.go#newcode283\nsrc/pkg/strings/replace.go:283: var last, wn int\nThis function body is a copy/paste of genericReplacer.Replace. Is it possible to look for a WriteString method, a la https://codereview.appspot.com/6495094, and avoid the duplicated code?",
			"disapproval": false,
			"date": "2012-09-06 03:23:58.333580",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"dsymonds@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/07 08:17:35, nigeltao wrote:\n> https://codereview.appspot.com/6492076/diff/8005/src/pkg/strings/replace.go\n> File src/pkg/strings/replace.go (right):\n> \n> https://codereview.appspot.com/6492076/diff/8005/src/pkg/strings/replace.go#newcode93\n> src/pkg/strings/replace.go:93: // If this node has no children, the previous 3\n> fields will be nil.\n> s/nil/zero/\n\nDone.\n> \n> https://codereview.appspot.com/6492076/diff/8005/src/pkg/strings/replace.go#newcode106\n> src/pkg/strings/replace.go:106: for n = 0; n < len(t.prefix) && n < len(key);\n> n++ {\n> You can drop the \"n=0\".\n\nDone.\n> \n> https://codereview.appspot.com/6492076/diff/8005/src/pkg/strings/replace.go#newcode177\n> src/pkg/strings/replace.go:177: break\n> Is this correct if every byte in the range [0, 255] is actually part of some old\n> string?\n\nI cleaned up this logic, so it should be more clear. I also added a test that hits this case.\n> \n> Again, I would like to see many more tests before I'm confident that this is all\n> correct.\n\nI added a few more tests, and changed the handling of the empty match (which magically removed a lot of code). The last test in that suite {NewReplacer(\"a\", \"A\", \"\", \"X\"), \"abba\", \"AXbXbAX\"}, follows the spec to my understanding, but it is a different behavior than the original implementation.\n> \n> https://codereview.appspot.com/6492076/diff/8005/src/pkg/strings/replace.go#newcode278\n> src/pkg/strings/replace.go:278: var buf []byte\n> Even if it's slightly slower, I would still prefer Replace to just call\n> WriteString, for now. If it really matters, we can copy/paste the code later,\n> but for now I would prefer to avoid the duplication.\n\nSounds good.",
			"disapproval": false,
			"date": "2012-09-07 18:03:20.871760",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=23b89fb47d66 ***\n\nstrings: implement a faster generic Replacer\n\nThis also fixes the semantics of some corner cases with the empty\nmatch. TODOs for genericReplacer in the tests are fixed.\n\nbenchmark                  old ns/op    new ns/op    delta\nBenchmarkGenericNoMatch        71395         3132  -95.61%\nBenchmarkGenericMatch1         75610        20280  -73.18%\nBenchmarkGenericMatch2        837995        86725  -89.65%\n\nR=nigeltao, rsc\nCC=golang-dev\nhttp://codereview.appspot.com/6492076\n\nCommitter: Nigel Tao <nigeltao@golang.org>",
			"disapproval": false,
			"date": "2012-09-17 01:50:55.198660",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-04 06:27:36.276050",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/05 07:27:14, nigeltao wrote:\n> https://codereview.appspot.com/6492076/diff/11001/src/pkg/strings/replace.go\n> File src/pkg/strings/replace.go (right):\n> \n> https://codereview.appspot.com/6492076/diff/11001/src/pkg/strings/replace.go#newcode178\n> src/pkg/strings/replace.go:178: } else if node.prefix != \"\" && node.prefix ==\n> s[:len(node.prefix)] {\n> Won't this panic if node.prefix is longer than s?\n> \n> A larger point is that I'd want a lot more test cases to cover all the different\n> paths in this new code.\n\nI added another test replacer that covers all of the cases in the new builder. Fixed the panic.",
			"disapproval": false,
			"date": "2012-09-05 15:40:53.508520",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I'm sorry, but while I am still worried about the memory usage,\r\n\r\nTo get the memory usage down, one trick that has worked well for me in\r\nthe past is to group the input bytes into equivalence classes. Here it\r\nis probably enough to keep a list of all the bytes that occur in the\r\nmatch strings. You can use that list to map input bytes into a dense\r\nencoding. The n bytes that do occur map to a dense encoding 0 .. n-1\r\nand all the other bytes, if there are any, map to n. You can keep the\r\nmapping in a [256]byte stored once in the replacer, not per trie node,\r\nand then each node has a []*trie instead of a [256]*trie. The line\r\nnode = node.table[s[0]] becomes node = node.table[mapping[s[0]]]. This\r\nis in some sense a generalization of your most recent change.\r\n\r\nI suspect that you'll find it reduces the memory usage considerably.\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2012-09-05 22:11:43.344700",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"dsymonds@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6492076/diff/8005/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/8005/src/pkg/strings/replace.go#newcode93\nsrc/pkg/strings/replace.go:93: // If this node has no children, the previous 3 fields will be nil.\ns/nil/zero/\n\nhttps://codereview.appspot.com/6492076/diff/8005/src/pkg/strings/replace.go#newcode106\nsrc/pkg/strings/replace.go:106: for n = 0; n < len(t.prefix) && n < len(key); n++ {\nYou can drop the \"n=0\".\n\nhttps://codereview.appspot.com/6492076/diff/8005/src/pkg/strings/replace.go#newcode177\nsrc/pkg/strings/replace.go:177: break\nIs this correct if every byte in the range [0, 255] is actually part of some old string?\n\nAgain, I would like to see many more tests before I'm confident that this is all correct.\n\nhttps://codereview.appspot.com/6492076/diff/8005/src/pkg/strings/replace.go#newcode278\nsrc/pkg/strings/replace.go:278: var buf []byte\nEven if it's slightly slower, I would still prefer Replace to just call WriteString, for now. If it really matters, we can copy/paste the code later, but for now I would prefer to avoid the duplication.",
			"disapproval": false,
			"date": "2012-09-07 08:17:35.918010",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\nA couple of trivial comments below.\n\nhttp://codereview.appspot.com/6492076/diff/8001/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttp://codereview.appspot.com/6492076/diff/8001/src/pkg/strings/replace.go#newcode172\nsrc/pkg/strings/replace.go:172: } else if r.emptyMatch != \"\" {\nthis else is unnecessary. it's nice to make the sequential logic obvious, i think.\n\nhttp://codereview.appspot.com/6492076/diff/8001/src/pkg/strings/replace.go#newcode221\nsrc/pkg/strings/replace.go:221: } else if r.emptyMatch != \"\" {\nthis else is unnecessary.",
			"disapproval": false,
			"date": "2012-09-04 09:14:06.073550",
			"approval": true
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/06 03:23:58, nigeltao wrote:\n> The original post says\n> \n> > BenchmarkGenericNoMatch  2482 ns/op  -96.36%\n> > BenchmarkGenericMatch    6995 ns/op  -90.42%\n> \n> but that is against a baseline that is a poor implementation of a simple\n> algorithm.\n> \n> For comparison, https://codereview.appspot.com/6495094 is a better\n> implementation of that same algorithm, unlike this CL which uses a different\n> algorithm, with different memory requirements. Compared to tip, that CL gets:\n> \n> benchmark                  old ns/op    new ns/op    delta\n> BenchmarkGenericNoMatch        76550        18709  -75.56%\n> BenchmarkGenericMatch          88093        29899  -66.06%\n\nQuick question: what tool/option generates these benchmark deltas?\n\n> \n> and the number of mallocs per iteration drop from 403 and 343 before to 3 and 3\n> after.\n> \n> I'm not saying that this CL should be abandoned. I'm just providing another\n> reference point on how much this CL improves performance.\n> \n> Eric, is it possible to get a fresh set of numbers for this CL?\n\nI had updated the numbers in the description (and dropped the part that said it was memory inefficient) in the last update or so. They are still multiple times faster than your improved simple implementation (but now more complex with a few memory workarounds).\n\n> \n> https://codereview.appspot.com/6492076/diff/6/src/pkg/strings/replace.go\n> File src/pkg/strings/replace.go (right):\n> \n> https://codereview.appspot.com/6492076/diff/6/src/pkg/strings/replace.go#newcode232\n> src/pkg/strings/replace.go:232: if r.emptyMatch == \"\" {\n> Does this work if I say NewReplacer(\"\", \"\", \"\", \"foo\")?\n> \n\nIt doesn't, but I am a bit confused as to the semantics of the empty match. After thinking more about precedence, I think the following should yeild \"AXbXbAX\" (maybe without the trailing \"X\")\n\nNewReplacer(\"a\", \"A\", \"\", \"X\").Replace(\"abba\")\n\nThe original implementation returns \"AXbbAX\", mine is very confused and returns \"XAXbXbXAX\"\n> https://codereview.appspot.com/6492076/diff/6/src/pkg/strings/replace.go#newcode283\n> src/pkg/strings/replace.go:283: var last, wn int\n> This function body is a copy/paste of genericReplacer.Replace. Is it possible to\n> look for a WriteString method, a la https://codereview.appspot.com/6495094, and\n> avoid the duplicated code?\n\nI tried swapping out the copy-pasted Replace code with a call to WriteString on a simple buffer, and it added a 35% runtime overhead to the two benchmarks. The NoMatch case also now allocates buffer memory where it didn't used to allocate any. I included this version for reference as *genericReplacer.BufferedReplace",
			"disapproval": false,
			"date": "2012-09-06 07:53:54.911680",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I think that the data structure is generally OK, but the code could be re-written to be more obviously correct. I'll take a closer look tomorrow.\n\nAlso, it might be nice to have some tests that adds things to a trie and then dumps it out as ASCII art. I'm thinking of something like\n\ntestCases := []struct{ in, out }string{\n  {\n    \"abc;abdef;abdefgh;xx;xy;z\", `\n    -ab\n    +.c\n    +.def\n    +..gh\n    -x\n    +.x\n    +.y\n    +z`,\n  },\n  // etc\n}\n\nThe +/- prefix means has/has-not a value.\n\nhttps://codereview.appspot.com/6492076/diff/4014/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/4014/src/pkg/strings/replace.go#newcode217\nsrc/pkg/strings/replace.go:217: for i := range r.mapping {\nfor _, x := range mapping {\n  r.tableSize += int(x)\n}\n\nhttps://codereview.appspot.com/6492076/diff/4014/src/pkg/strings/replace.go#newcode222\nsrc/pkg/strings/replace.go:222: for i := range r.mapping {\nfor i, x := range r.mapping {\n  if x == 0 {\n    r.mapping[i] = etc\n  } else {\n    // etc\n  }\n}",
			"disapproval": false,
			"date": "2012-09-11 08:56:32.008860",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/05 22:11:43, rsc wrote:\n> I'm sorry, but while I am still worried about the memory usage,\n> \n> To get the memory usage down, one trick that has worked well for me in\n> the past is to group the input bytes into equivalence classes. Here it\n> is probably enough to keep a list of all the bytes that occur in the\n> match strings. You can use that list to map input bytes into a dense\n> encoding. The n bytes that do occur map to a dense encoding 0 .. n-1\n> and all the other bytes, if there are any, map to n. You can keep the\n> mapping in a [256]byte stored once in the replacer, not per trie node,\n> and then each node has a []*trie instead of a [256]*trie. The line\n> node = node.table[s[0]] becomes node = node.table[mapping[s[0]]]. This\n> is in some sense a generalization of your most recent change.\n> \n> I suspect that you'll find it reduces the memory usage considerably.\n> \n> Russ\n\nThis is a clever trick. I added this mapping using a [256]int (otherwise a malicious set of keys that uses every byte would fail), and it only slightly decreased runtime performance, but dropped the memory by another factor of 2-3.",
			"disapproval": false,
			"date": "2012-09-06 00:05:56.005500",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"dsymonds@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, rogpeppe@gmail.com, remyoudompheng@gmail.com, rsc@golang.org, dsymonds@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-11 05:08:55.926520",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/export_test.go\nFile src/pkg/strings/export_test.go (right):\n\nhttp://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/export_test.go#newcode29\nsrc/pkg/strings/export_test.go:29: index := int(m)\nYou don't really need this variable. The next line could be\nif int(m) != r.tableSize && t.table[m] != nil {\n\nhttp://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/replace_test.go\nFile src/pkg/strings/replace_test.go (right):\n\nhttp://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/replace_test.go#newcode317\nsrc/pkg/strings/replace_test.go:317: .bra-\nI'm surprised that \"abra\" is broken over two tries. Similarly with \"c/adabra\", \"h/am\" and \"s/ion\". Do you know if the opening \"a\" in \"abra\" is a prefix or a table entry? Either way, it seems sub-optimal.\n\nhttp://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/replace_test.go#newcode342\nsrc/pkg/strings/replace_test.go:342: spaceRemover := NewReplacer(\" \", \"\", \"\\t\", \"\")\nAre there any spaces? Isn't the leading white space all tabs?\n\nAlso, it's a little worrying that this test uses a NewReplacer that is a generic replacer that relies on the trie that this test is testing. Instead, I'd write the replacer by hand:\n\nstripTabs := func(s string) string {\n  b := make([]byte, 0, len(s))\n  for i := 0; i < len(s); i++ {\n    if s[i] != '\\t' {\n      b = append(b, s[i])\n    }\n  }\n  return string(b)\n}\n\nhttp://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/replace_test.go#newcode350\nsrc/pkg/strings/replace_test.go:350: gen := NewReplacer(args...)\nYou could roll this into the next line:\nin := NewReplacer(args...).PrintTrie()\n\nMore idiomatic would be to rename in and out to got and want:\n\ngot := NewReplacer(args...).PrintTrie()\nwant := stripTabs(tc.out)\nif got != want {\n  etc\n}\n\nhttp://codereview.appspot.com/6492076/diff/2008/src/pkg/strings/replace_test.go#newcode356\nsrc/pkg/strings/replace_test.go:356: t.Errorf(\"PrintTrie(%q) = %s, want %s\", tc.in, in, out)\nGiven that in and out (or got and want) have new-lines in them, it might be better to format it as\n\nt.Errorf(\"input=%q\\ngot  %s\\nwant %s\\n\", tc.in, got, want)",
			"disapproval": false,
			"date": "2012-09-12 12:23:57.077360",
			"approval": false
		},
		{
			"sender": "remyoudompheng@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Can you compare the allocation pattern before and after? (allocation count + bytes per iteration)",
			"disapproval": false,
			"date": "2012-09-04 09:29:16.700340",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6492076/diff/11001/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/11001/src/pkg/strings/replace.go#newcode178\nsrc/pkg/strings/replace.go:178: } else if node.prefix != \"\" && node.prefix == s[:len(node.prefix)] {\nWon't this panic if node.prefix is longer than s?\n\nA larger point is that I'd want a lot more test cases to cover all the different paths in this new code.",
			"disapproval": false,
			"date": "2012-09-05 07:27:14.578750",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 6 September 2012 17:53,  <eric.d.eisner@gmail.com> wrote:\r\n> I had updated the numbers in the description (and dropped the part that\r\n> said it was memory inefficient) in the last update or so. They are still\r\n> multiple times faster than your improved simple implementation (but now\r\n> more complex with a few memory workarounds).\r\n\r\nSorry for being dumb, but I can't find the new numbers. Can you e-mail\r\nthem to this thread?\r\n\r\n\r\n> I tried swapping out the copy-pasted Replace code with a call to\r\n> WriteString on a simple buffer, and it added a 35% runtime overhead to\r\n> the two benchmarks. The NoMatch case also now allocates buffer memory\r\n> where it didn't used to allocate any. I included this version for\r\n> reference as *genericReplacer.BufferedReplace\r\n\r\nYour version calls io.WriteString, which has to sniff for the\r\ninterface each time. My version does the interface check only once, at\r\nthe top of genericReplacer.WriteString.\r\n",
			"disapproval": false,
			"date": "2012-09-07 00:03:17.824280",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"dsymonds@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/07 00:03:17, nigeltao wrote:\n> On 6 September 2012 17:53,  <mailto:eric.d.eisner@gmail.com> wrote:\n> > I had updated the numbers in the description (and dropped the part that\n> > said it was memory inefficient) in the last update or so. They are still\n> > multiple times faster than your improved simple implementation (but now\n> > more complex with a few memory workarounds).\n> \n> Sorry for being dumb, but I can't find the new numbers. Can you e-mail\n> them to this thread?\n> \n> \n> > I tried swapping out the copy-pasted Replace code with a call to\n> > WriteString on a simple buffer, and it added a 35% runtime overhead to\n> > the two benchmarks. The NoMatch case also now allocates buffer memory\n> > where it didn't used to allocate any. I included this version for\n> > reference as *genericReplacer.BufferedReplace\n> \n> Your version calls io.WriteString, which has to sniff for the\n> interface each time. My version does the interface check only once, at\n> the top of genericReplacer.WriteString.\n\nI used your WriteString interface sniffing, and here are the updated numbers:\n\nCopy-paste Replace logic:\n\nbenchmark                  old ns/op    new ns/op    delta\nBenchmarkGenericNoMatch        72882         2461  -96.62%\nBenchmarkGenericMatch          90858         9313  -89.75%\n\nbenchmark                   old MB/s     new MB/s  speedup\nBenchmarkGenericNoMatch         2.74        81.26   29.66x\nBenchmarkGenericMatch           3.74        36.50    9.76x\n\n\nUsing the buffer and WriteString:\n\nbenchmark                  old ns/op    new ns/op    delta\nBenchmarkGenericNoMatch        72882         3058  -95.80%\nBenchmarkGenericMatch          90858        10361  -88.60%\n\nbenchmark                   old MB/s     new MB/s  speedup\nBenchmarkGenericNoMatch         2.74        65.39   23.86x\nBenchmarkGenericMatch           3.74        32.81    8.77x",
			"disapproval": false,
			"date": "2012-09-07 00:42:10.626430",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/13 08:05:58, nigeltao wrote:\n> https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go\n> File src/pkg/strings/replace.go (right):\n> \n> https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode83\n> src/pkg/strings/replace.go:83: type trie struct {\n> s/trie/trieNode/ might be a better name.\n\nDone.\n> \n> Also, I think that future maintainers (including you or me six months from now)\n> will be helped by a worked example. It took me a while to figure out how it all\n> works. In my example below, it wasn't obvious to me that the \"cbc\" prefix was\n> part of node n4, not n5.\n> \n> I've pasted a proposal below. WDYT?\n\nLooks good and thorough. I tweaked it a little.\n> \n> \n> // trieNode is a node in a lookup trie for prioritized key/value pairs. Keys\n> // and values may be empty. For example, the trie containing keys \"ax\", \"ay\",\n> // \"bcbc\", \"x\" and \"xy\" could have eight nodes:\n> //\n> //  n0  -\n> //  n1  a-\n> //  n2  .x+\n> //  n3  .y+\n> //  n4  b-\n> //  n5  .cbc+\n> //  n6  x+\n> //  n7  .y+\n> //\n> // n0 is the root node, and its children are n1, n4 and n6; n1's children are\n> // n2 and n3; n4's child is n5; n6's child is n7. Nodes n0, n1 and n4 (marked\n> // with a trailing \"-\") are partial keys, and nodes n2, n3, n5, n6 and n7\n> // (marked with a trailing \"+\") are complete keys.\n> type trieNode struct {\n>     // value is the value of the trie node's key/value pair. It is empty if\n>     // this node is not a complete key.\n>     value string\n>     // priority is the priority (higher is more important) of the trie node's\n>     // key/value pair; keys are not necessarily matched shortest- or longest-\n>     // first. Priority is positive if this node is a complete key, and zero\n>     // otherwise. In the example above, positive/zero priorities are marked\n>     // with a trailing \"+\" or \"-\".\n>     priority int\n> \n>     // A trie node may have zero, one or more child nodes:\n>     //  * if zero, the remaining fields are zero.\n>     //  * if one, prefix and next are non-zero.\n>     //  * if more, table is non-zero.\n>     //\n>     // For lookup efficiency, the root node is an exception, and will never\n>     // use its prefix or next fields. It will always use the table field,\n>     // unless the only key is empty.\n> \n>     // prefix is the difference in keys between this trie node and the next.\n>     // In the example above, node n4 has prefix \"cbc\" and n4's next node is n5.\n>     // Node n5 has no children and so has zero prefix, next and table fields.\n>     prefix string\n>     next   *trieNode\n> \n>     // table is a lookup table indexed by the next byte in the key, after\n>     // remapping that byte through genericReplacer.mapping to create a dense\n>     // index. In the example above, the keys only use 'a', 'b', 'c', 'x' and\n>     // 'y', which remap to 0, 1, 2, 3 and 4. All other bytes map to 5, so that\n>     // genericReplacer.tableSize will be 6. Node n0's table will be\n\ntablesize will be 5 here, and lookup explicitly checks for the mapping yielding tablesize, and aborts if so. I did it this way instead of having a space at the end of the table for \"no match\", because it makes the performance 5-15% faster.\n\n>     // []*trieNode{ 0:n1, 1:n4, 3:n6 }, where the 0, 1 and 3 are the remapped\n>     // 'a', 'b' and 'x'.\n>     table []*trieNode\n> }\n> \n> https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode86\n> src/pkg/strings/replace.go:86: // Priority of this match vs superstrings. Higher\n> is better, and 0 means\n> What is a superstring?\n\nI meant priority vs all potential children, to which this node is a prefix. Your version explains it better though.\n> \n> https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode89\n> src/pkg/strings/replace.go:89: // If this node has multiple children (and thus\n> with multiple different\n> http://golang.org/doc/effective_go.html#commentary says that \"The first sentence\n> [of a documentation comment] should be a one-sentence summary that starts with\n> the name being declared.\" Thus, we usually say something like \"table is ...\"\n> instead of \"If this node ...\".\n> \n> https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode93\n> src/pkg/strings/replace.go:93: // If this node has exactly one child, this will\n> be nonempty.\n> Ah, \"a/bra\" means that this comment isn't true for the root node, right?\n\nYes, the doc might more accurately explain it inversely:\n* if the remaining fields are zero, there are no children\n* if prefix and next are non-zero, there is one child in next\n* if table is non-zero, it defines all the children, 0-256 of them\n\nadd just happens to implement it to favor using prefixes over tables to save memory.\n\n> \n> https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode151\n> src/pkg/strings/replace.go:151: b := key[0]\n> The next few lines simplify if this is\n> m := r.mapping[key[0]]\n\nDone.\n> \n> https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace_test.go\n> File src/pkg/strings/replace_test.go (right):\n> \n> https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace_test.go#newcode305\n> src/pkg/strings/replace_test.go:305: testCases := []struct{ in, out string }{\n> It's worth testing \"foo;foo\" and \"foo;foo;foo1\" as inputs. It's probably also\n> worth testing those in TestReplacer.\n\nDone. The abra* test covers using duplicate keys.\n> \n> https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace_test.go#newcode306\n> src/pkg/strings/replace_test.go:306: {\"abc;abdef;abdefgh;xx;xy;z\", `- table:\n> Now that I understand how it works, the \"table:\" strings are kind of ugly, and\n> I'd rather leave them out.\n\nDone.\n> \n> https://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace_test.go#newcode353\n> src/pkg/strings/replace_test.go:353: want := Replace(tc.out, \"\\t\", \"\", -1)\n> I would still do this by hand. A future refactoring could implement\n> strings.Replace using strings.NewReplacer, and then this test might give false\n> positives.\n\nDone.",
			"disapproval": false,
			"date": "2012-09-13 16:27:48.259370",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM, submitting...\n\nThanks for your patience in this code review.\n\nhttps://codereview.appspot.com/6492076/diff/6006/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/6006/src/pkg/strings/replace.go#newcode113\nsrc/pkg/strings/replace.go:113: //  * if prefix and next are non-zero, there is one child in next\nTrailing full stop, and ditto on the next line.\n\nhttps://codereview.appspot.com/6492076/diff/6006/src/pkg/strings/replace.go#newcode156\nsrc/pkg/strings/replace.go:156: // what is crrently t.prefix[0] will lead to prefixNode, and\nTypo in currently.\n\nhttps://codereview.appspot.com/6492076/diff/6006/src/pkg/strings/replace_test.go\nFile src/pkg/strings/replace_test.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/6006/src/pkg/strings/replace_test.go#newcode236\nsrc/pkg/strings/replace_test.go:236: testCase{blankHighPriority, \"iooi\", \"XiXOXOXiX\"},\nI'd also add an \"oiio\" test.",
			"disapproval": false,
			"date": "2012-09-17 01:49:24.686920",
			"approval": true
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, rogpeppe@gmail.com, remyoudompheng@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-05 04:34:53.800280",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, rogpeppe@gmail.com, remyoudompheng@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-05 15:36:49.893870",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, rogpeppe@gmail.com, remyoudompheng@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-05 15:43:22.883850",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "> This is a clever trick. I added this mapping using a [256]int (otherwise\r\n> a malicious set of keys that uses every byte would fail)\r\n\r\nYou can make [256]byte work. If all the bytes are used then there is\r\nno need for a value for \"other\".\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2012-09-06 00:47:05.181380",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"dsymonds@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello nigeltao@golang.org, rogpeppe@gmail.com, remyoudompheng@gmail.com, rsc@golang.org, dsymonds@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-09-07 00:43:36.726230",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rogpeppe@gmail.com",
				"remyoudompheng@gmail.com",
				"rsc@golang.org",
				"dsymonds@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6492076/diff/7005/src/pkg/strings/replace_test.go\nFile src/pkg/strings/replace_test.go (right):\n\nhttps://codereview.appspot.com/6492076/diff/7005/src/pkg/strings/replace_test.go#newcode83\nsrc/pkg/strings/replace_test.go:83: // Added here for initialization.\nYou might as well move all the ReplacerTests into here. This is done in http://codereview.appspot.com/6488110.",
			"disapproval": false,
			"date": "2012-09-11 03:14:41.466060",
			"approval": false
		},
		{
			"sender": "nigeltao@golang.org",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go\nFile src/pkg/strings/replace.go (right):\n\nhttp://codereview.appspot.com/6492076/diff/12011/src/pkg/strings/replace.go#newcode204\nsrc/pkg/strings/replace.go:204: root *trie\nDropping the * would also save you one level of indirection.",
			"disapproval": false,
			"date": "2012-09-13 10:47:53.922430",
			"approval": false
		},
		{
			"sender": "eric.d.eisner@gmail.com",
			"recipients": [
				"eric.d.eisner@gmail.com",
				"nigeltao@golang.org",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/09/14 04:10:28, nigeltao wrote:\n> This is getting pretty close.\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go\n> File src/pkg/strings/replace.go (right):\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode128\n> src/pkg/strings/replace.go:128: // 'y', which remap to 0, 1, 2, 3 and 4. All\n> other bytes map to 5, and\n> My fault, but changing the second \"map\" to \"remap\" would be more consistent.\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode156\n> src/pkg/strings/replace.go:156: // The current prefixed node ends up in\n> prefixnode,\n> Maybe\n> // Looking up what is currently t.prefix[0] will lead to prefixnode, and\n> // looking up key[0] will lead to keynode.\n> \n> Also, s/prefixnode/prefixNode/ and s/keynode/keyNode/.\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode190\n> src/pkg/strings/replace.go:190: next := t.table[m]\n> You could just write\n> t.table[m].add(etc)\n> on the next line.\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode240\n> src/pkg/strings/replace.go:240: // The size of a trie node's lookup table: the\n> number of unique key bytes.\n> // tableSize is the size of a trie node's lookup table. It is the number of\n> // unique key bytes.\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode242\n> src/pkg/strings/replace.go:242: // At the index of each byte found anywhere in\n> any key, this will contain\n> // mapping maps from key bytes to a dense index for trieNode.table.\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode249\n> src/pkg/strings/replace.go:249: t := &r.root\n> Just use r.root below:\n> r.root.table = make(etc)\n> r.root.add(etc)\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode275\n> src/pkg/strings/replace.go:275: key, val := oldnew[i], oldnew[i+1]\n> I'm not sure if the key and val variables add much. I'd make the next line\n> r.root.add(oldnew[i], oldnew[i+1], len(oldnew)-i, r)\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode309\n> src/pkg/strings/replace.go:309: // WriteString writes the replaced version of s\n> to w, using the same logic as\n> I'd just use the same comment as the one on Replacer.WriteString\n> // WriteString writes s to w with all replacements performed.\n> and drop the parts about (1) using the same logic, and (2) avoiding small\n> writes.\n> \n> Or just drop the doc comment entirely. It's not an exported type, and I don't\n> think it adds much.\n> \n> Sorry for the busywork if I've asked you to add these comments before.\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode343\n> src/pkg/strings/replace.go:343: wn, err = sw.WriteString(s[last:])\n> Wrapping this line and the next with a\n> if last != len(s)\n> might save a few unnecessary writes.\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace.go#newcode490\n> src/pkg/strings/replace.go:490: var discard io.Writer = devNull(0)\n> Delete discard and devNull (lines 488-496).\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace_test.go\n> File src/pkg/strings/replace_test.go (right):\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace_test.go#newcode226\n> src/pkg/strings/replace_test.go:226: blankLowPriority := NewReplacer(\"a\", \"A\",\n> \"\", \"X\")\n> Rename blankToXOToO as blankHighPriority? Use the same inputs for both: \"oo\",\n> \"ii\", \"iooi\", \"oiio\" and \"\"?\n> \n> https://codereview.appspot.com/6492076/diff/13010/src/pkg/strings/replace_test.go#newcode363\n> src/pkg/strings/replace_test.go:363: var wantbuf []byte\n> wantbuf := make([]byte, 0, len(tc.out))\n> might save a few re-allocations.\n\nDone all.",
			"disapproval": false,
			"date": "2012-09-14 07:15:30.978510",
			"approval": false
		}
	],
	"owner_email": "eric.d.eisner@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "Eric Roshan Eisner",
	"subject": "code review 6492076: strings: implement a faster generic Replacer",
	"created": "2012-09-03 23:07:07.839660",
	"patchsets": [
		1,
		2001,
		5001,
		8001,
		11001,
		10003,
		14001,
		6004,
		6,
		13004,
		8005,
		7005,
		4014,
		5011,
		2008,
		12011,
		7009,
		12,
		13010,
		6006
	],
	"modified": "2012-09-17 15:48:25.493120",
	"closed": true,
	"issue": 6492076
}