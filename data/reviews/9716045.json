{
	"description": "runtime: simplify runtime\u00b7settype()\n\nThis changeset removes buffering of type information\nand removes support for SysAlloc from the code.",
	"cc": [
		"golang-dev@googlegroups.com",
		"rsc@golang.org"
	],
	"reviewers": [
		"golang-dev@googlegroups.com",
		"khr@golang.org",
		"khr@google.com",
		"cshapiro@google.com",
		"dvyukov@google.com",
		"iant@golang.org"
	],
	"messages": [
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com (cc: dvyukov@google.com, rsc@golang.org),\n\nI'd like you to review this change to\nhttps://code.google.com/p/go/",
			"disapproval": false,
			"date": "2013-05-30 14:24:15.198160",
			"approval": false
		},
		{
			"sender": "khr@golang.org",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"dvyukov@google.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9716045/diff/1007/src/pkg/runtime/malloc.goc\nFile src/pkg/runtime/malloc.goc (right):\n\nhttps://codereview.appspot.com/9716045/diff/1007/src/pkg/runtime/malloc.goc#newcode572\nsrc/pkg/runtime/malloc.goc:572: data2 = runtime\u00b7mallocgc(nbytes2, FlagNoProfiling|FlagNoPointers, 0, 1);\nDon't call malloc while holding a spin lock.  Malloc might gc, and everyone else waiting on this lock is spinning.  stoptheworld won't be able to stop them => deadlock.\n\nCalling malloc is ok.  Use a better lock.",
			"disapproval": false,
			"date": "2013-05-30 17:34:02.846550",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"dvyukov@google.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9716045/diff/1007/src/pkg/runtime/malloc.goc\nFile src/pkg/runtime/malloc.goc (right):\n\nhttps://codereview.appspot.com/9716045/diff/1007/src/pkg/runtime/malloc.goc#newcode572\nsrc/pkg/runtime/malloc.goc:572: data2 = runtime\u00b7mallocgc(nbytes2, FlagNoProfiling|FlagNoPointers, 0, 1);\nOn 2013/05/30 17:34:03, khr wrote:\n> Don't call malloc while holding a spin lock.  Malloc might gc, and everyone else\n> waiting on this lock is spinning.  stoptheworld won't be able to stop them =>\n> deadlock.\n> \n> Calling malloc is ok.  Use a better lock.\n\nmallocgc is called with dogc=0.",
			"disapproval": false,
			"date": "2013-05-30 18:25:54.498450",
			"approval": false
		},
		{
			"sender": "khr@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I did not see that, sorry.  I'm still concerned about the spin lock,\r\nthough, if the holder gets (os) descheduled for some reason.  Why can't we\r\njust use a Lock?\r\n\r\n\r\nOn Thu, May 30, 2013 at 11:25 AM, <0xE2.0x9A.0x9B@gmail.com> wrote:\r\n\r\n>\r\n> https://codereview.appspot.**com/9716045/diff/1007/src/pkg/**\r\n> runtime/malloc.goc<https://codereview.appspot.com/9716045/diff/1007/src/pkg/runtime/malloc.goc>\r\n> File src/pkg/runtime/malloc.goc (right):\r\n>\r\n> https://codereview.appspot.**com/9716045/diff/1007/src/pkg/**\r\n> runtime/malloc.goc#newcode572<https://codereview.appspot.com/9716045/diff/1007/src/pkg/runtime/malloc.goc#newcode572>\r\n> src/pkg/runtime/malloc.goc:**572: data2 = runtime\u00b7mallocgc(nbytes2,\r\n> FlagNoProfiling|**FlagNoPointers, 0, 1);\r\n> On 2013/05/30 17:34:03, khr wrote:\r\n>\r\n>> Don't call malloc while holding a spin lock.  Malloc might gc, and\r\n>>\r\n> everyone else\r\n>\r\n>> waiting on this lock is spinning.  stoptheworld won't be able to stop\r\n>>\r\n> them =>\r\n>\r\n>> deadlock.\r\n>>\r\n>\r\n>  Calling malloc is ok.  Use a better lock.\r\n>>\r\n>\r\n> mallocgc is called with dogc=0.\r\n>\r\n> https://codereview.appspot.**com/9716045/<https://codereview.appspot.com/9716045/>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-05-30 19:39:44.991350",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, khr@golang.org, khr@google.com (cc: dvyukov@google.com, golang-dev@googlegroups.com, rsc@golang.org),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-05-30 19:52:31.360570",
			"approval": false
		},
		{
			"sender": "khr@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM.  Have Dmitry or Carl take a look also.\r\n\r\n\r\nOn Thu, May 30, 2013 at 12:52 PM, <0xE2.0x9A.0x9B@gmail.com> wrote:\r\n\r\n> Hello golang-dev@googlegroups.com, khr@golang.org, khr@google.com (cc:\r\n> dvyukov@google.com, golang-dev@googlegroups.com, rsc@golang.org),\r\n>\r\n> Please take another look.\r\n>\r\n>\r\n> https://codereview.appspot.**com/9716045/<https://codereview.appspot.com/9716045/>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-05-30 20:03:22.921690",
			"approval": true
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nWhat, if any, is the performance consequence of this change?\n\nhttps://codereview.appspot.com/9716045/diff/18006/src/pkg/runtime/malloc.goc\nFile src/pkg/runtime/malloc.goc (right):\n\nhttps://codereview.appspot.com/9716045/diff/18006/src/pkg/runtime/malloc.goc#newcode509\nsrc/pkg/runtime/malloc.goc:509: uintptr ntypes, nbytes2, nbytes3;\nI realize the names \"nbytes{2,3}\" and \"data{2,3}\" come from the earlier revision, but they are very confusing.  Could you rename these values to something more descriptive?  A follow-up change is okay.  It looks like they are for word type data and byte type data, a better name might reflect that.",
			"disapproval": false,
			"date": "2013-05-30 21:59:07.852410",
			"approval": true
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9716045/diff/18006/src/pkg/runtime/malloc.goc\nFile src/pkg/runtime/malloc.goc (right):\n\nhttps://codereview.appspot.com/9716045/diff/18006/src/pkg/runtime/malloc.goc#newcode509\nsrc/pkg/runtime/malloc.goc:509: uintptr ntypes, nbytes2, nbytes3;\nOn 2013/05/30 21:59:08, cshapiro1 wrote:\n> I realize the names \"nbytes{2,3}\" and \"data{2,3}\" come from the earlier\n> revision, but they are very confusing.  Could you rename these values to\n> something more descriptive?  A follow-up change is okay.  It looks like they are\n> for word type data and byte type data, a better name might reflect that.\n\nI suggest to keep the names and add a comment to C code:\n\n// The suffix 2 (nbytes2, data2) means that the variable is related to MType_Words.\n// The suffix 3 (nbytes3, data3) means that the variable is related to MType_Bytes.",
			"disapproval": false,
			"date": "2013-05-31 05:26:23.255260",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "The \"remove sysalloc\" part looks good. But the \"remove caching\" NOT LGTM.\nThere is already very significant slowdown in the memory subsystem since Go1.1, and this adds another 6%.\n\nOn test/bench/garbage/parser:\nbefore:\ngarbage.BenchmarkParser 4 2851583751 ns/op\nafter:\ngarbage.BenchmarkParser 4 3037543341 ns/op\n\nbefore:\n  9.78%  parser  parser             [.] scanblock                                                                              \u25c6\n  7.83%  parser  parser             [.] sweepspan                                                                              \u2592\n  6.61%  parser  parser             [.] runtime.mallocgc                                                                       \u2592\n  6.44%  parser  parser             [.] flushptrbuf                                                                            \u2592\n  4.06%  parser  parser             [.] runtime.settype_flush                                                                  \u2592\n  3.76%  parser  parser             [.] go/scanner.(*Scanner).next                                                             \u2592\n  2.92%  parser  parser             [.] runtime.gettype                                                                        \u2592\n  2.44%  parser  parser             [.] runtime.newstack                                                                       \u2592\n  2.29%  parser  parser             [.] runtime.memclr                           \n\nafter:\n  9.82%  parser  parser             [.] scanblock                                                                              \u25c6\n  7.63%  parser  parser             [.] sweepspan                                                                              \u2592\n  6.20%  parser  parser             [.] flushptrbuf                                                                            \u2592\n  5.77%  parser  parser             [.] runtime.mallocgc                                                                       \u2592\n  5.11%  parser  parser             [.] runtime.xchg                                                                          \u2592\n  4.10%  parser  parser             [.] runtime.settype                                                                       \u2592\n  3.32%  parser  parser             [.] go/scanner.(*Scanner).next                                                             \u2592\n  2.93%  parser  parser             [.] runtime.gettype                                                                        \u2592\n  2.45%  parser  parser             [.] runtime.newstack                                                                       \u2592\n  2.19%  parser  parser             [.] go/scanner.(*Scanner).Scan                                                             \u2592\n  2.13%  parser  parser             [.] runtime.memclr                                                                         \u2592\n\nNote that 5.11% for runtime.xchg.\nMalloc really should be just a pop from freelist (or bump pointer), in no way it must take locks (even if local).",
			"disapproval": true,
			"date": "2013-05-31 06:33:07.287140",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Patchset 5 has runtime\u00b7lock() inlined into runtime\u00b7settype(). Could you please rerun the benchmark with patchset 5 and state whether the performance of patchset 5 would be LGTM?\n\nI can rewrite the for(;;) loop into assembler if necessary. \n\nOn 2013/05/31 06:33:07, dvyukov wrote:\n> The \"remove sysalloc\" part looks good. But the \"remove caching\" NOT LGTM.\n> There is already very significant slowdown in the memory subsystem since Go1.1,\n> and this adds another 6%.\n> \n> On test/bench/garbage/parser:\n> before:\n> garbage.BenchmarkParser 4 2851583751 ns/op\n> after:\n> garbage.BenchmarkParser 4 3037543341 ns/op\n> \n> before:\n>   9.78%  parser  parser             [.] scanblock                               \n>                                               \u25c6\n>   7.83%  parser  parser             [.] sweepspan                               \n>                                               \u2592\n>   6.61%  parser  parser             [.] runtime.mallocgc                        \n>                                               \u2592\n>   6.44%  parser  parser             [.] flushptrbuf                             \n>                                               \u2592\n>   4.06%  parser  parser             [.] runtime.settype_flush                   \n>                                               \u2592\n>   3.76%  parser  parser             [.] go/scanner.(*Scanner).next              \n>                                               \u2592\n>   2.92%  parser  parser             [.] runtime.gettype                         \n>                                               \u2592\n>   2.44%  parser  parser             [.] runtime.newstack                        \n>                                               \u2592\n>   2.29%  parser  parser             [.] runtime.memclr                          \n> \n> \n> after:\n>   9.82%  parser  parser             [.] scanblock                               \n>                                               \u25c6\n>   7.63%  parser  parser             [.] sweepspan                               \n>                                               \u2592\n>   6.20%  parser  parser             [.] flushptrbuf                             \n>                                               \u2592\n>   5.77%  parser  parser             [.] runtime.mallocgc                        \n>                                               \u2592\n>   5.11%  parser  parser             [.] runtime.xchg                            \n>                                              \u2592\n>   4.10%  parser  parser             [.] runtime.settype                         \n>                                              \u2592\n>   3.32%  parser  parser             [.] go/scanner.(*Scanner).next              \n>                                               \u2592\n>   2.93%  parser  parser             [.] runtime.gettype                         \n>                                               \u2592\n>   2.45%  parser  parser             [.] runtime.newstack                        \n>                                               \u2592\n>   2.19%  parser  parser             [.] go/scanner.(*Scanner).Scan              \n>                                               \u2592\n>   2.13%  parser  parser             [.] runtime.memclr                          \n>                                               \u2592\n> \n> Note that 5.11% for runtime.xchg.\n> Malloc really should be just a pop from freelist (or bump pointer), in no way it\n> must take locks (even if local).",
			"disapproval": false,
			"date": "2013-05-31 06:40:27.926610",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I expect the spinlock variable to be zero on entry to settype() in majority of cases. If mallocgc if called from N threads at the same time, it is likely that the N mspans will be different from each other. I am unable to prove that those N mspans are different in all possible situations, so I was forced to put a lock there.",
			"disapproval": false,
			"date": "2013-05-31 06:51:09.153090",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/05/31 06:40:27, atom wrote:\n> Patchset 5 has runtime\u00b7lock() inlined into runtime\u00b7settype(). Could you please\n> rerun the benchmark with patchset 5 and state whether the performance of\n> patchset 5 would be LGTM?\n\nSlightly better, but still 4% slowdown:\n\nbefore:\ngarbage.BenchmarkParser 4 2814602888 ns/op\ngarbage.BenchmarkParser 4 2796648863 ns/op\ngarbage.BenchmarkParser 4 2786491624 ns/op\n\nafter:\ngarbage.BenchmarkParser 4 2961402827 ns/op\ngarbage.BenchmarkParser 4 2882486866 ns/op\ngarbage.BenchmarkParser 4 2899995700 ns/op",
			"disapproval": false,
			"date": "2013-05-31 07:17:01.711720",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Considering what's been written in discussion \"Better GC and Memory Allocator\" (https://groups.google.com/forum/?fromgroups#!topic/golang-dev/pwUh0BVFpY0) and taking into account the fact that further optimizing the current settype() seems impossible, I am thinking of removing MTypes_Bytes. This would make settype() and mgc0.c both simpler and slightly faster, at the cost of increased memory consumption. The cost per object would initially be 8 bytes on 64-bit platforms, with the option of shrinking it to 4 bytes per object in the future.\n\nIs there an agreement that this is the way to go?\n\nOn 2013/06/03 09:04:17, dvyukov wrote:\n> Now it's quite debatable whether it's a simplification as the change description\n> says.\n> I've remeasured the performance, the best out of 8 runs is:\n> garbage.BenchmarkParser 4 2825486313 ns/op\n> So it's very close, but ~0.5-1% slower.\n> Before:\n>   4.06%  parser  parser             [.] runtime.settype_flush                   \n>   1.11%  parser  parser             [.] runtime.xchg      \n> After:\n>   4.65%  parser  parser             [.] runtime.settype\n>   1.30%  parser  parser             [.] runtime.xchg\n> \n> My conclusion is still the same:\n> The \"remove sysalloc\" part is good.\n> But the rest is either complicates the code, or slows it down, or both.",
			"disapproval": false,
			"date": "2013-06-03 12:21:51.484330",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "So your benchmarks show 2.22% speedup and 2.86% memory increase.\nOn linux/am64 I see 2.19% speedup and 5.27% memory increase (it's probably expected, because word is twice as big).\n+ some code simplification\nI can't make my mind right now, it's a difficult decision.",
			"disapproval": false,
			"date": "2013-06-03 14:55:26.615700",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I uploaded a new patchset. Please rerun the benchmark.",
			"disapproval": false,
			"date": "2013-05-31 08:12:13.294430",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I updated the settype function and fixed the irrational code introduced in the previous changeset. I hope the code is correct now.\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-05-31 18:38:19.033260",
			"approval": false
		},
		{
			"sender": "iant@golang.org",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc\nFile src/pkg/runtime/malloc.goc (right):\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode564\nsrc/pkg/runtime/malloc.goc:564: if(DebugTypeAtBlockEnd) {\nThis seems unrelated to this CL.\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode577\nsrc/pkg/runtime/malloc.goc:577: switch(s->types.compression) {\nThis appears to be an unlocked access to a field that is protected by a lock.  Shouldn't it be an atomic load?\n\nThe locking semantics here are puzzling; is there a comment somewhere, e.g., malloc.h, that explains them?\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode580\nsrc/pkg/runtime/malloc.goc:580: {\nWhy start a new block here?\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode582\nsrc/pkg/runtime/malloc.goc:582: // An other OS thread won the race\ns/An other/Another/\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode587\nsrc/pkg/runtime/malloc.goc:587: // An other OS thread won the race\na/An other/Another/",
			"disapproval": false,
			"date": "2013-05-31 19:04:17.400830",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc\nFile src/pkg/runtime/malloc.goc (right):\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode577\nsrc/pkg/runtime/malloc.goc:577: switch(s->types.compression) {\nOn 2013/05/31 19:04:17, iant wrote:\n> This appears to be an unlocked access to a field that is protected by a lock. \n> Shouldn't it be an atomic load?\n> \n> The locking semantics here are puzzling; is there a comment somewhere, e.g.,\n> malloc.h, that explains them?\n\nThe semantics is based on the fact that MTypes_Words is the final state. Once the final state is reached, the value s->types.data is a constant.\n\nI just realized there is a race condition in s->types.data when going from MTypes_Bytes to MTypes_Words. I will attempt to post a fix tomorrow.",
			"disapproval": false,
			"date": "2013-05-31 19:33:11.358050",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc\nFile src/pkg/runtime/malloc.goc (right):\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode564\nsrc/pkg/runtime/malloc.goc:564: if(DebugTypeAtBlockEnd) {\nOn 2013/05/31 19:04:17, iant wrote:\n> This seems unrelated to this CL.\n\nIt comes from the old runtime\u00b7settype().\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode577\nsrc/pkg/runtime/malloc.goc:577: switch(s->types.compression) {\nThe code has been updated. It isn't race free, but it should be very close to being race free. The non-zero probability of information loss shouldn't be a problem for the garbage collector.\n\nThere are now more comments in the code.\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode580\nsrc/pkg/runtime/malloc.goc:580: {\nOn 2013/05/31 19:04:17, iant wrote:\n> Why start a new block here?\n\nDone.\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode582\nsrc/pkg/runtime/malloc.goc:582: // An other OS thread won the race\nOn 2013/05/31 19:04:17, iant wrote:\n> s/An other/Another/\n\nDone.\n\nhttps://codereview.appspot.com/9716045/diff/35001/src/pkg/runtime/malloc.goc#newcode587\nsrc/pkg/runtime/malloc.goc:587: // An other OS thread won the race\nOn 2013/05/31 19:04:17, iant wrote:\n> a/An other/Another/\n\nDone.",
			"disapproval": false,
			"date": "2013-06-01 16:33:45.241730",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc\nFile src/pkg/runtime/malloc.goc (right):\n\nhttps://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc#newcode560\nsrc/pkg/runtime/malloc.goc:560: // The suffix 3 (nbytes3, data3) means that the variable is related to MType_Bytes.\nI also experience cognitive pressure when encounter 2/3 names. That may be find for a very local thing.\nAt least I would expect 1 - single, 2 - bytes, 3 - words; because words are larger and the final state. But they are actually the other way around.\ndatas, datab, dataw would give a useful hint.\n\nhttps://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc#newcode568\nsrc/pkg/runtime/malloc.goc:568: if(DebugTypeAtBlockEnd) {\ndrop {}\n\nhttps://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc#newcode580\nsrc/pkg/runtime/malloc.goc:580: ofs = ((uintptr)v - (s->start<<PageShift)) / size;\nthis seems to be index, not offset\n\nhttps://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc#newcode635\nsrc/pkg/runtime/malloc.goc:635: if(((uintptr*)data3)[j] == typ) {\ndrop {}\n\nhttps://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc#newcode640\nsrc/pkg/runtime/malloc.goc:640: // Label1\n?\n\nhttps://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc#newcode640\nsrc/pkg/runtime/malloc.goc:640: // Label1\nNow I see you refer to the Label1 below.\nPerhaps say something like:\n// possible race condition, see the \"Move contents of data3 to data2\" comment below\n\nhttps://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc#newcode657\nsrc/pkg/runtime/malloc.goc:657: if(((uintptr*)data3)[j] == typ) {\ndrop {}\n\nhttps://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc#newcode666\nsrc/pkg/runtime/malloc.goc:666: // Another OS thread added typ to data3\nit is not necessary another thread, it can be the current thread\n\nhttps://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc#newcode685\nsrc/pkg/runtime/malloc.goc:685: // Although we may misread some elements of data3[8..N] due to a race condition with Label1,\nit can also race with 'Another OS thread added typ to data3'",
			"disapproval": false,
			"date": "2013-06-03 07:30:52.066250",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc\nFile src/pkg/runtime/malloc.goc (right):\n\nhttps://codereview.appspot.com/9716045/diff/41001/src/pkg/runtime/malloc.goc#newcode687\nsrc/pkg/runtime/malloc.goc:687: // The probability of the race condition is extremely low.\nIt's fine to have such races now, but we must aim for 100% precise GC in future. At least we need some plan on how to implement it w/o the race and so it is still fast. It will be pity to revert this CL in future.",
			"disapproval": false,
			"date": "2013-06-03 08:23:34.186880",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Now it's quite debatable whether it's a simplification as the change description says.\nI've remeasured the performance, the best out of 8 runs is:\ngarbage.BenchmarkParser 4 2825486313 ns/op\nSo it's very close, but ~0.5-1% slower.\nBefore:\n  4.06%  parser  parser             [.] runtime.settype_flush                   \n  1.11%  parser  parser             [.] runtime.xchg      \nAfter:\n  4.65%  parser  parser             [.] runtime.settype\n  1.30%  parser  parser             [.] runtime.xchg\n\nMy conclusion is still the same:\nThe \"remove sysalloc\" part is good.\nBut the rest is either complicates the code, or slows it down, or both.",
			"disapproval": false,
			"date": "2013-06-03 09:04:17.790640",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/03 12:21:51, atom wrote:\n> Considering what's been written in discussion \"Better GC and Memory Allocator\"\n> (https://groups.google.com/forum/?fromgroups#%21topic/golang-dev/pwUh0BVFpY0) and\n> taking into account the fact that further optimizing the current settype() seems\n> impossible, I am thinking of removing MTypes_Bytes. This would make settype()\n> and mgc0.c both simpler and slightly faster, at the cost of increased memory\n> consumption. The cost per object would initially be 8 bytes on 64-bit platforms,\n> with the option of shrinking it to 4 bytes per object in the future.\n> \n> Is there an agreement that this is the way to go?\n\n\nSimplifications due to removal of sysalloc and MTypes_Bytes will be great. But you need to measure how it affects performance and memory consumption.",
			"disapproval": false,
			"date": "2013-06-03 12:29:17.795250",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/03 12:29:17, dvyukov wrote:\n> On 2013/06/03 12:21:51, atom wrote:\n> > Considering what's been written in discussion \"Better GC and Memory Allocator\"\n> > (https://groups.google.com/forum/?fromgroups#%2521topic/golang-dev/pwUh0BVFpY0)\n> and\n> > taking into account the fact that further optimizing the current settype()\n> seems\n> > impossible, I am thinking of removing MTypes_Bytes. This would make settype()\n> > and mgc0.c both simpler and slightly faster, at the cost of increased memory\n> > consumption. The cost per object would initially be 8 bytes on 64-bit\n> platforms,\n> > with the option of shrinking it to 4 bytes per object in the future.\n> > \n> > Is there an agreement that this is the way to go?\n> \n> \n> Simplifications due to removal of sysalloc and MTypes_Bytes will be great. But\n> you need to measure how it affects performance and memory consumption.\n\nA = with MTypes_Bytes\nB = without MTypes_Bytes\n\nlinux/386\n\ntest/bench/garbage/parser.go:\n  A: 65.087user 1.870system 0:54.170elapsed 123%CPU (390488maxresident)k\n  B: 63.042user 1.960system 0:52.967elapsed 122%CPU (401664maxresident)k\n\ntest/bench/garbage/tree2.go:\n  A: 12.246user 0.192system 0:11.578elapsed 107%CPU (148576maxresident)k\n  B: 11.827user 0.213system 0:11.349elapsed 106%CPU (173208maxresident)k",
			"disapproval": false,
			"date": "2013-06-03 13:11:39.369250",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/03 13:11:39, atom wrote:\n> On 2013/06/03 12:29:17, dvyukov wrote:\n> > On 2013/06/03 12:21:51, atom wrote:\n> > > Considering what's been written in discussion \"Better GC and Memory\n> Allocator\"\n> > >\n> (https://groups.google.com/forum/?fromgroups#%252521topic/golang-dev/pwUh0BVFpY0)\n> > and\n> > > taking into account the fact that further optimizing the current settype()\n> > seems\n> > > impossible, I am thinking of removing MTypes_Bytes. This would make\n> settype()\n> > > and mgc0.c both simpler and slightly faster, at the cost of increased memory\n> > > consumption. The cost per object would initially be 8 bytes on 64-bit\n> > platforms,\n> > > with the option of shrinking it to 4 bytes per object in the future.\n> > > \n> > > Is there an agreement that this is the way to go?\n> > \n> > \n> > Simplifications due to removal of sysalloc and MTypes_Bytes will be great. But\n> > you need to measure how it affects performance and memory consumption.\n> \n> A = with MTypes_Bytes\n> B = without MTypes_Bytes\n> \n> linux/386\n> \n> test/bench/garbage/parser.go:\n>   A: 65.087user 1.870system 0:54.170elapsed 123%CPU (390488maxresident)k\n>   B: 63.042user 1.960system 0:52.967elapsed 122%CPU (401664maxresident)k\n> \n> test/bench/garbage/tree2.go:\n>   A: 12.246user 0.192system 0:11.578elapsed 107%CPU (148576maxresident)k\n>   B: 11.827user 0.213system 0:11.349elapsed 106%CPU (173208maxresident)k\n\n\nPlease also measure memory consumption on linux/amd64. You can do it with:\n$ TIME=\"%e %M\" time ./parser",
			"disapproval": false,
			"date": "2013-06-03 13:23:43.242260",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/03 13:23:43, dvyukov wrote:\n> Please also measure memory consumption on linux/amd64. You can do it with:\n> $ TIME=\"%e %M\" time ./parser\n\nThis could take half an hour to complete with my resources. I uploaded the new code as patchset 12. Could you please run the benchmarks?",
			"disapproval": false,
			"date": "2013-06-03 13:28:56.210750",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/03 13:28:56, atom wrote:\n> On 2013/06/03 13:23:43, dvyukov wrote:\n> > Please also measure memory consumption on linux/amd64. You can do it with:\n> > $ TIME=\"%e %M\" time ./parser\n> \n> This could take half an hour to complete with my resources. I uploaded the new\n> code as patchset 12. Could you please run the benchmarks?\n\nAbout half an hour, as estimated.\n\nThe parser benchmark exceeds the 512 MB memory limit of the amd64 virtualized environment I am occasionally using for testing Go.",
			"disapproval": false,
			"date": "2013-06-03 14:11:03.894950",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/03 14:55:26, dvyukov wrote:\n> So your benchmarks show 2.22% speedup and 2.86% memory increase.\n> On linux/am64 I see 2.19% speedup and 5.27% memory increase (it's probably\n> expected, because word is twice as big).\n> + some code simplification\n> I can't make my mind right now, it's a difficult decision.\n\nThere are possibilities for lowering the typeinfo memory consumption in the future:\n\n1. Avoid mallocgc() in settype().\n\n2. Try to allocate hashmaps outside of mheap. The runtime knows type information of all hashmaps and the garbage collection of hashmaps is fully precise.\n\n3. (already mentioned) Shrinking the 8 byte typeinfo into 4 bytes.\n\nI plan to deal with (1) in a short time. (2) shouldn't be hard, it shares code with (1). (3) requires changes to the runtime, the compiler and the reflect package, so it may take some time to implement.\n\nIf we have a sufficiently firm belief in the realization of these 3 changes, the 5.27% memory increase seems acceptable.",
			"disapproval": false,
			"date": "2013-06-03 15:25:28.839740",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/03 14:55:26, dvyukov wrote:\n> So your benchmarks show 2.22% speedup and 2.86% memory increase.\n> On linux/am64 I see 2.19% speedup and 5.27% memory increase (it's probably\n> expected, because word is twice as big).\n> + some code simplification\n> I can't make my mind right now, it's a difficult decision.\n\nI have a prototype implementation of settype() without mallocgc(). It uses a new allocator.\n\nThe results:\n\nA = with MTypes_Bytes, with mallocgc in settype\nB = without MTypes_Bytes, without mallocgc in settype\n\nlinux/386\n\ntest/bench/garbage/parser.go:\n  A: 65.190user 2.057system 0:54.463elapsed 123%CPU 390488maxresident\n  B: 66.798user 2.015system 0:54.812elapsed 125%CPU 381224maxresident\n\ntest/bench/garbage/tree2.go:\n  A: 12.243user 0.192system 0:11.563elapsed 107%CPU 148576maxresident\n  B: 12.081user 0.219system 0:11.436elapsed 107%CPU 169152maxresident\n\nThe user times for parser.go are not comparable because in case B the scanblock() function is consuming about 1 second more time than in case A. The garbage collector also runs more often in case B when running parser.go, but this is to be expected because of smaller mheap.",
			"disapproval": false,
			"date": "2013-06-05 10:11:30.573970",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/05 10:11:30, atom wrote:\n> On 2013/06/03 14:55:26, dvyukov wrote:\n> > So your benchmarks show 2.22% speedup and 2.86% memory increase.\n> > On linux/am64 I see 2.19% speedup and 5.27% memory increase (it's probably\n> > expected, because word is twice as big).\n> > + some code simplification\n> > I can't make my mind right now, it's a difficult decision.\n> \n> I have a prototype implementation of settype() without mallocgc(). It uses a new\n> allocator.\n> \n> The results:\n> \n> A = with MTypes_Bytes, with mallocgc in settype\n> B = without MTypes_Bytes, without mallocgc in settype\n> \n> linux/386\n> \n> test/bench/garbage/parser.go:\n>   A: 65.190user 2.057system 0:54.463elapsed 123%CPU 390488maxresident\n>   B: 66.798user 2.015system 0:54.812elapsed 125%CPU 381224maxresident\n> \n> test/bench/garbage/tree2.go:\n>   A: 12.243user 0.192system 0:11.563elapsed 107%CPU 148576maxresident\n>   B: 12.081user 0.219system 0:11.436elapsed 107%CPU 169152maxresident\n> \n> The user times for parser.go are not comparable because in case B the\n> scanblock() function is consuming about 1 second more time than in case A. The\n> garbage collector also runs more often in case B when running parser.go, but\n> this is to be expected because of smaller mheap.\n\n\nparser looks good. I don't care too much about tree2 for such changes.\nWhat do you mean by \"new allocator\"?\nAlso please allocate the type array directly when the span is allocated for small blocks, it will simplify settype() significantly. And free it directly when the span is returned to heap, it should be possible with custom allocator.",
			"disapproval": false,
			"date": "2013-06-05 11:50:05.929560",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/05 11:50:05, dvyukov wrote:\n> On 2013/06/05 10:11:30, atom wrote:\n> > I have a prototype implementation of settype() without mallocgc(). It uses a\n> new\n> > allocator.\n> > \n> > The results:\n> > \n> > A = with MTypes_Bytes, with mallocgc in settype\n> > B = without MTypes_Bytes, without mallocgc in settype\n> > \n> > linux/386\n> > \n> > test/bench/garbage/parser.go:\n> >   A: 65.190user 2.057system 0:54.463elapsed 123%CPU 390488maxresident\n> >   B: 66.798user 2.015system 0:54.812elapsed 125%CPU 381224maxresident\n> > \n> > test/bench/garbage/tree2.go:\n> >   A: 12.243user 0.192system 0:11.563elapsed 107%CPU 148576maxresident\n> >   B: 12.081user 0.219system 0:11.436elapsed 107%CPU 169152maxresident\n> > \n> > The user times for parser.go are not comparable because in case B the\n> > scanblock() function is consuming about 1 second more time than in case A. The\n> > garbage collector also runs more often in case B when running parser.go, but\n> > this is to be expected because of smaller mheap.\n> \n> \n> parser looks good. I don't care too much about tree2 for such changes.\n> What do you mean by \"new allocator\"?\n\nhttps://codereview.appspot.com/10046043\n\nIt isn't prepared for code review yet, but you can comment on it. I published it in advance because this CL (9716045) cannot be LGTMed without seeing the allocator source code. Please ignore the style of the source code for now.\n\n> Also please allocate the type array directly when the span is allocated for\n> small blocks, it will simplify settype() significantly. And free it directly\n> when the span is returned to heap, it should be possible with custom allocator.\n\nI agree. Because of recursion it wasn't possible when settype() was using mallocgc(). I would suggest for this to be a separate code review that should be posted after we are done with CL 10046043. Splitting the process into 3 CLs should make it easier to review.",
			"disapproval": false,
			"date": "2013-06-05 12:29:37.048260",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jun 5, 2013 at 4:29 PM,  <0xE2.0x9A.0x9B@gmail.com> wrote:\r\n> On 2013/06/05 11:50:05, dvyukov wrote:\r\n>>\r\n>> On 2013/06/05 10:11:30, atom wrote:\r\n>> > I have a prototype implementation of settype() without mallocgc().\r\n>\r\n> It uses a\r\n>>\r\n>> new\r\n>> > allocator.\r\n>> >\r\n>> > The results:\r\n>> >\r\n>> > A = with MTypes_Bytes, with mallocgc in settype\r\n>> > B = without MTypes_Bytes, without mallocgc in settype\r\n>> >\r\n>> > linux/386\r\n>> >\r\n>> > test/bench/garbage/parser.go:\r\n>> >   A: 65.190user 2.057system 0:54.463elapsed 123%CPU\r\n>\r\n> 390488maxresident\r\n>>\r\n>> >   B: 66.798user 2.015system 0:54.812elapsed 125%CPU\r\n>\r\n> 381224maxresident\r\n>>\r\n>> >\r\n>> > test/bench/garbage/tree2.go:\r\n>> >   A: 12.243user 0.192system 0:11.563elapsed 107%CPU\r\n>\r\n> 148576maxresident\r\n>>\r\n>> >   B: 12.081user 0.219system 0:11.436elapsed 107%CPU\r\n>\r\n> 169152maxresident\r\n>>\r\n>> >\r\n>> > The user times for parser.go are not comparable because in case B\r\n>\r\n> the\r\n>>\r\n>> > scanblock() function is consuming about 1 second more time than in\r\n>\r\n> case A. The\r\n>>\r\n>> > garbage collector also runs more often in case B when running\r\n>\r\n> parser.go, but\r\n>>\r\n>> > this is to be expected because of smaller mheap.\r\n>\r\n>\r\n>\r\n>> parser looks good. I don't care too much about tree2 for such changes.\r\n>> What do you mean by \"new allocator\"?\r\n>\r\n>\r\n> https://codereview.appspot.com/10046043\r\n>\r\n> It isn't prepared for code review yet, but you can comment on it. I\r\n> published it in advance because this CL (9716045) cannot be LGTMed\r\n> without seeing the allocator source code. Please ignore the style of the\r\n> source code for now.\r\n\r\n\r\nKind of lot of code... and another allocator in the runtime...\r\nCan we do what we've discussed in golang-dev about improved GC --\r\nembed this type table directly at the end of the span itself? Then it\r\nwon't require all that code.\r\nMSpan will need to embed few slots for large objects (so that 4K\r\nobject can fit into 4K span).\r\n\r\n\r\n\r\n>> Also please allocate the type array directly when the span is\r\n>\r\n> allocated for\r\n>>\r\n>> small blocks, it will simplify settype() significantly. And free it\r\n>\r\n> directly\r\n>>\r\n>> when the span is returned to heap, it should be possible with custom\r\n>\r\n> allocator.\r\n>\r\n> I agree. Because of recursion it wasn't possible when settype() was\r\n> using mallocgc(). I would suggest for this to be a separate code review\r\n> that should be posted after we are done with CL 10046043. Splitting the\r\n> process into 3 CLs should make it easier to review.\r\n>\r\n> https://codereview.appspot.com/9716045/\r\n",
			"disapproval": false,
			"date": "2013-06-05 13:03:01.387760",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/05 13:03:01, dvyukov wrote:\n> On Wed, Jun 5, 2013 at 4:29 PM,  <mailto:0xE2.0x9A.0x9B@gmail.com> wrote:\n> >\n> > https://codereview.appspot.com/10046043\n> >\n> > It isn't prepared for code review yet, but you can comment on it. I\n> > published it in advance because this CL (9716045) cannot be LGTMed\n> > without seeing the allocator source code. Please ignore the style of the\n> > source code for now.\n> \n> \n> Kind of lot of code... and another allocator in the runtime...\n\nI believe an allocator completely separate from mallocgc() is necessary and can be used from multiple places in the runtime.\n\n> Can we do what we've discussed in golang-dev about improved GC --\n> embed this type table directly at the end of the span itself? Then it\n> won't require all that code.\n> MSpan will need to embed few slots for large objects (so that 4K\n> object can fit into 4K span).\n\nThe typical size of a memory block holding typeinfos is about 1024 bytes. The list of memory allocation requests for the parser benchmark looks as follows (size in bytes, 32-bit platform):\n\n... 2048 512 1024 512 2048 1024 344 512 144 168 256 128 1024 344 512 2048 1024 256 512 1024 512 2048 1024 32 512 1024 512 1024 2048 512 1024 344 512 2048 1024 16 512 1024 512 344 2048 1024 512 512 1024 2048 512 64 1024 344 512 2048 1024 512 256 1024 2048 512 16 512 1024 2048 512 1024 512 1024 2048 88 1024 8 8 ...\n\nA span is aligned to a page size, which is 4096 bytes. Embedding the type table directly into span itself would mean that the above numbers have to be rounded to a multiple of 4096. This would increase memory consumption.\n\nI would like to close this CL (9716045) soon if possible. There is a lot of other improvements ahead.",
			"disapproval": false,
			"date": "2013-06-05 13:29:51.047570",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jun 5, 2013 at 5:29 PM,  <0xE2.0x9A.0x9B@gmail.com> wrote:\r\n> On 2013/06/05 13:03:01, dvyukov wrote:\r\n>>\r\n>> On Wed, Jun 5, 2013 at 4:29 PM,  <mailto:0xE2.0x9A.0x9B@gmail.com>\r\n>\r\n> wrote:\r\n>\r\n>> >\r\n>> > https://codereview.appspot.com/10046043\r\n>> >\r\n>> > It isn't prepared for code review yet, but you can comment on it. I\r\n>> > published it in advance because this CL (9716045) cannot be LGTMed\r\n>> > without seeing the allocator source code. Please ignore the style of\r\n>\r\n> the\r\n>>\r\n>> > source code for now.\r\n>\r\n>\r\n>\r\n>> Kind of lot of code... and another allocator in the runtime...\r\n>\r\n>\r\n> I believe an allocator completely separate from mallocgc() is necessary\r\n> and can be used from multiple places in the runtime.\r\n\r\nWhere else?\r\n\r\n>> Can we do what we've discussed in golang-dev about improved GC --\r\n>> embed this type table directly at the end of the span itself? Then it\r\n>> won't require all that code.\r\n>> MSpan will need to embed few slots for large objects (so that 4K\r\n>> object can fit into 4K span).\r\n>\r\n>\r\n> The typical size of a memory block holding typeinfos is about 1024\r\n> bytes. The list of memory allocation requests for the parser benchmark\r\n> looks as follows (size in bytes, 32-bit platform):\r\n>\r\n> ... 2048 512 1024 512 2048 1024 344 512 144 168 256 128 1024 344 512\r\n> 2048 1024 256 512 1024 512 2048 1024 32 512 1024 512 1024 2048 512 1024\r\n> 344 512 2048 1024 16 512 1024 512 344 2048 1024 512 512 1024 2048 512 64\r\n> 1024 344 512 2048 1024 512 256 1024 2048 512 16 512 1024 2048 512 1024\r\n> 512 1024 2048 88 1024 8 8 ...\r\n>\r\n> A span is aligned to a page size, which is 4096 bytes. Embedding the\r\n> type table directly into span itself would mean that the above numbers\r\n> have to be rounded to a multiple of 4096.\r\n\r\nWhat they have to be rounded to 4096?\r\nA single 4096-byte span can hold lots of 8-byte allocations and the\r\nassociated type info, no rounding is required.\r\n\r\n\r\n> This would increase memory\r\n> consumption.\r\n>\r\n> I would like to close this CL (9716045) soon if possible. There is a lot\r\n> of other improvements ahead.\r\n",
			"disapproval": false,
			"date": "2013-06-05 13:36:49.434900",
			"approval": false
		},
		{
			"sender": "0xE2.0x9A.0x9B@gmail.com",
			"recipients": [
				"0xE2.0x9A.0x9B@gmail.com",
				"golang-dev@googlegroups.com",
				"khr@golang.org",
				"khr@google.com",
				"cshapiro@google.com",
				"dvyukov@google.com",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/06/05 13:36:49, dvyukov wrote:\n> On Wed, Jun 5, 2013 at 5:29 PM,  <mailto:0xE2.0x9A.0x9B@gmail.com> wrote:\n> > The typical size of a memory block holding typeinfos is about 1024\n> > bytes. The list of memory allocation requests for the parser benchmark\n> > looks as follows (size in bytes, 32-bit platform):\n> >\n> > ... 2048 512 1024 512 2048 1024 344 512 144 168 256 128 1024 344 512\n> > 2048 1024 256 512 1024 512 2048 1024 32 512 1024 512 1024 2048 512 1024\n> > 344 512 2048 1024 16 512 1024 512 344 2048 1024 512 512 1024 2048 512 64\n> > 1024 344 512 2048 1024 512 256 1024 2048 512 16 512 1024 2048 512 1024\n> > 512 1024 2048 88 1024 8 8 ...\n> >\n> > A span is aligned to a page size, which is 4096 bytes. Embedding the\n> > type table directly into span itself would mean that the above numbers\n> > have to be rounded to a multiple of 4096.\n> \n> What they have to be rounded to 4096?\n> A single 4096-byte span can hold lots of 8-byte allocations and the\n> associated type info, no rounding is required.\n\nI don't have enough vitality. I am closing this CL.",
			"disapproval": false,
			"date": "2013-06-05 14:40:35.610490",
			"approval": false
		}
	],
	"owner_email": "0xE2.0x9A.0x9B@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "atom",
	"subject": "code review 9716045: runtime: simplify runtime\u00b7settype()",
	"created": "2013-05-30 14:20:36.669030",
	"patchsets": [
		1,
		2001,
		5001,
		7001,
		1007,
		16001,
		18006,
		27001,
		32001,
		35001,
		41001,
		52001
	],
	"modified": "2013-06-05 14:40:44.365230",
	"closed": true,
	"issue": 9716045
}