{
	"description": "gc: inlining (disabled without -l)\n\nCross- and intra package inlining of single assignments or return <expression>.\nMinus some hairy cases, currently including other calls, expressions with closures and ... arguments.",
	"cc": [
		"rsc@golang.org",
		"rogpeppe@gmail.com",
		"adg@golang.org",
		"gri@golang.org",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"dave@cheney.net"
	],
	"messages": [
		{
			"sender": "adg@golang.org",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5400043/diff/24017/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/24017/src/cmd/gc/inl.c#newcode11\nsrc/cmd/gc/inl.c:11: // TODO(lvd) this CL contains just pass 1.\nBest to refer to the file, not the CL.\n\n// TODO(lvd): implement the second and third passes.",
			"disapproval": false,
			"date": "2011-11-30 23:26:01.378624",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I am going to wait to review this until the other CL is\ndone being reviewed and checked in, just so that I can\nsee the diffs.",
			"disapproval": false,
			"date": "2011-12-01 05:01:52.253026",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 1, 2011 at 06:01, <rsc@golang.org> wrote:\n\n> I am going to wait to review this until the other CL is\n> done being reviewed and checked in, just so that I can\n> see the diffs.\n>\n\ni was going to suggest that.  but you may want this one to test and play\nand break things in the other one.\n\n\n>\n>\n> http://codereview.appspot.com/**5400043/<http://codereview.appspot.com/5400043/>\n>\n",
			"disapproval": false,
			"date": "2011-12-01 06:54:49.263656",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Nov 30, 2011 at 17:13, roger peppe <rogpeppe@gmail.com> wrote:\n\n> On 30 November 2011 16:05, Luuk van Dijk <lvd@google.com> wrote:\n> >\n> >\n> > On Wed, Nov 30, 2011 at 16:45, roger peppe <rogpeppe@gmail.com> wrote:\n> >>\n> >> out of curiosity, does this change significantly affect compilation\n> time?\n> >>\n> >\n> > on my otherwise idle macbook: cd pkg\n> >\n> > export GCFLAGS=-l; make nuke; time make\n> > real    0m23.535s\n> > user    0m15.211s\n> > sys     0m6.656s\n> >\n> > export GCFLAGS=; make nuke; time make\n> > real    0m24.127s\n> > user    0m15.180s\n> > sys     0m6.658s\n> >\n> > repeated each a few times without notable differences.  so i double\n> checked\n> > that with -l the packages actually have inline info, and not without -l\n> :-)\n>\n> 2.5% faster... i think we can live with that. how does that happen, then?\n>\n\ni think time in this setup is not very accurate.  'otherwise idle' included\nchrome open to read gmail for example.  but the point was: i didn't notice\ndifferences before and i rebuild the whole tree and run all tests all the\ntime.\n\nattached benchmark on regexp for the whole tree without vs with -l.  Note\nthat this is pretty conservative inlining still, mainly to test that the\nimport and export and basic AST glueing works.\n\nin particular, during make test, 6g reported (-ll):\n\nexec.go:76: can inline @\"\".(*machine).free as: method(@\"\".m *@\"\".machine)\nfunc(@\"\".t *@\"\".thread) { @\"\".m.@\"\".pool = append(@\"\".m.@\"\".pool, @\"\".t) }\nregexp.go:71: can inline @\"\".Error.Error as: method(@\"\".e @\"\".Error) func()\nstring { return string(@\"\".e) }\nregexp.go:96: can inline @\"\".(*Regexp).String as: method(@\"\".re\n*@\"\".Regexp) func() string { return @\"\".re.@\"\".expr }\nregexp.go:222: can inline @\"\".(*Regexp).NumSubexp as: method(@\"\".re\n*@\"\".Regexp) func() int { return @\"\".re.@\"\".numSubexp }\nregexp.go:243: can inline @\"\".newInputString as: func(@\"\".str string)\n*@\"\".inputString { return &@\"\".inputString{ @\"\".str:@\"\".str } }\nregexp.go:258: can inline @\"\".(*inputString).canCheckPrefix as:\nmethod(@\"\".i *@\"\".inputString) func() bool { return true }\nregexp.go:286: can inline @\"\".newInputBytes as: func(@\"\".str []byte)\n*@\"\".inputBytes { return &@\"\".inputBytes{ @\"\".str:@\"\".str } }\nregexp.go:301: can inline @\"\".(*inputBytes).canCheckPrefix as: method(@\"\".i\n*@\"\".inputBytes) func() bool { return true }\nregexp.go:331: can inline @\"\".newInputReader as: func(@\"\".r\n@\"io\".RuneReader) *@\"\".inputReader { return &@\"\".inputReader{ @\"\".r:@\"\".r }\n}\nregexp.go:349: can inline @\"\".(*inputReader).canCheckPrefix as:\nmethod(@\"\".i *@\"\".inputReader) func() bool { return false }\nregexp.go:353: can inline @\"\".(*inputReader).hasPrefix as: method(@\"\".i\n*@\"\".inputReader) func(@\"\".re *@\"\".Regexp) bool { return false }\nregexp.go:357: can inline @\"\".(*inputReader).index as: method(@\"\".i\n*@\"\".inputReader) func(@\"\".re *@\"\".Regexp, @\"\".pos int) int { return -1 }\nregexp.go:361: can inline @\"\".(*inputReader).context as: method(@\"\".i\n*@\"\".inputReader) func(@\"\".pos int) @\"regexp/syntax\".EmptyOp { return 0 }\nregexp.go:368: can inline @\"\".(*Regexp).LiteralPrefix as: method(@\"\".re\n*@\"\".Regexp) func() (@\"\".prefix string, @\"\".complete bool) { return\n@\"\".re.@\"\".prefix,\n@\"\".re.@\"\".prefixComplete }\nregexp.go:263: inlining call to strings.HasPrefix func(@\"strings\".s string\n\"noescape\", @\"strings\".prefix string \"noescape\") bool { return\nlen(@\"strings\".s) >= len(@\"strings\".prefix) &&\n@\"strings\".s[0:len(@\"strings\".prefix)] == @\"strings\".prefix }\n\nregexp.go:376: inlining call to newInputReader func(@\"\".r @\"io\".RuneReader)\n*@\"\".inputReader { return &@\"\".inputReader{ @\"\".r:@\"\".r } }\nregexp.go:382: inlining call to newInputString func(@\"\".str string)\n*@\"\".inputString { return &@\"\".inputString{ @\"\".str:@\"\".str } }\nregexp.go:388: inlining call to newInputBytes func(@\"\".str []byte)\n*@\"\".inputBytes { return &@\"\".inputBytes{ @\"\".str:@\"\".str } }\nregexp.go:440: inlining call to newInputString func(@\"\".str string)\n*@\"\".inputString { return &@\"\".inputString{ @\"\".str:@\"\".str } }\nregexp.go:492: inlining call to newInputBytes func(@\"\".str []byte)\n*@\"\".inputBytes { return &@\"\".inputBytes{ @\"\".str:@\"\".str } }\nregexp.go:582: inlining call to newInputString func(@\"\".str string)\n*@\"\".inputString { return &@\"\".inputString{ @\"\".str:@\"\".str } }\nregexp.go:584: inlining call to newInputBytes func(@\"\".str []byte)\n*@\"\".inputBytes { return &@\"\".inputBytes{ @\"\".str:@\"\".str } }\nregexp.go:626: inlining call to newInputBytes func(@\"\".str []byte)\n*@\"\".inputBytes { return &@\"\".inputBytes{ @\"\".str:@\"\".str } }\nregexp.go:638: inlining call to newInputBytes func(@\"\".str []byte)\n*@\"\".inputBytes { return &@\"\".inputBytes{ @\"\".str:@\"\".str } }\nregexp.go:651: inlining call to newInputString func(@\"\".str string)\n*@\"\".inputString { return &@\"\".inputString{ @\"\".str:@\"\".str } }\nregexp.go:663: inlining call to newInputString func(@\"\".str string)\n*@\"\".inputString { return &@\"\".inputString{ @\"\".str:@\"\".str } }\nregexp.go:675: inlining call to newInputReader func(@\"\".r @\"io\".RuneReader)\n*@\"\".inputReader { return &@\"\".inputReader{ @\"\".r:@\"\".r } }\nregexp.go:688: inlining call to newInputBytes func(@\"\".str []byte)\n*@\"\".inputBytes { return &@\"\".inputBytes{ @\"\".str:@\"\".str } }\nregexp.go:707: inlining call to newInputBytes func(@\"\".str []byte)\n*@\"\".inputBytes { return &@\"\".inputBytes{ @\"\".str:@\"\".str } }\nregexp.go:716: inlining call to newInputString func(@\"\".str string)\n*@\"\".inputString { return &@\"\".inputString{ @\"\".str:@\"\".str } }\nregexp.go:735: inlining call to newInputString func(@\"\".str string)\n*@\"\".inputString { return &@\"\".inputString{ @\"\".str:@\"\".str } }\nregexp.go:744: inlining call to newInputReader func(@\"\".r @\"io\".RuneReader)\n*@\"\".inputReader { return &@\"\".inputReader{ @\"\".r:@\"\".r } }\nexec_test.go:72: inlining call to testing.Short func() bool { return\n*@\"testing\".short }\nexec_test.go:86: inlining call to strings.HasSuffix func(@\"strings\".s\nstring \"noescape\", @\"strings\".suffix string \"noescape\") bool { return\nlen(@\"strings\".s) >= len(@\"strings\".suffix) &&\n@\"strings\".s[len(@\"strings\".s) - len(@\"strings\".suffix):] ==\n@\"strings\".suffix }\nfind_test.go:223: inlining call to strings.NewReader func(@\"strings\".s\nstring) *@\"strings\".Reader { return &@\"strings\".Reader{\n@\"strings\".s:@\"strings\".s,\n@\"strings\".i:0, @\"strings\".prevRune:-1 } }\nfind_test.go:425: inlining call to strings.NewReader func(@\"strings\".s\nstring) *@\"strings\".Reader { return &@\"strings\".Reader{\n@\"strings\".s:@\"strings\".s,\n@\"strings\".i:0, @\"strings\".prevRune:-1 } }\n\n/L\n",
			"disapproval": false,
			"date": "2011-11-30 16:21:55.510945",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5400043/diff/21024/src/cmd/gc/export.c\nFile src/cmd/gc/export.c (left):\n\nhttp://codereview.appspot.com/5400043/diff/21024/src/cmd/gc/export.c#oldcode130\nsrc/cmd/gc/export.c:130: }\nsorry, let me move this back",
			"disapproval": false,
			"date": "2011-12-07 19:04:36.932373",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Superficial comments.\nHave not tried to read inl.c for real yet.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c\nFile src/cmd/gc/export.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode94\nsrc/cmd/gc/export.c:94: for(;ll;ll=ll->next)\nfor(; ll; ll=ll->next)\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode99\nsrc/cmd/gc/export.c:99: reexportdep(Node *n) {\n\\n{\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode133\nsrc/cmd/gc/export.c:133: if(!t->sym && t->type) t = t->type;\nmultiple lines\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode134\nsrc/cmd/gc/export.c:134: if (t && t->sym && t->sym->def && t->sym->pkg != localpkg) {\nReferring to t->sym->def is usually wrong: the def field refers\nto the current definition of a symbol, but the definition might\nhave had a different meaning when it was actually used.\nCode should not refer to sym->def except during name\nresolution while parsing.\n\nFor example\n\ntype T int   // now \"T\"->def is this type\nfunc main() {\n    type T float  // now \"T\"->def is this type\n}\n// now \"T\"->def is the first type again\n\nEven if you are holding the t corresponding to the float type,\nt->sym->def will be the int type at this point, since parsing\nhas completed.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode153\nsrc/cmd/gc/export.c:153: methcmp(const void *va, const void *vb)\nMove back where it was, to make diffs smaller.\nOr send a separate CL doing nothing but moving the code.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode163\nsrc/cmd/gc/export.c:163: dumpexporttype(Type *t)\nMove back where it was, to make diffs smaller.\nOr send a separate CL doing nothing but moving the code.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.h#newcode997\nsrc/cmd/gc/go.h:997: void\tinlcalls(Node* fn);\nNode *fn\n(like surrounding lines)\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.y\nFile src/cmd/gc/go.y (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.y#newcode1298\nsrc/cmd/gc/go.y:1298: $$->type->nname = $$;\nI am a little confused about why a method type would\nhave a nname pointing at the method itself.\nWhat's going on here?\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.y#newcode1801\nsrc/cmd/gc/go.y:1801: if(debug['l'] > 2 && $2->inl) print (\"inl body:%+H\\n\", $2->inl);\nmultiple lines.  no space before ( in function call.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode50\nsrc/cmd/gc/inl.c:50: if (!fn->nname)\n,s/if (/if(/g\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode103\nsrc/cmd/gc/inl.c:103: ishairy(Node *n) {\n\\n{\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode116\nsrc/cmd/gc/inl.c:116: return ishairy(n->left) || ishairy(n->right) || ishairylist(n->list) || ishairylist(n->rlist)\nMaybe \\n after each ||?\nIt's very irregular right now.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode118\nsrc/cmd/gc/inl.c:118: || ishairylist(n->nbody) ||ishairylist(n->nelse);\ns2/||/|| /\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode396\nsrc/cmd/gc/inl.c:396: return;\n?\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode463\nsrc/cmd/gc/inl.c:463: (*np) = nod(OINLCALL, N, N);\nall the (*np) are kind of annoying.\n\nn = nod...\n*np = n\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode585\nsrc/cmd/gc/inl.c:585: // fallthrough\nhardly seems worth it for 'return n'\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c\nFile src/cmd/gc/lex.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode340\nsrc/cmd/gc/lex.c:340: // TODO, lazily do this only for used ones, but for now make sure they would pass\nOnly do for debug['l']\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode347\nsrc/cmd/gc/lex.c:347: if (debug['l']>2) print(\"typecheck import [%S] %lN { %#H }\\n\", l->n->sym, l->n, l->n->inl);\nmultiple lines\n,s/if (/if(/g\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode363\nsrc/cmd/gc/lex.c:363: // Expand inlineable calls in all functions\nindent to match code?\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode367\nsrc/cmd/gc/lex.c:367: }\nblank line before next phase?",
			"disapproval": false,
			"date": "2011-12-07 20:56:54.481178",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 1, 2011 at 00:26, <adg@golang.org> wrote:\n\n>\n> http://codereview.appspot.com/**5400043/diff/24017/src/cmd/gc/**inl.c<http://codereview.appspot.com/5400043/diff/24017/src/cmd/gc/inl.c>\n> File src/cmd/gc/inl.c (right):\n>\n> http://codereview.appspot.com/**5400043/diff/24017/src/cmd/gc/**\n> inl.c#newcode11<http://codereview.appspot.com/5400043/diff/24017/src/cmd/gc/inl.c#newcode11>\n> src/cmd/gc/inl.c:11: // TODO(lvd) this CL contains just pass 1.\n>\n\nthis comment is no longer true.  it comes from the other one with just the\nimport/export (and i took inl.c out of that completely later)\n\n\n> Best to refer to the file, not the CL.\n>\n> // TODO(lvd): implement the second and third passes.\n>\n> http://codereview.appspot.com/**5400043/<http://codereview.appspot.com/5400043/>\n>\n",
			"disapproval": false,
			"date": "2011-12-01 06:52:17.458475",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2011-11-30 15:37:44.002780",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "out of curiosity, does this change significantly affect compilation time?\n\nOn 30 November 2011 15:37,  <lvd@google.com> wrote:\n> Reviewers: rsc,\n>\n> Message:\n> Hello rsc@golang.org (cc: golang-dev@googlegroups.com),\n>\n> I'd like you to review this change to\n> https://go.googlecode.com/hg/\n>\n>\n> Description:\n> gc: inlining\n>\n> Depends on 5451050 and contains 5431046.\n>\n> Cross- and intra package inlining of single assignments or return\n> <expression>.\n> Minus some hairy cases, currently including other calls, expressions\n> with closures and ... arguments.\n>\n> Please review this at http://codereview.appspot.com/5400043/\n>\n> Affected files:\n> \u00a0M src/cmd/gc/Makefile\n> \u00a0M src/cmd/gc/builtin.c.boot\n> \u00a0M src/cmd/gc/dcl.c\n> \u00a0M src/cmd/gc/export.c\n> \u00a0M src/cmd/gc/fmt.c\n> \u00a0M src/cmd/gc/go.h\n> \u00a0M src/cmd/gc/go.y\n> \u00a0M src/cmd/gc/init.c\n> \u00a0A src/cmd/gc/inl.c\n> \u00a0M src/cmd/gc/lex.c\n> \u00a0M src/cmd/gc/subr.c\n> \u00a0M src/cmd/gc/typecheck.c\n> \u00a0M src/cmd/gc/walk.c\n> \u00a0M src/pkg/Makefile\n>\n>\n",
			"disapproval": false,
			"date": "2011-11-30 15:45:49.335271",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Nov 30, 2011 at 16:45, roger peppe <rogpeppe@gmail.com> wrote:\n\n> out of curiosity, does this change significantly affect compilation time?\n>\n>\non my otherwise idle macbook: cd pkg\n\nexport GCFLAGS=-l; make nuke; time make\nreal    0m23.535s\nuser    0m15.211s\nsys     0m6.656s\n\nexport GCFLAGS=; make nuke; time make\nreal    0m24.127s\nuser    0m15.180s\nsys     0m6.658s\n\nrepeated each a few times without notable differences.  so i double checked\nthat with -l the packages actually have inline info, and not without -l :-)\n",
			"disapproval": false,
			"date": "2011-11-30 16:05:06.192062",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 30 November 2011 16:05, Luuk van Dijk <lvd@google.com> wrote:\n>\n>\n> On Wed, Nov 30, 2011 at 16:45, roger peppe <rogpeppe@gmail.com> wrote:\n>>\n>> out of curiosity, does this change significantly affect compilation time?\n>>\n>\n> on my otherwise idle macbook: cd pkg\n>\n> export GCFLAGS=-l; make nuke; time make\n> real \u00a0 \u00a00m23.535s\n> user \u00a0 \u00a00m15.211s\n> sys \u00a0 \u00a0 0m6.656s\n>\n> export GCFLAGS=; make nuke; time make\n> real \u00a0 \u00a00m24.127s\n> user \u00a0 \u00a00m15.180s\n> sys \u00a0 \u00a0 0m6.658s\n>\n> repeated each a few times without notable differences. \u00a0so i double checked\n> that with -l the packages actually have inline info, and not without -l :-)\n\n2.5% faster... i think we can live with that. how does that happen, then?\n\nmarvellous stuff BTW, thanks for all your hard work.\n",
			"disapproval": false,
			"date": "2011-11-30 16:13:19.313221",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello rsc@golang.org, rogpeppe@gmail.com, adg@golang.org, gri@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2011-12-07 18:52:16.392687",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "FYI.\n\ngcimporter changes LGTM\n\nhttp://codereview.appspot.com/5400043/diff/21024/src/pkg/exp/types/gcimporter.go\nFile src/pkg/exp/types/gcimporter.go (right):\n\nhttp://codereview.appspot.com/5400043/diff/21024/src/pkg/exp/types/gcimporter.go#newcode148\nsrc/pkg/exp/types/gcimporter.go:148: // during imports, anything may have been declared before - if it exists\n// the object may have been imported before - if it exists\n// already in the respective package scope, return that object\n\nhttp://codereview.appspot.com/5400043/diff/21024/src/pkg/exp/types/gcimporter.go#newcode156\nsrc/pkg/exp/types/gcimporter.go:156: // for a newly declared object -\n// otherwise create a new object and insert it into the package scope",
			"disapproval": false,
			"date": "2011-12-07 19:04:54.412423",
			"approval": true
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "all done\n\nOn Wed, Dec 7, 2011 at 20:04, <gri@golang.org> wrote:\n\n> FYI.\n>\n> gcimporter changes LGTM\n>\n>\n> http://codereview.appspot.com/**5400043/diff/21024/src/pkg/**\n> exp/types/gcimporter.go<http://codereview.appspot.com/5400043/diff/21024/src/pkg/exp/types/gcimporter.go>\n> File src/pkg/exp/types/gcimporter.**go (right):\n>\n> http://codereview.appspot.com/**5400043/diff/21024/src/pkg/**\n> exp/types/gcimporter.go#**newcode148<http://codereview.appspot.com/5400043/diff/21024/src/pkg/exp/types/gcimporter.go#newcode148>\n> src/pkg/exp/types/gcimporter.**go:148: // during imports, anything may\n> have been declared before - if it exists\n> // the object may have been imported before - if it exists\n> // already in the respective package scope, return that object\n> alhttp://codereview.appspot.com/**5400043/diff/21024/src/pkg/**\n> exp/types/gcimporter.go#**newcode156<http://codereview.appspot.com/5400043/diff/21024/src/pkg/exp/types/gcimporter.go#newcode156>\n> src/pkg/exp/types/gcimporter.**go:156: // for a newly declared object -\n> // otherwise create a new object and insert it into the package scope\n>\n> http://codereview.appspot.com/**5400043/<http://codereview.appspot.com/5400043/>\n>\n",
			"disapproval": false,
			"date": "2011-12-07 19:07:31.057597",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "added gri because i had to make 1 extra change to gcimporter.  b/c of\nreexports of anything referred to in inlined bodies, during imports things\ncan get redefined.  in gcimporter i just check that the kinds are equal, 6g\nchecks that types are equal (mostly).  i can iterate on that later.\n\nthis CL includes {intra,cross}-package inlining of methods and functions\nconsisting of a single assignment or return <expression>, not containing\nother calls or closures, and no ... args.  roughly the smallest thing that\nbuilds the whole tree without errors and actually inlines stuff.\n\nit includes an older CL that no longer exist that rsc reviewed months ago,\nthat did only the intra-package inlining (wow that was _easy_ in\nretrospect).  I adressed all comments from back then except the comment\nnoted with NOTE in inl.c\n\ni need to make 1 more sweep to mop up commented-out prints and perhaps a\nstray #if 0, but that shouldn't stand in the way of a thorough review.\n\n-l enables inlining, -ll reports inlinable candidates + actual inlined\ncalls, more 'l's add more diagnostic noise.  I'll trim that down later as\nwell, but if you want to patch in to review you might like to use it.\n\n/L\n",
			"disapproval": false,
			"date": "2011-12-07 19:00:30.104801",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Dec 7, 2011 at 21:56, <rsc@golang.org> wrote:\n\n> Superficial comments.\n> Have not tried to read inl.c for real yet.\n>\n>\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**export.c<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c>\n> File src/cmd/gc/export.c (right):\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> export.c#newcode94<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode94>\n> src/cmd/gc/export.c:94: for(;ll;ll=ll->next)\n> for(; ll; ll=ll->next)\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> export.c#newcode99<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode99>\n> src/cmd/gc/export.c:99: reexportdep(Node *n) {\n> \\n{\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> export.c#newcode133<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode133>\n> src/cmd/gc/export.c:133: if(!t->sym && t->type) t = t->type;\n> multiple lines\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> export.c#newcode134<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode134>\n> src/cmd/gc/export.c:134: if (t && t->sym && t->sym->def && t->sym->pkg\n> != localpkg) {\n> Referring to t->sym->def is usually wrong: the def field refers\n> to the current definition of a symbol, but the definition might\n> have had a different meaning when it was actually used.\n> Code should not refer to sym->def except during name\n> resolution while parsing.\n>\n> For example\n>\n> type T int   // now \"T\"->def is this type\n> func main() {\n>    type T float  // now \"T\"->def is this type\n> }\n> // now \"T\"->def is the first type again\n>\n> Even if you are holding the t corresponding to the float type,\n> t->sym->def will be the int type at this point, since parsing\n> has completed.\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> export.c#newcode153<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode153>\n> src/cmd/gc/export.c:153: methcmp(const void *va, const void *vb)\n> Move back where it was, to make diffs smaller.\n> Or send a separate CL doing nothing but moving the code.\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> export.c#newcode163<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode163>\n> src/cmd/gc/export.c:163: dumpexporttype(Type *t)\n> Move back where it was, to make diffs smaller.\n> Or send a separate CL doing nothing but moving the code.\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**go.h<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.h>\n> File src/cmd/gc/go.h (right):\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> go.h#newcode997<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.h#newcode997>\n> src/cmd/gc/go.h:997: void       inlcalls(Node* fn);\n> Node *fn\n> (like surrounding lines)\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**go.y<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.y>\n> File src/cmd/gc/go.y (right):\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> go.y#newcode1298<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.y#newcode1298>\n> src/cmd/gc/go.y:1298: $$->type->nname = $$;\n> I am a little confused about why a method type would\n> have a nname pointing at the method itself.\n> What's going on here?\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> go.y#newcode1801<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.y#newcode1801>\n> src/cmd/gc/go.y:1801: if(debug['l'] > 2 && $2->inl) print (\"inl\n> body:%+H\\n\", $2->inl);\n> multiple lines.  no space before ( in function call.\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**inl.c<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c>\n> File src/cmd/gc/inl.c (right):\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> inl.c#newcode50<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode50>\n> src/cmd/gc/inl.c:50: if (!fn->nname)\n> ,s/if (/if(/g\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> inl.c#newcode103<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode103>\n> src/cmd/gc/inl.c:103: ishairy(Node *n) {\n> \\n{\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> inl.c#newcode116<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode116>\n> src/cmd/gc/inl.c:116: return ishairy(n->left) || ishairy(n->right) ||\n> ishairylist(n->list) || ishairylist(n->rlist)\n> Maybe \\n after each ||?\n> It's very irregular right now.\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> inl.c#newcode118<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode118>\n> src/cmd/gc/inl.c:118: || ishairylist(n->nbody) ||ishairylist(n->nelse);\n> s2/||/|| /\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> inl.c#newcode396<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode396>\n> src/cmd/gc/inl.c:396: return;\n> ?\n>\n\ndoh. put that there to get everything else working before worrying about\ngluing in the receiver argument.  shouldn't try to rush things in the\nevening.  will ping you again tomorrow after adressing all the rest as well.\n\n\n\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> inl.c#newcode463<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode463>\n> src/cmd/gc/inl.c:463: (*np) = nod(OINLCALL, N, N);\n> all the (*np) are kind of annoying.\n>\n> n = nod...\n> *np = n\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> inl.c#newcode585<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode585>\n> src/cmd/gc/inl.c:585: // fallthrough\n> hardly seems worth it for 'return n'\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**lex.c<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c>\n> File src/cmd/gc/lex.c (right):\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> lex.c#newcode340<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode340>\n> src/cmd/gc/lex.c:340: // TODO, lazily do this only for used ones, but\n> for now make sure they would pass\n> Only do for debug['l']\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> lex.c#newcode347<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode347>\n> src/cmd/gc/lex.c:347: if (debug['l']>2) print(\"typecheck import [%S] %lN\n> { %#H }\\n\", l->n->sym, l->n, l->n->inl);\n> multiple lines\n> ,s/if (/if(/g\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> lex.c#newcode363<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode363>\n> src/cmd/gc/lex.c:363: // Expand inlineable calls in all functions\n> indent to match code?\n>\n> http://codereview.appspot.com/**5400043/diff/23054/src/cmd/gc/**\n> lex.c#newcode367<http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode367>\n> src/cmd/gc/lex.c:367: }\n> blank line before next phase?\n>\n> http://codereview.appspot.com/**5400043/<http://codereview.appspot.com/5400043/>\n>\n",
			"disapproval": false,
			"date": "2011-12-07 22:05:03.036099",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "all done\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c\nFile src/cmd/gc/export.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode94\nsrc/cmd/gc/export.c:94: for(;ll;ll=ll->next)\nOn 2011/12/07 20:56:54, rsc wrote:\n> for(; ll; ll=ll->next)\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode99\nsrc/cmd/gc/export.c:99: reexportdep(Node *n) {\nOn 2011/12/07 20:56:54, rsc wrote:\n> \\n{\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode134\nsrc/cmd/gc/export.c:134: if (t && t->sym && t->sym->def && t->sym->pkg != localpkg) {\nOn 2011/12/07 20:56:54, rsc wrote:\n> Referring to t->sym->def is usually wrong: the def field refers\n> to the current definition of a symbol, but the definition might\n> have had a different meaning when it was actually used.\n> Code should not refer to sym->def except during name\n> resolution while parsing.\n> \n\ni realize that, but the exportlist (of nodes) is used below to dump their ->sym->def's so i figured anything that needs dumping apparently will have sym->def set right.\n\nof course that could mean i put global types spuriously on the list here if they're locally aliased.  need to think on how to fix that.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/export.c#newcode163\nsrc/cmd/gc/export.c:163: dumpexporttype(Type *t)\nOn 2011/12/07 20:56:54, rsc wrote:\n> Move back where it was, to make diffs smaller.\n> Or send a separate CL doing nothing but moving the code.\nyes, sorry.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.h#newcode997\nsrc/cmd/gc/go.h:997: void\tinlcalls(Node* fn);\nOn 2011/12/07 20:56:54, rsc wrote:\n> Node *fn\n> (like surrounding lines)\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.y\nFile src/cmd/gc/go.y (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.y#newcode1298\nsrc/cmd/gc/go.y:1298: $$->type->nname = $$;\nOn 2011/12/07 20:56:54, rsc wrote:\n> I am a little confused about why a method type would\n> have a nname pointing at the method itself.\n> What's going on here?\n\nadded comment\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/go.y#newcode1801\nsrc/cmd/gc/go.y:1801: if(debug['l'] > 2 && $2->inl) print (\"inl body:%+H\\n\", $2->inl);\nOn 2011/12/07 20:56:54, rsc wrote:\n> multiple lines.  no space before ( in function call.\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode50\nsrc/cmd/gc/inl.c:50: if (!fn->nname)\nOn 2011/12/07 20:56:54, rsc wrote:\n> ,s/if (/if(/g\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode116\nsrc/cmd/gc/inl.c:116: return ishairy(n->left) || ishairy(n->right) || ishairylist(n->list) || ishairylist(n->rlist)\nOn 2011/12/07 20:56:54, rsc wrote:\n> Maybe \\n after each ||?\n> It's very irregular right now.\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode396\nsrc/cmd/gc/inl.c:396: return;\nOn 2011/12/07 20:56:54, rsc wrote:\n> ?\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode463\nsrc/cmd/gc/inl.c:463: (*np) = nod(OINLCALL, N, N);\nOn 2011/12/07 20:56:54, rsc wrote:\n> all the (*np) are kind of annoying.\n> \n> n = nod...\n> *np = n\n\nthey are only here, and n is the original used till the very end that i don't want to clobber, so i thought it would be clearer this way.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/inl.c#newcode585\nsrc/cmd/gc/inl.c:585: // fallthrough\nOn 2011/12/07 20:56:54, rsc wrote:\n> hardly seems worth it for 'return n'\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c\nFile src/cmd/gc/lex.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode340\nsrc/cmd/gc/lex.c:340: // TODO, lazily do this only for used ones, but for now make sure they would pass\nOn 2011/12/07 20:56:54, rsc wrote:\n> Only do for debug['l']\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode347\nsrc/cmd/gc/lex.c:347: if (debug['l']>2) print(\"typecheck import [%S] %lN { %#H }\\n\", l->n->sym, l->n, l->n->inl);\nOn 2011/12/07 20:56:54, rsc wrote:\n> multiple lines\n> ,s/if (/if(/g\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode363\nsrc/cmd/gc/lex.c:363: // Expand inlineable calls in all functions\nOn 2011/12/07 20:56:54, rsc wrote:\n> indent to match code?\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode367\nsrc/cmd/gc/lex.c:367: }\nOn 2011/12/07 20:56:54, rsc wrote:\n> blank line before next phase?\n\nDone.",
			"disapproval": false,
			"date": "2011-12-08 11:57:38.332319",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "not LGTM\nSorry, wrong window.\n",
			"disapproval": true,
			"date": "2011-12-09 12:59:30.180653",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c\nFile src/cmd/gc/lex.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/23054/src/cmd/gc/lex.c#newcode340\nsrc/cmd/gc/lex.c:340: // TODO, lazily do this only for used ones, but for now make sure they would pass\nOn 2011/12/08 11:57:38, lvd wrote:\n> On 2011/12/07 20:56:54, rsc wrote:\n> > Only do for debug['l']\n> \n> Done.\n\nand then spent 2 hours figuring out why exp/norm/test fails.  here's why:\neven if -l is false, the imported packages may still have inlined bodies, and these will be re-exported if they are methods  of types that are re-exported. but if they're not typechecked, len(...) will never be transformed from an OCALL @\"go.builtin\".len to OLEN etc. so in the re-export they get qualified, meaning that in the next import, or when the linker compares types, they have @\"go.builtin\".len (or @\"\".len in place of the len.\n\nsee the //!!? in lex.c where i can choose between those 2 options.\n\ni could also put some plaster over it all in export.   i think it's desirable if you can put -l on and off per-package for now.",
			"disapproval": false,
			"date": "2011-12-08 14:57:12.204291",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 8, 2011 at 09:57,  <lvd@google.com> wrote:\n> and then spent 2 hours figuring out why exp/norm/test fails. \u00a0here's\n> why:\n> even if -l is false, the imported packages may still have inlined\n> bodies, and these will be re-exported if they are methods \u00a0of types that\n> are re-exported. but if they're not typechecked, len(...) will never be\n> transformed from an OCALL @\"go.builtin\".len to OLEN etc. so in the\n> re-export they get qualified, meaning that in the next import, or when\n> the linker compares types, they have @\"go.builtin\".len (or @\"\".len in\n> place of the len.\n>\n> see the //!!? in lex.c where i can choose between those 2 options.\n>\n> i could also put some plaster over it all in export. \u00a0 i think it's\n> desirable if you can put -l on and off per-package for now.\n\ni expected that lack of -l meant 'do not export things for inlining',\n'do not do inlining in this package', and 'do not inline things from\nother packages'.  it sounds like it only disables the last two.\nthe main reason to have this flag is so that none of this code\n(which might have bugs) is active in normal use.  can we make\nit mean 'do not run any of the new code' (all 3)?\n\nruss\n",
			"disapproval": false,
			"date": "2011-12-08 21:59:09.048538",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "yes. i'll go fix the linker.\nOn Dec 8, 2011 10:59 PM, \"Russ Cox\" <rsc@golang.org> wrote:\n\n> On Thu, Dec 8, 2011 at 09:57,  <lvd@google.com> wrote:\n> > and then spent 2 hours figuring out why exp/norm/test fails.  here's\n> > why:\n> > even if -l is false, the imported packages may still have inlined\n> > bodies, and these will be re-exported if they are methods  of types that\n> > are re-exported. but if they're not typechecked, len(...) will never be\n> > transformed from an OCALL @\"go.builtin\".len to OLEN etc. so in the\n> > re-export they get qualified, meaning that in the next import, or when\n> > the linker compares types, they have @\"go.builtin\".len (or @\"\".len in\n> > place of the len.\n> >\n> > see the //!!? in lex.c where i can choose between those 2 options.\n> >\n> > i could also put some plaster over it all in export.   i think it's\n> > desirable if you can put -l on and off per-package for now.\n>\n> i expected that lack of -l meant 'do not export things for inlining',\n> 'do not do inlining in this package', and 'do not inline things from\n> other packages'.  it sounds like it only disables the last two.\n> the main reason to have this flag is so that none of this code\n> (which might have bugs) is active in normal use.  can we make\n> it mean 'do not run any of the new code' (all 3)?\n>\n> russ\n>\n",
			"disapproval": false,
			"date": "2011-12-09 06:37:59.296171",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nhttp://codereview.appspot.com/5400043/diff/37003/src/cmd/gc/export.c\nFile src/cmd/gc/export.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/37003/src/cmd/gc/export.c#newcode123\nsrc/cmd/gc/export.c:123: // for operations that need a type when rendered, put the type on the export list.\nWhat about operations that refer to a type definition implicitly?\nFor example, if you did\n\npackage p\ntype T struct { v *v }\ntype v struct { x int }\nfunc (t *T) Fetch() int { return t.v.x }\n\nthen the second dot should need to know the definition\nof v, but I don't see that being exported here.\n\nhttp://codereview.appspot.com/5400043/diff/37003/src/cmd/gc/lex.c\nFile src/cmd/gc/lex.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/37003/src/cmd/gc/lex.c#newcode338\nsrc/cmd/gc/lex.c:338: if(1) {\nShould be if(debug['l'])\n\nhttp://codereview.appspot.com/5400043/diff/37003/src/cmd/gc/lex.c#newcode1785\nsrc/cmd/gc/lex.c:1785: s1->def->sym = s1;  //!!?\nThis should be unnecessary as long as not passing -l really means \"no inlining\".\nIt might make sense to look for builtinpkg during export anyway, of course,\nsince there is no situation when printing @\"go.builtin\".int is preferable to int.",
			"disapproval": false,
			"date": "2011-12-09 12:59:13.838153",
			"approval": true
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "all addressed, all tests pass with GCFLAGS=, and all but 1 pass for GCFLAGS=-l\n\nthe one that doesnt is the malloc check in strconv/ftoa.  A fix for that is pending in 5483071, but since -l is off by default, i'l go ahead and check this in now.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/export.c\nFile src/cmd/gc/export.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/export.c#newcode122\nsrc/cmd/gc/export.c:122: \nOn 2011/12/13 21:00:16, rsc wrote:\n> There are many operations that use types implicitly, like anything\n> that copies a value (OAS, OCALL's parameters, etc) or things that\n> pick apart values (ODOT, OINDEX, OSLICE).  It seems like there is\n> more needed here.  It can and should wait for a later CL though.\n\nThe cases here cover the _rendering_ of the export section, everything that mentiones a type explicitly.  i'll see if i can come up with some tests that break through implicit use. because everthing else you list, when used in a function must come in trhough a param or a global, in which case they've been named with their type, or declared locally, for which the same holds.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode52\nsrc/cmd/gc/inl.c:52: // exactly 1 statement\nOn 2011/12/13 21:00:16, rsc wrote:\n> It would be good to have \n> \n> // Must not be just a declaration.\n> //     func Foo() // implemented in assembly\n> // must not turn into\n> //     func Foo() {}\n> if(fn->nbody == nil)\n>      return;\n> \n> and then the current // Exactly 1 statement.\n> Just so that if we relax the statement count we don't\n> accidentally relax the body requirement.\n> I am not sure how to distinguish no body from\n> empty body, but that should be here too.\n\ni think those have 1 OEMTPY as a body.  will check.\n\n> Empty body is probably fine for inlining now.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode114\nsrc/cmd/gc/inl.c:114: case OCLOSURE:\nOn 2011/12/13 21:00:16, rsc wrote:\n> Add\n> \n> case OFOR:\n> case OIF:\n> case OBLOCK:\n> case OSWITCH:\n> case OSELECT:\n> \n> Without any kind of bounds on the size of these, the inlining\n> would treat them all as '1-statement' and therefore okay to\n> inline, no matter how large.  So for now it seems okay to just\n> exclude them.  I believe that is all the complex statements.\n\nthats already covered by the requirement that the one statement is an assignment or return <expression>  the things you list can't occur inside an expression.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode214\nsrc/cmd/gc/inl.c:214: inlgluelist(Node *n) {\nOn 2011/12/13 21:00:16, rsc wrote:\n> \\n{\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode226\nsrc/cmd/gc/inl.c:226: inlgluerlist(Node *n) {\nOn 2011/12/13 21:00:16, rsc wrote:\n> \\n{\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode265\nsrc/cmd/gc/inl.c:265: n->left->etype = n->op;\nOn 2011/12/13 21:00:16, rsc wrote:\n> Not sure if this is safe.  If you have defer println(), for example,\n> is the etype meaningful in the OPRINTN node?  Maybe not.\n> But you'd want to check all the built-in functions.\n\nit was your suggestion at the time and i remember had exactly the same objection.  checked and yes, nobody does it but you can say go println(..), so i narrowed it down to OCALL{FUNC|METH}\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode392\nsrc/cmd/gc/inl.c:392: if (!fn->inl)\nOn 2011/12/13 21:00:16, rsc wrote:\n> ,s/if (/if(/g\n> \n> fn->inl == nil\n> to remind me that it's a pointer not a bool\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode482\nsrc/cmd/gc/inl.c:482: (*np) = nod(OINLCALL, N, N);\nOn 2011/12/13 21:00:16, rsc wrote:\n> I missed that there was a use of n later here.\n> Maybe have Node *call above and make this\n> call = ...\n> call->...\n> *np = call\n> \n> just so that no one is tempted to ,s/(*np)/n/ later.\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/lex.c\nFile src/cmd/gc/lex.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/lex.c#newcode339\nsrc/cmd/gc/lex.c:339: if (debug['l'] /* > 1 */) {  \t\t// TODO only if debug['l'] > 1, otherwise lazily when used.\nOn 2011/12/13 21:00:16, rsc wrote:\n> the TODO is sufficient.  drop the /* > 1 */\n> ,s/if (/if(/g\n\nDone.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/lex.c#newcode352\nsrc/cmd/gc/lex.c:352: l->n->inl = nil;  // type errors; discard\nOn 2011/12/13 21:00:16, rsc wrote:\n> Does this matter?  You're going to errorexit when the loop ends.\n\nDone.",
			"disapproval": false,
			"date": "2011-12-14 13:51:58.127669",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "thought so.   i'm working on that if(1) -> if(debug['l']) now, by\nmaking the linker skip the bodies when comparing types\n\nOn Fri, Dec 9, 2011 at 13:59, Russ Cox <rsc@golang.org> wrote:\n> not LGTM\n> Sorry, wrong window.\n",
			"disapproval": false,
			"date": "2011-12-09 13:01:20.587098",
			"approval": false
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Fantastic!\n\nSent from my iPad\n\nOn 15/12/2011, at 1:05, lvd@google.com wrote:\n\n> *** Submitted as\n> http://code.google.com/p/go/source/detail?r=bba6fb4199df ***\n> \n> gc: inlining (disabled without -l)\n> \n> Cross- and intra package inlining of single assignments or return\n> <expression>.\n> Minus some hairy cases, currently including other calls, expressions\n> with closures and ... arguments.\n> \n> R=rsc, rogpeppe, adg, gri\n> CC=golang-dev\n> http://codereview.appspot.com/5400043\n> \n> \n> http://codereview.appspot.com/5400043/\n",
			"disapproval": false,
			"date": "2011-12-14 20:23:38.755263",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nLet's get this in and then future CLs can address\nsome of the generality issues.  Please change CL\ndescription first line to\n\ngc: inlining (disabled without -l)\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/export.c\nFile src/cmd/gc/export.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/export.c#newcode122\nsrc/cmd/gc/export.c:122: \nThere are many operations that use types implicitly, like anything\nthat copies a value (OAS, OCALL's parameters, etc) or things that\npick apart values (ODOT, OINDEX, OSLICE).  It seems like there is\nmore needed here.  It can and should wait for a later CL though.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c\nFile src/cmd/gc/inl.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode52\nsrc/cmd/gc/inl.c:52: // exactly 1 statement\nIt would be good to have \n\n// Must not be just a declaration.\n//     func Foo() // implemented in assembly\n// must not turn into\n//     func Foo() {}\nif(fn->nbody == nil)\n     return;\n\nand then the current // Exactly 1 statement.\nJust so that if we relax the statement count we don't\naccidentally relax the body requirement.\nI am not sure how to distinguish no body from\nempty body, but that should be here too.\nEmpty body is probably fine for inlining now.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode114\nsrc/cmd/gc/inl.c:114: case OCLOSURE:\nAdd\n\ncase OFOR:\ncase OIF:\ncase OBLOCK:\ncase OSWITCH:\ncase OSELECT:\n\nWithout any kind of bounds on the size of these, the inlining\nwould treat them all as '1-statement' and therefore okay to\ninline, no matter how large.  So for now it seems okay to just\nexclude them.  I believe that is all the complex statements.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode214\nsrc/cmd/gc/inl.c:214: inlgluelist(Node *n) {\n\\n{\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode226\nsrc/cmd/gc/inl.c:226: inlgluerlist(Node *n) {\n\\n{\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode265\nsrc/cmd/gc/inl.c:265: n->left->etype = n->op;\nNot sure if this is safe.  If you have defer println(), for example,\nis the etype meaningful in the OPRINTN node?  Maybe not.\nBut you'd want to check all the built-in functions.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode392\nsrc/cmd/gc/inl.c:392: if (!fn->inl)\n,s/if (/if(/g\n\nfn->inl == nil\nto remind me that it's a pointer not a bool\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode468\nsrc/cmd/gc/inl.c:468: // make the outparams.  No need to declare because they'll only be used in the assignment that replaces returns.\nThis is true today but not likely to be true forever.\nFor example\n\nfunc nop(x int) (r int) { r = x; return }\n\nMaybe the out parameters should just be declared above\nif they have names?  Can wait for a later CL.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/inl.c#newcode482\nsrc/cmd/gc/inl.c:482: (*np) = nod(OINLCALL, N, N);\nI missed that there was a use of n later here.\nMaybe have Node *call above and make this\ncall = ...\ncall->...\n*np = call\n\njust so that no one is tempted to ,s/(*np)/n/ later.\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/lex.c\nFile src/cmd/gc/lex.c (right):\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/lex.c#newcode339\nsrc/cmd/gc/lex.c:339: if (debug['l'] /* > 1 */) {  \t\t// TODO only if debug['l'] > 1, otherwise lazily when used.\nthe TODO is sufficient.  drop the /* > 1 */\n,s/if (/if(/g\n\nhttp://codereview.appspot.com/5400043/diff/44002/src/cmd/gc/lex.c#newcode352\nsrc/cmd/gc/lex.c:352: l->n->inl = nil;  // type errors; discard\nDoes this matter?  You're going to errorexit when the loop ends.",
			"disapproval": false,
			"date": "2011-12-13 21:00:15.983787",
			"approval": true
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"lvd@google.com",
				"rsc@golang.org",
				"rogpeppe@gmail.com",
				"adg@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=bba6fb4199df ***\n\ngc: inlining (disabled without -l)\n\nCross- and intra package inlining of single assignments or return <expression>.\nMinus some hairy cases, currently including other calls, expressions with closures and ... arguments.\n\nR=rsc, rogpeppe, adg, gri\nCC=golang-dev\nhttp://codereview.appspot.com/5400043",
			"disapproval": false,
			"date": "2011-12-14 14:05:39.735088",
			"approval": false
		}
	],
	"owner_email": "lvd@google.com",
	"private": false,
	"base_url": "",
	"owner": "lvd",
	"subject": "code review 5400043: gc: inlining",
	"created": "2011-11-16 14:16:30.981753",
	"patchsets": [
		1,
		3,
		2001,
		4001,
		7001,
		9001,
		10001,
		10002,
		12014,
		14002,
		12015,
		11014,
		17002,
		18002,
		21003,
		24002,
		25002,
		24017,
		21008,
		21023,
		22045,
		24018,
		28016,
		21024,
		25025,
		23054,
		31002,
		33002,
		34012,
		37003,
		39003,
		44002,
		46003
	],
	"modified": "2011-12-14 20:23:38.815183",
	"closed": true,
	"issue": 5400043
}