{
	"description": "      database/sql: ensure Stmts are correctly closed.\n\nTo make sure that there is no resource leak,\nI suggest to fix the 'fakedb' driver such as it fails when any\nStmt is not closed.\nFirst, add a check in fakeConn.Close().\nThen, fix all missing Stmt.Close()/Rows.Close().\nI am not sure that the strategy choose in fakeConn.Prepare/prepare* is ok.\nThe weak point in this patch is the change in Tx.Query:\n  - Tests pass without this change,\n  - I found it by manually analyzing the code,\n  - I just try to make Tx.Query look like DB.Query.",
	"cc": [
		"golang-dev@googlegroups.com",
		"bradfitz@golang.org"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Gwenn,\n\nThis patch looks fine to me, but just so I understand: does this fix any\nreal bug?\n\nI see it does fix a statement leak if there's an invalid Stmt.Query after\nPrepare, which is good to fix, but minor.\n\nAnd you say that the Tx change is \"the weak point\" in this patch... why?\n It seems fine.\n\n\nOn Tue, Mar 6, 2012 at 7:12 PM, <gwenn.kahz@gmail.com> wrote:\n\n> Reviewers: golang-dev_googlegroups.com,\n>\n> Message:\n> Hello golang-dev@googlegroups.com,\n>\n> I'd like you to review this change to\n> https://go.googlecode.com/hg\n>\n>\n> Description:\n>      database/sql: ensure Stmts are correctly closed.\n>\n> To make sure that there is no resource leak,\n> I suggest to fix the 'fakedb' driver such as it fails when any\n> Stmt is not closed.\n> First, add a check in fakeConn.Close().\n> Then, fix all missing Stmt.Close()/Rows.Close().\n> I am not sure that the strategy choose in fakeConn.Prepare/prepare* is\n> ok.\n> The weak point in this patch is the change in Tx.Query:\n>  - Tests pass without this change,\n>  - I found it by manually analyzing the code,\n>  - I just try to make Tx.Query look like DB.Query.\n>\n> Please review this at http://codereview.appspot.com/**5759050/<http://codereview.appspot.com/5759050/>\n>\n> Affected files:\n>  M src/pkg/database/sql/fakedb_**test.go\n>  M src/pkg/database/sql/sql.go\n>  M src/pkg/database/sql/sql_test.**go\n>\n>\n> Index: src/pkg/database/sql/fakedb_**test.go\n> ==============================**==============================**=======\n> --- a/src/pkg/database/sql/fakedb_**test.go\n> +++ b/src/pkg/database/sql/fakedb_**test.go\n> @@ -213,6 +213,9 @@\n>        if c.db == nil {\n>                return errors.New(\"can't close; already closed\")\n>        }\n> +       if c.stmtsMade > c.stmtsClosed {\n> +               return errors.New(\"can't close; dangling statement(s)\")\n> +       }\n>        c.db = nil\n>        return nil\n>  }\n> @@ -249,6 +252,7 @@\n>  //  just a limitation for fakedb)\n>  func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string)\n> (driver.Stmt, error) {\n>        if len(parts) != 3 {\n> +               stmt.Close()\n>                return nil, errf(\"invalid SELECT syntax with %d parts; want\n> 3\", len(parts))\n>        }\n>        stmt.table = parts[0]\n> @@ -259,14 +263,17 @@\n>                }\n>                nameVal := strings.Split(colspec, \"=\")\n>                if len(nameVal) != 2 {\n> +                       stmt.Close()\n>                        return nil, errf(\"SELECT on table %q has invalid\n> column spec of %q (index %d)\", stmt.table, colspec, n)\n>                }\n>                column, value := nameVal[0], nameVal[1]\n>                _, ok := c.db.columnType(stmt.table, column)\n>                if !ok {\n> +                       stmt.Close()\n>                        return nil, errf(\"SELECT on table %q references\n> non-existent column %q\", stmt.table, column)\n>                }\n>                if value != \"?\" {\n> +                       stmt.Close()\n>                        return nil, errf(\"SELECT on table %q has pre-bound\n> value for where column %q; need a question mark\",\n>                                stmt.table, column)\n>                }\n> @@ -279,12 +286,14 @@\n>  // parts are table|col=type,col2=type2\n>  func (c *fakeConn) prepareCreate(stmt *fakeStmt, parts []string)\n> (driver.Stmt, error) {\n>        if len(parts) != 2 {\n> +               stmt.Close()\n>                return nil, errf(\"invalid CREATE syntax with %d parts; want\n> 2\", len(parts))\n>        }\n>        stmt.table = parts[0]\n>        for n, colspec := range strings.Split(parts[1], \",\") {\n>                nameType := strings.Split(colspec, \"=\")\n>                if len(nameType) != 2 {\n> +                       stmt.Close()\n>                        return nil, errf(\"CREATE table %q has invalid\n> column spec of %q (index %d)\", stmt.table, colspec, n)\n>                }\n>                stmt.colName = append(stmt.colName, nameType[0])\n> @@ -296,17 +305,20 @@\n>  // parts are table|col=?,col2=val\n>  func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string)\n> (driver.Stmt, error) {\n>        if len(parts) != 2 {\n> +               stmt.Close()\n>                return nil, errf(\"invalid INSERT syntax with %d parts; want\n> 2\", len(parts))\n>        }\n>        stmt.table = parts[0]\n>        for n, colspec := range strings.Split(parts[1], \",\") {\n>                nameVal := strings.Split(colspec, \"=\")\n>                if len(nameVal) != 2 {\n> +                       stmt.Close()\n>                        return nil, errf(\"INSERT table %q has invalid\n> column spec of %q (index %d)\", stmt.table, colspec, n)\n>                }\n>                column, value := nameVal[0], nameVal[1]\n>                ctype, ok := c.db.columnType(stmt.table, column)\n>                if !ok {\n> +                       stmt.Close()\n>                        return nil, errf(\"INSERT table %q references\n> non-existent column %q\", stmt.table, column)\n>                }\n>                stmt.colName = append(stmt.colName, column)\n> @@ -322,10 +334,12 @@\n>                        case \"int32\":\n>                                i, err := strconv.Atoi(value)\n>                                if err != nil {\n> +                                       stmt.Close()\n>                                        return nil, errf(\"invalid\n> conversion to int32 from %q\", value)\n>                                }\n>                                subsetVal = int64(i) // int64 is a subset\n> type, but not int32\n>                        default:\n> +                               stmt.Close()\n>                                return nil, errf(\"unsupported conversion\n> for pre-bound parameter %q to type %q\", value, ctype)\n>                        }\n>                        stmt.colValue = append(stmt.colValue, subsetVal)\n> @@ -360,6 +374,7 @@\n>        case \"INSERT\":\n>                return c.prepareInsert(stmt, parts)\n>        default:\n> +               stmt.Close()\n>                return nil, errf(\"unsupported command type %q\", cmd)\n>        }\n>        return stmt, nil\n> Index: src/pkg/database/sql/sql.go\n> ==============================**==============================**=======\n> --- a/src/pkg/database/sql/sql.go\n> +++ b/src/pkg/database/sql/sql.go\n> @@ -561,9 +561,11 @@\n>                return nil, err\n>        }\n>        rows, err := stmt.Query(args...)\n> -       if err == nil {\n> -               rows.closeStmt = stmt\n> +       if err != nil {\n> +               stmt.Close()\n> +               return nil, err\n>        }\n> +       rows.closeStmt = stmt\n>        return rows, err\n>  }\n>\n> @@ -963,7 +965,7 @@\n>        }\n>\n>        // TODO(bradfitz): for now we need to defensively clone all\n> -       // []byte that the driver returned (not permitting\n> +       // []byte that the driver returned (not permitting\n>        // *RawBytes in Rows.Scan), since we're about to close\n>        // the Rows in our defer, when we return from this function.\n>        // the contract with the driver.Next(...) interface is that it\n> Index: src/pkg/database/sql/sql_test.**go\n> ==============================**==============================**=======\n> --- a/src/pkg/database/sql/sql_**test.go\n> +++ b/src/pkg/database/sql/sql_**test.go\n> @@ -216,6 +216,7 @@\n>        if err != nil {\n>                t.Fatalf(\"Prepare: %v\", err)\n>        }\n> +       defer stmt.Close()\n>        var age int\n>        for n, tt := range []struct {\n>                name string\n> @@ -256,6 +257,7 @@\n>        if err != nil {\n>                t.Errorf(\"Stmt, err = %v, %v\", stmt, err)\n>        }\n> +       defer stmt.Close()\n>\n>        type execTest struct {\n>                args    []interface{}\n> @@ -297,11 +299,14 @@\n>        if err != nil {\n>                t.Fatalf(\"Stmt, err = %v, %v\", stmt, err)\n>        }\n> +       defer stmt.Close()\n>        tx, err := db.Begin()\n>        if err != nil {\n>                t.Fatalf(\"Begin = %v\", err)\n>        }\n> -       _, err = tx.Stmt(stmt).Exec(\"Bobby\", 7)\n> +       txs := tx.Stmt(stmt)\n> +       defer txs.Close()\n> +       _, err = txs.Exec(\"Bobby\", 7)\n>        if err != nil {\n>                t.Fatalf(\"Exec = %v\", err)\n>        }\n> @@ -330,6 +335,7 @@\n>        if err != nil {\n>                t.Fatal(err)\n>        }\n> +       defer r.Close()\n>\n>        if !r.Next() {\n>                if r.Err() != nil {\n> @@ -510,6 +516,7 @@\n>        if err != nil {\n>                t.Fatalf(\"prepare: %v\", err)\n>        }\n> +       defer stmt.Close()\n>        if _, err := stmt.Exec(3, \"chris\", spec.rows[2].nullParam,\n> spec.rows[2].notNullParam); err != nil {\n>                t.Errorf(\"exec insert chris: %v\", err)\n>        }\n>\n>\n>\n",
			"disapproval": false,
			"date": "2012-03-06 23:00:43.992677",
			"approval": false
		},
		{
			"sender": "gwenn.kahz@gmail.com",
			"recipients": [
				"gwenn.kahz@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Brad,\nAs specified on github,\n1) the build error is related to your sqlite version,\n2) you can use the 'mattn' driver to reproduce the bug.\nAnd I suggest you to keep only the 'mattn' driver. Mine is bloated with stuff not exposed by the 'database/sql' package (like BLOB I/O)...\n\nIf I have enough time, I will try to write another patch to validate that a new Stmt.Reset method is needed.\nRegards.\n\nOn 2012/03/06 23:16:55, bradfitz wrote:\n> Gwenn,\n> \n> In particular, I tried to add your sqlite driver (github.com/gwenn/gosqlite)\n> to the external go-sql-test test suite (\n> https://github.com/bradfitz/go-sql-test), but it fails to compile:\n> \n> $ go get github.com/gwenn/gosqlite\n> # github.com/gwenn/gosqlite\n> error: 'sqlite3_blob_reopen' undeclared (first use in this function)\n> error: (Each undeclared identifier is reported only once\n> \n> Want to send me a pull request on github to add it there, once it's fixed?",
			"disapproval": false,
			"date": "2012-03-07 13:19:58.390363",
			"approval": false
		},
		{
			"sender": "gwenn.kahz@gmail.com",
			"recipients": [
				"gwenn.kahz@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg",
			"disapproval": false,
			"date": "2012-03-06 08:12:34.569958",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Gwenn,\n\nIn particular, I tried to add your sqlite driver (github.com/gwenn/gosqlite)\nto the external go-sql-test test suite (\nhttps://github.com/bradfitz/go-sql-test), but it fails to compile:\n\n$ go get github.com/gwenn/gosqlite\n# github.com/gwenn/gosqlite\nerror: 'sqlite3_blob_reopen' undeclared (first use in this function)\nerror: (Each undeclared identifier is reported only once\n\nWant to send me a pull request on github to add it there, once it's fixed?\n\n\n\nOn Wed, Mar 7, 2012 at 10:00 AM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\n\n> Gwenn,\n>\n> This patch looks fine to me, but just so I understand: does this fix any\n> real bug?\n>\n> I see it does fix a statement leak if there's an invalid Stmt.Query after\n> Prepare, which is good to fix, but minor.\n>\n> And you say that the Tx change is \"the weak point\" in this patch... why?\n>  It seems fine.\n>\n>\n> On Tue, Mar 6, 2012 at 7:12 PM, <gwenn.kahz@gmail.com> wrote:\n>\n>> Reviewers: golang-dev_googlegroups.com,\n>>\n>> Message:\n>> Hello golang-dev@googlegroups.com,\n>>\n>> I'd like you to review this change to\n>> https://go.googlecode.com/hg\n>>\n>>\n>> Description:\n>>      database/sql: ensure Stmts are correctly closed.\n>>\n>> To make sure that there is no resource leak,\n>> I suggest to fix the 'fakedb' driver such as it fails when any\n>> Stmt is not closed.\n>> First, add a check in fakeConn.Close().\n>> Then, fix all missing Stmt.Close()/Rows.Close().\n>> I am not sure that the strategy choose in fakeConn.Prepare/prepare* is\n>> ok.\n>> The weak point in this patch is the change in Tx.Query:\n>>  - Tests pass without this change,\n>>  - I found it by manually analyzing the code,\n>>  - I just try to make Tx.Query look like DB.Query.\n>>\n>> Please review this at http://codereview.appspot.com/**5759050/<http://codereview.appspot.com/5759050/>\n>>\n>> Affected files:\n>>  M src/pkg/database/sql/fakedb_**test.go\n>>  M src/pkg/database/sql/sql.go\n>>  M src/pkg/database/sql/sql_test.**go\n>>\n>>\n>> Index: src/pkg/database/sql/fakedb_**test.go\n>> ==============================**==============================**=======\n>> --- a/src/pkg/database/sql/fakedb_**test.go\n>> +++ b/src/pkg/database/sql/fakedb_**test.go\n>> @@ -213,6 +213,9 @@\n>>        if c.db == nil {\n>>                return errors.New(\"can't close; already closed\")\n>>        }\n>> +       if c.stmtsMade > c.stmtsClosed {\n>> +               return errors.New(\"can't close; dangling statement(s)\")\n>> +       }\n>>        c.db = nil\n>>        return nil\n>>  }\n>> @@ -249,6 +252,7 @@\n>>  //  just a limitation for fakedb)\n>>  func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string)\n>> (driver.Stmt, error) {\n>>        if len(parts) != 3 {\n>> +               stmt.Close()\n>>                return nil, errf(\"invalid SELECT syntax with %d parts;\n>> want 3\", len(parts))\n>>        }\n>>        stmt.table = parts[0]\n>> @@ -259,14 +263,17 @@\n>>                }\n>>                nameVal := strings.Split(colspec, \"=\")\n>>                if len(nameVal) != 2 {\n>> +                       stmt.Close()\n>>                        return nil, errf(\"SELECT on table %q has invalid\n>> column spec of %q (index %d)\", stmt.table, colspec, n)\n>>                }\n>>                column, value := nameVal[0], nameVal[1]\n>>                _, ok := c.db.columnType(stmt.table, column)\n>>                if !ok {\n>> +                       stmt.Close()\n>>                        return nil, errf(\"SELECT on table %q references\n>> non-existent column %q\", stmt.table, column)\n>>                }\n>>                if value != \"?\" {\n>> +                       stmt.Close()\n>>                        return nil, errf(\"SELECT on table %q has pre-bound\n>> value for where column %q; need a question mark\",\n>>                                stmt.table, column)\n>>                }\n>> @@ -279,12 +286,14 @@\n>>  // parts are table|col=type,col2=type2\n>>  func (c *fakeConn) prepareCreate(stmt *fakeStmt, parts []string)\n>> (driver.Stmt, error) {\n>>        if len(parts) != 2 {\n>> +               stmt.Close()\n>>                return nil, errf(\"invalid CREATE syntax with %d parts;\n>> want 2\", len(parts))\n>>        }\n>>        stmt.table = parts[0]\n>>        for n, colspec := range strings.Split(parts[1], \",\") {\n>>                nameType := strings.Split(colspec, \"=\")\n>>                if len(nameType) != 2 {\n>> +                       stmt.Close()\n>>                        return nil, errf(\"CREATE table %q has invalid\n>> column spec of %q (index %d)\", stmt.table, colspec, n)\n>>                }\n>>                stmt.colName = append(stmt.colName, nameType[0])\n>> @@ -296,17 +305,20 @@\n>>  // parts are table|col=?,col2=val\n>>  func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string)\n>> (driver.Stmt, error) {\n>>        if len(parts) != 2 {\n>> +               stmt.Close()\n>>                return nil, errf(\"invalid INSERT syntax with %d parts;\n>> want 2\", len(parts))\n>>        }\n>>        stmt.table = parts[0]\n>>        for n, colspec := range strings.Split(parts[1], \",\") {\n>>                nameVal := strings.Split(colspec, \"=\")\n>>                if len(nameVal) != 2 {\n>> +                       stmt.Close()\n>>                        return nil, errf(\"INSERT table %q has invalid\n>> column spec of %q (index %d)\", stmt.table, colspec, n)\n>>                }\n>>                column, value := nameVal[0], nameVal[1]\n>>                ctype, ok := c.db.columnType(stmt.table, column)\n>>                if !ok {\n>> +                       stmt.Close()\n>>                        return nil, errf(\"INSERT table %q references\n>> non-existent column %q\", stmt.table, column)\n>>                }\n>>                stmt.colName = append(stmt.colName, column)\n>> @@ -322,10 +334,12 @@\n>>                        case \"int32\":\n>>                                i, err := strconv.Atoi(value)\n>>                                if err != nil {\n>> +                                       stmt.Close()\n>>                                        return nil, errf(\"invalid\n>> conversion to int32 from %q\", value)\n>>                                }\n>>                                subsetVal = int64(i) // int64 is a subset\n>> type, but not int32\n>>                        default:\n>> +                               stmt.Close()\n>>                                return nil, errf(\"unsupported conversion\n>> for pre-bound parameter %q to type %q\", value, ctype)\n>>                        }\n>>                        stmt.colValue = append(stmt.colValue, subsetVal)\n>> @@ -360,6 +374,7 @@\n>>        case \"INSERT\":\n>>                return c.prepareInsert(stmt, parts)\n>>        default:\n>> +               stmt.Close()\n>>                return nil, errf(\"unsupported command type %q\", cmd)\n>>        }\n>>        return stmt, nil\n>> Index: src/pkg/database/sql/sql.go\n>> ==============================**==============================**=======\n>> --- a/src/pkg/database/sql/sql.go\n>> +++ b/src/pkg/database/sql/sql.go\n>> @@ -561,9 +561,11 @@\n>>                return nil, err\n>>        }\n>>        rows, err := stmt.Query(args...)\n>> -       if err == nil {\n>> -               rows.closeStmt = stmt\n>> +       if err != nil {\n>> +               stmt.Close()\n>> +               return nil, err\n>>        }\n>> +       rows.closeStmt = stmt\n>>        return rows, err\n>>  }\n>>\n>> @@ -963,7 +965,7 @@\n>>        }\n>>\n>>        // TODO(bradfitz): for now we need to defensively clone all\n>> -       // []byte that the driver returned (not permitting\n>> +       // []byte that the driver returned (not permitting\n>>        // *RawBytes in Rows.Scan), since we're about to close\n>>        // the Rows in our defer, when we return from this function.\n>>        // the contract with the driver.Next(...) interface is that it\n>> Index: src/pkg/database/sql/sql_test.**go\n>> ==============================**==============================**=======\n>> --- a/src/pkg/database/sql/sql_**test.go\n>> +++ b/src/pkg/database/sql/sql_**test.go\n>> @@ -216,6 +216,7 @@\n>>        if err != nil {\n>>                t.Fatalf(\"Prepare: %v\", err)\n>>        }\n>> +       defer stmt.Close()\n>>        var age int\n>>        for n, tt := range []struct {\n>>                name string\n>> @@ -256,6 +257,7 @@\n>>        if err != nil {\n>>                t.Errorf(\"Stmt, err = %v, %v\", stmt, err)\n>>        }\n>> +       defer stmt.Close()\n>>\n>>        type execTest struct {\n>>                args    []interface{}\n>> @@ -297,11 +299,14 @@\n>>        if err != nil {\n>>                t.Fatalf(\"Stmt, err = %v, %v\", stmt, err)\n>>        }\n>> +       defer stmt.Close()\n>>        tx, err := db.Begin()\n>>        if err != nil {\n>>                t.Fatalf(\"Begin = %v\", err)\n>>        }\n>> -       _, err = tx.Stmt(stmt).Exec(\"Bobby\", 7)\n>> +       txs := tx.Stmt(stmt)\n>> +       defer txs.Close()\n>> +       _, err = txs.Exec(\"Bobby\", 7)\n>>        if err != nil {\n>>                t.Fatalf(\"Exec = %v\", err)\n>>        }\n>> @@ -330,6 +335,7 @@\n>>        if err != nil {\n>>                t.Fatal(err)\n>>        }\n>> +       defer r.Close()\n>>\n>>        if !r.Next() {\n>>                if r.Err() != nil {\n>> @@ -510,6 +516,7 @@\n>>        if err != nil {\n>>                t.Fatalf(\"prepare: %v\", err)\n>>        }\n>> +       defer stmt.Close()\n>>        if _, err := stmt.Exec(3, \"chris\", spec.rows[2].nullParam,\n>> spec.rows[2].notNullParam); err != nil {\n>>                t.Errorf(\"exec insert chris: %v\", err)\n>>        }\n>>\n>>\n>>\n>\n",
			"disapproval": false,
			"date": "2012-03-06 23:16:55.847816",
			"approval": false
		},
		{
			"sender": "gwenn.kahz@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello,\nFirst, I think that Rows.Close() implementation should be fixed: the\nassociated Stmt must be Reset (and not Closed).\n\nBut with this fix, the go-sql-test still fails:\n2012/03/11 12:23:14 SQLITE: Library used incorrectly, Dangling\nstatement (not finalize): \"INSERT INTO t (count) VALUES (?)\"\n...\n2012/03/11 12:23:14 SQLITE: Library used incorrectly, Dangling\nstatement (not finalize): \"SELECT count FROM t ORDER BY count DESC\"\n...\n2012/03/11 12:23:14 SQLITE: Library used incorrectly, Dangling\nstatement (not finalize): \"\"\npanic: runtime error: invalid memory address or nil pointer dereference\n...\nI am investigating.\nBut I am stupid/slow: how do you easily have a backtrace in Go?\nRegards.\n\nOn Sat, Mar 10, 2012 at 11:13 PM, Brad Fitzpatrick <bradfitz@golang.org> wrote:\n> [+mattn.jp]\n>\n> Mattn's sqlite driver still fails my tests, though:\n>\n> ante:sqltest $ git remote -v\n> origin git@github.com:bradfitz/go-sql-test.git (fetch)\n> origin git@github.com:bradfitz/go-sql-test.git (push)\n>\n> ante:sqltest $ pwd\n> /home/bradfitz/hack/go-sql-test/src/sqltest\n>\n> ante:sqltest $ echo $GOPATH\n> /home/bradfitz/hack/go-sql-test\n>\n> ante:sqltest $ go test -v -run=TestPreparedStmt_SQLite\n>\n> === RUN TestPreparedStmt_SQLite\n> panic: runtime error: invalid memory address or nil pointer dereference\n> [signal 0xb code=0x1 addr=0x2a pc=0x7f7e6f590840]\n>\n> goroutine 1 [chan receive]:\n> testing.RunTests(0x400c00, 0x682070, 0xc0000000c, 0x1, 0xf800000007, ...)\n> /home/bradfitz/go/src/pkg/testing/testing.go:350 +0x79f\n> testing.Main(0x400c00, 0x682070, 0xc0000000c, 0x685480, 0x0, ...)\n> /home/bradfitz/go/src/pkg/testing/testing.go:285 +0x7a\n> main.main()\n> /tmp/go-build762216293/sqltest/_test/_testmain.go:65 +0x91\n>\n> goroutine 2 [syscall]:\n> created by runtime.main\n> /home/bradfitz/go/src/pkg/runtime/proc.c:221\n>\n> goroutine 3 [syscall]:\n> github.com/mattn/go-sqlite3._Cfunc_sqlite3_reset(0x3d07188, 0xf840092100)\n> /tmp/go-build762216293/github.com/mattn/go-sqlite3/_obj/_cgo_defun.c:218\n> +0x2f\n> github.com/mattn/go-sqlite3.(*SQLiteStmt).bind(0xf840057c90, 0x6856e0, 0x0,\n> 0x0, 0x0, ...)\n> /tmp/go-build762216293/github.com/mattn/go-sqlite3/_obj/sqlite3.cgo1.go:170\n> +0x34\n> github.com/mattn/go-sqlite3.(*SQLiteStmt).Query(0xf840057c90, 0x6856e0, 0x0,\n> 0x0, 0x0, ...)\n> /tmp/go-build762216293/github.com/mattn/go-sqlite3/_obj/sqlite3.cgo1.go:223\n> +0x4a\n> database/sql.(*Stmt).Query(0xf8400588a0, 0x0, 0x0, 0x8, 0x100000001, ...)\n> /home/bradfitz/go/src/pkg/database/sql/sql.go:812 +0x28e\n> database/sql.(*Stmt).QueryRow(0xf8400588a0, 0x0, 0x0, 0xf840057c30,\n> 0xf840063760, ...)\n> /home/bradfitz/go/src/pkg/database/sql/sql.go:840 +0x40\n> sqltest._func_004(0xf8400711a8, 0x7f7e6f995da8, 0x7f7e6f995e38,\n> 0x7f7e6f995de8, 0xf840063700, ...)\n> /home/bradfitz/hack/go-sql-test/src/sqltest/sql_test.go:301 +0x8e\n> sqltest.testPreparedStmt(0xf840057990, 0xf8400579c0)\n> /home/bradfitz/hack/go-sql-test/src/sqltest/sql_test.go:310 +0x4db\n> sqltest.sqliteDB.RunTest(0xf840064230, 0x426e5a, 0x426dc3, 0xf8400579c0)\n> /home/bradfitz/hack/go-sql-test/src/sqltest/sql_test.go:132 +0x361\n> sqltest.sqliteDB.RunTest\u00b7i(0xf8400579c0, 0xf840064230, 0x426e5a, 0x421b31,\n> 0xf840064230, ...)\n> /home/bradfitz/hack/go-sql-test/src/sqltest/drivers.go:0 +0x38\n> sqltest.TestPreparedStmt_SQLite(0xf840064230, 0x1e965668)\n> /home/bradfitz/hack/go-sql-test/src/sqltest/sql_test.go:271 +0x44\n> testing.tRunner(0xf840064230, 0x682148, 0x0, 0x0)\n> /home/bradfitz/go/src/pkg/testing/testing.go:273 +0x6f\n> created by testing.RunTests\n> /home/bradfitz/go/src/pkg/testing/testing.go:349 +0x77c\n> exit status 2\n> FAIL sqltest 0.022s\n>\n> Or, sometimes it fails like:\n>\n> --- FAIL: TestPreparedStmt_SQLite (0.02 seconds)\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:302: Query: sql: statement expects 1117 inputs; got 0\n>\n>\n> Or sometimes like:\n>\n> --- FAIL: TestPreparedStmt_SQLite (0.05 seconds)\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:306: Insert: database is locked\n> sql_test.go:302: Query: SQL logic error or missing database\n> FAIL\n>\n>\n> I could use help debugging why the mattn driver fails like this. \u00a0I'll keep\n> digging, but more eyeballs welcome.\n>\n> - Brad\n>\n>\n> On Sat, Mar 10, 2012 at 12:21 PM, gwenn <gwenn.kahz@gmail.com> wrote:\n>>\n>> Nice,\n>> Your fix make all tests pass.\n>> I have merged/updated the patch.\n>> Thanks.\n>>\n>> On Sat, Mar 10, 2012 at 8:33 PM, Brad Fitzpatrick <bradfitz@golang.org>\n>> wrote:\n>> > Yes, see the patch I just submitted with the fix.\n>> >\n>> > Could you update this patch to apply to tip?\n>> >\n>> > On Mar 10, 2012 11:29 AM, <gwenn.kahz@gmail.com> wrote:\n>> >>\n>> >> Ok,\n>> >> The same connection is released (ie putConn) twice:\n>> >> 1) by tx.Query() -> Stmt.Query() with err,\n>> >> 2) by defer tx.Rollback().\n>> >> If I comment out the \"s.db.putConn(ci, err)\", all tests pass but it\n>> >> seems bad.\n>> >>\n>> >> http://codereview.appspot.com/5759050/\n>\n>\n",
			"disapproval": false,
			"date": "2012-03-11 11:34:09.136332",
			"approval": false
		},
		{
			"sender": "gwenn.kahz@gmail.com",
			"recipients": [
				"gwenn.kahz@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Brad,\nYou are right when you say that this patch fix only a minor bug.\nI was expecting to find the reason why your 'go-sql-test' fails with SQLite by just adding the check in fakeConn.Close() but I was wrong (the error is elsewhere (in Row.Scan)).\n\nAnd the weak point is that there is no test associated with Tx.Query that can validate the fix. I tried to keep the patch as small as possible and I am not sure that I can actually write this test with my poor skill.\n\nRegards.\n\nOn 2012/03/06 23:00:43, bradfitz wrote:\n> Gwenn,\n> \n> This patch looks fine to me, but just so I understand: does this fix any\n> real bug?\n> \n> I see it does fix a statement leak if there's an invalid Stmt.Query after\n> Prepare, which is good to fix, but minor.\n> \n> And you say that the Tx change is \"the weak point\" in this patch... why?\n>  It seems fine.\n> \n> \n> On Tue, Mar 6, 2012 at 7:12 PM, <mailto:gwenn.kahz@gmail.com> wrote:\n> \n> > Reviewers: http://golang-dev_googlegroups.com,\n> >\n> > Message:\n> > Hello mailto:golang-dev@googlegroups.com,\n> >\n> > I'd like you to review this change to\n> > https://go.googlecode.com/hg\n> >\n> >\n> > Description:\n> >      database/sql: ensure Stmts are correctly closed.\n> >\n> > To make sure that there is no resource leak,\n> > I suggest to fix the 'fakedb' driver such as it fails when any\n> > Stmt is not closed.\n> > First, add a check in fakeConn.Close().\n> > Then, fix all missing Stmt.Close()/Rows.Close().\n> > I am not sure that the strategy choose in fakeConn.Prepare/prepare* is\n> > ok.\n> > The weak point in this patch is the change in Tx.Query:\n> >  - Tests pass without this change,\n> >  - I found it by manually analyzing the code,\n> >  - I just try to make Tx.Query look like DB.Query.\n> >\n> > Please review this at\n> http://codereview.appspot.com/**5759050/%3Chttp://codereview.appspot.com/5759050/>\n> >\n> > Affected files:\n> >  M src/pkg/database/sql/fakedb_**test.go\n> >  M src/pkg/database/sql/sql.go\n> >  M src/pkg/database/sql/sql_test.**go\n> >\n> >\n> > Index: src/pkg/database/sql/fakedb_**test.go\n> > ==============================**==============================**=======\n> > --- a/src/pkg/database/sql/fakedb_**test.go\n> > +++ b/src/pkg/database/sql/fakedb_**test.go\n> > @@ -213,6 +213,9 @@\n> >        if c.db == nil {\n> >                return errors.New(\"can't close; already closed\")\n> >        }\n> > +       if c.stmtsMade > c.stmtsClosed {\n> > +               return errors.New(\"can't close; dangling statement(s)\")\n> > +       }\n> >        c.db = nil\n> >        return nil\n> >  }\n> > @@ -249,6 +252,7 @@\n> >  //  just a limitation for fakedb)\n> >  func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string)\n> > (driver.Stmt, error) {\n> >        if len(parts) != 3 {\n> > +               stmt.Close()\n> >                return nil, errf(\"invalid SELECT syntax with %d parts; want\n> > 3\", len(parts))\n> >        }\n> >        stmt.table = parts[0]\n> > @@ -259,14 +263,17 @@\n> >                }\n> >                nameVal := strings.Split(colspec, \"=\")\n> >                if len(nameVal) != 2 {\n> > +                       stmt.Close()\n> >                        return nil, errf(\"SELECT on table %q has invalid\n> > column spec of %q (index %d)\", stmt.table, colspec, n)\n> >                }\n> >                column, value := nameVal[0], nameVal[1]\n> >                _, ok := c.db.columnType(stmt.table, column)\n> >                if !ok {\n> > +                       stmt.Close()\n> >                        return nil, errf(\"SELECT on table %q references\n> > non-existent column %q\", stmt.table, column)\n> >                }\n> >                if value != \"?\" {\n> > +                       stmt.Close()\n> >                        return nil, errf(\"SELECT on table %q has pre-bound\n> > value for where column %q; need a question mark\",\n> >                                stmt.table, column)\n> >                }\n> > @@ -279,12 +286,14 @@\n> >  // parts are table|col=type,col2=type2\n> >  func (c *fakeConn) prepareCreate(stmt *fakeStmt, parts []string)\n> > (driver.Stmt, error) {\n> >        if len(parts) != 2 {\n> > +               stmt.Close()\n> >                return nil, errf(\"invalid CREATE syntax with %d parts; want\n> > 2\", len(parts))\n> >        }\n> >        stmt.table = parts[0]\n> >        for n, colspec := range strings.Split(parts[1], \",\") {\n> >                nameType := strings.Split(colspec, \"=\")\n> >                if len(nameType) != 2 {\n> > +                       stmt.Close()\n> >                        return nil, errf(\"CREATE table %q has invalid\n> > column spec of %q (index %d)\", stmt.table, colspec, n)\n> >                }\n> >                stmt.colName = append(stmt.colName, nameType[0])\n> > @@ -296,17 +305,20 @@\n> >  // parts are table|col=?,col2=val\n> >  func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string)\n> > (driver.Stmt, error) {\n> >        if len(parts) != 2 {\n> > +               stmt.Close()\n> >                return nil, errf(\"invalid INSERT syntax with %d parts; want\n> > 2\", len(parts))\n> >        }\n> >        stmt.table = parts[0]\n> >        for n, colspec := range strings.Split(parts[1], \",\") {\n> >                nameVal := strings.Split(colspec, \"=\")\n> >                if len(nameVal) != 2 {\n> > +                       stmt.Close()\n> >                        return nil, errf(\"INSERT table %q has invalid\n> > column spec of %q (index %d)\", stmt.table, colspec, n)\n> >                }\n> >                column, value := nameVal[0], nameVal[1]\n> >                ctype, ok := c.db.columnType(stmt.table, column)\n> >                if !ok {\n> > +                       stmt.Close()\n> >                        return nil, errf(\"INSERT table %q references\n> > non-existent column %q\", stmt.table, column)\n> >                }\n> >                stmt.colName = append(stmt.colName, column)\n> > @@ -322,10 +334,12 @@\n> >                        case \"int32\":\n> >                                i, err := strconv.Atoi(value)\n> >                                if err != nil {\n> > +                                       stmt.Close()\n> >                                        return nil, errf(\"invalid\n> > conversion to int32 from %q\", value)\n> >                                }\n> >                                subsetVal = int64(i) // int64 is a subset\n> > type, but not int32\n> >                        default:\n> > +                               stmt.Close()\n> >                                return nil, errf(\"unsupported conversion\n> > for pre-bound parameter %q to type %q\", value, ctype)\n> >                        }\n> >                        stmt.colValue = append(stmt.colValue, subsetVal)\n> > @@ -360,6 +374,7 @@\n> >        case \"INSERT\":\n> >                return c.prepareInsert(stmt, parts)\n> >        default:\n> > +               stmt.Close()\n> >                return nil, errf(\"unsupported command type %q\", cmd)\n> >        }\n> >        return stmt, nil\n> > Index: src/pkg/database/sql/sql.go\n> > ==============================**==============================**=======\n> > --- a/src/pkg/database/sql/sql.go\n> > +++ b/src/pkg/database/sql/sql.go\n> > @@ -561,9 +561,11 @@\n> >                return nil, err\n> >        }\n> >        rows, err := stmt.Query(args...)\n> > -       if err == nil {\n> > -               rows.closeStmt = stmt\n> > +       if err != nil {\n> > +               stmt.Close()\n> > +               return nil, err\n> >        }\n> > +       rows.closeStmt = stmt\n> >        return rows, err\n> >  }\n> >\n> > @@ -963,7 +965,7 @@\n> >        }\n> >\n> >        // TODO(bradfitz): for now we need to defensively clone all\n> > -       // []byte that the driver returned (not permitting\n> > +       // []byte that the driver returned (not permitting\n> >        // *RawBytes in Rows.Scan), since we're about to close\n> >        // the Rows in our defer, when we return from this function.\n> >        // the contract with the driver.Next(...) interface is that it\n> > Index: src/pkg/database/sql/sql_test.**go\n> > ==============================**==============================**=======\n> > --- a/src/pkg/database/sql/sql_**test.go\n> > +++ b/src/pkg/database/sql/sql_**test.go\n> > @@ -216,6 +216,7 @@\n> >        if err != nil {\n> >                t.Fatalf(\"Prepare: %v\", err)\n> >        }\n> > +       defer stmt.Close()\n> >        var age int\n> >        for n, tt := range []struct {\n> >                name string\n> > @@ -256,6 +257,7 @@\n> >        if err != nil {\n> >                t.Errorf(\"Stmt, err = %v, %v\", stmt, err)\n> >        }\n> > +       defer stmt.Close()\n> >\n> >        type execTest struct {\n> >                args    []interface{}\n> > @@ -297,11 +299,14 @@\n> >        if err != nil {\n> >                t.Fatalf(\"Stmt, err = %v, %v\", stmt, err)\n> >        }\n> > +       defer stmt.Close()\n> >        tx, err := db.Begin()\n> >        if err != nil {\n> >                t.Fatalf(\"Begin = %v\", err)\n> >        }\n> > -       _, err = tx.Stmt(stmt).Exec(\"Bobby\", 7)\n> > +       txs := tx.Stmt(stmt)\n> > +       defer txs.Close()\n> > +       _, err = txs.Exec(\"Bobby\", 7)\n> >        if err != nil {\n> >                t.Fatalf(\"Exec = %v\", err)\n> >        }\n> > @@ -330,6 +335,7 @@\n> >        if err != nil {\n> >                t.Fatal(err)\n> >        }\n> > +       defer r.Close()\n> >\n> >        if !r.Next() {\n> >                if r.Err() != nil {\n> > @@ -510,6 +516,7 @@\n> >        if err != nil {\n> >                t.Fatalf(\"prepare: %v\", err)\n> >        }\n> > +       defer stmt.Close()\n> >        if _, err := stmt.Exec(3, \"chris\", spec.rows[2].nullParam,\n> > spec.rows[2].notNullParam); err != nil {\n> >                t.Errorf(\"exec insert chris: %v\", err)\n> >        }\n> >\n> >\n> >",
			"disapproval": false,
			"date": "2012-03-07 12:58:30.978441",
			"approval": false
		},
		{
			"sender": "gwenn.kahz@gmail.com",
			"recipients": [
				"gwenn.kahz@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, bradfitz@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-03-10 10:20:27.941066",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Yes, see the patch I just submitted with the fix.\n\nCould you update this patch to apply to tip?\n On Mar 10, 2012 11:29 AM, <gwenn.kahz@gmail.com> wrote:\n\n> Ok,\n> The same connection is released (ie putConn) twice:\n> 1) by tx.Query() -> Stmt.Query() with err,\n> 2) by defer tx.Rollback().\n> If I comment out the \"s.db.putConn(ci, err)\", all tests pass but it\n> seems bad.\n>\n> http://codereview.appspot.com/**5759050/<http://codereview.appspot.com/5759050/>\n>\n",
			"disapproval": false,
			"date": "2012-03-10 19:33:28.174422",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "[+mattn.jp]\n\nMattn's sqlite driver still fails my tests, though:\n\nante:sqltest $ git remote -v\norigin git@github.com:bradfitz/go-sql-test.git (fetch)\norigin git@github.com:bradfitz/go-sql-test.git (push)\n\nante:sqltest $ pwd\n/home/bradfitz/hack/go-sql-test/src/sqltest\n\nante:sqltest $ echo $GOPATH\n/home/bradfitz/hack/go-sql-test\n\nante:sqltest $ go test -v -run=TestPreparedStmt_SQLite\n\n=== RUN TestPreparedStmt_SQLite\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal 0xb code=0x1 addr=0x2a pc=0x7f7e6f590840]\n\ngoroutine 1 [chan receive]:\ntesting.RunTests(0x400c00, 0x682070, 0xc0000000c, 0x1, 0xf800000007, ...)\n/home/bradfitz/go/src/pkg/testing/testing.go:350 +0x79f\ntesting.Main(0x400c00, 0x682070, 0xc0000000c, 0x685480, 0x0, ...)\n/home/bradfitz/go/src/pkg/testing/testing.go:285 +0x7a\nmain.main()\n/tmp/go-build762216293/sqltest/_test/_testmain.go:65 +0x91\n\ngoroutine 2 [syscall]:\ncreated by runtime.main\n/home/bradfitz/go/src/pkg/runtime/proc.c:221\n\ngoroutine 3 [syscall]:\ngithub.com/mattn/go-sqlite3._Cfunc_sqlite3_reset(0x3d07188, 0xf840092100)\n/tmp/go-build762216293/github.com/mattn/go-sqlite3/_obj/_cgo_defun.c:218+0x2f\ngithub.com/mattn/go-sqlite3.(*SQLiteStmt).bind(0xf840057c90, 0x6856e0, 0x0,\n0x0, 0x0, ...)\n/tmp/go-build762216293/github.com/mattn/go-sqlite3/_obj/sqlite3.cgo1.go:170+0x34\ngithub.com/mattn/go-sqlite3.(*SQLiteStmt).Query(0xf840057c90, 0x6856e0,\n0x0, 0x0, 0x0, ...)\n/tmp/go-build762216293/github.com/mattn/go-sqlite3/_obj/sqlite3.cgo1.go:223+0x4a\ndatabase/sql.(*Stmt).Query(0xf8400588a0, 0x0, 0x0, 0x8, 0x100000001, ...)\n/home/bradfitz/go/src/pkg/database/sql/sql.go:812 +0x28e\ndatabase/sql.(*Stmt).QueryRow(0xf8400588a0, 0x0, 0x0, 0xf840057c30,\n0xf840063760, ...)\n/home/bradfitz/go/src/pkg/database/sql/sql.go:840 +0x40\nsqltest._func_004(0xf8400711a8, 0x7f7e6f995da8, 0x7f7e6f995e38,\n0x7f7e6f995de8, 0xf840063700, ...)\n/home/bradfitz/hack/go-sql-test/src/sqltest/sql_test.go:301 +0x8e\nsqltest.testPreparedStmt(0xf840057990, 0xf8400579c0)\n/home/bradfitz/hack/go-sql-test/src/sqltest/sql_test.go:310 +0x4db\nsqltest.sqliteDB.RunTest(0xf840064230, 0x426e5a, 0x426dc3, 0xf8400579c0)\n/home/bradfitz/hack/go-sql-test/src/sqltest/sql_test.go:132 +0x361\nsqltest.sqliteDB.RunTest\u00b7i(0xf8400579c0, 0xf840064230, 0x426e5a, 0x421b31,\n0xf840064230, ...)\n/home/bradfitz/hack/go-sql-test/src/sqltest/drivers.go:0 +0x38\nsqltest.TestPreparedStmt_SQLite(0xf840064230, 0x1e965668)\n/home/bradfitz/hack/go-sql-test/src/sqltest/sql_test.go:271 +0x44\ntesting.tRunner(0xf840064230, 0x682148, 0x0, 0x0)\n/home/bradfitz/go/src/pkg/testing/testing.go:273 +0x6f\ncreated by testing.RunTests\n/home/bradfitz/go/src/pkg/testing/testing.go:349 +0x77c\nexit status 2\nFAIL sqltest 0.022s\n\nOr, sometimes it fails like:\n\n--- FAIL: TestPreparedStmt_SQLite (0.02 seconds)\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:302: Query: sql: statement expects 1117 inputs; got 0\n\n\nOr sometimes like:\n\n--- FAIL: TestPreparedStmt_SQLite (0.05 seconds)\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:306: Insert: database is locked\nsql_test.go:302: Query: SQL logic error or missing database\nFAIL\n\n\nI could use help debugging why the mattn driver fails like this.  I'll keep\ndigging, but more eyeballs welcome.\n\n- Brad\n\n\nOn Sat, Mar 10, 2012 at 12:21 PM, gwenn <gwenn.kahz@gmail.com> wrote:\n\n> Nice,\n> Your fix make all tests pass.\n> I have merged/updated the patch.\n> Thanks.\n>\n> On Sat, Mar 10, 2012 at 8:33 PM, Brad Fitzpatrick <bradfitz@golang.org>\n> wrote:\n> > Yes, see the patch I just submitted with the fix.\n> >\n> > Could you update this patch to apply to tip?\n> >\n> > On Mar 10, 2012 11:29 AM, <gwenn.kahz@gmail.com> wrote:\n> >>\n> >> Ok,\n> >> The same connection is released (ie putConn) twice:\n> >> 1) by tx.Query() -> Stmt.Query() with err,\n> >> 2) by defer tx.Rollback().\n> >> If I comment out the \"s.db.putConn(ci, err)\", all tests pass but it\n> >> seems bad.\n> >>\n> >> http://codereview.appspot.com/5759050/\n>\n",
			"disapproval": false,
			"date": "2012-03-10 22:13:12.619054",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nOn Sat, Mar 10, 2012 at 12:21 PM, gwenn <gwenn.kahz@gmail.com> wrote:\n\n> Nice,\n> Your fix make all tests pass.\n> I have merged/updated the patch.\n> Thanks.\n>\n> On Sat, Mar 10, 2012 at 8:33 PM, Brad Fitzpatrick <bradfitz@golang.org>\n> wrote:\n> > Yes, see the patch I just submitted with the fix.\n> >\n> > Could you update this patch to apply to tip?\n> >\n> > On Mar 10, 2012 11:29 AM, <gwenn.kahz@gmail.com> wrote:\n> >>\n> >> Ok,\n> >> The same connection is released (ie putConn) twice:\n> >> 1) by tx.Query() -> Stmt.Query() with err,\n> >> 2) by defer tx.Rollback().\n> >> If I comment out the \"s.db.putConn(ci, err)\", all tests pass but it\n> >> seems bad.\n> >>\n> >> http://codereview.appspot.com/5759050/\n>\n",
			"disapproval": false,
			"date": "2012-03-10 23:18:58.196731",
			"approval": true
		},
		{
			"sender": "gwenn.kahz@gmail.com",
			"recipients": [
				"gwenn.kahz@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "A new test 'TestTxQueryInvalid' has been added to reproduce the minor bug in Tx.Query:\n\"error closing DB: can't close; dangling statement(s)\"\nBut another error is raised with the patch:\n\"error closing DB: can't close; already closed\"\nSorry.",
			"disapproval": false,
			"date": "2012-03-10 10:30:28.497913",
			"approval": false
		},
		{
			"sender": "gwenn.kahz@gmail.com",
			"recipients": [
				"gwenn.kahz@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Ok,\nThe same connection is released (ie putConn) twice:\n1) by tx.Query() -> Stmt.Query() with err,\n2) by defer tx.Rollback().\nIf I comment out the \"s.db.putConn(ci, err)\", all tests pass but it seems bad.",
			"disapproval": false,
			"date": "2012-03-10 19:29:41.862239",
			"approval": false
		},
		{
			"sender": "gwenn.kahz@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Nice,\nYour fix make all tests pass.\nI have merged/updated the patch.\nThanks.\n\nOn Sat, Mar 10, 2012 at 8:33 PM, Brad Fitzpatrick <bradfitz@golang.org> wrote:\n> Yes, see the patch I just submitted with the fix.\n>\n> Could you update this patch to apply to tip?\n>\n> On Mar 10, 2012 11:29 AM, <gwenn.kahz@gmail.com> wrote:\n>>\n>> Ok,\n>> The same connection is released (ie putConn) twice:\n>> 1) by tx.Query() -> Stmt.Query() with err,\n>> 2) by defer tx.Rollback().\n>> If I comment out the \"s.db.putConn(ci, err)\", all tests pass but it\n>> seems bad.\n>>\n>> http://codereview.appspot.com/5759050/\n",
			"disapproval": false,
			"date": "2012-03-10 20:21:07.532417",
			"approval": false
		},
		{
			"sender": "gwenn.kahz@gmail.com",
			"recipients": [
				"gwenn.kahz@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, bradfitz@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2012-03-10 20:18:26.816228",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"gwenn.kahz@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=91a86970157c ***\n\ndatabase/sql: ensure Stmts are correctly closed.\n\nTo make sure that there is no resource leak,\nI suggest to fix the 'fakedb' driver such as it fails when any\nStmt is not closed.\nFirst, add a check in fakeConn.Close().\nThen, fix all missing Stmt.Close()/Rows.Close().\nI am not sure that the strategy choose in fakeConn.Prepare/prepare* is ok.\nThe weak point in this patch is the change in Tx.Query:\n  - Tests pass without this change,\n  - I found it by manually analyzing the code,\n  - I just try to make Tx.Query look like DB.Query.\n\nR=golang-dev, bradfitz\nCC=golang-dev\nhttp://codereview.appspot.com/5759050\n\nCommitter: Brad Fitzpatrick <bradfitz@golang.org>",
			"disapproval": false,
			"date": "2012-03-10 23:25:14.217635",
			"approval": false
		}
	],
	"owner_email": "gwenn.kahz@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "gwenn",
	"subject": "code review 5759050:       database/sql: ensure Stmts are correctly closed.",
	"created": "2012-03-06 08:05:17.667874",
	"patchsets": [
		1,
		3,
		2004,
		5002,
		7006
	],
	"modified": "2012-03-11 11:15:21.345012",
	"closed": true,
	"issue": 5759050
}