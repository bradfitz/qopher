{
	"description": "big: added recursive subdivision to nat.string to increase performance 4x to 35x\nfor medium and long length numbers. extended tests in nat_test to stress the new\ncode and added benchmarks for performance analysis and setting the subdivision\nthreshold.",
	"cc": [
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"gri@google.com",
		"gri@golang.org",
		"mtj@google.com"
	],
	"messages": [
		{
			"sender": "mtj@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Yep. The former version, when doing the PiDigits test in the test suite,\ncreates a string that is13118 bytes too long! For really big numbers that\nwould be worse, so just can't go with the old solution. I also did a fancy\nversion...\n\ni := int(math.Ceil(float64(x.bitLen())/math.Log2(float64(b))))\n\n... that does not need the guard +1, but I did not stop to prove it\nsufficient so I went with the +1.\n\nOn Tue, Jun 21, 2011 at 4:07 PM, <gri@golang.org> wrote:\n\n> http://codereview.appspot.com/**4634075/diff/2001/src/pkg/big/**\n> nat.go#newcode761<http://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode761>\n> src/pkg/big/nat.go:761: i :=\n> int(float64(x.bitLen())/math.**Log2(float64(b))) + 1 // off by one at most\n> I assume this is because the integer division is too inaccurate? I would\n> guess that math.Log2 returns a larger number than log2, so the quotient\n> should be smaller; and the old result should have been fine. Or what is\n> the reason?\n\n\n\n\n-- \n\n*Michael T. Jones*\n\n   Chief Technology Advocate, Google Inc.\n\n   1600 Amphitheatre Parkway, Mountain View, California\n94043<http://maps.google.com/?ie=UTF8&ll=37.422313,-122.088048&spn=0.001135,0.001367&t=h&z=20>\n\n   Email: mtj@google.com  Mobile: 650-335-5765  Fax: 650-649-1938\n\n   *Organizing the world's information to make it universally accessible and\nuseful*\n",
			"disapproval": false,
			"date": "2011-06-21 23:18:32.951133",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"michael.jones@gmail.com",
				"gri@google.com",
				"gri@golang.org",
				"reply@codereview.appspotmail.com"
			],
			"text": "Some initial comments. More to come.\n- gri\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go\nFile src/pkg/big/nat.go (left):\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#oldcode655\nsrc/pkg/big/nat.go:655: \nplease leave this empty line\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go\nFile src/pkg/big/nat.go (right):\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode761\nsrc/pkg/big/nat.go:761: i := int(float64(x.bitLen())/math.Log2(float64(b))) + 1 // off by one at most\nI assume this is because the integer division is too inaccurate? I would guess that math.Log2 returns a larger number than log2, so the quotient should be smaller; and the old result should have been fine. Or what is the reason?\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode813\nsrc/pkg/big/nat.go:813: ndigits := 0  // greatest number of base-b digits representable in a Word\ns/base-b digits/digits in base b/\n\nI repeatedly read \"base-b digits\" as \"base minus b digits\" and get confused.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode819\nsrc/pkg/big/nat.go:819: if leafSize > 1 && len(x) > leafSize {\nAll the code inside this if statement (including the if statement) looks like it should be factored into a function, with a goo function comment.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode820\nsrc/pkg/big/nat.go:820: // determine depth required for divisors from leafSize to that just exceeding pow(q, 1/2)\ns/pow(q, 1/2)/sqrt(q)/\n\n(can it be equal to sqrt(q)?)\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode822\nsrc/pkg/big/nat.go:822: for words, lenx := leafSize, len(x); words <= lenx && depth < maxCache; words <<= 1 {\ns/lenx/len(x)/\n\nlen(x) is as fast as lenx; get rid of lenx\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode889\nsrc/pkg/big/nat.go:889: // convert words of q to base-b digits in s directly using iterated nat/Word divison to extract\ns/base-b digits/digits in base b/\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode892\nsrc/pkg/big/nat.go:892: // slowly shrinking q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s. indirect\ns/divW()'s. indirect/divW() calls. Indirect/\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode893\nsrc/pkg/big/nat.go:893: // conversion divides q by its approximate square root, yielding two halves of half-size. using\nPlease start sentences with upper-case letters. Apply everywhere.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode903\nsrc/pkg/big/nat.go:903: i := hi // startng index for output conversion\ns/startng/start/",
			"disapproval": false,
			"date": "2011-06-21 23:07:04.058380",
			"approval": false
		},
		{
			"sender": "michael.jones@gmail.com",
			"recipients": [
				"michael.jones@gmail.com",
				"gri@google.com",
				"gri@golang.org",
				"mtj@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello gri@google.com, gri@golang.org, mtj@google.com (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2011-06-23 15:13:33.300086",
			"approval": false
		},
		{
			"sender": "mtj@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "sorry to have forgotten the \"hg mail\" step yesterday! all indicated changes\nmade in reflected in the hg mail.\n\nOn Thu, Jun 23, 2011 at 8:13 AM, <michael.jones@gmail.com> wrote:\n\n> Reviewers: gri1, gri, mtj1,\n>\n> Message:\n> Hello gri@google.com, gri@golang.org, mtj@google.com (cc:\n> golang-dev@googlegroups.com),\n>\n> I'd like you to review this change to\n> https://go.googlecode.com/hg/\n>\n>\n> Description:\n> big: added recursive subdivision to nat.string to increase performance\n> 4x to 35x\n> for medium and long length numbers. extended tests in nat_test to stress\n> the new\n> code and added benchmarks for performance analysis and setting the\n> subdivision\n> threshold.\n>\n> Please review this at http://codereview.appspot.com/**4634075/<http://codereview.appspot.com/4634075/>\n>\n> Affected files:\n>  M src/pkg/big/nat.go\n>  M src/pkg/big/nat_test.go\n>\n>\n>\n\n\n-- \n\n*Michael T. Jones*\n\n   Chief Technology Advocate, Google Inc.\n\n   1600 Amphitheatre Parkway, Mountain View, California\n94043<http://maps.google.com/?ie=UTF8&ll=37.422313,-122.088048&spn=0.001135,0.001367&t=h&z=20>\n\n   Email: mtj@google.com  Mobile: 650-335-5765  Fax: 650-649-1938\n\n   *Organizing the world's information to make it universally accessible and\nuseful*\n",
			"disapproval": false,
			"date": "2011-06-23 15:19:07.200429",
			"approval": false
		},
		{
			"sender": "mtj@google.com",
			"recipients": [
				"michael.jones@gmail.com",
				"gri@google.com",
				"gri@golang.org",
				"mtj@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "sorry, overlooked need to do this as well. thought commenting made them visible to you.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go\nFile src/pkg/big/nat.go (left):\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#oldcode655\nsrc/pkg/big/nat.go:655: \nOn 2011/06/21 23:07:04, gri wrote:\n> please leave this empty line\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go\nFile src/pkg/big/nat.go (right):\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode761\nsrc/pkg/big/nat.go:761: i := int(float64(x.bitLen())/math.Log2(float64(b))) + 1 // off by one at most\nYep. The former version, when doing the PiDigits test in the test suite, creates a string that is 13118 bytes too long! For really big numbers that would be worse, so just can't go with the old solution. I also did a fancy version...\n\ni := int(math.Ceil(float64(x.bitLen())/math.Log2(float64(b))))\n\n... that does not need the guard +1, but I did not stop to prove it sufficient so I went with the +1.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode813\nsrc/pkg/big/nat.go:813: ndigits := 0  // greatest number of base-b digits representable in a Word\nOn 2011/06/21 23:07:04, gri wrote:\n> s/base-b digits/digits in base b/\n> \n> I repeatedly read \"base-b digits\" as \"base minus b digits\" and get confused. \n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode819\nsrc/pkg/big/nat.go:819: if leafSize > 1 && len(x) > leafSize {\nOn 2011/06/21 23:07:04, gri wrote:\n> All the code inside this if statement (including the if statement) looks like it\n> should be factored into a function, with a goo function comment.\n\nGreat. I wanted to do that but did not see any \"single-use\" functions. Trying to fit into the neighborhood.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode819\nsrc/pkg/big/nat.go:819: if leafSize > 1 && len(x) > leafSize {\nOn 2011/06/21 23:07:04, gri wrote:\n> All the code inside this if statement (including the if statement) looks like it\n> should be factored into a function, with a goo function comment.\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode820\nsrc/pkg/big/nat.go:820: // determine depth required for divisors from leafSize to that just exceeding pow(q, 1/2)\nOn 2011/06/21 23:07:04, gri wrote:\n> s/pow(q, 1/2)/sqrt(q)/\n> \n> (can it be equal to sqrt(q)?)\n\nyes, that would be OK. in base ten, with two digit bb = 100 and a table of 100**2, 100**4, 100**8, ... then an example would be the number 10000, which when divided by the most appropriate table entry of 100 == sqrt(10000), would yield upper = 100 and lower=0. Values greater than the sqrt work too. 12345 would give [123, 45]  then the next recursive split of the 123 will give [1, 23]. Smaller values work also. The limit is just dividing by 10 over and over which is the direct case. The most efficient is somewhere between the most balanced tree and the tree with the greatest number of maxed-out divisors.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode822\nsrc/pkg/big/nat.go:822: for words, lenx := leafSize, len(x); words <= lenx && depth < maxCache; words <<= 1 {\nOn 2011/06/21 23:07:04, gri wrote:\n> s/lenx/len(x)/\n> \n> len(x) is as fast as lenx; get rid of lenx\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode889\nsrc/pkg/big/nat.go:889: // convert words of q to base-b digits in s directly using iterated nat/Word divison to extract\nOn 2011/06/21 23:07:04, gri wrote:\n> s/base-b digits/digits in base b/\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode892\nsrc/pkg/big/nat.go:892: // slowly shrinking q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s. indirect\nOn 2011/06/21 23:07:04, gri wrote:\n> s/divW()'s. indirect/divW() calls. Indirect/\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode893\nsrc/pkg/big/nat.go:893: // conversion divides q by its approximate square root, yielding two halves of half-size. using\nOn 2011/06/21 23:07:04, gri wrote:\n> Please start sentences with upper-case letters. Apply everywhere.\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/2001/src/pkg/big/nat.go#newcode903\nsrc/pkg/big/nat.go:903: i := hi // startng index for output conversion\nOn 2011/06/21 23:07:04, gri wrote:\n> s/startng/start/\n\nDone.",
			"disapproval": false,
			"date": "2011-06-24 13:58:44.221379",
			"approval": false
		},
		{
			"sender": "michael.jones@gmail.com",
			"recipients": [
				"michael.jones@gmail.com",
				"gri@google.com",
				"gri@golang.org",
				"mtj@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "did most all; exception is related to table/cache/lock. will review this aspect now.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go\nFile src/pkg/big/nat.go (right):\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode657\nsrc/pkg/big/nat.go:657: \nOn 2011/07/11 22:48:00, gri wrote:\n> please run the files through gofmt.\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode768\nsrc/pkg/big/nat.go:768: // base is a power of two: extract output digits directly from words without division\nOn 2011/07/11 22:48:00, gri wrote:\n> please use just a simple // comment.\n> \n> starting 3-line // comments sets a precedent, and after a while all the code\n> gets bloated with very ornate comments because other people are inclined to come\n> up with their comment style, too.\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode813\nsrc/pkg/big/nat.go:813: // base is not a power of two: extract groups of digits by division\nOn 2011/07/11 22:48:00, gri wrote:\n> ditto (comment)\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode838\nsrc/pkg/big/nat.go:838: func divisors (x nat, b Word, ndigits int, bb Word) []divisor {\nGreat point!\n\nOn 2011/07/11 22:48:00, gri wrote:\n> I think only the length of x is used in here. Clearer to pass only that, so\n> there's no dependency expressed on the value of x.\n> \n> s/x nat/m int/\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode838\nsrc/pkg/big/nat.go:838: func divisors (x nat, b Word, ndigits int, bb Word) []divisor {\nOn 2011/07/11 22:48:00, gri wrote:\n> I think only the length of x is used in here. Clearer to pass only that, so\n> there's no dependency expressed on the value of x.\n> \n> s/x nat/m int/\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode846\nsrc/pkg/big/nat.go:846: for words := leafSize; words <= len(x)>>1 + 1 && k < maxCache; words <<= 1 {\nStruggling with this one. There could be multiple cached bases. They all would indeed be no more than maxCache, indeed much smaller, and since they all have the same size any could be the length exemplar for the others. But there is no dependency between a cache for base, 85, say and that for base 10 so i'm uncomfortable forcing the false connection. hmm...\n\nOn 2011/07/11 22:48:00, gri wrote:\n> s/maxCache/len(cacheBase10)/\n> \n> and then you don't need maxCache (and the connection between this value and\n> cacheBase10 is obvious in the code); note the len(cacheBase10) is still a\n> constant\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode851\nsrc/pkg/big/nat.go:851: var cached bool\nSame objection. Could be other cached bases. If a user (users) do lots of other base conversions then we might want to add those bases to the \"are you special and deserve to be cached\" switch. Maybe we should cache all of them? (seems a memory hole)\n\nOn 2011/07/11 22:48:00, gri wrote:\n> get rid of cached, just check for b == 10?\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode854\nsrc/pkg/big/nat.go:854: case 10:\nprobably. I was thinking about hex encoding or other base translations. code works correctly for bases 2..256\n\nas you say, though, likely no need. Especially since 2/8/16 are handled elsewhere.\n\nOn 2011/07/11 22:48:00, gri wrote:\n> It's probably overkill to cache any other bases.\n> \n> If b == 10 {\n>    ...\n> } else {\n>    ...\n> }\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode861\nsrc/pkg/big/nat.go:861: // create new table of divisors or extend existing table as needed\nBut I can't really, since you might call printf on numbers of 100, 80, 200, then 2000000 digits. Shame to build the tables if you never call final big conversion.\n\nOn 2011/07/11 22:48:00, gri wrote:\n> I think this is too complicated. There's no need to bring in locking here. It's\n> much simpler to just pre-compute the table for base 10 in an init function and\n> be done with it.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode883\nsrc/pkg/big/nat.go:883: if cached {\nMust make a table for every base (not a power of two) that is to be converted. Must have the divisors something like successive square roots of the starting nat. They could always throw a huge number at me, and could always do base 10 now and 12 later.\n\nOn 2011/07/11 22:48:00, gri wrote:\n> This if statement can go, I think if the b=10 case is done at initialization\n> time.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode910\nsrc/pkg/big/nat.go:910: // Indirect conversion divides q by its approximate square root, yielding two halves of half-size.\nOn 2011/07/11 22:48:00, gri wrote:\n> s/half-size/half the length of q/ ?\n> \n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode918\nsrc/pkg/big/nat.go:918: \nOn 2011/07/11 22:48:00, gri wrote:\n> line 918: //\n> \n> This way, the comment gets associated with convertWords (and is shown, once\n> godoc has a mode to show documentation for all code, not just exported idents).\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode923\nsrc/pkg/big/nat.go:923: //\nOn 2011/07/11 22:48:00, gri wrote:\n> simple // comment please\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode940\nsrc/pkg/big/nat.go:940: //for j := 0; j < ndigits; j++ {\nOn 2011/07/11 22:48:00, gri wrote:\n> delete this commented out code\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode960\nsrc/pkg/big/nat.go:960: //for j := 0; j < ndigits; j++ {\nOn 2011/07/11 22:48:00, gri wrote:\n> delete this commented out code\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode970\nsrc/pkg/big/nat.go:970: //\nOn 2011/07/11 22:48:00, gri wrote:\n> simple // comment please\n> (perhaps empty lines around the \"} else {\"\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode988\nsrc/pkg/big/nat.go:988: // splt q into the two digit number (upper*bbb + lower) in big big base\nOn 2011/07/11 22:48:00, gri wrote:\n> s/splt/split/\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode991\nsrc/pkg/big/nat.go:991: // convert subblocks and collect results in s[lo..middle-1] and s[middle..hi-1]\nOn 2011/07/11 22:48:00, gri wrote:\n> s/s[lo..middle-1]/s[lo:middle]/\n> s/s[middle..hi-1]/s[middle:hi]/\n> \n> (we have a perfectly good slice notation :-)\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode997\nsrc/pkg/big/nat.go:997: // Generate enough leading zeroes to satsfy the \"fill lo..hi\" contract. Example: 102 in base 100\nOn 2011/07/11 22:48:00, gri wrote:\n> s/satsfy/satisfy/\n\nDone.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode1017\nsrc/pkg/big/nat.go:1017: // Split blocks greater than leafSize Words (or set to 0 to disable indirect conversion)\nOn 2011/07/11 22:48:00, gri wrote:\n> I would prefer seeing this code (1017-1033) before the divisors routine where\n> some of it gets used.\n\nDone.",
			"disapproval": false,
			"date": "2011-07-12 01:08:31.712105",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"michael.jones@gmail.com",
				"gri@google.com",
				"gri@golang.org",
				"mtj@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "A first round of comments.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go\nFile src/pkg/big/nat.go (left):\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#oldcode760\nsrc/pkg/big/nat.go:760: i := x.bitLen()/log2(b) + 1 // +1: round up\nlog2 is only used in nat_test.go now. perhaps it should move there.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go\nFile src/pkg/big/nat.go (right):\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode657\nsrc/pkg/big/nat.go:657: \nplease run the files through gofmt.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode768\nsrc/pkg/big/nat.go:768: // base is a power of two: extract output digits directly from words without division\nplease use just a simple // comment.\n\nstarting 3-line // comments sets a precedent, and after a while all the code gets bloated with very ornate comments because other people are inclined to come up with their comment style, too.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode813\nsrc/pkg/big/nat.go:813: // base is not a power of two: extract groups of digits by division\nditto (comment)\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode838\nsrc/pkg/big/nat.go:838: func divisors (x nat, b Word, ndigits int, bb Word) []divisor {\nI think only the length of x is used in here. Clearer to pass only that, so there's no dependency expressed on the value of x.\n\ns/x nat/m int/\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode846\nsrc/pkg/big/nat.go:846: for words := leafSize; words <= len(x)>>1 + 1 && k < maxCache; words <<= 1 {\ns/maxCache/len(cacheBase10)/\n\nand then you don't need maxCache (and the connection between this value and cacheBase10 is obvious in the code); note the len(cacheBase10) is still a constant\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode851\nsrc/pkg/big/nat.go:851: var cached bool\nget rid of cached, just check for b == 10?\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode854\nsrc/pkg/big/nat.go:854: case 10:\nIt's probably overkill to cache any other bases.\n\nIf b == 10 {\n   ...\n} else {\n   ...\n}\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode861\nsrc/pkg/big/nat.go:861: // create new table of divisors or extend existing table as needed\nI think this is too complicated. There's no need to bring in locking here. It's much simpler to just pre-compute the table for base 10 in an init function and be done with it.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode862\nsrc/pkg/big/nat.go:862: if table[k-1].ndigits == 0 {\nthis code now only needs to run if b != 10 I think\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode864\nsrc/pkg/big/nat.go:864: if cached {\nget rid of this\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode883\nsrc/pkg/big/nat.go:883: if cached {\nThis if statement can go, I think if the b=10 case is done at initialization time.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode895\nsrc/pkg/big/nat.go:895: if cached {\nget rid of this\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode910\nsrc/pkg/big/nat.go:910: // Indirect conversion divides q by its approximate square root, yielding two halves of half-size.\ns/half-size/half the length of q/ ?\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode918\nsrc/pkg/big/nat.go:918: \nline 918: //\n\nThis way, the comment gets associated with convertWords (and is shown, once godoc has a mode to show documentation for all code, not just exported idents).\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode919\nsrc/pkg/big/nat.go:919: func (q nat) convertWords(lo, hi int, s []byte, charset string, b Word, ndigits int, bb Word, table []divisor) int {\nlo, hi are not documented? this code could be easier to understand\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode923\nsrc/pkg/big/nat.go:923: //\nsimple // comment please\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode940\nsrc/pkg/big/nat.go:940: //for j := 0; j < ndigits; j++ {\ndelete this commented out code\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode960\nsrc/pkg/big/nat.go:960: //for j := 0; j < ndigits; j++ {\ndelete this commented out code\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode970\nsrc/pkg/big/nat.go:970: //\nsimple // comment please\n(perhaps empty lines around the \"} else {\"\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode988\nsrc/pkg/big/nat.go:988: // splt q into the two digit number (upper*bbb + lower) in big big base\ns/splt/split/\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode991\nsrc/pkg/big/nat.go:991: // convert subblocks and collect results in s[lo..middle-1] and s[middle..hi-1]\ns/s[lo..middle-1]/s[lo:middle]/\ns/s[middle..hi-1]/s[middle:hi]/\n\n(we have a perfectly good slice notation :-)\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode997\nsrc/pkg/big/nat.go:997: // Generate enough leading zeroes to satsfy the \"fill lo..hi\" contract. Example: 102 in base 100\ns/satsfy/satisfy/\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode1017\nsrc/pkg/big/nat.go:1017: // Split blocks greater than leafSize Words (or set to 0 to disable indirect conversion)\nI would prefer seeing this code (1017-1033) before the divisors routine where some of it gets used.\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode1023\nsrc/pkg/big/nat.go:1023: type divisor struct {\nall fields could use comments in this struct\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode1030\nsrc/pkg/big/nat.go:1030: const maxCache = 64\nget rid of this constant, just use 64 below\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode1032\nsrc/pkg/big/nat.go:1032: var cacheBase10 [maxCache]divisor\ns/maxCache/64/\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode1033\nsrc/pkg/big/nat.go:1033: var cacheLock sync.Mutex\nget rid of this lock\n\nhttp://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode1363\nsrc/pkg/big/nat.go:1363: func (z nat) expWW(x, y Word) nat {\nperhaps move this before divisors, which is where it is used. As it is, this function seems a bit randomly placed.",
			"disapproval": false,
			"date": "2011-07-11 22:48:00.183753",
			"approval": false
		},
		{
			"sender": "gri@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Did you upload the changes?\n- Robert\n\nOn Mon, Jul 11, 2011 at 6:08 PM,  <michael.jones@gmail.com> wrote:\n> did most all; exception is related to table/cache/lock. will review this\n> aspect now.\n>\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go\n> File src/pkg/big/nat.go (right):\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode657\n> src/pkg/big/nat.go:657:\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> please run the files through gofmt.\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode768\n> src/pkg/big/nat.go:768: // base is a power of two: extract output digits\n> directly from words without division\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> please use just a simple // comment.\n>\n>> starting 3-line // comments sets a precedent, and after a while all\n>\n> the code\n>>\n>> gets bloated with very ornate comments because other people are\n>\n> inclined to come\n>>\n>> up with their comment style, too.\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode813\n> src/pkg/big/nat.go:813: // base is not a power of two: extract groups of\n> digits by division\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> ditto (comment)\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode838\n> src/pkg/big/nat.go:838: func divisors (x nat, b Word, ndigits int, bb\n> Word) []divisor {\n> Great point!\n>\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> I think only the length of x is used in here. Clearer to pass only\n>\n> that, so\n>>\n>> there's no dependency expressed on the value of x.\n>\n>> s/x nat/m int/\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode838\n> src/pkg/big/nat.go:838: func divisors (x nat, b Word, ndigits int, bb\n> Word) []divisor {\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> I think only the length of x is used in here. Clearer to pass only\n>\n> that, so\n>>\n>> there's no dependency expressed on the value of x.\n>\n>> s/x nat/m int/\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode846\n> src/pkg/big/nat.go:846: for words := leafSize; words <= len(x)>>1 + 1 &&\n> k < maxCache; words <<= 1 {\n> Struggling with this one. There could be multiple cached bases. They all\n> would indeed be no more than maxCache, indeed much smaller, and since\n> they all have the same size any could be the length exemplar for the\n> others. But there is no dependency between a cache for base, 85, say and\n> that for base 10 so i'm uncomfortable forcing the false connection.\n> hmm...\n>\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> s/maxCache/len(cacheBase10)/\n>\n>> and then you don't need maxCache (and the connection between this\n>\n> value and\n>>\n>> cacheBase10 is obvious in the code); note the len(cacheBase10) is\n>\n> still a\n>>\n>> constant\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode851\n> src/pkg/big/nat.go:851: var cached bool\n> Same objection. Could be other cached bases. If a user (users) do lots\n> of other base conversions then we might want to add those bases to the\n> \"are you special and deserve to be cached\" switch. Maybe we should cache\n> all of them? (seems a memory hole)\n>\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> get rid of cached, just check for b == 10?\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode854\n> src/pkg/big/nat.go:854: case 10:\n> probably. I was thinking about hex encoding or other base translations.\n> code works correctly for bases 2..256\n>\n> as you say, though, likely no need. Especially since 2/8/16 are handled\n> elsewhere.\n>\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> It's probably overkill to cache any other bases.\n>\n>> If b == 10 {\n>> \u00a0 \u00a0...\n>> } else {\n>> \u00a0 \u00a0...\n>> }\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode861\n> src/pkg/big/nat.go:861: // create new table of divisors or extend\n> existing table as needed\n> But I can't really, since you might call printf on numbers of 100, 80,\n> 200, then 2000000 digits. Shame to build the tables if you never call\n> final big conversion.\n>\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> I think this is too complicated. There's no need to bring in locking\n>\n> here. It's\n>>\n>> much simpler to just pre-compute the table for base 10 in an init\n>\n> function and\n>>\n>> be done with it.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode883\n> src/pkg/big/nat.go:883: if cached {\n> Must make a table for every base (not a power of two) that is to be\n> converted. Must have the divisors something like successive square roots\n> of the starting nat. They could always throw a huge number at me, and\n> could always do base 10 now and 12 later.\n>\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> This if statement can go, I think if the b=10 case is done at\n>\n> initialization\n>>\n>> time.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode910\n> src/pkg/big/nat.go:910: // Indirect conversion divides q by its\n> approximate square root, yielding two halves of half-size.\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> s/half-size/half the length of q/ ?\n>\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode918\n> src/pkg/big/nat.go:918:\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> line 918: //\n>\n>> This way, the comment gets associated with convertWords (and is shown,\n>\n> once\n>>\n>> godoc has a mode to show documentation for all code, not just exported\n>\n> idents).\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode923\n> src/pkg/big/nat.go:923: //\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> simple // comment please\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode940\n> src/pkg/big/nat.go:940: //for j := 0; j < ndigits; j++ {\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> delete this commented out code\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode960\n> src/pkg/big/nat.go:960: //for j := 0; j < ndigits; j++ {\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> delete this commented out code\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode970\n> src/pkg/big/nat.go:970: //\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> simple // comment please\n>> (perhaps empty lines around the \"} else {\"\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode988\n> src/pkg/big/nat.go:988: // splt q into the two digit number (upper*bbb +\n> lower) in big big base\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> s/splt/split/\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode991\n> src/pkg/big/nat.go:991: // convert subblocks and collect results in\n> s[lo..middle-1] and s[middle..hi-1]\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> s/s[lo..middle-1]/s[lo:middle]/\n>> s/s[middle..hi-1]/s[middle:hi]/\n>\n>> (we have a perfectly good slice notation :-)\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode997\n> src/pkg/big/nat.go:997: // Generate enough leading zeroes to satsfy the\n> \"fill lo..hi\" contract. Example: 102 in base 100\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> s/satsfy/satisfy/\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/diff/5001/src/pkg/big/nat.go#newcode1017\n> src/pkg/big/nat.go:1017: // Split blocks greater than leafSize Words (or\n> set to 0 to disable indirect conversion)\n> On 2011/07/11 22:48:00, gri wrote:\n>>\n>> I would prefer seeing this code (1017-1033) before the divisors\n>\n> routine where\n>>\n>> some of it gets used.\n>\n> Done.\n>\n> http://codereview.appspot.com/4634075/\n>\n",
			"disapproval": false,
			"date": "2011-07-12 20:26:48.158931",
			"approval": false
		}
	],
	"owner_email": "michael.jones@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "mtj",
	"subject": "code review 4634075: big: added recursive subdivision to nat.string to incre...",
	"created": "2011-06-21 16:40:14.172888",
	"patchsets": [
		1,
		2001,
		5001,
		10001,
		8003,
		15001,
		18001
	],
	"modified": "2011-07-12 20:26:48.158931",
	"closed": false,
	"issue": 4634075
}