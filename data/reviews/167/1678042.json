{
	"description": "Be \"smarter\" when injecting ';' into the parser's input stream\r\nin order to avoid unnecessary restrictions on source code format.\r\nIn order to more accurately implement the apparent desire in the\r\ndescription of ';' injection that ';' are only optional at the end\r\nof statements the injection of ';' for newlines in \"for\", \"if\" and\r\n\"switch\" statements may be disallowed.\r\n\r\nPatch set 1 disallows them and patch set 2 allows them.",
	"cc": [
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"pwil3058@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"iant@golang.org",
				"gloang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Two patch sets have been uploaded.\n\nThey are identical except that the first disallows ';' injection in \"if\", \"for\" and \"switch\" headers and the second allows them.",
			"disapproval": false,
			"date": "2010-06-17 05:57:21.016780",
			"approval": false
		},
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 23/06/10 12:55, Russ Cox wrote:\n> Regarding the code:\n>\n> We tried various context-sensitive semicolon elision\n> before the public release of Go, and they were dissatisfying mainly\n> because understanding a failure mode required understanding\n> complex rules that dictated when semicolons were okay or not.\n> The current scheme has disadvantages but also the significant\n> advantage that when it disagrees with what programmers expect,\n> it is utterly trivial to explain what happened.\n\nBut it will also make Go a laughing stock amongst those who take these \nthings seriously.  E.g. allowing:\n\n     for\n         i := 0\n         i < 10\n         i++ {\n     }\n     for\n         i := 0\n         i < 10\n     {\n         i++\n     }\n     for i := 0; i < 10; i++ {\n     }\n     for i := 0; i < 10;\n     {\n         i++\n     }\n     for ;;\n     {\n     }\n\nbut not:\n\n     for i := 0; i < 10; i++\n     {\n     }\n\nis pretty hard to explain except as an artefact of a sloppy \nimplementation.  Please note instances of new lines before the '{' in \nsome of the legal instances.\n\n>  The complexity of\n> the changes to lex.c scare me.\n\nYou're easily frightened as they're fairly simple.\n\n>  They remind me of the other\n> attempts: when they break they'll be mysterious.  Whatever\n> proposal is made, it will need a significantly simpler implementation\n> than what's in this CL.\n\nIt has to be as complex as it has to be.  As a programmer, you should be \naware of this.\n\nI examined a lot of alternative mechanisms and this was the simplest \nthat didn't have unnecessary side effects.\n\n> I haven't thought enough about the spec changes\n> to tell whether the current code can be simplified, but I urge you to try.\n\nI think that only places that \"surprising\" failures due to ';' injection \nwith this change will occur are:\n\n1. before a 'func' where it is the return type for a function (easy to \nexplain and easy work around using '(' ')') and\n2. with new lines in function types and literals headers when not at top \nlevel (harder but not impossible to explain).  It's not possible to \nsafely address these in lex.c but changes to lex.c and go.y may do the job.\n\nIn other words, nowhere where they don't already occur.\n\n>\n> Regarding the spec:\n>\n>> The semicolon at the end of a statement may be omitted if the statement ends in\n>> a new line and the line's final token is\n>\n> This wording, which does not _require_ semicolon insertion in those cases,\n> is dangerously close to the JavaScript fiasco, where changing one line\n> affects whether the previous line has a semicolon inserted.  The equivalent\n> case in Go is something like\n>\n>      x = a\n>      <-b\n>\n> which is a valid statement list whether or not a semicolon is inserted at the\n> end of the first line.\n\nOK.  I see that as a possible problem but my wording does say \"at the \nend of a statement\".  Does it need a rider to say expressions can only \nbe broken by a new line after an operator?\n\nBTW, my change will not effect the interpretation of that code.\n\n>  The current spec is very clear that semicolons are\n> always inserted, in part to avoid ambiguity and context sensitive behavior\n> in examples like this one.\n\nThe current wording does NOT read as a specification.  It reads as a \nstatement of what the implementation does.  It's OK to do the \nimplementation first and then write the spec but you've got to make it \nsound like the implementation was a consequence of the spec and the \ncurrent wording doesn't pass that test.\n\n>\n> Can you summarize, as concisely as possible, the intended changes\n> your CL makes to the language?\n\nThe changes it makes are:\n\n1. Allow new lines in top level function headers.\n2. Allow new lines before '{' in if, for and switch headers.\n3. Allow new lines before \"else\".\n\nThe first patch also disallows the use of new lines instead of ';' in \nif, for and switch headers which is different to the current \nimplementation which allows it.\n\n>  Is the case above supposed to be\n> handled differently than in the current implementation?\n\nIf you mean the:\n\nx = a\n<- b\n\nthen no.\n\nWould it help if I gave a more detailed explanation of how the change works?\n\nPeter\nPS another advantage of this patch is that it provides a mechanism to \nget rid of all those annoying invalid \"illegal non declaration statement \nat top level\" error messages that are triggered by a syntax error \nfollowed by valid statements inside a function.\n",
			"disapproval": false,
			"date": "2010-06-23 05:23:23.050781",
			"approval": false
		},
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 25/06/10 12:05, Peter Williams wrote:\n> On 25/06/10 03:24, Russ Cox wrote:\n>>> The reason it won't be taken seriously are not that statement but its\n>>> consequences: irrational and inconsistent source format restrictions.\n>>\n>> You may disagree with them, but I don't think you can argue\n>> that they're either irrational or inconsistent. We've given you\n>> the rationale,\n>\n> rationale != rational\n>\n>> repeatedly, and the rule is nothing if not consistent:\n>\n> It's the consequences which appear inconsistent to a human. I draw your\n> attention to the list of possible \"for\" statements that are acceptable\n> and those that aren't that I've presented before.\n>\n>> if the line ends with one of the line-ending tokens, you get a\n>> semicolon for free. Always.\n>\n> Well it's a computer, isn't it.\n>\n> I look forward to your SIGPLAN article where you justify this situation.\n>\n>>\n>>> No comment yet on whether you really want people to be able to use\n>>> new lines\n>>> instead of ';' in \"if\", \"for\" and \"switch\" statements? I'm inferring\n>>> from\n>>> gofmt's behaviour that you'd rather they didn't.\n>>\n>> My favorite thing about Go is that it explores the result of applying\n>> simple rules consistently. The case-based visibility is a great\n>> example of this. If you look back in the Mercurial history you'll\n>> find a time when top-level declarations were tagged with\n>> \"export\" or \"package\" to make them exported or package-local\n>> (as opposed to file-local). It was a simple rule and seemed to\n>> work fine, but it didn't give us a nice way to handle struct fields.\n>> (Annotating every struct field with export or package was too\n>> heavy on the page.) After a lot of discussion, we agreed to try\n>> the case-based visibility rule instead. We gave up file-local\n>> visibility entirely, gave up uppercase local constants and types,\n>> and in return got a simpler, lighter weight rule that provided the\n>> needed functionality (control over fields). It felt weird at the time,\n>> probably because we were so used to the C++ and Java\n>> approaches, but in retrospect I think it is one of Go's best tiny\n>> features. When I look at code in C++ or Java now, it frustrates\n>> me that I can't tell from a use of the name whether it is a\n>> public name or private name. I see a call to DangerousMethod()\n>> and think \"wow, I hope external callers can't call that method!\".\n>> And then I have to spend time looking around to find out.\n>> We also went through a handful of other proposals that were\n>> rejected as not good enough yet, and in retrospect they weren't.\n>> And if we'd settled for any of those we wouldn't have gotten\n>> to where we are today.\n>\n> I mostly agree with your argument here except for your choice of lower\n> case characters as the indicator as it reduces the namespace. Did you\n> consider using \"_\" as the first character for local variables? Or if\n> that's not viable some other character?\n>\n> In a lot of fields, the capitalization of the first character of a name,\n> abbreviation or symbol conveys meaning and you've stifled that a little\n> with the current model.\n\nBy the way, if this failed attempt to demonstrate your brilliance was \nintended to justify your other poor decisions that is an invalid ploy. \nEach decision has to stand on its own.\n\nPeter\n\n",
			"disapproval": false,
			"date": "2010-06-26 00:20:25.844890",
			"approval": false
		},
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"pwil3058@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"iant@golang.org",
				"gloang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "The test/syntax/ff*.go files added by this patch will need to be modified in order to prevent \"hg gofmt\" reformatting them and making them pointless.  As I see it all that is necessary is the addition of a syntax error so I think adding a ';' on a fresh line at the end of each file should do the trick by triggering the \"empty top level statement\" error.",
			"disapproval": false,
			"date": "2010-06-20 02:04:29.771094",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"pwil3058@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"iant@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "",
			"disapproval": false,
			"date": "2010-06-23 02:44:11.345999",
			"approval": false
		},
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 24/06/10 08:28, Russ Cox wrote:\n>> The changes it makes are:\n>>\n>> 1. Allow new lines in top level function headers.\n>> 2. Allow new lines before '{' in if, for and switch headers.\n>> 3. Allow new lines before \"else\".\n>>\n>> The first patch also disallows the use of new lines\n>> instead of ';' in if, for and switch headers which is\n>> different to the current implementation which allows it.\n>\n> It seems to me that there are much simpler ways to solve\n> those three problems, like defining that there is no ; injected\n> before a {\n\nNo. Compound statement rules this out.\n\n> or the word else.\n\nYes, this would work.  On reflection my attempts to avoid reading ahead \none token when it might not be needed are a false saving as it has to be \nscanned eventually anyway.  It's always safe to read ahead one token \nwhen an injection has occurred.\n\n>  In fact, that suggestion has been\n> made and discussed multiple times on the various lists.\n> But this CL does all sorts of other processing, looking for\n> tokens such as const, func, import, for, switch.\n> I'm not comfortable with that.\n\nThis top level can be simplified as well but may effect some of the \nerror reporting stuff in place at the top level.  Basically, Go's \ngrammar means the the only place a ';' can legally occur at the top \nlevel is before an \"import\", \"const\", \"type\", \"var\" or \"func\" key word \nand the top level could be simplified to swallowing all new lines except \nimmediately before one of those key words.  The effect of this would be \nto weaken the effectiveness of the \"non_dcl_stmt\" production in \"xdcl\".\n\nIt would also have some effect on the \"empty top level declaration\" \nerror but this could probably be fixed by adding ';' to the list of \ntokens before which it's OK to inject a new line.\n\n>\n>>> The complexity of\n>>> the changes to lex.c scare me.\n>>\n>> You're easily frightened ...\n>\n> Most of us are.  That's a large part of why the language is\n> as simple as it is, and at least for me that's a huge benefit.\n> There have been many language features that were proposed\n> and delayed because they were still too complex or still not\n> right; and when the right thing finally came along, it was worth\n> the wait, and wouldn't have happened if we'd settled earlier.\n>\n>> It has to be as complex as it has to be.  As a programmer,\n>> you should be aware of this.\n>\n> Ignoring the fact that this is a tautology,\n> no, it doesn't have to be that complex.\n> That might as well be Go's slogan.\n>\n> If the definition you're using requires such complex code,\n> then maybe the definition should be revised.  Not questioning\n> the definition, even in the face of overwhelming implementation\n> complexity, is exactly how we got C++.\n>\n>> The current wording does NOT read as a specification.\n>> It reads as a statement of what the implementation does.\n>> It's OK to do the implementation first and then write the\n>> spec but you've got to make it sound like the implementation\n>> was a consequence of the spec and the current wording\n>> doesn't pass that test.\n>\n> You've made this opinion very clear.  I disagree.\n>\n> Also, we're not trying to please everyone.\n> If someone can't take Go seriously because of one line\n> in the spec that sounds too much like an implementation\n> for their taste, I'm okay with them looking elsewhere.\n\nThe reason it won't be taken seriously are not that statement but its \nconsequences: irrational and inconsistent source format restrictions.\n\nNo comment yet on whether you really want people to be able to use new \nlines instead of ';' in \"if\", \"for\" and \"switch\" statements?  I'm \ninferring from gofmt's behaviour that you'd rather they didn't.\n\nPeter\n\n\n",
			"disapproval": false,
			"date": "2010-06-24 00:08:17.481915",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Regarding the code:\n\nWe tried various context-sensitive semicolon elision\nbefore the public release of Go, and they were dissatisfying mainly\nbecause understanding a failure mode required understanding\ncomplex rules that dictated when semicolons were okay or not.\nThe current scheme has disadvantages but also the significant\nadvantage that when it disagrees with what programmers expect,\nit is utterly trivial to explain what happened.  The complexity of\nthe changes to lex.c scare me.  They remind me of the other\nattempts: when they break they'll be mysterious.  Whatever\nproposal is made, it will need a significantly simpler implementation\nthan what's in this CL.  I haven't thought enough about the spec changes\nto tell whether the current code can be simplified, but I urge you to try.\n\nRegarding the spec:\n\n> The semicolon at the end of a statement may be omitted if the statement ends in\n> a new line and the line's final token is\n\nThis wording, which does not _require_ semicolon insertion in those cases,\nis dangerously close to the JavaScript fiasco, where changing one line\naffects whether the previous line has a semicolon inserted.  The equivalent\ncase in Go is something like\n\n    x = a\n    <-b\n\nwhich is a valid statement list whether or not a semicolon is inserted at the\nend of the first line.  The current spec is very clear that semicolons are\nalways inserted, in part to avoid ambiguity and context sensitive behavior\nin examples like this one.\n\nCan you summarize, as concisely as possible, the intended changes\nyour CL makes to the language?  Is the case above supposed to be\nhandled differently than in the current implementation?\n\nRuss\n",
			"disapproval": false,
			"date": "2010-06-23 02:55:28.063589",
			"approval": false
		},
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 25/06/10 03:24, Russ Cox wrote:\n>> The reason it won't be taken seriously are not that statement but its\n>> consequences: irrational and inconsistent source format restrictions.\n>\n> You may disagree with them, but I don't think you can argue\n> that they're either irrational or inconsistent.  We've given you\n> the rationale,\n\nrationale != rational\n\n> repeatedly, and the rule is nothing if not consistent:\n\nIt's the consequences which appear inconsistent to a human.  I draw your \nattention to the list of possible \"for\" statements that are acceptable \nand those that aren't that I've presented before.\n\n> if the line ends with one of the line-ending tokens, you get a\n> semicolon for free.  Always.\n\nWell it's a computer, isn't it.\n\nI look forward to your SIGPLAN article where you justify this situation.\n\n>\n>> No comment yet on whether you really want people to be able to use new lines\n>> instead of ';' in \"if\", \"for\" and \"switch\" statements?  I'm inferring from\n>> gofmt's behaviour that you'd rather they didn't.\n>\n> My favorite thing about Go is that it explores the result of applying\n> simple rules consistently.  The case-based visibility is a great\n> example of this.  If you look back in the Mercurial history you'll\n> find a time when top-level declarations were tagged with\n> \"export\" or \"package\" to make them exported or package-local\n> (as opposed to file-local).  It was a simple rule and seemed to\n> work fine, but it didn't give us a nice way to handle struct fields.\n> (Annotating every struct field with export or package was too\n> heavy on the page.)  After a lot of discussion, we agreed to try\n> the case-based visibility rule instead.  We gave up file-local\n> visibility entirely, gave up uppercase local constants and types,\n> and in return got a simpler, lighter weight rule that provided the\n> needed functionality (control over fields).  It felt weird at the time,\n> probably because we were so used to the C++ and Java\n> approaches, but in retrospect I think it is one of Go's best tiny\n> features.  When I look at code in C++ or Java now, it frustrates\n> me that I can't tell from a use of the name whether it is a\n> public name or private name.  I see a call to DangerousMethod()\n> and think \"wow, I hope external callers can't call that method!\".\n> And then I have to spend time looking around to find out.\n> We also went through a handful of other proposals that were\n> rejected as not good enough yet, and in retrospect they weren't.\n> And if we'd settled for any of those we wouldn't have gotten\n> to where we are today.\n\nI mostly agree with your argument here except for your choice of lower \ncase characters as the indicator as it reduces the namespace.  Did you \nconsider using \"_\" as the first character for local variables?  Or if \nthat's not viable some other character?\n\nIn a lot of fields, the capitalization of the first character of a name, \nabbreviation or symbol conveys meaning and you've stifled that a little \nwith the current model.\n\n>\n> Getting back to semicolons, I don't care whether semicolons are\n> required in loop headers,  nor do I care whether else needs to be\n> on the same line as }.  What I do care about is that the rule is as\n> simple and predictable as possible while still giving the basic\n> result that I can always drop an end-of-statement semicolon from\n> a valid program without changing the program's meaning.  Not caring\n> about consequences like whether ; is required in for loop headers\n> underconstrains the solution space, making it more likely for it to\n> contain a simple one.\n>\n> Your question suggests that the approach is \"define the exact\n> behavior you want and then accept any complexity required to\n> get there.\"  It's not.  If you can suggest a rule as simple and\n> predictable as the current rule that produces more useful behavior,\n> then we'll be happy to consider it.  Multiple people have looked at\n> this CL and found the spec wording ambiguous and the effects\n> unsettling.\n\nWe can work on that.\n\n>  Instead of continuing to argue about this particular\n> solution, I suggest looking for others that achieve similar effects\n> with less mechanism.\n\nBy the way, if you wanted Go programs to be ';' free why didn't you \ndefine it that way in the formal grammar i.e. define new line as the \nstatement terminator.  All you get from the current mess is the ability \nto put two statements on one line separated by ';' and that could be \nachieved in a formal grammar that uses new line as a statement terminator.\n\nPeter\n",
			"disapproval": false,
			"date": "2010-06-25 02:05:36.790828",
			"approval": false
		},
		{
			"sender": "iant@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Peter Williams <pwil3058@gmail.com> writes:\n\n> The current wording does NOT read as a specification.  It reads as a\n> statement of what the implementation does.  It's OK to do the\n> implementation first and then write the spec but you've got to make it\n> sound like the implementation was a consequence of the spec and the\n> current wording doesn't pass that test.\n\nYou've said things like this before, but I honestly do not understand\nthis complaint.  The current wording is clear and unambiguous.  It\nsays precisely how any tool which reads Go is required to behave.\nThat is exactly what I want from a language spec.\n\n\nI am concerned by your spec patch\n\nhttp://codereview.appspot.com/1678042/diff/2001/3001\n\nbecause your proposed wording does not seem clear and unambiguous to\nme.  It relies on the notion of \"the end of a statement\" which is not\ndefined.  We all agree that under all proposals statements are\npermitted to continue across lines in some cases.  It seems to me that\nsaying \"the end of a statement\" in combination with \"if the statement\nends in a new line\" implies that we already know where the statement\nends.  But the spec is supposed to be telling us where the statement\nends.  It's not supposed to assume that we already know.\n\nIan\n",
			"disapproval": false,
			"date": "2010-06-23 06:38:20.288597",
			"approval": false
		},
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 23/06/10 16:37, Ian Lance Taylor wrote:\n> Peter Williams<pwil3058@gmail.com>  writes:\n>\n>> The current wording does NOT read as a specification.  It reads as a\n>> statement of what the implementation does.  It's OK to do the\n>> implementation first and then write the spec but you've got to make it\n>> sound like the implementation was a consequence of the spec and the\n>> current wording doesn't pass that test.\n>\n> You've said things like this before, but I honestly do not understand\n> this complaint.\n\nSpecifications are supposed to say \"this is what we want\" not \"we did \nthis it has strange consequences and you can figure them out for \nyourselves\".  But maybe that's just me.\n\n>  The current wording is clear and unambiguous.  It\n> says precisely how any tool which reads Go is required to behave.\n> That is exactly what I want from a language spec.\n\nIt's consequences are far from clear as demonstrated by e-mails to \ngolang-nuts.\n\n>\n>\n> I am concerned by your spec patch\n>\n> http://codereview.appspot.com/1678042/diff/2001/3001\n>\n> because your proposed wording does not seem clear and unambiguous to\n> me.  It relies on the notion of \"the end of a statement\" which is not\n> defined.\n\nI disagree.\n\n>  We all agree that under all proposals statements are\n> permitted to continue across lines in some cases.  It seems to me that\n> saying \"the end of a statement\" in combination with \"if the statement\n> ends in a new line\" implies that we already know where the statement\n> ends.  But the spec is supposed to be telling us where the statement\n> ends.  It's not supposed to assume that we already know.\n\nI was trying to keep it as simple as possible and make it sound like a \nspec rather than a statement of implementation.  I'm happy for it to be \nreworded or even keep the original.\n\nPeter\nPS It worries me that you don't see the problems caused by ';' injection \nas a \"show stopper\".  You need to eliminate them or abandon ';' \ninjection if you want Go to be taken seriously.\n",
			"disapproval": false,
			"date": "2010-06-23 06:52:56.128752",
			"approval": false
		},
		{
			"sender": "iant@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Peter Williams <pwil3058@gmail.com> writes:\n\n> On 23/06/10 16:37, Ian Lance Taylor wrote:\n>> Peter Williams<pwil3058@gmail.com>  writes:\n>>\n>>> The current wording does NOT read as a specification.  It reads as a\n>>> statement of what the implementation does.  It's OK to do the\n>>> implementation first and then write the spec but you've got to make it\n>>> sound like the implementation was a consequence of the spec and the\n>>> current wording doesn't pass that test.\n>>\n>> You've said things like this before, but I honestly do not understand\n>> this complaint.\n>\n> Specifications are supposed to say \"this is what we want\" not \"we did\n> this it has strange consequences and you can figure them out for\n> yourselves\".  But maybe that's just me.\n\nI disagree.  The place for \"this is what we want\" is in the\ndocumentation and the tutorial.  The specification is where you\ndescribe precisely how implementations should behave.  The\nspecification corresponds to the ISO standard for a language; it's not\nsomething everybody is expected to read.  (That said, I agree that the\nrest of the documentation for Go is not yet complete; there is no\nequivalent to K&R or \"The C++ Programming Language\".)\n\nThat is, for Go, the place to say \"this is what we want\" regarding\nsemicolons is: http://golang.org/doc/go_tutorial.html#tmp_35 .\n\n\n>>  The current wording is clear and unambiguous.  It\n>> says precisely how any tool which reads Go is required to behave.\n>> That is exactly what I want from a language spec.\n>\n> It's consequences are far from clear as demonstrated by e-mails to\n> golang-nuts.\n\nI'm not sure how to interpret that.  The consequences are perfectly\nclear in that they predict exactly the behaviour you have described.\nI think you may mean something more like the consequences are\nsurprising.  When I say clear and unambiguous, I mean that any\nreasonable person reading the text will come to the same conclusion.\n\nOf course, it's not ideal for a spec to be surprising, and I do\nappreciate your efforts to reduce the surprise.  But as somebody who\nwrites tools, it's far more important that the spec be clear and\nunambiguous than that it be unsurprising.\n\n\n>> I am concerned by your spec patch\n>>\n>> http://codereview.appspot.com/1678042/diff/2001/3001\n>>\n>> because your proposed wording does not seem clear and unambiguous to\n>> me.  It relies on the notion of \"the end of a statement\" which is not\n>> defined.\n>\n> I disagree.\n\nI hope that my writing above has made more clear what my concern is\nhere.  Go is not a language defined by an implementation--there are\nalready two independent implementations.  It's important that every\nimplementor who reads the spec understand it in the same way.  That\nmeans that the spec must not rely on undefined notions like \"the end\nof a statement.\"\n\n\n>>  We all agree that under all proposals statements are\n>> permitted to continue across lines in some cases.  It seems to me that\n>> saying \"the end of a statement\" in combination with \"if the statement\n>> ends in a new line\" implies that we already know where the statement\n>> ends.  But the spec is supposed to be telling us where the statement\n>> ends.  It's not supposed to assume that we already know.\n>\n> I was trying to keep it as simple as possible and make it sound like a\n> spec rather than a statement of implementation.  I'm happy for it to\n> be reworded or even keep the original.\n\nKeeping the original language would not make sense under your\nproposal, since you are in fact proposing a change in the language.\nWhat I'm trying to get is clear and unambiguous language which\ndescribes your proposed change.\n\n\n> PS It worries me that you don't see the problems caused by ';'\n> injection as a \"show stopper\".  You need to eliminate them or abandon\n> ;' injection if you want Go to be taken seriously.\n\nI don't agree with this argument (this does not imply that I reject\nyour proposed change).  One of the decisions made early on for the Go\nlanguage was that all Go code should be formatted the same way.  You\ncan agree or disagree with that decision, but it wasn't made\ncarelessly or accidentally.  One of the consequences of that decision\nis that it is not very important what happens if you format your code\nin a different way.  It doesn't have zero importance, because we do in\ngeneral want to avoid surprises.  But I believe that the issue is not\na show stopper.\n\n\nAlthough this is a weak argument in this context, I'll mention that C\nand C++, languages for which I am very familiar with the\nspecifications, have many examples of specifications that are clear,\nunambiguous, and surprising.  They are surprising at the semantic\nlevel, which is much worse than the way that Go is surprising at the\nsyntactic level.  Yet they are successful languages which are taken\nseriously.\n\nIan\n",
			"disapproval": false,
			"date": "2010-06-23 14:06:56.183113",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> The changes it makes are:\n>\n> 1. Allow new lines in top level function headers.\n> 2. Allow new lines before '{' in if, for and switch headers.\n> 3. Allow new lines before \"else\".\n>\n> The first patch also disallows the use of new lines\n> instead of ';' in if, for and switch headers which is\n> different to the current implementation which allows it.\n\nIt seems to me that there are much simpler ways to solve\nthose three problems, like defining that there is no ; injected\nbefore a { or the word else.  In fact, that suggestion has been\nmade and discussed multiple times on the various lists.\nBut this CL does all sorts of other processing, looking for\ntokens such as const, func, import, for, switch.\nI'm not comfortable with that.\n\n>> The complexity of\n>> the changes to lex.c scare me.\n>\n> You're easily frightened ...\n\nMost of us are.  That's a large part of why the language is\nas simple as it is, and at least for me that's a huge benefit.\nThere have been many language features that were proposed\nand delayed because they were still too complex or still not\nright; and when the right thing finally came along, it was worth\nthe wait, and wouldn't have happened if we'd settled earlier.\n\n> It has to be as complex as it has to be.  As a programmer,\n> you should be aware of this.\n\nIgnoring the fact that this is a tautology,\nno, it doesn't have to be that complex.\nThat might as well be Go's slogan.\n\nIf the definition you're using requires such complex code,\nthen maybe the definition should be revised.  Not questioning\nthe definition, even in the face of overwhelming implementation\ncomplexity, is exactly how we got C++.\n\n> The current wording does NOT read as a specification.\n> It reads as a statement of what the implementation does.\n> It's OK to do the implementation first and then write the\n> spec but you've got to make it sound like the implementation\n> was a consequence of the spec and the current wording\n> doesn't pass that test.\n\nYou've made this opinion very clear.  I disagree.\n\nAlso, we're not trying to please everyone.\nIf someone can't take Go seriously because of one line\nin the spec that sounds too much like an implementation\nfor their taste, I'm okay with them looking elsewhere.\n\nRuss\n",
			"disapproval": false,
			"date": "2010-06-23 22:28:13.509889",
			"approval": false
		},
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 24/06/10 00:06, Ian Lance Taylor wrote:\n> Peter Williams<pwil3058@gmail.com>  writes:\n>> PS It worries me that you don't see the problems caused by ';'\n>> injection as a \"show stopper\".  You need to eliminate them or abandon\n>> ;' injection if you want Go to be taken seriously.\n>\n> I don't agree with this argument (this does not imply that I reject\n> your proposed change).  One of the decisions made early on for the Go\n> language was that all Go code should be formatted the same way.  You\n> can agree or disagree with that decision, but it wasn't made\n> carelessly or accidentally.\n\nIn that case, you should have specified that format and arranged for the \ncompiler to enforce it.  At the moment there are a myriad of ways (some \nof them quite ugly) that a programmer can deviate from \"the one true \nway\" to format code without having the compiler reject it.\n\nSaying that gofmt takes up the slack doesn't cut it as one only needs to \nuse that if one wants to have code accepted into the package library.\n\n>  One of the consequences of that decision\n> is that it is not very important what happens if you format your code\n> in a different way.  It doesn't have zero importance, because we do in\n> general want to avoid surprises.  But I believe that the issue is not\n> a show stopper.\n>\n>\n> Although this is a weak argument in this context, I'll mention that C\n> and C++, languages for which I am very familiar with the\n> specifications, have many examples of specifications that are clear,\n> unambiguous, and surprising.  They are surprising at the semantic\n> level, which is much worse than the way that Go is surprising at the\n> syntactic level.  Yet they are successful languages which are taken\n> seriously.\n\nI find that true of C++ but not of C.  I graduated to C from C++ because \nI found C++ to be a confusing mess.\n\nPeter\nPS I like a lot of the new things that Go brings with it and hope it \nsucceeds but am starting to give up hope.\n",
			"disapproval": false,
			"date": "2010-06-24 00:21:14.027036",
			"approval": false
		},
		{
			"sender": "iant@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Peter Williams <pwil3058@gmail.com> writes:\n\n> On 24/06/10 00:06, Ian Lance Taylor wrote:\n>> Peter Williams<pwil3058@gmail.com>  writes:\n>>> PS It worries me that you don't see the problems caused by ';'\n>>> injection as a \"show stopper\".  You need to eliminate them or abandon\n>>> ;' injection if you want Go to be taken seriously.\n>>\n>> I don't agree with this argument (this does not imply that I reject\n>> your proposed change).  One of the decisions made early on for the Go\n>> language was that all Go code should be formatted the same way.  You\n>> can agree or disagree with that decision, but it wasn't made\n>> carelessly or accidentally.\n>\n> In that case, you should have specified that format and arranged for\n> the compiler to enforce it.  At the moment there are a myriad of ways\n> (some of them quite ugly) that a programmer can deviate from \"the one\n> true way\" to format code without having the compiler reject it.\n\nHaving the compiler enforce the formatting would just waste\ncompilation time which is better used for other things.  In any case\ngofmt does not specify the position of every character; it just\napplies certain formatting rules.\n\n\n>> Although this is a weak argument in this context, I'll mention that C\n>> and C++, languages for which I am very familiar with the\n>> specifications, have many examples of specifications that are clear,\n>> unambiguous, and surprising.  They are surprising at the semantic\n>> level, which is much worse than the way that Go is surprising at the\n>> syntactic level.  Yet they are successful languages which are taken\n>> seriously.\n>\n> I find that true of C++ but not of C.  I graduated to C from C++\n> because I found C++ to be a confusing mess.\n\nSpecific issues with C which I have found to frequently surprise\npeople are the fact that signed overflow is undefined, the definition\nof volatile, and the definition of restrict.\n\n\nI hope you will consider my comments about the change to the spec.  I\nwould have to recommend against your patch if you do not include a\nchange to the spec which precisely describes the new rule you are\nproposing, such that all Go parser implementations will always behave\nin precisely the same way.\n\nIan\n",
			"disapproval": false,
			"date": "2010-06-24 04:36:42.421842",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> The reason it won't be taken seriously are not that statement but its\n> consequences: irrational and inconsistent source format restrictions.\n\nYou may disagree with them, but I don't think you can argue\nthat they're either irrational or inconsistent.  We've given you\nthe rationale, repeatedly, and the rule is nothing if not consistent:\nif the line ends with one of the line-ending tokens, you get a\nsemicolon for free.  Always.\n\n> No comment yet on whether you really want people to be able to use new lines\n> instead of ';' in \"if\", \"for\" and \"switch\" statements? \u00a0I'm inferring from\n> gofmt's behaviour that you'd rather they didn't.\n\nMy favorite thing about Go is that it explores the result of applying\nsimple rules consistently.  The case-based visibility is a great\nexample of this.  If you look back in the Mercurial history you'll\nfind a time when top-level declarations were tagged with\n\"export\" or \"package\" to make them exported or package-local\n(as opposed to file-local).  It was a simple rule and seemed to\nwork fine, but it didn't give us a nice way to handle struct fields.\n(Annotating every struct field with export or package was too\nheavy on the page.)  After a lot of discussion, we agreed to try\nthe case-based visibility rule instead.  We gave up file-local\nvisibility entirely, gave up uppercase local constants and types,\nand in return got a simpler, lighter weight rule that provided the\nneeded functionality (control over fields).  It felt weird at the time,\nprobably because we were so used to the C++ and Java\napproaches, but in retrospect I think it is one of Go's best tiny\nfeatures.  When I look at code in C++ or Java now, it frustrates\nme that I can't tell from a use of the name whether it is a\npublic name or private name.  I see a call to DangerousMethod()\nand think \"wow, I hope external callers can't call that method!\".\nAnd then I have to spend time looking around to find out.\nWe also went through a handful of other proposals that were\nrejected as not good enough yet, and in retrospect they weren't.\nAnd if we'd settled for any of those we wouldn't have gotten\nto where we are today.\n\nGetting back to semicolons, I don't care whether semicolons are\nrequired in loop headers, nor do I care whether else needs to be\non the same line as }.  What I do care about is that the rule is as\nsimple and predictable as possible while still giving the basic\nresult that I can always drop an end-of-statement semicolon from\na valid program without changing the program's meaning.  Not caring\nabout consequences like whether ; is required in for loop headers\nunderconstrains the solution space, making it more likely for it to\ncontain a simple one.\n\nYour question suggests that the approach is \"define the exact\nbehavior you want and then accept any complexity required to\nget there.\"  It's not.  If you can suggest a rule as simple and\npredictable as the current rule that produces more useful behavior,\nthen we'll be happy to consider it.  Multiple people have looked at\nthis CL and found the spec wording ambiguous and the effects\nunsettling.  Instead of continuing to argue about this particular\nsolution, I suggest looking for others that achieve similar effects\nwith less mechanism.\n\nRuss\n",
			"disapproval": false,
			"date": "2010-06-24 17:24:07.723110",
			"approval": false
		},
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 24/06/10 14:36, Ian Lance Taylor wrote:\n> Peter Williams<pwil3058@gmail.com>  writes:\n>\n>> On 24/06/10 00:06, Ian Lance Taylor wrote:\n>>> Peter Williams<pwil3058@gmail.com>   writes:\n>>>> PS It worries me that you don't see the problems caused by ';'\n>>>> injection as a \"show stopper\".  You need to eliminate them or abandon\n>>>> ;' injection if you want Go to be taken seriously.\n>>>\n>>> I don't agree with this argument (this does not imply that I reject\n>>> your proposed change).  One of the decisions made early on for the Go\n>>> language was that all Go code should be formatted the same way.  You\n>>> can agree or disagree with that decision, but it wasn't made\n>>> carelessly or accidentally.\n>>\n>> In that case, you should have specified that format and arranged for\n>> the compiler to enforce it.  At the moment there are a myriad of ways\n>> (some of them quite ugly) that a programmer can deviate from \"the one\n>> true way\" to format code without having the compiler reject it.\n>\n> Having the compiler enforce the formatting would just waste\n> compilation time which is better used for other things.  In any case\n> gofmt does not specify the position of every character; it just\n> applies certain formatting rules.\n\nThen why use the \"one true style\" argument for supporting the problems \ncaused by ';' injection?\n\n>\n>\n>>> Although this is a weak argument in this context, I'll mention that C\n>>> and C++, languages for which I am very familiar with the\n>>> specifications, have many examples of specifications that are clear,\n>>> unambiguous, and surprising.  They are surprising at the semantic\n>>> level, which is much worse than the way that Go is surprising at the\n>>> syntactic level.  Yet they are successful languages which are taken\n>>> seriously.\n>>\n>> I find that true of C++ but not of C.  I graduated to C from C++\n>> because I found C++ to be a confusing mess.\n>\n> Specific issues with C which I have found to frequently surprise\n> people are the fact that signed overflow is undefined,\n\nSomething (overflow that is) that I studiously avoid.\n\n> the definition\n> of volatile, and the definition of restrict.\n\nI've never found the need to use either of these (in fact I wasn't even \naware that \"restrict\" had been introduced in C99 until you mentioned it \nand I looked it up) which would explain why I don't find them confusing. \n  I had noticed a lot of discussion about \"volatile\" on LKML a few years \nago now that you mention it.  I believe the result was a much reduced \nuse of \"volatile\" in the Linux kernel.\n\n>\n>\n> I hope you will consider my comments about the change to the spec.  I\n> would have to recommend against your patch if you do not include a\n> change to the spec which precisely describes the new rule you are\n> proposing, such that all Go parser implementations will always behave\n> in precisely the same way.\n\nSomething along the lines of \"except in ....\" rider?\n\nPeter\nPS I just noticed something in go.y (namely the \"lbrace\" production) \nthat makes my assumptions about LBODY invalid so my change will need to \nbe changed anyway.\n\n",
			"disapproval": false,
			"date": "2010-06-25 01:46:23.980834",
			"approval": false
		},
		{
			"sender": "iant@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Peter Williams <pwil3058@gmail.com> writes:\n\n> On 24/06/10 14:36, Ian Lance Taylor wrote:\n>> Peter Williams<pwil3058@gmail.com>  writes:\n>>\n>>> On 24/06/10 00:06, Ian Lance Taylor wrote:\n>>>> Peter Williams<pwil3058@gmail.com>   writes:\n>>>>> PS It worries me that you don't see the problems caused by ';'\n>>>>> injection as a \"show stopper\".  You need to eliminate them or abandon\n>>>>> ;' injection if you want Go to be taken seriously.\n>>>>\n>>>> I don't agree with this argument (this does not imply that I reject\n>>>> your proposed change).  One of the decisions made early on for the Go\n>>>> language was that all Go code should be formatted the same way.  You\n>>>> can agree or disagree with that decision, but it wasn't made\n>>>> carelessly or accidentally.\n>>>\n>>> In that case, you should have specified that format and arranged for\n>>> the compiler to enforce it.  At the moment there are a myriad of ways\n>>> (some of them quite ugly) that a programmer can deviate from \"the one\n>>> true way\" to format code without having the compiler reject it.\n>>\n>> Having the compiler enforce the formatting would just waste\n>> compilation time which is better used for other things.  In any case\n>> gofmt does not specify the position of every character; it just\n>> applies certain formatting rules.\n>\n> Then why use the \"one true style\" argument for supporting the problems\n> caused by ';' injection?\n\nYou have changed the sense of my words, which are quoted above.  I\ndidn't use the \"one true style\" argument for supporting the problems\ncaused by ';' injection.  I used it to explain why those problems are\nnot a \"show stopper,\" and why it is not necessary to eliminate them in\norder for Go to be taken seriously.  If all code is formatted the same\nway (approximately) then there is no semicolon issue.  The semicolon\nissue only arises in code which is not formatted in the recommended\nstyle.\n\n\n>> I hope you will consider my comments about the change to the spec.  I\n>> would have to recommend against your patch if you do not include a\n>> change to the spec which precisely describes the new rule you are\n>> proposing, such that all Go parser implementations will always behave\n>> in precisely the same way.\n>\n> Something along the lines of \"except in ....\" rider?\n\nWhatever works.  The point is that somebody new to Go who wants to\nwrite a parser has to be able to read the spec and understand\nprecisely what should be accepted as a valid Go program and what\nshould be rejected.\n\nIan\n",
			"disapproval": false,
			"date": "2010-06-25 05:06:50.539530",
			"approval": false
		},
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 25/06/10 15:06, Ian Lance Taylor wrote:\n> Peter Williams<pwil3058@gmail.com>  writes:\n>\n>> On 24/06/10 14:36, Ian Lance Taylor wrote:\n>>> Peter Williams<pwil3058@gmail.com>   writes:\n>>>\n>>>> On 24/06/10 00:06, Ian Lance Taylor wrote:\n>>>>> Peter Williams<pwil3058@gmail.com>    writes:\n>>>>>> PS It worries me that you don't see the problems caused by ';'\n>>>>>> injection as a \"show stopper\".  You need to eliminate them or abandon\n>>>>>> ;' injection if you want Go to be taken seriously.\n>>>>>\n>>>>> I don't agree with this argument (this does not imply that I reject\n>>>>> your proposed change).  One of the decisions made early on for the Go\n>>>>> language was that all Go code should be formatted the same way.  You\n>>>>> can agree or disagree with that decision, but it wasn't made\n>>>>> carelessly or accidentally.\n>>>>\n>>>> In that case, you should have specified that format and arranged for\n>>>> the compiler to enforce it.  At the moment there are a myriad of ways\n>>>> (some of them quite ugly) that a programmer can deviate from \"the one\n>>>> true way\" to format code without having the compiler reject it.\n>>>\n>>> Having the compiler enforce the formatting would just waste\n>>> compilation time which is better used for other things.  In any case\n>>> gofmt does not specify the position of every character; it just\n>>> applies certain formatting rules.\n>>\n>> Then why use the \"one true style\" argument for supporting the problems\n>> caused by ';' injection?\n>\n> You have changed the sense of my words, which are quoted above.  I\n> didn't use the \"one true style\" argument for supporting the problems\n> caused by ';' injection.  I used it to explain why those problems are\n> not a \"show stopper,\" and why it is not necessary to eliminate them in\n> order for Go to be taken seriously.  If all code is formatted the same\n> way (approximately) then there is no semicolon issue.  The semicolon\n> issue only arises in code which is not formatted in the recommended\n> style.\n\nThat's a very big \"only\".  I can't think of any other languages where \nsomething like this arises.  As I said to Russ, I look forward to \nreading your SIGPLAN article explaining all of this.\n\nBecause you're too lazy to type a few ';'s or too lazy to implement ';' \nelision properly you're ruining what was a very promising new \nprogramming language.  I think that's a pity.\n\nI wish you good luck with Go but (for me) the frustrations are \noutweighing the benefits.  Back to C and Python for me.\n\nLet me know if you ever get a sensible resolution to this issue?\n\nThanks\nPeter\n",
			"disapproval": false,
			"date": "2010-06-25 05:33:27.122246",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": ">> You may disagree with them, but I don't think you can argue\n>> that they're either irrational or inconsistent. \u00a0We've given you\n>> the rationale,\n>\n> rationale != rational\n\nthanks.\n\n>> repeatedly, and the rule is nothing if not consistent:\n>\n> It's the consequences which appear inconsistent to a human. \u00a0I draw your\n> attention to the list of possible \"for\" statements that are acceptable and\n> those that aren't that I've presented before.\n\nthe consequences are entirely consistent if you know the rule.\nif you don't know the rule you don't know the language.\ngiven var x byte,\n\nx == 254 => x+1 == 255\nx == 255 => x+1 == 0\n\nthat's not very consistent either at some level, but you and i\nfind it okay because we know the rule.\n\n>> if the line ends with one of the line-ending tokens, you get a\n>> semicolon for free. \u00a0Always.\n>\n> Well it's a computer, isn't it.\n>\n> I look forward to your SIGPLAN article where you justify this situation.\n\ni'm pretty tired of this attitude.\n\nif you come back with another proposal, i'll look at it,\nbut i'm done with the discussion of this one.\n\nruss\n",
			"disapproval": false,
			"date": "2010-06-25 14:14:55.729945",
			"approval": false
		},
		{
			"sender": "pwil3058@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 26/06/10 00:14, Russ Cox wrote:\n>>> You may disagree with them, but I don't think you can argue\n>>> that they're either irrational or inconsistent.  We've given you\n>>> the rationale,\n>>\n>> rationale != rational\n>\n> thanks.\n>\n>>> repeatedly, and the rule is nothing if not consistent:\n>>\n>> It's the consequences which appear inconsistent to a human.  I draw your\n>> attention to the list of possible \"for\" statements that are acceptable and\n>> those that aren't that I've presented before.\n>\n> the consequences are entirely consistent if you know the rule.\n> if you don't know the rule you don't know the language.\n> given var x byte,\n>\n> x == 254 =>  x+1 == 255\n> x == 255 =>  x+1 == 0\n>\n> that's not very consistent either at some level, but you and i\n> find it okay because we know the rule.\n\nThat is very consistent with the way 1's compliment arithmetic works.\n\nThis is legal:\n\n     for\n         i := 0\n         i < 10\n         i++ {\n     }\n     for\n         i := 0\n         i < 10\n     {\n         i++\n     }\n     for i := 0; i < 10; i++ {\n     }\n     for i := 0; i < 10;\n     {\n         i++\n     }\n     for ;;\n     {\n     }\n\nbut not:\n\n     for i := 0; i < 10; i++\n     {\n     }\n\nis not consistent with anything but the refusal of people to admit they \nfailed to successfully implement ';' elision and give up on it.\n\n>\n>>> if the line ends with one of the line-ending tokens, you get a\n>>> semicolon for free.  Always.\n>>\n>> Well it's a computer, isn't it.\n>>\n>> I look forward to your SIGPLAN article where you justify this situation.\n>\n> i'm pretty tired of this attitude.\n>\n> if you come back with another proposal, i'll look at it,\n> but i'm done with the discussion of this one.\n\nDon't worry I'm giving up.  You all obviously have too much invested in \nyour bad decisions to look at them rationally and fix the problems they \ncause.  I'm wasting my time trying to convince you otherwise.\n\nThanks for the constructive/technical feedback on the patch.  Oops, I'm \nsorry there was none.\n\nGood luck\nPeter\nPS Good to see Qtvali back in golang-nuts.  He's got the right level of \nrationality to fit right in with you guys.\n",
			"disapproval": false,
			"date": "2010-06-26 00:42:59.866975",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"pwil3058@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "removing reviewers; timed out",
			"disapproval": false,
			"date": "2010-08-03 20:08:06.513640",
			"approval": false
		}
	],
	"owner_email": "pwil3058@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "pwil3058",
	"subject": "Be \"smarter\" when injecting ';' into the parser's input...",
	"created": "2010-06-17 04:57:10.248284",
	"patchsets": [
		1,
		2001
	],
	"modified": "2010-08-03 20:08:06.513864",
	"closed": false,
	"issue": 1678042
}