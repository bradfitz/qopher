{
	"description": "net: add DialOpt, the extensible Dial w/ options dialer\n\nAdd DialOpt. So we have:\n\nfunc Dial(net, addr string) (Conn, error)\nfunc DialTimeout(net, addr string, timeout time.Duration) (Conn, error)\nfunc DialOpt(addr string, opts ...DialOption) (Conn, error)\n\nDialTimeout (and Dial) are regrettable in retrospect. Maybe\nin a future Go we'll be back down to one Dial, with DialOpt\nbecoming Dial.\n\nDialOpt looks like:\n\nc, err := net.DialOpt(\"google.com:80\")  // tcp is default\nc, err := net.DialOpt(\"google.com:80\", net.Timeout(30 * time.Second))\nc, err := net.DialOpt(\"google.com:80\", net.TCPFastOpen())\nc, err := net.DialOpt(\"google.com:80\", net.LocalAddr(..))\nc, err := net.DialOpt(\"google.com:53\", net.Network(\"udp6\"))\n\nAnd then: (clustered in godoc)\n\ntype DialOption interface { /* private only */ }\n  func Deadline(time.Time) DialOption\n  func LocalAddr(Addr) DialOption\n  func Network(string) DialOption\n  func TCPFastOpen() DialOption\n  func Timeout(time.Duration) DialOption\n\nI'm pretty confident we could add Happy Eyeballs to this too.\n\nFixes issue 3097\nUpdate issue 3610\nUpdate issue 4842",
	"cc": [
		"golang-dev@googlegroups.com",
		"r@golang.org",
		"dave@cheney.net",
		"minux.ma@gmail.com",
		"rsc@golang.org"
	],
	"reviewers": [
		"google@julienschmidt.com"
	],
	"messages": [
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Feb 21, 2013 at 10:47 PM, <minux.ma@gmail.com> wrote:\r\n\r\n> i have an (probably bad) idea:\r\n> introduce this means a whole lot of networking packages also need\r\n> DialOpt like interface\r\n\r\n\r\nWhy is that?\r\n\r\n\r\n> could we add the option somehow to the address or network string?\r\n> and provide various constructor like this:\r\n> func SetTCPKeepAlive(addr string) string\r\n>\r\n\r\nSure, in theory, but we could also in theory stop using all static types\r\nand use interface{} for everything.\r\n\r\n\r\n> it will incur allocations at every dial, so perhaps it should be added\r\n> to the net part.\r\n>\r\n\r\nCompared to dialing and what happens with that connection afterwards, I'm\r\nnot concerned about a tiny allocation (which the compiler could in-theory\r\neliminate, if it doesn't largely already).\r\n",
			"disapproval": false,
			"date": "2013-02-22 07:04:55.149720",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Feb 22, 2013 at 10:57 AM, Russ Cox <rsc@golang.org> wrote:\r\n\r\n> Can we just make DialOpt a struct?\r\n>\r\n\r\nThat's like the original DialPlan proposal. With a Dial method on the Opt\r\nstruct? I could write that up as a separate CL so we can compare the two.\r\n",
			"disapproval": false,
			"date": "2013-02-22 19:21:20.985010",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Feb 22, 2013 at 3:04 PM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n\r\n> On Thu, Feb 21, 2013 at 10:47 PM, <minux.ma@gmail.com> wrote:\r\n>\r\n>> i have an (probably bad) idea:\r\n>\r\n> introduce this means a whole lot of networking packages also need\r\n>> DialOpt like interface\r\n>\r\n>\r\n> Why is that?\r\n>\r\nFor example, do we need DialOpt in crypto/tls?\r\nof course, we can say that people want this flexibility should use\r\ntls.Client directly.\r\n\r\n>\r\n>\r\n>> could we add the option somehow to the address or network string?\r\n>> and provide various constructor like this:\r\n>> func SetTCPKeepAlive(addr string) string\r\n>>\r\n>\r\n> Sure, in theory, but we could also in theory stop using all static types\r\n> and use interface{} for everything.\r\n>\r\nyes, this idea is not type safe. I was just worried about introducing\r\nDialOpt like interface\r\nto other networking related packages.\r\nBut, perhaps it's better to get it all done with a single DialOpt than with\r\na lot of Dail* functions, so this new API is ok.\r\n\r\nWe should have used a similar solution before adding DialTimeout, though.\r\nwe probably could eliminate DialTimeout in Go 2. ;-)\r\n",
			"disapproval": false,
			"date": "2013-02-22 08:38:38.505620",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2013-02-22 01:10:17.314720",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Note: it's tempting to just modify the net.Dial signature, but that's an\r\nAPI change.\r\n\r\nOn Thu, Feb 21, 2013 at 5:10 PM, <bradfitz@golang.org> wrote:\r\n\r\n> Reviewers: golang-dev_googlegroups.com,\r\n>\r\n> Message:\r\n> Hello golang-dev@googlegroups.com,\r\n>\r\n> I'd like you to review this change to\r\n> https://go.googlecode.com/hg/\r\n>\r\n>\r\n> Description:\r\n> net: add DialOpt, the extensible Dial w/ options dialer\r\n>\r\n> Proposal.\r\n>\r\n> Add DialOpt. So we have:\r\n>\r\n> func Dial(net, addr string) (Conn, error)\r\n> func DialTimeout(net, addr string, timeout time.Duration) (Conn, error)\r\n> func DialOpt(addr string, opts ...DialOption) (Conn, error)\r\n>\r\n> Dials like:\r\n>\r\n> c, err := net.DialOpt(\"google.com:80\")  // tcp is default\r\n> c, err := net.DialOpt(\"google.com:80\", net.Timeout(30 * time.Second))\r\n> c, err := net.DialOpt(\"google.com:80\", net.TCPFastOpen())\r\n> c, err := net.DialOpt(\"google.com:80\", net.LocalAddr(..))\r\n> c, err := net.DialOpt(\"google.com:53\", net.Network(\"udp6\"))\r\n>\r\n> And then: (clustered in godoc)\r\n>\r\n> type DialOption interface { /* private only */ }\r\n>   func Deadline(time.Time) DialOption\r\n>   func LocalAddr(...) DialOption\r\n>   func Network(string) DialOption\r\n>   func TCPFastOption() DialOption\r\n>   func Timeout(time.Duration) DialOption\r\n>\r\n> I'm pretty confident we could add Happy Eyeballs to this too.\r\n>\r\n> Update issue 3097\r\n> Update issue 3610\r\n> Update issue 4842\r\n>\r\n> Please review this at https://codereview.appspot.**com/7365049/<https://codereview.appspot.com/7365049/>\r\n>\r\n> Affected files:\r\n>   M src/pkg/net/dial.go\r\n>\r\n>\r\n> Index: src/pkg/net/dial.go\r\n> ==============================**==============================**=======\r\n> --- a/src/pkg/net/dial.go\r\n> +++ b/src/pkg/net/dial.go\r\n> @@ -6,6 +6,65 @@\r\n>\r\n>  import \"time\"\r\n>\r\n> +// A DialOption modifies a DialOpt call.\r\n> +type DialOption interface {\r\n> +       dialOption()\r\n> +}\r\n> +\r\n> +var (\r\n> +       // TCP is a dial option to dial with TCP (over IPv4 or IPv6).\r\n> +       TCP = Network(\"tcp\")\r\n> +\r\n> +       // UDP is a dial option to dial with UDP (over IPv4 or IPv6).\r\n> +       UDP = Network(\"udp\")\r\n> +)\r\n> +\r\n> +// Network returns a DialOption to dial using the given network.\r\n> +//\r\n> +// Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\r\n> +// \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\r\n> +// (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\r\n> +// \"unixpacket\".\r\n> +//\r\n> +// For IP networks, net must be \"ip\", \"ip4\" or \"ip6\" followed\r\n> +// by a colon and a protocol number or name, such as\r\n> +// \"ipv4:1\" or \"ip6:ospf\".\r\n> +func Network(net string) DialOption {\r\n> +       return dialNetwork(net)\r\n> +}\r\n> +\r\n> +type dialNetwork string\r\n> +\r\n> +func (dialNetwork) dialOption() {}\r\n> +\r\n> +// Deadline returns a DialOption to fail a dial that doesn't\r\n> +// complete before t.\r\n> +func Deadline(t time.Time) DialOption {\r\n> +       return dialDeadline(t)\r\n> +}\r\n> +\r\n> +// Timeout returns a DialOption to fail a dial that doesn't\r\n> +// complete before the provided duration.\r\n> +func Timeout(d time.Duration) DialOption {\r\n> +       return dialDeadline(time.Now().Add(d)**)\r\n> +}\r\n> +\r\n> +type dialDeadline time.Time\r\n> +\r\n> +func (dialDeadline) dialOption() {}\r\n> +\r\n> +type tcpFastOpen struct{}\r\n> +\r\n> +func (tcpFastOpen) dialOption() {}\r\n> +\r\n> +// TCPFastTimeout returns an option to use TCP Fast Open (TFO) when\r\n> +// doing this dial. It is only valid for use with TCP connections.\r\n> +// Data sent over a TFO connection may be processed by the peer\r\n> +// multiple times, so should be used with caution.\r\n> +func TCPFastTimeout() DialOption {\r\n> +       return tcpFastOpen{}\r\n> +}\r\n> +\r\n>  func parseNetwork(net string) (afnet string, proto int, err error) {\r\n>         i := last(net, ':')\r\n>         if i < 0 { // no colon\r\n> @@ -75,11 +134,38 @@\r\n>  //     Dial(\"ip6:ospf\", \"::1\")\r\n>  //\r\n>  func Dial(net, addr string) (Conn, error) {\r\n> -       ra, err := resolveAddr(\"dial\", net, addr, noDeadline)\r\n> +       return DialOpt(addr, dialNetwork(net))\r\n> +}\r\n> +\r\n> +func netFromOptions(opts []DialOption) string {\r\n> +       for _, opt := range opts {\r\n> +               if p, ok := opt.(dialNetwork); ok {\r\n> +                       return string(p)\r\n> +               }\r\n> +       }\r\n> +       return \"tcp\"\r\n> +}\r\n> +\r\n> +func deadlineFromOptions(opts []DialOption) time.Time {\r\n> +       for _, opt := range opts {\r\n> +               if d, ok := opt.(dialDeadline); ok {\r\n> +                       return time.Time(d)\r\n> +               }\r\n> +       }\r\n> +       return noDeadline\r\n> +}\r\n> +\r\n> +// DialOpt dials addr using the provided options.\r\n> +// If no options are provided, DialOpt(addr) is equivalent\r\n> +// to Dial(\"tcp\", addr). See Dial for the syntax of addr.\r\n> +func DialOpt(addr string, opts ...DialOption) (Conn, error) {\r\n> +       net := netFromOptions(opts)\r\n> +       deadline := deadlineFromOptions(opts)\r\n> +       ra, err := resolveAddr(\"dial\", net, addr, deadline)\r\n>         if err != nil {\r\n>                 return nil, err\r\n>         }\r\n> -       return dial(net, addr, ra, noDeadline)\r\n> +       return dial(net, addr, ra, deadline)\r\n>  }\r\n>\r\n>  func dial(net, addr string, ra Addr, deadline time.Time) (c Conn, err\r\n> error) {\r\n>\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-02-22 01:12:59.458410",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This is ready for review + submit now.\r\n\r\nUpdated CL description, added LocalAddr, and hid the TCPFastOpen option\r\nwith a TODO until it's implemented in a future CL.\r\n\r\n\r\nOn Wed, Feb 27, 2013 at 11:51 AM, <bradfitz@golang.org> wrote:\r\n\r\n> Hello golang-dev@googlegroups.com, r@golang.org, dave@cheney.net,\r\n> minux.ma@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\r\n>\r\n> Please take another look.\r\n>\r\n>\r\n> https://codereview.appspot.**com/7365049/<https://codereview.appspot.com/7365049/>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-02-27 19:52:22.695830",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"r@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM from an API perspective, but a networking maven should weigh in too\n\nhttps://codereview.appspot.com/7365049/diff/5001/src/pkg/net/dial.go\nFile src/pkg/net/dial.go (right):\n\nhttps://codereview.appspot.com/7365049/diff/5001/src/pkg/net/dial.go#newcode47\nsrc/pkg/net/dial.go:47: // complete before the provided duration.\ns/before/within/ ?",
			"disapproval": false,
			"date": "2013-02-22 01:13:38.904440",
			"approval": true
		},
		{
			"sender": "dave@cheney.net",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Strawman: Were you thinking of Dial(net, addr string, opts ...DialOption) ?\r\n\r\nOn Fri, Feb 22, 2013 at 12:12 PM, Brad Fitzpatrick <bradfitz@golang.org> wrote:\r\n> Note: it's tempting to just modify the net.Dial signature, but that's an API\r\n> change.\r\n>\r\n>\r\n> On Thu, Feb 21, 2013 at 5:10 PM, <bradfitz@golang.org> wrote:\r\n>>\r\n>> Reviewers: golang-dev_googlegroups.com,\r\n>>\r\n>> Message:\r\n>> Hello golang-dev@googlegroups.com,\r\n>>\r\n>> I'd like you to review this change to\r\n>> https://go.googlecode.com/hg/\r\n>>\r\n>>\r\n>> Description:\r\n>> net: add DialOpt, the extensible Dial w/ options dialer\r\n>>\r\n>> Proposal.\r\n>>\r\n>> Add DialOpt. So we have:\r\n>>\r\n>> func Dial(net, addr string) (Conn, error)\r\n>> func DialTimeout(net, addr string, timeout time.Duration) (Conn, error)\r\n>> func DialOpt(addr string, opts ...DialOption) (Conn, error)\r\n>>\r\n>> Dials like:\r\n>>\r\n>> c, err := net.DialOpt(\"google.com:80\")  // tcp is default\r\n>> c, err := net.DialOpt(\"google.com:80\", net.Timeout(30 * time.Second))\r\n>> c, err := net.DialOpt(\"google.com:80\", net.TCPFastOpen())\r\n>> c, err := net.DialOpt(\"google.com:80\", net.LocalAddr(..))\r\n>> c, err := net.DialOpt(\"google.com:53\", net.Network(\"udp6\"))\r\n>>\r\n>> And then: (clustered in godoc)\r\n>>\r\n>> type DialOption interface { /* private only */ }\r\n>>   func Deadline(time.Time) DialOption\r\n>>   func LocalAddr(...) DialOption\r\n>>   func Network(string) DialOption\r\n>>   func TCPFastOption() DialOption\r\n>>   func Timeout(time.Duration) DialOption\r\n>>\r\n>> I'm pretty confident we could add Happy Eyeballs to this too.\r\n>>\r\n>> Update issue 3097\r\n>> Update issue 3610\r\n>> Update issue 4842\r\n>>\r\n>> Please review this at https://codereview.appspot.com/7365049/\r\n>>\r\n>> Affected files:\r\n>>   M src/pkg/net/dial.go\r\n>>\r\n>>\r\n>> Index: src/pkg/net/dial.go\r\n>> ===================================================================\r\n>> --- a/src/pkg/net/dial.go\r\n>> +++ b/src/pkg/net/dial.go\r\n>> @@ -6,6 +6,65 @@\r\n>>\r\n>>  import \"time\"\r\n>>\r\n>> +// A DialOption modifies a DialOpt call.\r\n>> +type DialOption interface {\r\n>> +       dialOption()\r\n>> +}\r\n>> +\r\n>> +var (\r\n>> +       // TCP is a dial option to dial with TCP (over IPv4 or IPv6).\r\n>> +       TCP = Network(\"tcp\")\r\n>> +\r\n>> +       // UDP is a dial option to dial with UDP (over IPv4 or IPv6).\r\n>> +       UDP = Network(\"udp\")\r\n>> +)\r\n>> +\r\n>> +// Network returns a DialOption to dial using the given network.\r\n>> +//\r\n>> +// Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\r\n>> +// \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\r\n>> +// (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\r\n>> +// \"unixpacket\".\r\n>> +//\r\n>> +// For IP networks, net must be \"ip\", \"ip4\" or \"ip6\" followed\r\n>> +// by a colon and a protocol number or name, such as\r\n>> +// \"ipv4:1\" or \"ip6:ospf\".\r\n>> +func Network(net string) DialOption {\r\n>> +       return dialNetwork(net)\r\n>> +}\r\n>> +\r\n>> +type dialNetwork string\r\n>> +\r\n>> +func (dialNetwork) dialOption() {}\r\n>> +\r\n>> +// Deadline returns a DialOption to fail a dial that doesn't\r\n>> +// complete before t.\r\n>> +func Deadline(t time.Time) DialOption {\r\n>> +       return dialDeadline(t)\r\n>> +}\r\n>> +\r\n>> +// Timeout returns a DialOption to fail a dial that doesn't\r\n>> +// complete before the provided duration.\r\n>> +func Timeout(d time.Duration) DialOption {\r\n>> +       return dialDeadline(time.Now().Add(d))\r\n>> +}\r\n>> +\r\n>> +type dialDeadline time.Time\r\n>> +\r\n>> +func (dialDeadline) dialOption() {}\r\n>> +\r\n>> +type tcpFastOpen struct{}\r\n>> +\r\n>> +func (tcpFastOpen) dialOption() {}\r\n>> +\r\n>> +// TCPFastTimeout returns an option to use TCP Fast Open (TFO) when\r\n>> +// doing this dial. It is only valid for use with TCP connections.\r\n>> +// Data sent over a TFO connection may be processed by the peer\r\n>> +// multiple times, so should be used with caution.\r\n>> +func TCPFastTimeout() DialOption {\r\n>> +       return tcpFastOpen{}\r\n>> +}\r\n>> +\r\n>>  func parseNetwork(net string) (afnet string, proto int, err error) {\r\n>>         i := last(net, ':')\r\n>>         if i < 0 { // no colon\r\n>> @@ -75,11 +134,38 @@\r\n>>  //     Dial(\"ip6:ospf\", \"::1\")\r\n>>  //\r\n>>  func Dial(net, addr string) (Conn, error) {\r\n>> -       ra, err := resolveAddr(\"dial\", net, addr, noDeadline)\r\n>> +       return DialOpt(addr, dialNetwork(net))\r\n>> +}\r\n>> +\r\n>> +func netFromOptions(opts []DialOption) string {\r\n>> +       for _, opt := range opts {\r\n>> +               if p, ok := opt.(dialNetwork); ok {\r\n>> +                       return string(p)\r\n>> +               }\r\n>> +       }\r\n>> +       return \"tcp\"\r\n>> +}\r\n>> +\r\n>> +func deadlineFromOptions(opts []DialOption) time.Time {\r\n>> +       for _, opt := range opts {\r\n>> +               if d, ok := opt.(dialDeadline); ok {\r\n>> +                       return time.Time(d)\r\n>> +               }\r\n>> +       }\r\n>> +       return noDeadline\r\n>> +}\r\n>> +\r\n>> +// DialOpt dials addr using the provided options.\r\n>> +// If no options are provided, DialOpt(addr) is equivalent\r\n>> +// to Dial(\"tcp\", addr). See Dial for the syntax of addr.\r\n>> +func DialOpt(addr string, opts ...DialOption) (Conn, error) {\r\n>> +       net := netFromOptions(opts)\r\n>> +       deadline := deadlineFromOptions(opts)\r\n>> +       ra, err := resolveAddr(\"dial\", net, addr, deadline)\r\n>>         if err != nil {\r\n>>                 return nil, err\r\n>>         }\r\n>> -       return dial(net, addr, ra, noDeadline)\r\n>> +       return dial(net, addr, ra, deadline)\r\n>>  }\r\n>>\r\n>>  func dial(net, addr string, ra Addr, deadline time.Time) (c Conn, err\r\n>> error) {\r\n>>\r\n>>\r\n>\r\n> --\r\n>\r\n> ---\r\n> You received this message because you are subscribed to the Google Groups\r\n> \"golang-dev\" group.\r\n> To unsubscribe from this group and stop receiving emails from it, send an\r\n> email to golang-dev+unsubscribe@googlegroups.com.\r\n> For more options, visit https://groups.google.com/groups/opt_out.\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-02-22 01:16:28.461400",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Yes. That changes the type net.Dial, so it's a no-go.\r\n\r\npackage myprogram\r\n\r\nvar dial = net.Dial  // var for tests to change\r\n\r\nfunc program() {\r\n    c, err := dial(\"tcp\", \"example.com\")\r\n    ....\r\n}\r\n\r\npackage myprogram // test\r\n\r\nvar dialResc = make(chan struct { net.Conn; error })\r\nfunc init() {\r\n   dial = fakeDialForTest  // BOOM in Dave's proposal\r\n}\r\n\r\nfunc fakeDialForTest(net, addr string) (net.Conn, error) {\r\n      dialRes := <-dialResc\r\n      return dialRes.Conn, dialRes.error\r\n}\r\n\r\nOn Thu, Feb 21, 2013 at 5:16 PM, Dave Cheney <dave@cheney.net> wrote:\r\n\r\n> Strawman: Were you thinking of Dial(net, addr string, opts ...DialOption) ?\r\n>\r\n> On Fri, Feb 22, 2013 at 12:12 PM, Brad Fitzpatrick <bradfitz@golang.org>\r\n> wrote:\r\n> > Note: it's tempting to just modify the net.Dial signature, but that's an\r\n> API\r\n> > change.\r\n> >\r\n> >\r\n> > On Thu, Feb 21, 2013 at 5:10 PM, <bradfitz@golang.org> wrote:\r\n> >>\r\n> >> Reviewers: golang-dev_googlegroups.com,\r\n> >>\r\n> >> Message:\r\n> >> Hello golang-dev@googlegroups.com,\r\n> >>\r\n> >> I'd like you to review this change to\r\n> >> https://go.googlecode.com/hg/\r\n> >>\r\n> >>\r\n> >> Description:\r\n> >> net: add DialOpt, the extensible Dial w/ options dialer\r\n> >>\r\n> >> Proposal.\r\n> >>\r\n> >> Add DialOpt. So we have:\r\n> >>\r\n> >> func Dial(net, addr string) (Conn, error)\r\n> >> func DialTimeout(net, addr string, timeout time.Duration) (Conn, error)\r\n> >> func DialOpt(addr string, opts ...DialOption) (Conn, error)\r\n> >>\r\n> >> Dials like:\r\n> >>\r\n> >> c, err := net.DialOpt(\"google.com:80\")  // tcp is default\r\n> >> c, err := net.DialOpt(\"google.com:80\", net.Timeout(30 * time.Second))\r\n> >> c, err := net.DialOpt(\"google.com:80\", net.TCPFastOpen())\r\n> >> c, err := net.DialOpt(\"google.com:80\", net.LocalAddr(..))\r\n> >> c, err := net.DialOpt(\"google.com:53\", net.Network(\"udp6\"))\r\n> >>\r\n> >> And then: (clustered in godoc)\r\n> >>\r\n> >> type DialOption interface { /* private only */ }\r\n> >>   func Deadline(time.Time) DialOption\r\n> >>   func LocalAddr(...) DialOption\r\n> >>   func Network(string) DialOption\r\n> >>   func TCPFastOption() DialOption\r\n> >>   func Timeout(time.Duration) DialOption\r\n> >>\r\n> >> I'm pretty confident we could add Happy Eyeballs to this too.\r\n> >>\r\n> >> Update issue 3097\r\n> >> Update issue 3610\r\n> >> Update issue 4842\r\n> >>\r\n> >> Please review this at https://codereview.appspot.com/7365049/\r\n> >>\r\n> >> Affected files:\r\n> >>   M src/pkg/net/dial.go\r\n> >>\r\n> >>\r\n> >> Index: src/pkg/net/dial.go\r\n> >> ===================================================================\r\n> >> --- a/src/pkg/net/dial.go\r\n> >> +++ b/src/pkg/net/dial.go\r\n> >> @@ -6,6 +6,65 @@\r\n> >>\r\n> >>  import \"time\"\r\n> >>\r\n> >> +// A DialOption modifies a DialOpt call.\r\n> >> +type DialOption interface {\r\n> >> +       dialOption()\r\n> >> +}\r\n> >> +\r\n> >> +var (\r\n> >> +       // TCP is a dial option to dial with TCP (over IPv4 or IPv6).\r\n> >> +       TCP = Network(\"tcp\")\r\n> >> +\r\n> >> +       // UDP is a dial option to dial with UDP (over IPv4 or IPv6).\r\n> >> +       UDP = Network(\"udp\")\r\n> >> +)\r\n> >> +\r\n> >> +// Network returns a DialOption to dial using the given network.\r\n> >> +//\r\n> >> +// Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\r\n> >> +// \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\r\n> >> +// (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\r\n> >> +// \"unixpacket\".\r\n> >> +//\r\n> >> +// For IP networks, net must be \"ip\", \"ip4\" or \"ip6\" followed\r\n> >> +// by a colon and a protocol number or name, such as\r\n> >> +// \"ipv4:1\" or \"ip6:ospf\".\r\n> >> +func Network(net string) DialOption {\r\n> >> +       return dialNetwork(net)\r\n> >> +}\r\n> >> +\r\n> >> +type dialNetwork string\r\n> >> +\r\n> >> +func (dialNetwork) dialOption() {}\r\n> >> +\r\n> >> +// Deadline returns a DialOption to fail a dial that doesn't\r\n> >> +// complete before t.\r\n> >> +func Deadline(t time.Time) DialOption {\r\n> >> +       return dialDeadline(t)\r\n> >> +}\r\n> >> +\r\n> >> +// Timeout returns a DialOption to fail a dial that doesn't\r\n> >> +// complete before the provided duration.\r\n> >> +func Timeout(d time.Duration) DialOption {\r\n> >> +       return dialDeadline(time.Now().Add(d))\r\n> >> +}\r\n> >> +\r\n> >> +type dialDeadline time.Time\r\n> >> +\r\n> >> +func (dialDeadline) dialOption() {}\r\n> >> +\r\n> >> +type tcpFastOpen struct{}\r\n> >> +\r\n> >> +func (tcpFastOpen) dialOption() {}\r\n> >> +\r\n> >> +// TCPFastTimeout returns an option to use TCP Fast Open (TFO) when\r\n> >> +// doing this dial. It is only valid for use with TCP connections.\r\n> >> +// Data sent over a TFO connection may be processed by the peer\r\n> >> +// multiple times, so should be used with caution.\r\n> >> +func TCPFastTimeout() DialOption {\r\n> >> +       return tcpFastOpen{}\r\n> >> +}\r\n> >> +\r\n> >>  func parseNetwork(net string) (afnet string, proto int, err error) {\r\n> >>         i := last(net, ':')\r\n> >>         if i < 0 { // no colon\r\n> >> @@ -75,11 +134,38 @@\r\n> >>  //     Dial(\"ip6:ospf\", \"::1\")\r\n> >>  //\r\n> >>  func Dial(net, addr string) (Conn, error) {\r\n> >> -       ra, err := resolveAddr(\"dial\", net, addr, noDeadline)\r\n> >> +       return DialOpt(addr, dialNetwork(net))\r\n> >> +}\r\n> >> +\r\n> >> +func netFromOptions(opts []DialOption) string {\r\n> >> +       for _, opt := range opts {\r\n> >> +               if p, ok := opt.(dialNetwork); ok {\r\n> >> +                       return string(p)\r\n> >> +               }\r\n> >> +       }\r\n> >> +       return \"tcp\"\r\n> >> +}\r\n> >> +\r\n> >> +func deadlineFromOptions(opts []DialOption) time.Time {\r\n> >> +       for _, opt := range opts {\r\n> >> +               if d, ok := opt.(dialDeadline); ok {\r\n> >> +                       return time.Time(d)\r\n> >> +               }\r\n> >> +       }\r\n> >> +       return noDeadline\r\n> >> +}\r\n> >> +\r\n> >> +// DialOpt dials addr using the provided options.\r\n> >> +// If no options are provided, DialOpt(addr) is equivalent\r\n> >> +// to Dial(\"tcp\", addr). See Dial for the syntax of addr.\r\n> >> +func DialOpt(addr string, opts ...DialOption) (Conn, error) {\r\n> >> +       net := netFromOptions(opts)\r\n> >> +       deadline := deadlineFromOptions(opts)\r\n> >> +       ra, err := resolveAddr(\"dial\", net, addr, deadline)\r\n> >>         if err != nil {\r\n> >>                 return nil, err\r\n> >>         }\r\n> >> -       return dial(net, addr, ra, noDeadline)\r\n> >> +       return dial(net, addr, ra, deadline)\r\n> >>  }\r\n> >>\r\n> >>  func dial(net, addr string, ra Addr, deadline time.Time) (c Conn, err\r\n> >> error) {\r\n> >>\r\n> >>\r\n> >\r\n> > --\r\n> >\r\n> > ---\r\n> > You received this message because you are subscribed to the Google Groups\r\n> > \"golang-dev\" group.\r\n> > To unsubscribe from this group and stop receiving emails from it, send an\r\n> > email to golang-dev+unsubscribe@googlegroups.com.\r\n> > For more options, visit https://groups.google.com/groups/opt_out.\r\n> >\r\n> >\r\n>\r\n",
			"disapproval": false,
			"date": "2013-02-22 01:20:57.194410",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"r@golang.org",
				"dave@cheney.net",
				"minux.ma@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "i have an (probably bad) idea:\nintroduce this means a whole lot of networking packages also need\nDialOpt like interface which has a snow-ball effect imo.\n\ncould we add the option somehow to the address or network\u00a0string?\nand provide various constructor like this:\nfunc SetTCPKeepAlive(addr string) string\n\nit will incur allocations at every dial, so perhaps it should be added\nto the net part.",
			"disapproval": false,
			"date": "2013-02-22 06:47:45.085260",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I wonder if we could define DialOption as an interface?\r\n\r\ntype DialOption interface {\r\n    // handle could set any options (ioctls) on the connection or even\r\nreplace the incoming conn.\r\n    // This isn't a good name for the method, but you get the idea.\r\n    // we could make the interface private for now.\r\n    handle(conn net.Conn, addr string) (net.Conn, err)\r\n}\r\n\r\nthen in DialOpt, we just queue a Dial(\"tcp\", addr) in the front of options\r\nand then invoke the\r\nhandle method of all provided options in order (passing the net.Conn\r\nthrough the chain).\r\n\r\nWhen we think the interface is mature enough, we can make it public, so\r\nthat people could\r\nmake their application-specific DialOption (of course, they are on their\r\nown if they do this).\r\n(and yes, when 3rd-party packages are doing this, they must dig the fd out\r\nlike go.net/ipv4)\r\n\r\nperhaps there will be too much overhead for DialOpt(addr, NetOption(\"udp\"))?\r\n(but of course we can optimize this case)\r\n",
			"disapproval": false,
			"date": "2013-02-22 15:50:07.471190",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Feb 22, 2013 at 7:49 AM, minux <minux.ma@gmail.com> wrote:\r\n\r\n> I wonder if we could define DialOption as an interface?\r\n\r\n\r\nIt already _is_ an interface.  See the CL.  I'm confused.\r\n\r\n\r\n> type DialOption interface {\r\n>     // handle could set any options (ioctls) on the connection or even\r\n> replace the incoming conn.\r\n>     // This isn't a good name for the method, but you get the idea.\r\n>     // we could make the interface private for now.\r\n>     handle(conn net.Conn, addr string) (net.Conn, err)\r\n> }\r\n>\r\nthen in DialOpt, we just queue a Dial(\"tcp\", addr) in the front of options\r\n> and then invoke the\r\n> handle method of all provided options in order (passing the net.Conn\r\n> through the chain).\r\n>\r\n\r\nThat doesn't work for many of the options, or not without a lot of\r\nrefactoring.  We currently need to complete dialing before making a\r\nnet.Conn.  But with dial timeouts, your proposal would need to have a\r\nnet.Conn pre-dial.  Also, TCP_FASTOPEN needs to be set before you dial.\r\n How does that work in your proposal?\r\n\r\nYour proposal seems way more complicated, but has the exact same API:  an\r\ninterface with one private method.\r\n\r\n\r\n> When we think the interface is mature enough, we can make it public, so\r\n> that people could\r\n> make their application-specific DialOption (of course, they are on their\r\n> own if they do this).\r\n>  (and yes, when 3rd-party packages are doing this, they must dig the fd\r\n> out like go.net/ipv4)\r\n>\r\n\r\nI would rather not ever export this.  Seems like too much chaos to support,\r\nespecially when the implementors of said interface would just be using\r\nreflect to reach into internals and mess with stuff using unsafe.  No\r\nthanks.\r\n\r\n\r\n> perhaps there will be too much overhead for DialOpt(addr,\r\n> NetOption(\"udp\"))?\r\n> (but of course we can optimize this case)\r\n>\r\n\r\nThat's what I figured:  a) dialing/etc is more expensive anyway, 2) we can\r\nfix the compiler if anybody ever cares enough.\r\n",
			"disapproval": false,
			"date": "2013-02-22 18:50:54.631200",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\r\n",
			"disapproval": false,
			"date": "2013-02-27 16:42:45.890580",
			"approval": true
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Feb 22, 2013 at 12:38 AM, minux <minux.ma@gmail.com> wrote:\r\n\r\n>\r\n> On Fri, Feb 22, 2013 at 3:04 PM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n>\r\n>> On Thu, Feb 21, 2013 at 10:47 PM, <minux.ma@gmail.com> wrote:\r\n>>\r\n>>> i have an (probably bad) idea:\r\n>>\r\n>> introduce this means a whole lot of networking packages also need\r\n>>> DialOpt like interface\r\n>>\r\n>>\r\n>> Why is that?\r\n>>\r\n> For example, do we need DialOpt in crypto/tls?\r\n>\r\n\r\nNo, because there is already http://golang.org/pkg/crypto/tls/#Client which\r\ntakes a net.Conn.\r\n\r\nAlso, tls.Dial already takes a pointer to a struct, so we could add\r\n[]net.DialOption to *Config if we really wanted to. (I don't.)\r\n",
			"disapproval": false,
			"date": "2013-02-22 18:53:09.483940",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Can we just make DialOpt a struct? Making it an interface means adding tons\r\nmore API to package net (one top-level func per option), and package net\r\nalready has way too much API.\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2013-02-22 18:57:58.834630",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "My main objection to this CL is just the proliferation of API in package\r\nnet. The godoc output is already overwhelming. But perhaps this doesn't\r\nmake it much worse. I do like the general idea. If we were starting from\r\nscratch, there's a good argument for making this net.Dial.\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2013-02-22 20:23:16.828380",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Feb 22, 2013 at 12:23 PM, Russ Cox <rsc@golang.org> wrote:\r\n\r\n> My main objection to this CL is just the proliferation of API in package\r\n> net. The godoc output is already overwhelming. But perhaps this doesn't\r\n> make it much worse. I do like the general idea. If we were starting from\r\n> scratch, there's a good argument for making this net.Dial.\r\n>\r\n\r\nMy hunch is that the struct way adds just as much API (in terms of lines to\r\napi/go11.txt) but it's just lighter in godoc HTML visually.  I could've\r\nprobably made this much lighter in HTML by using vars instead of funcs in a\r\nfew places, but I was actually optimizing *for* more HTML, so things would\r\ngroup under the DialOption type.  (I was watching my local godoc as I\r\ndeveloped it)\r\n\r\nMaybe we're both wrong for designing APIs for how they will render in\r\ntoday's godoc.\r\n\r\nI don't know.\r\n",
			"disapproval": false,
			"date": "2013-02-22 20:28:33.633710",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Feb 27, 2013 at 8:42 AM, Russ Cox <rsc@golang.org> wrote:\r\n\r\n> LGTM\r\n>\r\n\r\nI'm confused.  I haven't even prototyped the struct version yet.  I thought\r\nyou/we wanted to compare the two approaches?\r\n\r\nIs that a LGTM or SGTM or ... ?\r\n",
			"disapproval": false,
			"date": "2013-02-27 16:46:33.890230",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"r@golang.org",
				"dave@cheney.net",
				"minux.ma@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com, r@golang.org, dave@cheney.net, minux.ma@gmail.com, rsc@golang.org (cc: golang-dev@googlegroups.com),\n\nPlease take another look.",
			"disapproval": false,
			"date": "2013-02-27 19:51:28.436870",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I think the DialOpt is nicer than the struct. As long as the new API all\r\nappears under type DialOption I think it's fine.\r\n",
			"disapproval": false,
			"date": "2013-02-27 18:00:12.753500",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"r@golang.org",
				"dave@cheney.net",
				"minux.ma@gmail.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/7365049/diff/5001/src/pkg/net/dial.go\nFile src/pkg/net/dial.go (right):\n\nhttps://codereview.appspot.com/7365049/diff/5001/src/pkg/net/dial.go#newcode47\nsrc/pkg/net/dial.go:47: // complete before the provided duration.\neither that or 'before the end of the duration'.",
			"disapproval": false,
			"date": "2013-02-27 18:29:53.931230",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"r@golang.org",
				"dave@cheney.net",
				"minux.ma@gmail.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM",
			"disapproval": false,
			"date": "2013-02-27 19:53:31.667230",
			"approval": true
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"r@golang.org",
				"dave@cheney.net",
				"minux.ma@gmail.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=54731addb542 ***\n\nnet: add DialOpt, the extensible Dial w/ options dialer\n\nAdd DialOpt. So we have:\n\nfunc Dial(net, addr string) (Conn, error)\nfunc DialTimeout(net, addr string, timeout time.Duration) (Conn, error)\nfunc DialOpt(addr string, opts ...DialOption) (Conn, error)\n\nDialTimeout (and Dial) are regrettable in retrospect. Maybe\nin a future Go we'll be back down to one Dial, with DialOpt\nbecoming Dial.\n\nDialOpt looks like:\n\nc, err := net.DialOpt(\"google.com:80\")  // tcp is default\nc, err := net.DialOpt(\"google.com:80\", net.Timeout(30 * time.Second))\nc, err := net.DialOpt(\"google.com:80\", net.TCPFastOpen())\nc, err := net.DialOpt(\"google.com:80\", net.LocalAddr(..))\nc, err := net.DialOpt(\"google.com:53\", net.Network(\"udp6\"))\n\nAnd then: (clustered in godoc)\n\ntype DialOption interface { /* private only */ }\n  func Deadline(time.Time) DialOption\n  func LocalAddr(Addr) DialOption\n  func Network(string) DialOption\n  func TCPFastOpen() DialOption\n  func Timeout(time.Duration) DialOption\n\nI'm pretty confident we could add Happy Eyeballs to this too.\n\nFixes issue 3097\nUpdate issue 3610\nUpdate issue 4842\n\nR=golang-dev, r, dave, minux.ma, rsc\nCC=golang-dev\nhttps://codereview.appspot.com/7365049\n\nhttps://codereview.appspot.com/7365049/diff/5001/src/pkg/net/dial.go\nFile src/pkg/net/dial.go (right):\n\nhttps://codereview.appspot.com/7365049/diff/5001/src/pkg/net/dial.go#newcode47\nsrc/pkg/net/dial.go:47: // complete before the provided duration.\nOn 2013/02/22 01:13:38, r wrote:\n> s/before/within/ ?\n\nDone.",
			"disapproval": false,
			"date": "2013-02-27 19:59:41.806880",
			"approval": false
		},
		{
			"sender": "google@julienschmidt.com",
			"recipients": [
				"bradfitz@golang.org",
				"google@julienschmidt.com",
				"golang-dev@googlegroups.com",
				"r@golang.org",
				"dave@cheney.net",
				"minux.ma@gmail.com",
				"rsc@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "That may well be a little late, but I just saw the commit and honestly, I think this is way to complex. Why not something as simple as this:\n\ntype DialOptions struct {\n\tLocalAdress net.Addr\n\tTCPFastOpen bool\n\tTimeout     time.Duration\n}\n\nfunc Dial(net, addr string) (net.Conn, error) {\n\treturn DialOpts(net, addr, &DialOptions{})\n}\n\nfunc DialOpts(net, add string, opts *DialOptions) (net.Conn, error) { // Not sure if opts should be a pointer\n\tra, err := resolveAddr(\"dial\", net, addr, opts.Timeout) // time.Duration here!\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// merge func dial(..) in here\n}\n\n\nExample Usage:\n\tnet.DialOpts(\"tcp\", \"google.com:80\", &net.DialOptions{\n\t\tTCPFastOpen: true,\n\t\tTimeout:     30 * time.Second,\n\t})\n\nIt is more consistent with the existing functions (and doesn't make them obsolete), doesn't extend the API so much and if I'm not completely wrong, this also saves a few byte memory and a few CPU cycles.\n\nWould a struct like this lead to problems with the API contract when it should be extended?\n\n\nAnd one other thing:\n>func Timeout(d time.Duration) DialOption {\n> \treturn dialDeadline(time.Now().Add(d))\n>}\n\nDoesn't this result in unexpected behavior if you create the DialOption some time before calling Dial?\nThe Deadline might even be passed before Dial is called despite the fact that you set a timeout of x seconds.\nThat is why I use time.Duration instead time.Time in the draft above. The actual deadline should be created somewhere internally right before the actual dial starts.",
			"disapproval": false,
			"date": "2013-02-28 02:36:44.198750",
			"approval": false
		}
	],
	"owner_email": "bradfitz@golang.org",
	"private": false,
	"base_url": "",
	"owner": "bradfitz",
	"subject": "code review 7365049: net: add DialOpt, the extensible Dial w/ options dialer",
	"created": "2013-02-22 01:09:58.450090",
	"patchsets": [
		1,
		2001,
		5001,
		21001,
		3003
	],
	"modified": "2013-02-28 02:36:44.362490",
	"closed": true,
	"issue": 7365049
}