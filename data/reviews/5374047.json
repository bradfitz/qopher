{
	"description": "time doc sketch",
	"cc": [],
	"reviewers": [
		"golang-dev@googlegroups.com",
		"dvyukov@google.com",
		"rogpeppe@gmail.com",
		"gustavo@niemeyer.net",
		"lvd@google.com",
		"bradfitz@golang.org",
		"r@golang.org",
		"cw@f00f.org",
		"n13m3y3r@gmail.com",
		"adg@golang.org",
		"r@google.com",
		"uriel@berlinblue.org",
		"lucio.dere@gmail.com",
		"karl@kingkarl.com",
		"kevlar@google.com",
		"dr.volker.dobler@gmail.com",
		"dsymonds@golang.org",
		"mpvl@google.com",
		"mpvl@golang.org"
	],
	"messages": [
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 01:42, Chris Wedgwood <cw@f00f.org> wrote:\n> but when it's used for delta's it's extremely\n> useful\n\nIsn't that exactly what time.Duration is?\n\n> zone worries me a little, it's probably unavoidable\n\nIn the {sec, nsec, zone} triple, sec+nsec are always UTC.\nzone just affects how it gets printed.\n\n> > time.Now returns a triple, time.Duration is nanoseconds,\n> > so you do\n> >\n> > t0 := time.Now()\n> > ... thing you want to time ...\n> > delta := time.Now().Sub(t0)\n>\n> if time.Nanoseconds stays about, i can continue to use\n> that where i see fit\n\nI still don't understand why you would want to do that.\nThe obvious reason would be that you think you can do better\nthan the above code, but the above code is nearly trivial:\n\n> t0 := time.Now()\n\nA function call, returns 3 words on the stack.\nJust as cheap as time.Nanoseconds() currently is.\nActually a little cheaper on Unix, since it doesn't\nmultiply sec*1e9 + nsec yet.\n\n> ... thing you want to time ...\n\nHasn't changed.\n\n> t1 := time.Now()\n\nSee last call.\n\n> delta := t1.Sub(t0)\n\nTwo subtractions, a multiply, and an add.\nIn the old way, it would be one subtraction,\nbut the old way also would have done an extra\nmultiply+add on each of the time.Nanoseconds\ncalls.  So in total this way is 2 sub + 1 mul + 1 add\nand the old total was 1 sub + 2 mul + 2 add.\n\nThey're basically identical.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 14:16:21.009968",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "What if zone was not an attribute of Time?\n\nHave Time as an abstract type that represents a real quantity in fixed but\narbitrary internal dimension, and have a Zone be an object that defines the\nzero (and dst jumps) and can extract\nyear/month/day/yearday/hour/min/sec/fractionalsecond from it.\n\nThat way you could have something like\n\ntype Duration int64 // private implementation detail: in units of\nnanoseconds\nfunc (Duration) Add(Duration)  Duration\nfunc (Duration) Sub(Duration)  Duration\nfunc (Duration) Multiply(f float64) Duration\n// nice constants like you had\n\nfunc (Duration) NanoSeconds() int64\nfunc (Duration) Seconds() int64\nfunc (Duration) Minutes() int64\nfunc (Duration) Hours() int64\nfunc (Duration) Days() int64\nfunc (Duration) Years() int64\nfunc (Duration) Split() (y, d, h, m, s, ns int64)\nfunc (Duration) String() string\n\n\ntype Time struct {\n    offset_to_hidden_fixed_but_arbitrary_zero_point Duration\n}\n\nfunc (Time) Add(Duration)\nfunc (Time) Sub(Duration)\n\nfunc Now() Time\n\ntype Zone interface {\n\n Seconds(Time) int64\n Minutes(Time) int64\n Hours(Time) int64\n Days(Time) int64\n Years(Time) int64\n IsDST(Time) bool\n Split(Time) (y, d, h, m, s, ns int64, dst bool)\n\n String(Time) string\n Parse(string) Time\n\n  // returns the Duration you'd have to wait in this Zone until the\nwallclock says the same as at time t in zone z.\n  Offset(z Zone, t Time) Duration\n\n}\n\nvar Local Zone\nvar UTC Zone\nvar Unix Zone   // ? is this still needed\n",
			"disapproval": false,
			"date": "2011-11-10 16:16:28.595600",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rogpeppe@gmail.com",
				"gustavo@niemeyer.net",
				"lvd@google.com",
				"bradfitz@golang.org",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\nFile src/pkg/time/time.doc (right):\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode69\nsrc/pkg/time/time.doc:69: in the range [0, 59].\nhave leap seconds been internationally voted out yet?\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode105\nsrc/pkg/time/time.doc:105: Day                  = 24 * Hour\nDay is kinda a Period, not a Duration, by some pedantic interpretations.\n\nI guess its type here is Duration, though, so people shouldn't be surprised when they add a Day and don't get back the same hour.\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode146\nsrc/pkg/time/time.doc:146: func (m Month) String() string\nin what language? or as %02d?\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode161\nsrc/pkg/time/time.doc:161: func (d Weekday) String() string\nlikewise",
			"disapproval": false,
			"date": "2011-11-10 17:11:59.046299",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 12:11,  <bradfitz@golang.org> wrote:\n> I guess its type here is Duration, though, so people shouldn't be\n> surprised when they add a Day and don't get back the same hour.\n\nThat's a good point.  I will remove Day.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 17:17:57.962599",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 12:56,  <cw@f00f.org> wrote:\n> might there be a case (uncommon perhaps) where years could be >9999 ?\n\nThose can be represented but not parsed.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 18:03:19.730294",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 19:04, Russ Cox <rsc@golang.org> wrote:\n\n> On Thu, Nov 10, 2011 at 12:56,  <cw@f00f.org> wrote:\n> > how does this work when t.zone != u.zone ?\n>\n> zone is only for presentation.  The actual value\n> in the time.Time is always UTC\n\n\nif you want convenience, you can give Time a method String that uses a\nprogram wide default (and settable) timezone, no reason to drag it around\nin all the values.  For programs that care, eg webservers with per\nuser/request timezone settings you make it always explicit.\n\n\n\n> , and it is adjusted\n> according to zone when printing.  Because the\n> actual value is always UTC, subtracting two\n> time.Time is well defined even if they are in\n> different zones.\n>\n\nsee, to me that you need extra constraint makes your proposal more complex\nthan mine in my book.    eg, when you call Local or UTC, i'm confused as to\nwhether that just changes the zone value or also adjusts the time.  when i\nthink about it i can see what has to be the case, but its still confusion\narising from mixing concepts.\n\n\n\n>\n> Thu Nov 10 18:04:06 GMT 2011 - Thu Nov 10 13:04:05 EST 2011 = 1s\n>\n> Russ\n>\n",
			"disapproval": false,
			"date": "2011-11-10 18:14:40.047398",
			"approval": false
		},
		{
			"sender": "n13m3y3r@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rogpeppe@gmail.com",
				"gustavo@niemeyer.net",
				"lvd@google.com",
				"bradfitz@golang.org",
				"r@golang.org",
				"cw@f00f.org",
				"n13m3y3r@gmail.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\nFile src/pkg/time/time.doc (right):\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode91\nsrc/pkg/time/time.doc:91: Zone returns t with the time zone set to z.\nI'd expect the Time.Zone method to return the Time's Zone, which seems to be missing.\n\nI suggest Time.AtZone for the method above.",
			"disapproval": false,
			"date": "2011-11-10 19:15:01.743738",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 14:28,  <n13m3y3r@gmail.com> wrote:\n> Would be nice to have <A> and <B> being equivalent.\n> I suggest renaming the time.Date function to time.New.\n\nRight.  So you can pick a prefix for all those (Make is the\ncorrect one, but confuses people), or you can do what\nthis CL does, which is to pick the convention that\nthe converters come in pairs:\n\nfunc Foo(xxx) Time\n\nfunc (t Time) Foo() (xxx)\n\nSo you can say time.Unix(1320953925) to get a Time\nand then t.Unix() to get back to the 1320953925.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 19:39:54.220672",
			"approval": false
		},
		{
			"sender": "uriel@berlinblue.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 11:39 PM, Rob 'Commander' Pike <r@google.com> wrote:\n>\n> On Nov 10, 2011, at 2:36 PM, Andrew Gerrand wrote:\n>\n>> I'm having trouble reconciling the idea of the zone as being part of the time.\n>>\n>> A zone is a property of place, not a property of time.\n>\n> It's not a property of a moment in time, but it is a property of the perception of time. What time is it where you are? It's 14:39 here.\n\nYes, but 'here' means where one of many potential users is, 'here'\nfrom the view of a program running on a server is rarely a property of\na time value, but of who and from where is *viewing* that particular\nvalue right now, which often is also presented to many people in other\nplaces with other zones.\n\nuriel\n",
			"disapproval": false,
			"date": "2011-11-10 22:44:38.812340",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "\nOn Nov 10, 2011, at 2:41 PM, Andrew Gerrand wrote:\n\n> On 11 November 2011 09:39, Rob 'Commander' Pike <r@google.com> wrote:\n>> \n>> On Nov 10, 2011, at 2:36 PM, Andrew Gerrand wrote:\n>> \n>>> I'm having trouble reconciling the idea of the zone as being part of the time.\n>>> \n>>> A zone is a property of place, not a property of time.\n>> \n>> It's not a property of a moment in time, but it is a property of the perception of time. What time is it where you are? It's 14:39 here.\n> \n> Exactly. It's a property of the communication of time. Zones belong at\n> the edges, not the core (time.Time), of our time package.\n\n\nI'm not going to argue this here. The design is really nice in practice - you'll see - and you're all getting hung up on semantics. There is no better place to store the time zone than in the time, and the time zone has no effect outside printing and formatting.\n\n-rob\n\n",
			"disapproval": false,
			"date": "2011-11-10 22:46:59.511239",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 18:19,  <tux21b@gmail.com> wrote:\n> E.g. times might be part of an atom feed (with many different time zones\n> attached to them, if its a planet for example), netchans or databases. By\n> default, printing all those times might lead to a big confusion, since every\n> time might be printed in a completely different timezone.\n\nIt's not like these times appeared randomly in your program.\nYou have control over both where they come from and\nhow you print them.  If you want hh:mm in UTC, you just\nwrite\n\n    fmt.Println(t.UTC().Format(\"15:04\"))\n\nIf you want UTC everywhere, print t.UTC().\nIf you want local time everywhere, print t.Local().\n\nThe argument about an Atom feed is invalid.\nAtom feeds are required to use RFC3339 time stamps,\nwhich include the time zone offset, so there is no\nambiguity about precisely what instant is meant.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 23:56:31.189309",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Since this is an opaque data structure, how will we handle\nserialization/deserialization? We could implement Gob(En|De)code and\n(M|Unm)arshalJSON methods, I guess, but it would \"just work\" in most\nplaces if the\nfields were exported.\n\nAnother option is to provide an \"export form\" struct with exported\nfields to/from which you can get/obtain a time.Time.\n\nIs the zone data included in the serialized form? This seems difficult\nif the Zone field is an interface.\n\nAndrew\n",
			"disapproval": false,
			"date": "2011-11-13 01:29:00.809157",
			"approval": false
		},
		{
			"sender": "uriel@berlinblue.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 11:55 PM, Rob 'Commander' Pike <r@google.com> wrote:\n> You're all seeing complexity as an option when simplicity achieves as much or more.\n\nYou know much more about complexity and simplicity than me, but I find\nthis claim baffling.\n\nFirst to be clear, I don't think Christoph, Andrew, Chris Wedgwood or\nme are advocating Luuk's proposal, which might be good, but I\npersonally don't quite understand and seems on first glance overly\ncomplex.\n\nThe question is: why not remove the zone field, and just provide a\ndesired zone when printing (the default can be UTC, or even the local\nzone if you like)?\n\nRemoving the zone from the Time type makes things simpler and more\ngeneral (you can always embed your Time along a zone in a new type if\nyou want that).\n\nKeeping it means it often wont be used or worse will be misused.\n\nMaybe we have very different use cases in mind, but I still can't\nimagine which ones you are thinking of.\n\nuriel\n",
			"disapproval": false,
			"date": "2011-11-13 03:07:16.292614",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 9:42 AM, Chris Wedgwood <cw@f00f.org> wrote:\n>> You have to remember that it's nanoseconds,\n>> and you have to know what the 0 time is.\n>\n> agreed\n>\n> but when it's used for delta's it's extremely\n> useful\n>\n>> You also have to remember if it is a time instant\n>> or a duration.\n>\n> true\n>\n>> The intent is that it is just fine for that. \u00a0Internally\n>> a Time is {sec, nsec, zone}, so three words.\n>\n> zone worries me a little, it's probably unavoidable\n>\n> (mostly because my experience with API's that have timezone knowledge\n> is they almost always are hard to use so people get things wrong\n> because they are hard to use (database date/datetime types are also\n> extremely error prone IME))\n\nAgree. A lot of server software works solely with UTC, and then things\nare easy. However, if you always have to deal with an object\ncontaining zone you as if have to handle it somehow, and it makes\nthings more complicated than they needs to be.\nI don't have a particular proposal, though.\n",
			"disapproval": false,
			"date": "2011-11-10 06:48:46.708811",
			"approval": false
		},
		{
			"sender": "cw@f00f.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> zone is only for presentation.\n\nSo every time.Time carries around this data that's only used for\nprinting?\n\nWhy not have zone be a feature at print-time?\n\n> The actual value in the time.Time is always UTC, and it is adjusted\n> according to zone when printing.\n\nit's not clear why the separation of ns & sec is useful then\n",
			"disapproval": false,
			"date": "2011-11-10 18:16:54.561504",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 13:16, Chris Wedgwood <cw@f00f.org> wrote:\n> it's not clear why the separation of ns & sec is useful then\n\nThe separation of ns & sec is only in the internal\nrepresentation.  The client of the API cannot see\nthat separation.  The implementation could change\nwithout the client knowing.\n\nThe reason to have the separation is that int64\nnanoseconds are only good for 292 years\non either side of 1970.  That's not terrible but\nnot fantastic either.  Also, most operations\nbegin by dividing by 1e9 anyway, so this avoids\nthat.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 18:20:06.403602",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 19:23, Chris Wedgwood <cw@f00f.org> wrote:\n\n> On Thu, Nov 10, 2011 at 01:20:05PM -0500, Russ Cox wrote:\n>\n> > The reason to have the separation is that int64\n> > nanoseconds are only good for 292 years\n> > on either side of 1970.\n>\n> oh, that's perfectly rasonable\n>\n\nbut you'd rarely want century stretches to be timed to nanosecond accuracy,\nIs carrying around 128 bits and doing 128bit integer arithmetic everywhere\nthat much cheaper than using float64?\n\n/L\n",
			"disapproval": false,
			"date": "2011-11-10 18:46:53.710632",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 14:42, Gustavo Niemeyer <gustavo@niemeyer.net> wrote:\n> Yeah, my point is precisely that time.Date doesn't follow this convention.\n\ntime.DateClockNanoZone seemed too long.  :-)\n",
			"disapproval": false,
			"date": "2011-11-10 19:44:03.824440",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> New(T) in general returns *T. \u00a0This wouldn't.\n\nThis seems to be a side effect of the fact that we use pointers most\nof the time, IMO.  It sounds fine to use New with a by-value return\ntype when this is the convention encouraged for the specific type,\nreflect.New being one such example.\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I'm not absolutely sure of anything.\n",
			"disapproval": false,
			"date": "2011-11-10 19:46:23.508184",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 10 November 2011 19:00,  <n13m3y3r@gmail.com> wrote:\n>\n> http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\n> File src/pkg/time/time.doc (right):\n>\n> http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode117\n> src/pkg/time/time.doc:117: Lookup(seconds int64) (minutes int, abbrev\n> string)\n> rog, duration is a delta rather than an instant, so it's not suitable\n> for the parameter.\n\noh, maybe i've misunderstood. i thought the parameter *was* a delta - the\nnumber of seconds elapsed since the epoch.\n",
			"disapproval": false,
			"date": "2011-11-10 20:25:55.400852",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> oh, maybe i've misunderstood. i thought the parameter *was* a delta - the\n> number of seconds elapsed since the epoch.\n\nIt is stored as a delta, but that's an implementation detail. It\nactually represents a specific instant in time rather than a duration\nlike a month or a year. If you still don't see the distinction, try to\nmake sense of adding the epoch delta to any other timestamp.\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I'm not absolutely sure of anything.\n",
			"disapproval": false,
			"date": "2011-11-10 22:04:13.543163",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "(...)\n> For example, is the modification time on a file a time.Sec,\n> a time.Nano, or a *time.Time? \u00a0This is the key point:\n> *** I never want to make that decision again. ***\n\nSo true.. MongoDB, for instance, happens to store timestamps as\nmicroseconds. Guess what happens when people try to use the Go driver.\n\nThe same is also true for deltas/durations.. we have _ns and NS\nvariables spreading all over the place in an attempt to remind people\nof the unit.\n\nI'm looking forward to cleaning things up with a single Time and a\nsingle Duration types.\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I'm not absolutely sure of anything.\n",
			"disapproval": false,
			"date": "2011-11-11 22:47:31.908276",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "If you would like to see the effect of the new API on the\nsource tree, see http://golang.org/cl/5390042 .\nPlease do not send comments on the time implementation\nitself yet.  It is not yet ready for review.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-15 22:59:45.895933",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 12:11,  <bradfitz@golang.org> wrote:\n> src/pkg/time/time.doc:69: in the range [0, 59].\n> have leap seconds been internationally voted out yet?\n\nThey've certainly been voted out of this package.\n",
			"disapproval": false,
			"date": "2011-11-10 17:22:50.564309",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rogpeppe@gmail.com",
				"gustavo@niemeyer.net",
				"lvd@google.com",
				"bradfitz@golang.org",
				"r@golang.org",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\nFile src/pkg/time/time.doc (right):\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode16\nsrc/pkg/time/time.doc:16: func Parse(alayout, avalue string) (Time, error)\nwhile we're here let's fix the silly argument names in parse and format\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode19\nsrc/pkg/time/time.doc:19: time, which is then used to describe the string to be parsed.  Predefined\ntwo spaces\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode19\nsrc/pkg/time/time.doc:19: time, which is then used to describe the string to be parsed.  Predefined\nwe should put the standard time in this comment while we're here,too, or at least a reference to it\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode21\nsrc/pkg/time/time.doc:21: representations.For more information about the formats, see the\nzero spaces\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode45\nsrc/pkg/time/time.doc:45: Day returns the day of the month specified by t.\nshow range\nalso i think somewhere in here we need to point out that these values are time-zone-dependent.\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode54\nsrc/pkg/time/time.doc:54: Local returns t with the time zone set to local time.\nthis is not a good explanation. maybe:\n\nLocal returns a copy of t with the time zone set to the local time zone but otherwise representing the same instant.\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode61\nsrc/pkg/time/time.doc:61: Month returns the month of the year specified by t.\nspecify the range\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode110\nsrc/pkg/time/time.doc:110: omitting leading and trailing zeros.\nyou could implement Formatter and allow a # version to use  zeros. or vice versa. also precision would be good.\n\ni wonder if inner zeros should be kept by default, for regularity\n\ndurations probably want methods for Days Hours Minutes Seconds Nanoseconds etc. here the plural is important",
			"disapproval": false,
			"date": "2011-11-10 17:36:04.933812",
			"approval": false
		},
		{
			"sender": "cw@f00f.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rogpeppe@gmail.com",
				"gustavo@niemeyer.net",
				"lvd@google.com",
				"bradfitz@golang.org",
				"r@golang.org",
				"cw@f00f.org",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\nFile src/pkg/time/time.doc (right):\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode14\nsrc/pkg/time/time.doc:14: Now returns the current time.\nwhat is .zone in this case?\n\ngettimeofday has a struct timezone, but IME  is purely a runtime artifact when values are printed\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode29\nsrc/pkg/time/time.doc:29: for syntax but it is otherwise ignored.\nmight there be a case (uncommon perhaps) where years could be >9999 ?\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode75\nsrc/pkg/time/time.doc:75: Sub returns the duration t-u.\nhow does this work when t.zone != u.zone ?",
			"disapproval": false,
			"date": "2011-11-10 17:56:57.709956",
			"approval": false
		},
		{
			"sender": "n13m3y3r@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rogpeppe@gmail.com",
				"gustavo@niemeyer.net",
				"lvd@google.com",
				"bradfitz@golang.org",
				"r@golang.org",
				"cw@f00f.org",
				"n13m3y3r@gmail.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\nFile src/pkg/time/time.doc (right):\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode117\nsrc/pkg/time/time.doc:117: Lookup(seconds int64) (minutes int, abbrev string)\nrog, duration is a delta rather than an instant, so it's not suitable for the parameter.\n\nThe description is a bit fuzzy, though. It mentions that it returns a zone offset, and then says the offset is given in seconds east of UTC, but it seems to refer to the result, which is specified as minutes in the return variable name.\n\nI guess the result could be a duration as rog implies.",
			"disapproval": false,
			"date": "2011-11-10 19:00:16.726614",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 11 November 2011 04:11,  <bradfitz@golang.org> wrote:\n> http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode69\n> src/pkg/time/time.doc:69: in the range [0, 59].\n> have leap seconds been internationally voted out yet?\n\nAccording to POSIX.1, Unix time is supposed to handle a leap second by\nreplaying the previous second.\n",
			"disapproval": false,
			"date": "2011-11-10 22:26:06.641665",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 11 November 2011 09:39, Rob 'Commander' Pike <r@google.com> wrote:\n>\n> On Nov 10, 2011, at 2:36 PM, Andrew Gerrand wrote:\n>\n>> I'm having trouble reconciling the idea of the zone as being part of the time.\n>>\n>> A zone is a property of place, not a property of time.\n>\n> It's not a property of a moment in time, but it is a property of the perception of time. What time is it where you are? It's 14:39 here.\n\nExactly. It's a property of the communication of time. Zones belong at\nthe edges, not the core (time.Time), of our time package.\n",
			"disapproval": false,
			"date": "2011-11-10 22:42:29.368554",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "You're all seeing complexity as an option when simplicity achieves as much or more.\n\n-rob\n\n",
			"disapproval": false,
			"date": "2011-11-10 22:55:17.224289",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 11 November 2011 09:55, Rob 'Commander' Pike <r@google.com> wrote:\n> You're all seeing complexity as an option when simplicity achieves as much or more.\n\nI see the conflation of time and zone as unnecessary complexity. You\nsay this as if nothing could be clearer, but I found the inclusion of\nthe zone in the time confusing.\n\nAndrew\n",
			"disapproval": false,
			"date": "2011-11-10 23:01:10.722412",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 13 November 2011 23:16, Russ Cox <rsc@golang.org> wrote:\n> I think for a specific time you'd only bother exporting the\n> zone offset.\n\nis it always possible to reconstruct the zone name from\nthe offset?\n\nif i've unmarshalled a Time t and i do t.Format(time.UnixDate),\nwhat will the time zone show if a suitable name cannot be found?\n",
			"disapproval": false,
			"date": "2011-11-14 09:22:58.551870",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "DESIGN REVIEW\n\nThis is a sketch of a new API for package time.\nIt is inspired by the current Go 1 plan but goes further.\nIt eliminates the Sec and Nano types in favor of a new\nvalue type called time.Time.  That new time replaces the\nexisting time.Time struct too.\n\nSchematically, a time.Time is probably three words:\n(sec, nsec, zone).  Ideally, these three fields would be\nunexported so as to ensure flexibility of the underlying\nimplementation if performance concerns warrant it.\n(The sketch assumes that is possible; it is something we've\ntalked about before.  Please keep this discussion to the\ntime API rather than that potential language change, though.)\n\nBecause the Time is just those three words, it should be\ncheap enough to use as the representation of instants in time,\ninstead of a field like Mtime_ns int64.  Access to the fields\nthat one expects from C's struct tm would be via methods\nDate, Clock, Year, Month, Day, Hour, Minute, Second, Weekday.\nThese can be made efficient (see CL 5369055 for a sketch).\n\nBecause the Time is not a number, methods are necessary\nto do calculations.  In particular, there is a new Duration type\nand methods Time.Add(Duration) Time and\nTime.Sub(Time) Duration.\n\nAn interesting detail is what time parsing \"7:15\" returns.\nRight now it returns a struct with zeroed fields.  In this CL\nI have described it as basically doing the same, but since\nthe fields are implicit, it returns the Time corresponding\nto 7:15am on January 1, year 0 UTC.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 06:19:41.973025",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 17:23, Luuk van Dijk <lvd@google.com> wrote:\n\n>\n>\n>> var Unix Zone   // ? is this still needed\n>>\n>\nTo answer my own question: No.  instead\n\nvar UnixEpoch Time = ...  // defines the zero so all unix times can be\nconverted to durations\n",
			"disapproval": false,
			"date": "2011-11-10 16:26:24.361057",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 11:28 AM, <n13m3y3r@gmail.com> wrote:\n\n>\n> http://codereview.appspot.com/**5374047/diff/5001/src/pkg/**time/time.doc<http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc>\n> File src/pkg/time/time.doc (right):\n>\n> http://codereview.appspot.com/**5374047/diff/5001/src/pkg/**\n> time/time.doc#newcode8<http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode8>\n> src/pkg/time/time.doc:8: Date returns the Time corresponding to\n> As a minor consistency detail:\n>\n>    var t Time\n>    t = time.Date(<A>)\n>    <B> = t.Date()\n>\n> Would be nice to have <A> and <B> being equivalent.\n> I suggest renaming the time.Date function to time.New.\n>\n\nNew(T) in general returns *T.  This wouldn't.\n",
			"disapproval": false,
			"date": "2011-11-10 19:35:01.099231",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I'm having trouble reconciling the idea of the zone as being part of the time.\n\nA zone is a property of place, not a property of time.\n\nIMO\n\nvar t time.Time\nt.String() // time string in UTC time\nt.ZoneString(z) // time string in the specified Zone\n\nTo get the local time:\n\nt.ZoneString(time.Local)\n// or, if you want to make it more convenient:\nt.LocalString()\n\nSeems like a very small price to pay for absolute clarity.\n\nAndrew\n",
			"disapproval": false,
			"date": "2011-11-10 22:37:28.693106",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 13 November 2011 12:28, Andrew Gerrand <adg@golang.org> wrote:\n> Another option is to provide an \"export form\" struct with exported\n> fields to/from which you can get/obtain a time.Time.\n\ns/get/store/\n",
			"disapproval": false,
			"date": "2011-11-13 01:46:48.865685",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 01:26, Chris Wedgwood <cw@f00f.org> wrote:\n> what's wrong with using 'ns int4' though?\n\nYou have to remember that it's nanoseconds,\nand you have to know what the 0 time is.\nYou also have to remember if it is a time instant\nor a duration.\n\n> i worry this means this representation isn't suitable for timing very\n> small intervals\n\nThe intent is that it is just fine for that.  Internally\na Time is {sec, nsec, zone}, so three words.\ntime.Now returns a triple, time.Duration is nanoseconds,\nso you do\n\nt0 := time.Now()\n... thing you want to time ...\ndelta := time.Now().Sub(t0)\n\nfmt.Println(\"That took\", delta)\n\nor\n\nfmt.Println(\"That took\", int(delta/time.Microsecond), \"microseconds.\")\n\nCompared to using Unix's gettimeofday for the same job,\nthere is just an extra word of memory being returned by\nthe call.  Otherwise the computations are identical.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 06:31:33.676103",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rogpeppe@gmail.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "i like the look of this in general, assuming performance is adequate (probably - on a 64 bit machine, Time would be exactly the size of interface{} and we pass enough of those around)\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\nFile src/pkg/time/time.doc (right):\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode33\nsrc/pkg/time/time.doc:33: sec seconds and nsec nanoseconds since January 1, 1970 UTC.\n- this doesn't describe the behaviour when nsec > 1e9.\n\n- AFAICS this means that to convert from a duration since the Unix epoch into a Time, you'd need to do:\nUnix(0, 0).Add(d)\nis this acceptably concise?\n\nan alternative might be to define Unix as\nfunc Unix(sec int64, nsec Duration)\n\nthen the above would be:\nUnix(0, d)\n\ni'm slightly concerned that using int64 for seconds and int for nsec means that any conversion between Duration and Time requires a couple of divisions, but perhaps that's not an issue.\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode117\nsrc/pkg/time/time.doc:117: Lookup(seconds int64) (minutes int, abbrev string)\ni wonder if this should be\n\nLookup(sinceEpoch Duration) (offset Duration, abbrev string)\n\nso that we consistently use Duration for time intervals.",
			"disapproval": false,
			"date": "2011-11-10 10:10:27.107892",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Hey Russ,\n\n> This is a sketch of a new API for package time.\n> It is inspired by the current Go 1 plan but goes further.\n> It eliminates the Sec and Nano types in favor of a new\n> value type called time.Time. \u00a0That new time replaces the\n> existing time.Time struct too.\n\nThe basic premise sounds great.\n\n> Schematically, a time.Time is probably three words:\n> (sec, nsec, zone). \u00a0Ideally, these three fields would be\n(...)\n> and methods Time.Add(Duration) Time and\n> Time.Sub(Time) Duration.\n\nWhat's your thinking in terms of the zone information? To keep it\nwithin three words, and to enable those operation methods, the zone\ninformation will have to be an index of some sort onto a richer data\nstructure that is able to compute zone deltas. Have you put some\nfurther thought onto those aspects yet?\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I'm not absolutely sure of anything.\n",
			"disapproval": false,
			"date": "2011-11-10 14:15:37.174780",
			"approval": false
		},
		{
			"sender": "cw@f00f.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 01:20:05PM -0500, Russ Cox wrote:\n\n> The reason to have the separation is that int64\n> nanoseconds are only good for 292 years\n> on either side of 1970.\n\noh, that's perfectly rasonable\n\nthanks for the clarification\n",
			"disapproval": false,
			"date": "2011-11-10 18:23:48.139521",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> time.DateClockNanoZone seemed too long. \u00a0:-)\n\nRight. :-)\n\nSince you're indeed passing all possible fields for the Time, I was\nsuggesting we use time.New for that, and then make time.Date reflect\nTime.Date as you pointed out.\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I'm not absolutely sure of anything.\n",
			"disapproval": false,
			"date": "2011-11-10 19:47:44.373910",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I may be the only one that dislikes this proposal, but just for my own\nenlightenment i've started sketching my counterproposal in some more detail\nin  http://codereview.appspot.com/5371053\n\nI'll ping again when everything there works and/or i've come around to\nRuss' views.\n\n/L\n",
			"disapproval": false,
			"date": "2011-11-10 22:26:02.297767",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Let me try to explain the thought process behind the API.\n\nA single number is insufficient for representing a time with the\ndesired nanosecond precision.  An int64 nanosecond count can only\nspan 292 years in each direction from its zero.  It is tempting\nto try floating point, but today's Unix time in nanoseconds is a\n60-bit number; storing it in a float64 would throw away 7 bits of\nprecision, and the problem only gets worse as time goes on.  The\nfact that one number is insufficient implies that a struct value is\nneeded.\n\nThe obvious name for this new struct representing an instant in\ntime would be time.Time, but that is taken by the current\ntime.Time, which represents the same concept but in a different\nform.  That form can be wildly inconsistent, claiming to\nrepresent times like February 71 8:28:18.  We had a similar\ninconsistency problem before, with dates like Sunday November 11\n2011, and the quite good solution was not to store the weekday\nexplicitly but instead provide it as a method, to be computed on\ndemand.  Thus, you can now parse \"Nov 11 2011\" and print it with\na weekday and get \"Friday\".  It's similarly redundant and complex to\nhave these multiple time representations.  A solution to both\nthese problems would be to have a single time representation that\nadmits no inconsistencies (elapsed time since 1970) and to make\nall the current time.Time fields methods to be computed on\ndemand.  All the conversions between equivalents of C's time_t\nand struct tm disappear and, with some care, the unified\nrepresentation can be made efficient both for doing time\nmeasurements and for computing an \"hh:mm:ss\" to display.\n\nComputations on the new time.Time values are quite efficient.\nThe obvious addition and subtraction are, because everything is\nUTC, no different than adding or subtracting C struct timevals as\nreturned by gettimeofday(2).  The most important operation is\nsubtraction, used for timing events:\n\n\t$ godoc -src exp/time Sub\n\t// Sub returns the duration t-u.\n\t// To compute t-d for a duration d, use t.Add(-d).\n\tfunc (t Time) Sub(u Time) Duration {\n\t    return Duration(t.Xsec-u.Xsec)*Second + Duration(t.Xnsec-u.Xnsec)\n\t}\n\t$\n\nGiven that we've ruled out storing times as a single number, it's\nimpossible to do better than this, and the computation is a great\ncandidate for inlining once the compiler is ready.\n\nThe new API then is 3x simpler than the existing API: where the\nold API had times in seconds since 1970, times in nanoseconds\nsince 1970, and times broken out in struct Time, the new API has\njust one representation, time.Time.\n\nTo obtain the system time and then convert between the three\nrepresentations, the current time API provides these functions:\n\n\tfunc Nanoseconds() int64\n\tfunc Seconds() int64\n\tfunc LocalTime() *Time\n\tfunc UTC() *Time\n\t\n\tfunc NanosecondsToLocalTime(nsec int64) *Time\n\tfunc NanosecondsToUTC(nsec int64) *Time\n\tfunc SecondsToLocalTime(sec int64) *Time\n\tfunc SecondsToUTC(sec int64) *Time\n\t\n\tfunc (t *Time) Nanoseconds() int64\n\tfunc (t *Time) Seconds() int64\n\nThe new API provides:\n\n\tfunc Now() Time\n\nThere is, of course, a catch.\n\nIn order to give meaning to methods like Weekday or Hour, the\nunified time.Time must carry with it minimal zone information.\nObviously, tying times to time zone information has been a cause\nof problems in other systems and is not to be undertaken carelessly.\nThe systems that I can think of that have botched time zone\nhandling all made the same mistake: they interpret time values\nrelative to a certain (often unspecified) time zone, which makes\nthe meaning of the time values uncertain.  To avoid that pitfall,\nthe representation we are proposing defines that the stored time\nvalue is always UTC.  The zone information is only consulted when\ncomputing \"display\" information about the time, such as the\ncurrent day or hour.  Changing the zone associated with a time\ndoes not change the instant that time represents.  It only changes\nhow that instant gets printed.  Computations on these time values\nare always well-defined, and the meaning of the values is always\nclear.\n\nThere is no question that bad time APIs exist that make\nassumptions about time zones and mix that into the interpretation\nof time values, and that those APIs cause bugs.  Many of the\npeople who replied yesterday seem to have used such systems.\nA tempting reaction here is to build up API scar tissue, designing\nAPIs that make you write extra lines of code, so that when there\nis a bug it's something explicit on the page instead of implicit,\nso that you feel like it's your fault instead of the API's fault.\nThat doesn't make the API better: it just makes it long-winded.\nA better API is one that is equally easy to use but harder to use\nincorrectly, and I believe that's what this is.\n\nThe comments yesterday reminded me, appropriately enough, of the\ncomments about Go on November 10, 2009.  No one had used the\nlanguage yet, so none of the comments were based on experience\nwith it.  Some were positive, some were negative, but all of them\nwere based on experience with things that were not Go rather than\nbased on Go itself.\n\nInstead of making assumptions about the API because it reminds you\nof an API that some other language has, try it.  I fleshed out the code\nyesterday, and it passes all the existing tests.  Run hg clpatch 5369055,\ninstall exp/time, and write some programs.  Here's one to get you started.\n\n\t$ cat worldclock.go\n\tpackage main\n\t\n\timport (\n\t\t\"exp/time\"\n\t\t\"fmt\"\n\t\t\"path\"\n\t\t\"strings\"\n\t)\n\t\n\tvar zoneNames = []string{\n\t\t\"America/Los_Angeles\",\n\t\t\"Europe/London\",\n\t\t\"America/New_York\",\n\t\t\"Australia/Sydney\",\n\t\t\"Asia/Toyko\",\n\t\t\"Europe/Zurich\",\n\t}\n\t\n\tfunc main() {\n\t\tt := time.Now()\n\t\tfor _, name := range zoneNames {\n\t\t\t_, short := path.Split(name)\n\t\t\tshort = strings.Replace(short, \"_\", \" \", -1)\n\t\t\tz, _ := time.LoadZoneInfo(name)\n\t\n\t\t\tfmt.Println(t.In(z), short)\n\t\t}\n\t}\n\t$ ./6.out\n\tFri Nov 11 08:14:42 PST -0800 2011 Los Angeles\n\tFri Nov 11 16:14:42 GMT +0000 2011 London\n\tFri Nov 11 11:14:42 EST -0500 2011 New York\n\tSat Nov 12 03:14:42 EST +1100 2011 Sydney\n\tFri Nov 11 11:14:42 EST -0500 2011 Toyko\n\tFri Nov 11 17:14:42 CET +0100 2011 Zurich\n\t$\n\nThanks.\nRuss\n",
			"disapproval": false,
			"date": "2011-11-11 16:28:30.473080",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Fri, Nov 11, 2011 at 17:28, Russ Cox <rsc@golang.org> wrote:\n\n> Let me try to explain the thought process behind the API.\n>\n> A single number is insufficient for representing a time with the\n> desired nanosecond precision.  An int64 nanosecond count can only\n> span 292 years in each direction from its zero.  It is tempting\n> to try floating point, but today's Unix time in nanoseconds is a\n> 60-bit number; storing it in a float64 would throw away 7 bits of\n> precision, and the problem only gets worse as time goes on.  The\n> fact that one number is insufficient implies that a struct value is\n> needed.\n>\n>\nvery few people need both the range and the precision.  why use the type\nsystem to keep track of that a certain int means a month or day of week,\nbut not for keeping track of what the uint64 means?\n\n\n> The obvious name for this new struct representing an instant in\n> time would be time.Time, but that is taken by the current\n>\n\nwalltime.Instant?\n\n\n> time.Time, which represents the same concept but in a different\n> form.  That form can be wildly inconsistent, claiming to\n> represent times like February 71 8:28:18.  We had a similar\n> inconsistency problem before, with dates like Sunday November 11\n> 2011, and the quite good solution was not to store the weekday\n> explicitly but instead provide it as a method, to be computed on\n> demand.  Thus, you can now parse \"Nov 11 2011\" and print it with\n> a weekday and get \"Friday\".  It's similarly redundant and complex to\n> have these multiple time representations.  A solution to both\n> these problems would be to have a single time representation that\n> admits no inconsistencies (elapsed time since 1970) and to make\n> all the current time.Time fields methods to be computed on\n> demand.  All the conversions between equivalents of C's time_t\n> and struct tm disappear and, with some care, the unified\n> representation can be made efficient both for doing time\n> measurements and for computing an \"hh:mm:ss\" to display.\n>\n\ni think nobody objects to that goal\n\n\n>\n> Computations on the new time.Time values are quite efficient.\n>\n\nbut not as efficient as on a plain uint64\n\n\n> The obvious addition and subtraction are, because everything is\n> UTC, no different than adding or subtracting C struct timevals as\n> returned by gettimeofday(2).  The most important operation is\n> subtraction, used for timing events:\n>\n>        $ godoc -src exp/time Sub\n>        // Sub returns the duration t-u.\n>        // To compute t-d for a duration d, use t.Add(-d).\n>        func (t Time) Sub(u Time) Duration {\n>            return Duration(t.Xsec-u.Xsec)*Second +\n> Duration(t.Xnsec-u.Xnsec)\n>        }\n>        $\n>\n> Given that we've ruled out storing times as a single number,\n\n\nexcept if we would let the programmer choose the precision for each\ntime-like variable on a case by case basis, just like we leave it to the\nprogrammer to choose int64 vs uint8\n\n\n> it's\n> impossible to do better than this, and the computation is a great\n> candidate for inlining once the compiler is ready.\n>\n>\n... i'm doing my best....real soon now....\n\n\n> The new API then is 3x simpler than the existing API: where the\n> old API had times in seconds since 1970, times in nanoseconds\n> since 1970, and times broken out in struct Time, the new API has\n> just one representation, time.Time.\n>\n>\n<... good explanation, thanks... >\n\n\n> There is, of course, a catch.\n>\n> In order to give meaning to methods like Weekday or Hour, the\n> unified time.Time must carry with it minimal zone information.\n> Obviously, tying times to time zone information has been a cause\n> of problems in other systems and is not to be undertaken carelessly.\n> The systems that I can think of that have botched time zone\n> handling all made the same mistake: they interpret time values\n> relative to a certain (often unspecified) time zone, which makes\n> the meaning of the time values uncertain.  To avoid that pitfall,\n> the representation we are proposing defines that the stored time\n> value is always UTC.\n\n\nUTC != seconds since the epoch..  this is a nice example of an\nsimplification you think everybody is willing to make, but it is only\nsimpler if you ignore the fact that it is wrong.\n\n\n>  The zone information is only consulted when\n> computing \"display\" information about the time, such as the\n> current day or hour.  Changing the zone associated with a time\n> does not change the instant that time represents.  It only changes\n> how that instant gets printed.  Computations on these time values\n> are always well-defined, and the meaning of the values is always\n> clear.\n>\n\nthen why drag it around, and why is it that having to explain this\nbehaviour is not counted against the complexity of the design?  if you have\na representation of instant independent of zone, there's nothing to\nexplain.  that is simpler.\n\n\n>\n> There is no question that bad time APIs exist that make\n> assumptions about time zones and mix that into the interpretation\n> of time values, and that those APIs cause bugs.  Many of the\n> people who replied yesterday seem to have used such systems.\n>\n\n\n> A tempting reaction here is to build up API scar tissue, designing\n> APIs that make you write extra lines of code, so that when there\n> is a bug it's something explicit on the page instead of implicit,\n> so that you feel like it's your fault instead of the API's fault.\n> That doesn't make the API better: it just makes it long-winded.\n> A better API is one that is equally easy to use but harder to use\n> incorrectly, and I believe that's what this is.\n>\n>\nI respectfully disagree in an non-adversary way, (and i have yet to\npersonally come to terms with the fact that you (or Rob) could be wrong\nabout something.)\nI think everybody wants simple things easy, but what is simple and what is\neasy is not that clear cut.\n\n\n> The comments yesterday reminded me, appropriately enough, of the\n> comments about Go on November 10, 2009.  No one had used the\n> language yet, so none of the comments were based on experience\n> with it.  Some were positive, some were negative, but all of them\n> were based on experience with things that were not Go rather than\n> based on Go itself.\n>\n>\nPeople were outraged because they had never seen such an abomination as\ndeciding visibility on the basis of the name rather than the type, whereas\nthe people on this thread who objected, i believe, have experience with\ntime related API's that have the fundamental design flaw of considering\nzone a property of a time as opposed to a first class entity that has it's\nown role in the division of labour. I've seen companies stuck in a single\nglobal timezone and datacenters not being able to roll out something as\ntrivial as a leap second, because someone thought that an API was good\nenough.\n\nI can see that your API allows me to write a reasonable combination of\nconstructs to get what i probably mean most of the time, but the same goes\nfor any api built on the assumption that ASCII is good enough to represent\nmost strings, and there is only 1 collation order that matters. Or an api\nthat solves that by carrying a (language, encoding) tuple along with any\nstring, and promises you that if you call .Latin8() on it the meaning of\nthe string will stay the same.\n\nI always thought the socket api's were pretty nice until i was enlightened\nby net.Dial, and i wouldn't want to go back and i can see the error of my\nways. So to dismiss the criticism on this thread as coming from people who\nare stuck in the past doesn't do justice to our collective experience i\nthink.\n\n\n\n> Instead of making assumptions about the API because it reminds you\n> of an API that some other language has, try it.  I fleshed out the code\n> yesterday, and it passes all the existing tests.  Run hg clpatch 5369055,\n> install exp/time, and write some programs.\n\n\n\nnice.  i'll see if i can make mine as nice.  The only reason i started  to\ncode up the counter proposal is because i don't want to just criticise in a\ngratuit manner.\n\n/L\n",
			"disapproval": false,
			"date": "2011-11-11 20:17:54.880211",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Sat, Nov 12, 2011 at 20:28, Andrew Gerrand <adg@golang.org> wrote:\n> Since this is an opaque data structure, how will we handle\n> serialization/deserialization? We could implement Gob(En|De)code and\n> (M|Unm)arshalJSON methods, I guess, but it would \"just work\" in most\n> places if the\n> fields were exported.\n\nYes, but exporting the fields locks us into a representation.\nI very much do not want to be locked into a specific representation.\nIt is easier to commit to a method set than to a representation.\nThere are already quite powerful options for serialization\nin the form of the Parse function and Format method.\nFor JSON I was thinking about serializing to an RFC3339 string.\nGob can do three varints in a row: sec, nsec, zone offset.\n\n> Another option is to provide an \"export form\" struct with exported\n> fields to/from which you can get/obtain a time.Time.\n>\n> Is the zone data included in the serialized form? This seems difficult\n> if the Zone field is an interface.\n\nZone is not an interface in the current version of the CL.\nI think for a specific time you'd only bother exporting the\nzone offset.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-13 23:16:53.556475",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg",
			"disapproval": false,
			"date": "2011-11-10 06:19:00.488726",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 11:16, Luuk van Dijk <lvd@google.com> wrote:\n> What if zone was not an attribute of Time?\n\nThis is more complex.  Among other things, you can't just print a Time,\nand you have to know about Zone to do anything with it.  In the\ncurrent proposal, you can write trivial stuff like\n\n    t0 := time.Now()\n    ...\n    t1 := time.Now()\n    fmt.Printf(\"%s to %s is %s\\n\", t0, t1, t1.Sub(t0))\n\nand get something like\n\n    Thu Nov 10 11:34:40 EST 2011 to Thu Nov 10 11:35:44 EST 2011 is 1m4s.\n\nand you can write\n\n    fmt.Printf(\"UTC: %s\\n\", time.Now().UTC())\n\nall without having to think about why you need a Zone type.\n\nAlso, making Zone be the interface you propose means that\nevery implementation of Zone has to duplicate the implementation\nof Split, which is non-trivial and invariant across time zones.\nThe only thing that varies across time zones is the mapping\nfrom time instant to (offset, time name), so the Zone interface\nin the CL only has the one method.\n\nOf course, being more complex is not a showstopper, but\nthat complexity needs to be paid for by some additional\nbenefit.  What is it, and why is that a benefit?\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 16:42:12.299141",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 12:56,  <cw@f00f.org> wrote:\n> how does this work when t.zone != u.zone ?\n\nzone is only for presentation.  The actual value\nin the time.Time is always UTC, and it is adjusted\naccording to zone when printing.  Because the\nactual value is always UTC, subtracting two\ntime.Time is well defined even if they are in\ndifferent zones.\n\nThu Nov 10 18:04:06 GMT 2011 - Thu Nov 10 13:04:05 EST 2011 = 1s\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 18:04:28.223308",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "\nOn Nov 10, 2011, at 2:26 PM, Luuk van Dijk wrote:\n\n> I may be the only one that dislikes this proposal, but just for my own enlightenment i've started sketching my counterproposal in some more detail in  http://codereview.appspot.com/5371053\n> \n> I'll ping again when everything there works and/or i've come around to Russ' views.\n\nThey're mine too.\n\n-rob\n\n\n",
			"disapproval": false,
			"date": "2011-11-10 22:26:35.902295",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "\nOn Nov 10, 2011, at 2:36 PM, Andrew Gerrand wrote:\n\n> I'm having trouble reconciling the idea of the zone as being part of the time.\n> \n> A zone is a property of place, not a property of time.\n\nIt's not a property of a moment in time, but it is a property of the perception of time. What time is it where you are? It's 14:39 here.\n\n-rob\n\n\n",
			"disapproval": false,
			"date": "2011-11-10 22:39:12.294823",
			"approval": false
		},
		{
			"sender": "uriel@berlinblue.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 7:16 PM, Chris Wedgwood <cw@f00f.org> wrote:\n>> zone is only for presentation.\n>\n> So every time.Time carries around this data that's only used for\n> printing?\n>\n> Why not have zone be a feature at print-time?\n\nI agree, this would be much better, one rarely wants to associate the\nzone with the time value itself, but with the context in which it is\npresented.\n\nThis can be system-wide,  app-wide, user-wide (which is different for\nmulti-user apps), etc. In most cases you tend to have many time values\nall to be presented on the same zone, or one time value to be\npresented in several zones.\n\nIf for example you have a web app that displays an index page of what\ncomments various users have made, including when they were\nmade/updated, when two users visit this page, they will want the same\ntimes displayed in different zones. In this case you want the zone to\nbe part of the User type, not of the fields timePosted and timeUpdate\nin your Comment type.\n\nIn some cases you might want to carry the zone along with the time\n(although I find it difficult to think of an use case), and then you\ncan just embed both a Time and a Zone field into your own custom type.\n\nBut usually you want to provide the zone at the very last moment,\nexactly when you are presenting the time, and what zone you want to\nuse will often be unrelated to where that time value came from.\n\nuriel\n",
			"disapproval": false,
			"date": "2011-11-10 22:52:01.405993",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 17:52, Uriel <uriel@berlinblue.org> wrote:\n> I agree, this would be much better, one rarely wants to associate the\n> zone with the time value itself, but with the context in which it is\n> presented.\n\nIt is very hard to tell how much of that attitude is rooted\nin years of using C, where time_t and struct tm are\nseparate concepts.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 22:55:04.055744",
			"approval": false
		},
		{
			"sender": "lucio.dere@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I think Russ and Rob are trying to concoct the minimal time structure\nthat encompasses the widest useful object.  Leaving the timezone out\nmeans that 99% of the time the user needs to construct a wider type\nand that isn't fruitful.  That the timezone may frequently go unused\ndoesn't matter, the proposal ensures that you don't have to invent a\nnew, inconsistent type every time you want to print a value.\n\nPutting it another way, the proposal covers, with a single data\nobject, two closely coupled concepts, the time instant as well as the\ntimezone.  Decoupling is philosophically correct, but the pragmatic\ndecision is more convenient.\n\nLucio.\n\nOn 11/13/11, Uriel <uriel@berlinblue.org> wrote:\n> On Thu, Nov 10, 2011 at 11:55 PM, Rob 'Commander' Pike <r@google.com> wrote:\n>> You're all seeing complexity as an option when simplicity achieves as much\n>> or more.\n>\n> You know much more about complexity and simplicity than me, but I find\n> this claim baffling.\n>\n> First to be clear, I don't think Christoph, Andrew, Chris Wedgwood or\n> me are advocating Luuk's proposal, which might be good, but I\n> personally don't quite understand and seems on first glance overly\n> complex.\n>\n> The question is: why not remove the zone field, and just provide a\n> desired zone when printing (the default can be UTC, or even the local\n> zone if you like)?\n>\n> Removing the zone from the Time type makes things simpler and more\n> general (you can always embed your Time along a zone in a new type if\n> you want that).\n>\n> Keeping it means it often wont be used or worse will be misused.\n>\n> Maybe we have very different use cases in mind, but I still can't\n> imagine which ones you are thinking of.\n>\n> uriel\n>\n",
			"disapproval": false,
			"date": "2011-11-13 04:24:00.073698",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Sun, Nov 13, 2011 at 18:16, Russ Cox <rsc@golang.org> wrote:\n> I think for a specific time you'd only bother exporting the\n> zone offset.\n\ns/exporting/serializing/\n",
			"disapproval": false,
			"date": "2011-11-13 23:17:06.110795",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 09:15, Gustavo Niemeyer <gustavo@niemeyer.net> wrote:\n> What's your thinking in terms of the zone information? To keep it\n> within three words, and to enable those operation methods, the zone\n> information will have to be an index of some sort onto a richer data\n> structure that is able to compute zone deltas. Have you put some\n> further thought onto those aspects yet?\n\nSee line 111 of\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\nIt is sketched as an interface but could be a concrete type instead.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 14:20:35.763559",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 17:16, Luuk van Dijk <lvd@google.com> wrote:\n\n> What if zone was not an attribute of Time?\n>\n> Have Time as an abstract type that represents a real quantity in fixed but\n> arbitrary internal dimension, and have a Zone be an object that defines the\n> zero (and dst jumps) and can extract\n> year/month/day/yearday/hour/min/sec/fractionalsecond from it.\n>\n> That way you could have something like\n>\n> type Duration int64 // private implementation detail: in units of\n> nanoseconds\n> func (Duration) Add(Duration)  Duration\n> func (Duration) Sub(Duration)  Duration\n> func (Duration) Multiply(f float64) Duration\n> // nice constants like you had\n>\n> func (Duration) NanoSeconds() int64\n> func (Duration) Seconds() int64\n> func (Duration) Minutes() int64\n> func (Duration) Hours() int64\n> func (Duration) Days() int64\n> func (Duration) Years() int64\n> func (Duration) Split() (y, d, h, m, s, ns int64)\n> func (Duration) String() string\n>\n>\n> type Time struct {\n>     offset_to_hidden_fixed_but_arbitrary_zero_point Duration\n> }\n>\n> func (Time) Add(Duration)\n> func (Time) Sub(Duration)\n>\n\nThese bth return Time of course.  you'd also need a separate\nfunc (Time) Difference(Time) Duration\n\n\nfunc Now() Time\n>\n\n> type Zone interface {\n>\n>  Seconds(Time) int64\n>  Minutes(Time) int64\n>  Hours(Time) int64\n>  Days(Time) int64\n>  Years(Time) int64\n>  IsDST(Time) bool\n>  Split(Time) (y, d, h, m, s, ns int64, dst bool)\n>\n>  String(Time) string\n>  Parse(string) Time\n>\n>   // returns the Duration you'd have to wait in this Zone until the\n> wallclock says the same as at time t in zone z.\n>   Offset(z Zone, t Time) Duration\n>\n> }\n>\n> var Local Zone\n> var UTC Zone\n> var Unix Zone   // ? is this still needed\n>\n>\n>\n>\n>\n",
			"disapproval": false,
			"date": "2011-11-10 16:23:26.848326",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 17:42, Russ Cox <rsc@golang.org> wrote:\n\n> On Thu, Nov 10, 2011 at 11:16, Luuk van Dijk <lvd@google.com> wrote:\n> > What if zone was not an attribute of Time?\n>\n> This is more complex.  Among other things, you can't just print a Time,\n> and you have to know about Zone to do anything with it.\n\n\nexactly, and not knowing a zone and trying to do something reasonable\nanyway is the reason, eg. a company i worked for once makes no money one\nday every year for an hour, and roughly half a year later their databases\nalways crash.\n\n\n>  In the\n> current proposal, you can write trivial stuff like\n>\n>    t0 := time.Now()\n>    ...\n>    t1 := time.Now()\n>    fmt.Printf(\"%s to %s is %s\\n\", t0, t1, t1.Sub(t0))\n>\n>\nthat lastt one you can still do in my proposal, t1.Sub(t2) is a Duration,\nwhich has a String()\n\n\n\n\n> and get something like\n>\n>    Thu Nov 10 11:34:40 EST 2011 to Thu Nov 10 11:35:44 EST 2011 is 1m4s.\n>\n>\nin my proposal that woould have been\n\nfmt.Printf(\"%s to %s is %s\\n\", time.Local.String(t0),\ntime.Local.String(t1), t1.Sub(t0))\n\na small price to pay for that company, trust me (no it's not my current\nemployer)\n\n\nand you can write\n>\n>    fmt.Printf(\"UTC: %s\\n\", time.Now().UTC())\n>\n> all without having to think about why you need a Zone type.\n>\n\nI need a zone type for the same reason you need a zone attribute.  In my\nproposal, one can't get confused about what zone your variable or function\nreturn value is in, in your proposal i have no idea what it means if i\nleave off the UTC.\n\n\n>\n> Also, making Zone be the interface you propose means that\n> every implementation of Zone has to duplicate the implementation\n> of Split, which is non-trivial and invariant across time zones.\n> The only thing that varies across time zones is the mapping\n> from time instant to (offset, time name), so the Zone interface\n> in the CL only has the one method.\n>\n\nit can be a struct with the only difference being a private table with\noffsets.\n\n\n>\n> Of course, being more complex is not a showstopper, but\n> that complexity needs to be paid for by some additional\n> benefit.  What is it, and why is that a benefit?\n>\n\ni challenge the statement that it is more complex.  your  complexity is\nhidden in assumptions about what zone is set to in certain calls.\n\n/L\n",
			"disapproval": false,
			"date": "2011-11-10 17:02:49.365658",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "You are designing an API for people who want to be forced\nto confront every possible detail.  That's a perfectly fine\ndesign point, but it's not the one I'm going for.  I am trying to\nmake something simple that works well, for people who want\nto focus on the rest of their work.\n\nChanging the zone on a time.Time in this proposal only\naffects presentation.  It does not affect calculations of\ntime differences at all.  That makes time.Time replace\nboth C's time_t and C's struct tm, relieving programmers\nfrom having to weigh the pros and cons of each and pick\njust one.  Best of all, it relieves API designers from having\nto guess which one a client of that API will need.\nIt eliminates conversions back and forth.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-11-10 17:23:16.947984",
			"approval": false
		},
		{
			"sender": "n13m3y3r@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rogpeppe@gmail.com",
				"gustavo@niemeyer.net",
				"lvd@google.com",
				"bradfitz@golang.org",
				"r@golang.org",
				"cw@f00f.org",
				"n13m3y3r@gmail.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\nFile src/pkg/time/time.doc (right):\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode8\nsrc/pkg/time/time.doc:8: Date returns the Time corresponding to\nAs a minor consistency detail:\n\n    var t Time\n    t = time.Date(<A>)\n    <B> = t.Date()\n\nWould be nice to have <A> and <B> being equivalent.\nI suggest renaming the time.Date function to time.New.",
			"disapproval": false,
			"date": "2011-11-10 19:28:29.894296",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> So you can say time.Unix(1320953925) to get a Time\n> and then t.Unix() to get back to the 1320953925.\n\nYeah, my point is precisely that time.Date doesn't follow this convention.\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I'm not absolutely sure of anything.\n",
			"disapproval": false,
			"date": "2011-11-10 19:43:09.372293",
			"approval": false
		},
		{
			"sender": "uriel@berlinblue.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 11:46 PM, Rob 'Commander' Pike <r@google.com> wrote:\n>\n>> Exactly. It's a property of the communication of time. Zones belong at\n>> the edges, not the core (time.Time), of our time package.\n>\n>\n> There is no better place to store the time zone than in the time, and the time zone has no effect outside printing and formatting.\n\nI very strongly disagree, that is rarely a good place for the zone to\nbe, a zone might be stored with the user preferences, or be a property\nof a  place, or even be global to the application, but I still have\nnot been able to come up with any good example where carrying along\nthe zone with the time value makes sense, and many where it doesn't at\nall (again, in most cases you want to be able to present the same\nvalue in various context that require different zones).\n\nuriel\n",
			"disapproval": false,
			"date": "2011-11-10 22:51:45.903681",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 11 November 2011 09:46, Rob 'Commander' Pike <r@google.com> wrote:\n> I'm not going to argue this here. The design is really nice in practice - you'll see - and you're all getting hung up on semantics.\n\nI'm in two minds about it. I'd love to see some example code that\nillustrates why it's so nice.\n",
			"disapproval": false,
			"date": "2011-11-10 22:53:42.581505",
			"approval": false
		},
		{
			"sender": "uriel@berlinblue.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 11:41 PM, Andrew Gerrand <adg@golang.org> wrote:\n> On 11 November 2011 09:39, Rob 'Commander' Pike <r@google.com> wrote:\n>>\n>> On Nov 10, 2011, at 2:36 PM, Andrew Gerrand wrote:\n>>\n>>> I'm having trouble reconciling the idea of the zone as being part of the time.\n>>>\n>>> A zone is a property of place, not a property of time.\n>>\n>> It's not a property of a moment in time, but it is a property of the perception of time. What time is it where you are? It's 14:39 here.\n>\n> Exactly. It's a property of the communication of time.\n\nOr put another way: of the *context* in which the time is presented,\nthe context is only known when the value is actually printed, and is\nnot related to the value itself which might be presented in many\ndifferent contexts.\n\n> Zones belong at the edges, not the core (time.Time), of our time package.\n\nI violently agree.\n\nuriel\n",
			"disapproval": false,
			"date": "2011-11-10 22:57:20.989530",
			"approval": false
		},
		{
			"sender": "uriel@berlinblue.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 11:55 PM, Russ Cox <rsc@golang.org> wrote:\n> On Thu, Nov 10, 2011 at 17:52, Uriel <uriel@berlinblue.org> wrote:\n>> I agree, this would be much better, one rarely wants to associate the\n>> zone with the time value itself, but with the context in which it is\n>> presented.\n>\n> It is very hard to tell how much of that attitude is rooted\n> in years of using C, where time_t and struct tm are\n> separate concepts.\n\nIn my case it is rooted in building systems that interface with users\nin many different timezones, and who move across time zones.\n\nSee the example I mentioned in another message, when you\ngather/generate the data to be presented, the time values are\nunrelated to who and where they will be presented, and often they will\nbe presented in different contexts with different zones.\n\nuriel\n",
			"disapproval": false,
			"date": "2011-11-10 23:07:40.784284",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "i think i've come around to the int64 approach.\nwhile it *is* a delta (and can even make sense\nto add to another time stamp,\ne.g. t, _ := time.Parse(\"15:04\", \"01:30\"); now := t.Add(unixTime))\nusing int64 seconds means that the time zone\nlookup can work for the full range of dates, not limited\nby the 584 year window.\n\nOn 10 November 2011 22:03, Gustavo Niemeyer <gustavo@niemeyer.net> wrote:\n>> oh, maybe i've misunderstood. i thought the parameter *was* a delta - the\n>> number of seconds elapsed since the epoch.\n>\n> It is stored as a delta, but that's an implementation detail. It\n> actually represents a specific instant in time rather than a duration\n> like a month or a year. If you still don't see the distinction, try to\n> make sense of adding the epoch delta to any other timestamp.\n>\n> --\n> Gustavo Niemeyer\n> http://niemeyer.net\n> http://niemeyer.net/plus\n> http://niemeyer.net/twitter\n> http://niemeyer.net/blog\n>\n> -- I'm not absolutely sure of anything.\n>\n",
			"disapproval": false,
			"date": "2011-11-11 10:45:25.039444",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 10 November 2011 19:15,  <n13m3y3r@gmail.com> wrote:\n> I'd expect the Time.Zone method to return the Time's Zone, which seems\n> to be missing.\n\ninterestingly CL 5369055 has Zone the way you expected it.\nwith the proposal in this CL there seems to be no way of extracting\nzone information without using Format.\n",
			"disapproval": false,
			"date": "2011-11-11 11:06:56.708111",
			"approval": false
		},
		{
			"sender": "uriel@berlinblue.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Fri, Nov 11, 2011 at 10:18 PM, Russ Cox <rsc@golang.org> wrote:\n> For example, is the modification time on a file a time.Sec,\n> a time.Nano, or a *time.Time? \u00a0This is the key point:\n> *** I never want to make that decision again. ***\n\nI completely agree, but a similar question will be: What is in the\nzone field? **I don't want to make that decision.** At least not when\nthe time value is created, only when it is presented.\n\nWhoever writes the API that returns the modification time will have to\ndecide this, when it is the *user* of the API who is much more likely\nto know which zone the time should be presented as.\n\nI think ignoring the zone field for everything other than presentation\nis great, I just think is better to go all the way and remove it from\ntime values, because all it will do is add confusion. To me this seems\nlike making things *simpler*, maybe not by much, but definitely\nsimpler.\n\nAgain, now from an API point of view, anything that returns a time\nwill probably want to document which zone is use (UTC, local time?\nsomething else based on the user? if it comes from the database based\non the DB's configuration?), which is mostly useless to the user of\nthe API, who will have its own ideas of which zone to use for\npresentation.\n\nIf there should be a default zone for printing, it is the printing\nfunctions who should consistently pick one (either UTC or 'local\ntime') and be done with it.\n\nuriel\n",
			"disapproval": false,
			"date": "2011-11-13 03:05:46.520302",
			"approval": false
		},
		{
			"sender": "lvd@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Thu, Nov 10, 2011 at 13:08, <tux21b@gmail.com> wrote:\n\n> I personally like the idea of just having one Time type with no timezone\n> information, so\n> that all times have to be UTC.\n>\n\nin my proposal,  they have no zone, not even UTC, times are numbers on a\nhidden internal scale (chosen for efficiency in implementation) .  all\nproblems arise from the zone being unspecified on parsing and printing/\nsplitting into and composing from y/m/d/h/m/s .  if you just divide the\nlabour such that that is the task of the Zone, the problem goes away.\n",
			"disapproval": false,
			"date": "2011-11-10 16:39:10.807446",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rogpeppe@gmail.com",
				"gustavo@niemeyer.net",
				"lvd@google.com",
				"bradfitz@golang.org",
				"r@golang.org",
				"cw@f00f.org",
				"n13m3y3r@gmail.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\nFile src/pkg/time/time.doc (right):\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode91\nsrc/pkg/time/time.doc:91: Zone returns t with the time zone set to z.\nperhaps. InZone would use a more appropriate preposition.",
			"disapproval": false,
			"date": "2011-11-10 19:16:37.816358",
			"approval": false
		},
		{
			"sender": "gustavo@niemeyer.net",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> I see the conflation of time and zone as unnecessary complexity. You\n> say this as if nothing could be clearer, but I found the inclusion of\n> the zone in the time confusing.\n\nFWIW, I find it quite natural myself. What time is it now?\n\n-- \nGustavo Niemeyer\nhttp://niemeyer.net\nhttp://niemeyer.net/plus\nhttp://niemeyer.net/twitter\nhttp://niemeyer.net/blog\n\n-- I'm not absolutely sure of anything.\n",
			"disapproval": false,
			"date": "2011-11-10 23:38:59.326850",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Fri, Nov 11, 2011 at 15:17, Luuk van Dijk <lvd@google.com> wrote:\n> very few people need both the range and the precision. \u00a0why use the type\n> system to keep track of that a certain int means a month or day of week, but\n> not for keeping track of what the uint64 means? ...\n\nThat's what the new Time and Duration types do.\nWe aren't just passing around untyped int64s anymore.\n\nFrom your CL and the above, it seems like you are suggesting\none type for seconds since 1970 and another for nanoseconds\nsince 1970.  That's exactly the first thing I tried and is described\nin the Go 1 proposal.  I implemented it and converted the entire tree.\nIt was an improvement over what we have now, but really was\njust a calcification of the status quo.  Not much got simpler;\nthere were more types (time.Nano and time.Sec instead of int64)\nand more conversions.\n\nBy far the most important thing about my CL is that there is\nonly one time type.  You argue later in your mail that programmers\nshould have a choice of type, so that they can decide whether\nto use seconds or nanoseconds.  The problem with this is that\nprogrammers will choose the wrong one.  We are still coping\nwith the fact that second time granularity seemed good enough\nin Unix file systems.  Second granularity may be fine right\nnow, but it may not be fine in a few years.  Situations change.\nIf programmers never interacted with other programmers,\nI would have far less objection to having multiple types for them\nto choose from.  But my code calls other code, and there is\nsignificant benefit from having just one way to say 'time', so\nthat all the APIs different programmers are creating will work\nwell together.\n\nFor example, is the modification time on a file a time.Sec,\na time.Nano, or a *time.Time?  This is the key point:\n*** I never want to make that decision again. ***\n\nThere should be one type, and only one type, and then all the\nAPIs gain power and composability because they all use it.\nIt is just as important as agreeing on the signature for Read\nso that everyone implements io.Reader.\n\nFrom a blank slate point of view, sure it makes sense to split\nthe time instant from the time zone, just as it makes sense to\nsplit times measured in seconds from times measured in\nnanoseconds.  What's more relevant in both cases is that we\ncan have just one time type and never worry about having to\npick the right one ever again.  Yes, it is three words.  Yes, the\nzone is sometimes unnecessary (like when subtracting times).\nBut the zone is also not getting in the way, not hurting anything,\nand having a single, unified time type more than compensates.\n\nIt is also worth noting (again) that the zone is not intertwined\nwith the actual time measurement.  One zone can be swapped\nin for another with no change in the meaning of the time.Time.\n\n>> Computations on the new time.Time values are quite efficient.\n>\n> but not as efficient as on a plain uint64\n\nIs your objection about sub+sub+mul+add vs sub?\nI thought it was about time zones.\n\nAs far as this efficiency question is concerned, it seems\nshort-sighted to decide an API based on three extra arithmetic\ninstructions.  In the case where this arises, you are timing\noperations, and the cost of fetching the system time twice,\nalong with whatever you are actually timing, is going to dwarf\nthese three instructions.  We should do what makes a good API,\nnot what saves three fragments of a nanosecond during an\noperation that takes microseconds or more.\n\n> UTC != seconds since the epoch.. \u00a0this is a nice example of an\n> simplification you think everybody is willing to make, but it is only\n> simpler if you ignore the fact that it is wrong.\n\nI'm sorry, but leap seconds are too special purpose for use in a\ngeneral purpose time handling library.  I am writing this at Unix\ntime 1321045116, not Unix time 1321045130.  More harm is\ncaused by libraries thinking they can handle them than by libraries\nignoring them.\n\nLeap smears [1] are a much better way to handle the physical/political\nreality of leap seconds than complicating every single piece of\nsoftware in existence.\n\nWhen a special case arises in a system, you have two choices.\nYou can change your abstractions to accommodate it, which\nmeans changing every piece that depended on or implemented\nthose abstractions.  Or you can change the implementation\nwhere the case arises, to preserve the abstraction, perhaps at\nsome cost in fidelity.  The first choice leads to complexity,\nthe second to simplicity.  Sometimes the loss in fidelity is too\ngreat, so complexity must be chosen.  But more often complexity\nis chosen without good justification.  The leap smear is a great\nexample of preserving simplicity by upholding the abstraction.\n\nLeap seconds are incompatible with nearly every program a\nGo program would want to talk to, link with, or interoperate with.\nThey are not an option.\n\nRuss\n\n[1] http://googleblog.blogspot.com/2011/09/time-technology-and-leaping-seconds.html\n",
			"disapproval": false,
			"date": "2011-11-11 21:18:34.687805",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On 14 November 2011 20:21, roger peppe <rogpeppe@gmail.com> wrote:\n> On 13 November 2011 23:16, Russ Cox <rsc@golang.org> wrote:\n>> I think for a specific time you'd only bother exporting the\n>> zone offset.\n>\n> is it always possible to reconstruct the zone name from\n> the offset?\n\nNo. There are time zones that share the same offset during daylight\nsavings but not otherwise, and vice versa.\n",
			"disapproval": false,
			"date": "2011-11-14 09:24:53.857796",
			"approval": false
		},
		{
			"sender": "karl@kingkarl.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "what is also crazy is that i just spend 10mins reading the time source and \nrecon i could whip something up that would work!\n\nbut if they are going to change it all!!!!!!! wow\n",
			"disapproval": false,
			"date": "2011-11-15 23:18:45.383765",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I thought the plan was to define struct equality as element-wise equality.\n\nSince you can't compare unexported elements, you couldn't use == on a\ntime.Time (outside of the time package itself).\n\n\nOn Tue, Nov 15, 2011 at 3:24 PM, Kyle Lemons <kevlar@google.com> wrote:\n\n> This also reminded me that in Go 1, structs will have equality; should two\n> times be equal if only their \"representation\" zone differ?\n",
			"disapproval": false,
			"date": "2011-11-15 23:27:20.168567",
			"approval": false
		},
		{
			"sender": "kevlar@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "This also reminded me that in Go 1, structs will have equality; should two \ntimes be equal if only their \"representation\" zone differ?",
			"disapproval": false,
			"date": "2011-11-15 23:24:21.903537",
			"approval": false
		},
		{
			"sender": "mpvl@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Nov 16, 2011 at 1:44 AM, David Symonds <dsymonds@golang.org> wrote:\n\n> I've read through this thread and stewed over it for a few days. I\n> still can't wrap my head around the zone info being inside time.Time,\n> yet only having effect for the the string presentation of the time.\n>\n> Many, many times will never be printed. I'd wager that's the majority\n> (think timestamps, timeouts, etc.). In all of those cases, that zone\n> information is wasted space.\n>\nOne could always use t.Unix() (and t.Nanoseconds()) to store a large number\ntime.Time values.\n\n\n>\n> I've had cause to print times with a specific time zone a number of\n> times in my past. However, all the times I can think have the zone\n> information as a final step; the times have been stored in UTC, and\n> then displayed in a particular zone that is specific to a user. Often\n> the easiest way to do that was to send it to client-side JS as a UTC\n> Unix epoch, and then print in the user's local time zone from the\n> browser. Even when doing the conversion server-side, the conversion\n> was most usefully done when turning it into a string; there was no\n> need to ever carry the zone information around with the time.\n>\n> I find it interesting that that is the same approach that your\n> worldclock.go example does that too; the real zone information is\n> brought in very late in the piece.\n>\n> The fact that the zone information is in there, and manifests itself\n> only occasionally (i.e. only when you try to format it) means that you\n> have to be cognitively aware of its existence, and aware of when it's\n> going to have an effect. That seems a lot harder than just being\n> explicit about converting the time into another zone when rendering it\n> as a string.\n>\n>\n> Dave.\n>\n\n\n\n-- \nTrying this for a while: http://go/OnlyCheckEmailTwiceADay.\nMarcel van Lohuizen -- Google Switzerland GmbH -- Identifikationsnummer:\nCH-020.4.028.116-1\n",
			"disapproval": false,
			"date": "2011-11-16 18:30:26.550229",
			"approval": false
		},
		{
			"sender": "kevlar@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "Hmm, all I see is:\n\nGo 1 will define equality on struct and array values composed from fields \non which equality is also defined (element-wise comparison).\n\nI guess you could read \"fields on which equality is also defined\" to \nexclude unexported fields.  I read it as only being based on the types of \nthe fields.\n",
			"disapproval": false,
			"date": "2011-11-15 23:36:28.494534",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "\nOn Nov 15, 2011, at 4:44 PM, David Symonds wrote:\n\n> I've read through this thread and stewed over it for a few days. I\n> still can't wrap my head around the zone info being inside time.Time,\n> yet only having effect for the the string presentation of the time.\n\nIt doesn't have effect only for the string presentation. What does time.Day() mean if you don't know the time zone?\n\nRuss has already explained all this very well, but let me add my perspective.\n\nThe most important part of an API is that it does what you expect in the simplest case, and that in turn the simplest case is useful. All the proposals to separate the time zone from the instant make the interface harder to use. The presence of a time zone does no harm, and the proposed API allows all the things you ask for. But if by default it were absent, things get harder to use.\n\n-rob\n\n",
			"disapproval": false,
			"date": "2011-11-16 02:12:18.830151",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Nov 16, 2011 at 1:12 PM, Rob 'Commander' Pike <r@google.com> wrote:\n\n> On Nov 15, 2011, at 4:44 PM, David Symonds wrote:\n>\n>> I've read through this thread and stewed over it for a few days. I\n>> still can't wrap my head around the zone info being inside time.Time,\n>> yet only having effect for the the string presentation of the time.\n>\n> It doesn't have effect only for the string presentation. What does time.Day() mean if you don't know the time zone?\n>\n> Russ has already explained all this very well, but let me add my perspective.\n\nBack about 5 days, Russ wrote:\n  \"zone is only for presentation.  The actual value\n  in the time.Time is always UTC, and it is adjusted\n  according to zone when printing.  Because the\n  actual value is always UTC, subtracting two\n  time.Time is well defined even if they are in\n  different zones.\"\n\nI take it then that \"presentation\" covers more than just the string\npresentation, but rather it means that all the exported methods (apart\nfrom the obvious exceptions like UTC, Zone) actually give you values\nin the zone of the time.Time?\n\nIf so, perhaps that's the source of much of the confusion here. I\ncertainly took \"presentation\" to mean only for string output; I think\nother people probably got confused too.\n\n\nDave.\n",
			"disapproval": false,
			"date": "2011-11-16 02:39:29.417776",
			"approval": false
		},
		{
			"sender": "dr.volker.dobler@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rogpeppe@gmail.com",
				"gustavo@niemeyer.net",
				"lvd@google.com",
				"bradfitz@golang.org",
				"r@golang.org",
				"cw@f00f.org",
				"n13m3y3r@gmail.com",
				"adg@golang.org",
				"r@google.com",
				"uriel@berlinblue.org",
				"lucio.dere@gmail.com",
				"karl@kingkarl.com",
				"kevlar@google.com",
				"dr.volker.dobler@gmail.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc\nFile src/pkg/time/time.doc (right):\n\nhttp://codereview.appspot.com/5374047/diff/5001/src/pkg/time/time.doc#newcode11\nsrc/pkg/time/time.doc:11: XXX define answer for times that happen twice or not at all due to DST.\n\"times that happen twice\" does not occur: If the clock is\nturned back from 4am to 3am your clock shows 3:30 twice\nbut these two 3:30 are in different zones. You request\none of these in the call to Date, so no ambiguity here.\n\nThe other case \"times that happen not at all\" is maybe a\nmixup of zone and location: When the clock is turned forward\nfrom 2am to 3am there is \"no\" 2:20am in my clock, but of\ncourse there _is_ a time 2:20am CET which can be represented\nin Time.  If I request CET as zone I'll get CET time and\nif this one is printed as CEST it will show as 3:20am.\n\nIt's a chicken and egg problem: If I would know the seconds\ncorresponding to yyyy-mm-dd hh:mm:ss I could use e.g.\nzone := Local.Lookup(seconds) to find the proper zone \nand then Date(yyyy-mm-dd hh:mm:ss, zone) to get my Time\nwhich I could convert to seconds to find the proper zone...\n \nThe big questions are: \n- How to find the proper zone for a given yyyy-mm-dd hh:mm?\n- How to find the proper zone for some time or calendar \nreading somewhere else?",
			"disapproval": false,
			"date": "2011-11-16 00:19:01.610223",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Tue, Nov 15, 2011 at 21:39, David Symonds <dsymonds@golang.org> wrote:\n> If so, perhaps that's the source of much of the confusion here. I\n> certainly took \"presentation\" to mean only for string output; I think\n> other people probably got confused too.\n\nYes, you have to think of Hour, Minute, Month, and so on as\npresentation (they are all parts of the string output).\nIt is Add, Sub, Unix, etc that are zone-independent:\nthe calculations on time.\n\nThe main thing I have yet to complete before sending out\nthe time implementation CL is good comments.  I will try\nto make this distinction clear, and if it's not, please do say so.\n\nThanks.\nRuss\n",
			"disapproval": false,
			"date": "2011-11-16 04:10:40.616928",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Nov 16, 2011 at 3:10 PM, Russ Cox <rsc@golang.org> wrote:\n\n> On Tue, Nov 15, 2011 at 21:39, David Symonds <dsymonds@golang.org> wrote:\n>> If so, perhaps that's the source of much of the confusion here. I\n>> certainly took \"presentation\" to mean only for string output; I think\n>> other people probably got confused too.\n>\n> Yes, you have to think of Hour, Minute, Month, and so on as\n> presentation (they are all parts of the string output).\n> It is Add, Sub, Unix, etc that are zone-independent:\n> the calculations on time.\n>\n> The main thing I have yet to complete before sending out\n> the time implementation CL is good comments. \u00a0I will try\n> to make this distinction clear, and if it's not, please do say so.\n\nOkay, this makes much more sense to me. I am on-board with this plan.\n\n\nDave.\n",
			"disapproval": false,
			"date": "2011-11-16 04:17:17.219791",
			"approval": false
		},
		{
			"sender": "dsymonds@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "I've read through this thread and stewed over it for a few days. I\nstill can't wrap my head around the zone info being inside time.Time,\nyet only having effect for the the string presentation of the time.\n\nMany, many times will never be printed. I'd wager that's the majority\n(think timestamps, timeouts, etc.). In all of those cases, that zone\ninformation is wasted space.\n\nI've had cause to print times with a specific time zone a number of\ntimes in my past. However, all the times I can think have the zone\ninformation as a final step; the times have been stored in UTC, and\nthen displayed in a particular zone that is specific to a user. Often\nthe easiest way to do that was to send it to client-side JS as a UTC\nUnix epoch, and then print in the user's local time zone from the\nbrowser. Even when doing the conversion server-side, the conversion\nwas most usefully done when turning it into a string; there was no\nneed to ever carry the zone information around with the time.\n\nI find it interesting that that is the same approach that your\nworldclock.go example does that too; the real zone information is\nbrought in very late in the piece.\n\nThe fact that the zone information is in there, and manifests itself\nonly occasionally (i.e. only when you try to format it) means that you\nhave to be cognitively aware of its existence, and aware of when it's\ngoing to have an effect. That seems a lot harder than just being\nexplicit about converting the time into another zone when rendering it\nas a string.\n\n\nDave.\n",
			"disapproval": false,
			"date": "2011-11-16 00:44:59.100360",
			"approval": false
		},
		{
			"sender": "mpvl@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Wed, Nov 16, 2011 at 5:10 AM, Russ Cox <rsc@golang.org> wrote:\n\n> On Tue, Nov 15, 2011 at 21:39, David Symonds <dsymonds@golang.org> wrote:\n> > If so, perhaps that's the source of much of the confusion here. I\n> > certainly took \"presentation\" to mean only for string output; I think\n> > other people probably got confused too.\n>\n> Yes, you have to think of Hour, Minute, Month, and so on as\n> presentation (they are all parts of the string output).\n>\n\n\n> It is Add, Sub, Unix, etc that are zone-independent:\n> the calculations on time.\n\n\n> The main thing I have yet to complete before sending out\n> the time implementation CL is good comments.  I will try\n> to make this distinction clear, and if it's not, please do say so.\n>\nIt may need clarification what you mean with a time zone as well.  Do you\nmean the time zone with the fixed offset from UTC, or the geographical\nregion.\n\nAssuming that t.tz == u.tz for u.tz := t.Add(x), the representation of u\nmay vary based on this definition, as the offset for a region may have\ncrossed in or out of daylight savings time.  I would expect the time zone\nto refer to the geographical region.  Doing otherwise would be rather\nuseless, as it will not handle the common case properly.  In this case, if\nthe goal is to preserve the tz in the representation, using an offset is\nnot sufficient to fully qualify it.  Neither is the use of common time\nzone abbreviations:  Ireland and Britain both use GMT for standard time,\nbut use IST and BST for DST, respectively.  Also, DST dates may differ per\nregion with the same time zone.  It is probably not a big deal, though, to\nnot preserve the exact time zone in the representation.\n\n\n>\n> Thanks.\n> Russ\n>\n",
			"disapproval": false,
			"date": "2011-11-16 19:44:25.292356",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"dvyukov@google.com",
				"rogpeppe@gmail.com",
				"gustavo@niemeyer.net",
				"lvd@google.com",
				"bradfitz@golang.org",
				"r@golang.org",
				"cw@f00f.org",
				"n13m3y3r@gmail.com",
				"adg@golang.org",
				"r@google.com",
				"uriel@berlinblue.org",
				"lucio.dere@gmail.com",
				"karl@kingkarl.com",
				"kevlar@google.com",
				"dr.volker.dobler@gmail.com",
				"dsymonds@golang.org",
				"mpvl@google.com",
				"mpvl@golang.org",
				"reply@codereview.appspotmail.com"
			],
			"text": "*** Abandoned ***",
			"disapproval": false,
			"date": "2011-11-16 22:38:19.279221",
			"approval": false
		}
	],
	"owner_email": "rsc@golang.org",
	"private": false,
	"base_url": "",
	"owner": "rsc",
	"subject": "code review 5374047: time doc sketch",
	"created": "2011-11-10 05:59:47.726470",
	"patchsets": [
		1,
		1002,
		2002,
		5001,
		1011
	],
	"modified": "2011-11-16 22:38:21.464334",
	"closed": true,
	"issue": 5374047
}