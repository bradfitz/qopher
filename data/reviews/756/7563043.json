{
	"description": "runtime: fix cgo callbacks on windows\n\nFixes issue 4955.",
	"cc": [
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"hanwen@google.com",
		"minux.ma@gmail.com",
		"alex.brainman@gmail.com"
	],
	"messages": [
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"alex.brainman@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=f800157ce425 ***\n\nruntime: fix cgo callbacks on windows\n\nFixes issue 4955.\n\nR=golang-dev, alex.brainman\nCC=golang-dev\nhttps://codereview.appspot.com/7563043",
			"disapproval": false,
			"date": "2013-03-07 14:18:52.544570",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://code.google.com/p/go/",
			"disapproval": false,
			"date": "2013-03-07 04:51:06.224080",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"alex.brainman@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "It fails on my 386:\n\n...\n# runtime -cpu=1,2,4\npanic: test timed out\n\ngoroutine 255 [running]:\ntesting.alarm()\n        C:/go/root/src/pkg/testing/testing.go:526 +0x43\ncreated by time.goFunc\n        C:/go/root/src/pkg/time/sleep.go:122 +0x44\n\ngoroutine 1 [chan receive]:\ntesting.RunTests(0x596424, 0x690278, 0x2b, 0x2b, 0x1, ...)\n        C:/go/root/src/pkg/testing/testing.go:427 +0x69e\ntesting.Main(0x596424, 0x690278, 0x2b, 0x2b, 0x690e08, ...)\n        C:/go/root/src/pkg/testing/testing.go:358 +0x68\nmain.main()\n        C:/DOCUME~1/brainman/LOCALS~1/Temp/go-build240754935/runtime/_test/_testmain.go:269 +0x80\n\ngoroutine 254 [syscall]:\nsyscall.Syscall6(0x7c801812, 0x5, 0x768, 0x11094c00, 0x200, ...)\n        C:/go/root/src/pkg/runtime/zsyscall_windows_windows_386.c:97 +0x49\nsyscall.ReadFile(0x768, 0x11094c00, 0x200, 0x200, 0x10fe0550, ...)\n        C:/go/root/src/pkg/syscall/zsyscall_windows_386.go:264 +0xa0\nsyscall.Read(0x768, 0x11094c00, 0x200, 0x200, 0x480d35, ...)\n        C:/go/root/src/pkg/syscall/syscall_windows.go:266 +0x70\nos.(*File).read(0x10fe0a58, 0x11094c00, 0x200, 0x200, 0x0, ...)\n        C:/go/root/src/pkg/os/file_windows.go:288 +0xd2\nos.(*File).Read(0x10fe0a58, 0x11094c00, 0x200, 0x200, 0x0, ...)\n        C:/go/root/src/pkg/os/file.go:95 +0x76\nbytes.(*Buffer).ReadFrom(0x11084000, 0x11052d80, 0x10fe0a58, 0x0, 0x0, ...)\n        C:/go/root/src/pkg/bytes/buffer.go:166 +0x194\nio.Copy(0x11052560, 0x11084000, 0x11052d80, 0x10fe0a58, 0x0, ...)\n        C:/go/root/src/pkg/io/io.go:328 +0x82\nos/exec.func\u00b7003(0x5999f0, 0x597b40)\n        C:/go/root/src/pkg/os/exec/exec.go:207 +0x53\nos/exec.func\u00b7004(0x1106ddc0)\n        C:/go/root/src/pkg/os/exec/exec.go:274 +0x2b\ncreated by os/exec.(*Cmd).Start\n        C:/go/root/src/pkg/os/exec/exec.go:275 +0x510\n\ngoroutine 253 [syscall]:\nsyscall.Syscall(0x7c802530, 0x2, 0x730, 0xffffffff, 0x0, ...)\n        C:/go/root/src/pkg/runtime/zsyscall_windows_windows_386.c:74 +0x49\nsyscall.WaitForSingleObject(0x730, 0xffffffff, 0x0, 0x0, 0x0, ...)\n        C:/go/root/src/pkg/syscall/zsyscall_windows_386.go:671 +0x66\nos.(*Process).wait(0x1106dff0, 0x0, 0x0, 0x0)\n        C:/go/root/src/pkg/os/exec_windows.go:16 +0x4b\nos.(*Process).Wait(0x1106dff0, 0x1106ddd0, 0x3, 0x4)\n        C:/go/root/src/pkg/os/doc.go:43 +0x28\nos/exec.(*Cmd).Wait(0x1103d5a0, 0x0, 0x0)\n        C:/go/root/src/pkg/os/exec/exec.go:308 +0x125\nos/exec.(*Cmd).Run(0x1103d5a0, 0x11084000, 0x4)\n        C:/go/root/src/pkg/os/exec/exec.go:232 +0x4d\nos/exec.(*Cmd).CombinedOutput(0x1103d5a0, 0x2, 0x31421648, 0x4, 0x4, ...)\n        C:/go/root/src/pkg/os/exec/exec.go:352 +0x1a0\nruntime_test.checkStaleRuntime(0x1106eb40)\n        C:/go/root/src/pkg/runtime/crash_test.go:46 +0x82\nruntime_test.executeTest(0x1106eb40, 0x599cc8, 0x358, 0x0, 0x0, ...)\n        C:/go/root/src/pkg/runtime/crash_test.go:18 +0x48\nruntime_test.TestCgoSignalDeadlock(0x1106eb40)\n        C:/go/root/src/pkg/runtime/crash_cgo_test.go:18 +0x3d\ntesting.tRunner(0x1106eb40, 0x6902c0)\n        C:/go/root/src/pkg/testing/testing.go:346 +0x86\ncreated by testing.RunTests\n        C:/go/root/src/pkg/testing/testing.go:426 +0x683\nFAIL    runtime 120.095s\n\nC:\\go\\root\\src>\n\nI think this is because you have bug in your code. But even, if you fix it, your new version is slower. But we will find out.\n\nAlex\n\nhttps://codereview.appspot.com/7563043/diff/8001/src/pkg/runtime/sys_windows_386.s\nFile src/pkg/runtime/sys_windows_386.s (right):\n\nhttps://codereview.appspot.com/7563043/diff/8001/src/pkg/runtime/sys_windows_386.s#newcode324\nsrc/pkg/runtime/sys_windows_386.s:324: MOVL\t$lo-8(SP), BX\nAre you sure about that line? See my gdb output:\n\nBreakpoint 1, runtime.usleep (usec=void)\n    at C:/go/root/src/pkg/runtime/sys_windows_386.s:334\n334     TEXT runtime-+usleep(SB),7,$20\n(gdb) disas\nDump of assembler code for function runtime.usleep:\n=> 0x0041e880 <+0>:     sub    $0x14,%esp\n   0x0041e883 <+3>:     mov    0x568478,%eax\n   0x0041e889 <+9>:     mov    0x18(%esp),%ebx\n   0x0041e88d <+13>:    movl   $0x0,0x10(%esp)\n   0x0041e895 <+21>:    mov    %ebx,0xc(%esp)\n   0x0041e899 <+25>:    lea    -0x8(%esp),%ebx\n   0x0041e89d <+29>:    mov    %ebx,0x8(%esp)\n   0x0041e8a1 <+33>:    movl   $0x0,0x4(%esp)\n   0x0041e8a9 <+41>:    movl   $0x0,(%esp)\n   0x0041e8b0 <+48>:    mov    %esp,%ebp\n   0x0041e8b2 <+50>:    call   0x41e8c0 <checkstack4>\n   0x0041e8b7 <+55>:    call   *%eax\n   0x0041e8b9 <+57>:    mov    %ebp,%esp\n   0x0041e8bb <+59>:    add    $0x14,%esp\n   0x0041e8be <+62>:    ret\nEnd of assembler dump.\n(gdb)\n\nhttps://codereview.appspot.com/7563043/diff/8001/src/pkg/runtime/sys_windows_386.s#newcode339\nsrc/pkg/runtime/sys_windows_386.s:339: MOVL\t$lo-8(SP), BX\nAs above\n\nhttps://codereview.appspot.com/7563043/diff/8001/src/pkg/runtime/sys_windows_amd64.s\nFile src/pkg/runtime/sys_windows_amd64.s (right):\n\nhttps://codereview.appspot.com/7563043/diff/8001/src/pkg/runtime/sys_windows_amd64.s#newcode355\nsrc/pkg/runtime/sys_windows_amd64.s:355: // a SYSENTER and a RET.\nShould we allow for stack alignment and room for first 4 parameters as per http://blogs.msdn.com/b/oldnewthing/archive/2004/01/14/58579.aspx ?",
			"disapproval": false,
			"date": "2013-03-07 06:32:04.243580",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thanks. In addition to MOVL not working the way I thought it did, I found a\r\nfew other bugs too (wrong handle, wrong time units). Please try the latest\r\npatch set.\r\n\r\nWe don't need the stack alignment and first 4 parameters on amd64 because\r\nit's just a system call, not an ordinary function call.\r\n",
			"disapproval": false,
			"date": "2013-03-07 06:35:54.272500",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"alex.brainman@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nThank you.\n\nAlex",
			"disapproval": false,
			"date": "2013-03-07 08:10:10.050580",
			"approval": true
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thanks for pushing back. The old sleep and yield were doing neither, which\r\nwas making various pieces of Go spin instead of schedule nicely.\r\n",
			"disapproval": false,
			"date": "2013-03-07 14:17:03.222920",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "It should work to switch to the m stack, which was allocated by\r\nCreateThread and should be \"big enough\".\r\n\r\nUntested:\r\n\r\nTEXT runtime\u00b7osyield(SB),7,$8\r\n// Tried NtYieldExecution but it doesn't yield hard enough.\r\n// NtWaitForSingleObject being used here as Sleep(0).\r\n// The CALL is safe because NtXxx is a system call wrapper:\r\n// it puts the right system call number in AX, then does\r\n// a SYSENTER and a RET.\r\nMOVQ runtime\u00b7NtWaitForSingleObject(SB), AX\r\nMOVQ $1, BX\r\nNEGQ BX\r\nMOVQ SP, R8 // ptime\r\nMOVQ BX, (R8)\r\nMOVQ $-1, CX // handle\r\nMOVQ $0, DX // alertable\r\n // Execute call on m->g0 stack, in case we are not actually\r\n// calling a system call wrapper, like when running under WINE.\r\nget_tls(R15)\r\nMOVQ m(R15), R14\r\nCMPQ g(R15), m_g0(R14)\r\nJNE 3(PC)\r\n// executing on m->g0 already\r\nCALL AX\r\nRET\r\n\r\n// Switch to m->g0 stack and back.\r\nMOVQ m_g0(R14), R14\r\nMOVQ (g_sched+gobuf_sp)(R14), R14\r\nMOVQ SP, -8(R14)\r\nLEAQ -8(R14), SP\r\nCALL AX\r\nMOVQ 0(SP), SP\r\nRET\r\n",
			"disapproval": false,
			"date": "2013-07-11 20:14:11.563650",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jul 3, 2013 at 5:10 PM, <alex.brainman@gmail.com> wrote:\r\n\r\n> On 2013/07/03 09:08:04, minux wrote:\r\n>\r\n>> On Wed, Jul 3, 2013 at 4:43 PM, Han-Wen Nienhuys\r\n>>\r\n> <mailto:hanwen@google.com> wrote:\r\n>\r\n>\r\n>  apply a change like this:\r\n>> diff -r bb98e4c9b6b3 src/pkg/runtime/sys_windows_**386.s\r\n>>\r\n>\r\n> This cannot be right. The problem is on windows/amd64 (not windows/386).\r\n> Isn't it?\r\n>\r\ni looked at the original bug report (\r\nhttps://code.google.com/p/go/issues/detail?id=5831)\r\nand i was misled by the small pc values...\r\nyes, it should be a problem of the windows/amd64.\r\n\r\nOn Wed, Jul 3, 2013 at 5:15 PM, <alex.brainman@gmail.com> wrote:\r\n\r\n> On 2013/07/03 09:08:04, minux wrote:\r\n>\r\n> so i think the cause might be that NtWaitForSingleObject requires more\r\n>> stack than\r\n>> available, so it overflows the goroutine stack and causes memory\r\n>>\r\n> corruption.\r\n>\r\n> That could well be a problem too. But, then it could be happening on\r\n> Windows too (not just on wine). :-( But I haven't heard anyone complain\r\n> yet. If that is the case, we should go back to switching stacks.\r\n>\r\ni suspect that is the real cause now given hanwen's experiments.\r\n\r\nthe reason why it doesn't happen on real windows, is that on real windows\r\nsystems, NtWaitForSingleObject in ntdll.ddl is just a syscall (the real\r\nsyscall in\r\nthe sense of int 0x2E/sysenter) wrapper, so it won't use arbitrary user\r\nspace\r\nstack space. (in fact, as Russ checks in the code, it requires precisely 4\r\nbytes\r\nof stack on i386 and no extra stack on amd64)\r\n\r\nwine implements ntdll.dll in user space, so it can use arbitrary amount of\r\nuser space stack space, so if we want to support wine, either we\r\nswitch stacks and accept the overhead,\r\nor use different call path for wine.\r\n",
			"disapproval": false,
			"date": "2013-07-03 09:25:23.670180",
			"approval": false
		},
		{
			"sender": "hanwen@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I applied this,\r\n\r\n$ hg diff\r\ndiff -r 09e39a9ce38e src/pkg/runtime/sys_windows_amd64.s\r\n--- a/src/pkg/runtime/sys_windows_amd64.s Wed Jul 03 00:33:38 2013 +0800\r\n+++ b/src/pkg/runtime/sys_windows_amd64.s Wed Jul 03 11:09:29 2013 +0200\r\n@@ -335,7 +335,10 @@\r\n  MOVQ BX, (R8)\r\n  MOVQ $-1, CX // handle\r\n  MOVQ $0, DX // alertable\r\n+\r\n+ SUBQ    $32, SP\r\n  CALL AX\r\n+ ADDQ    $32, SP\r\n  RET\r\n\r\nbut see the same problem as before.\r\n\r\nAnother thing to note is that the crash always says\r\n\r\n [signal 0xc0000005 code=0x0 addr=0x30 pc=0x41f530]\r\n\r\nif this was a routine overwriting the stack, wouldn't the fault addr\r\nchange depending on how I change the repro case? I've trimmed it down\r\nfrom its original significantly, but addr is always 0x30.\r\n\r\n\r\nOn Wed, Jul 3, 2013 at 11:10 AM,  <alex.brainman@gmail.com> wrote:\r\n> On 2013/07/03 09:08:04, minux wrote:\r\n>>\r\n>> On Wed, Jul 3, 2013 at 4:43 PM, Han-Wen Nienhuys\r\n>\r\n> <mailto:hanwen@google.com> wrote:\r\n>\r\n>\r\n>> apply a change like this:\r\n>> diff -r bb98e4c9b6b3 src/pkg/runtime/sys_windows_386.s\r\n>\r\n>\r\n> This cannot be right. The problem is on windows/amd64 (not windows/386).\r\n> Isn't it?\r\n>\r\n> Alex\r\n>\r\n> https://codereview.appspot.com/7563043/\r\n\r\n\r\n\r\n-- \r\nHan-Wen Nienhuys\r\nGoogle Munich\r\nhanwen@google.com\r\n",
			"disapproval": false,
			"date": "2013-07-03 09:18:03.720860",
			"approval": false
		},
		{
			"sender": "hanwen@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I tried\r\n\r\nTEXT runtime\u00b7osyield(SB),7,$0\r\n        MOVQ    runtime\u00b7NtYieldExecution(SB), AX\r\n        CALL    AX\r\n        RET\r\n\r\nTEXT runtime\u00b7usleep(SB),7,$8\r\n        MOVQ    runtime\u00b7NtDelayExecution(SB), AX\r\n        MOVL    usec+0(FP), BX\r\n        IMULQ   $10, BX\r\n        NEGQ    BX\r\n        MOVQ    SP, DX // ptime\r\n\r\n        MOVQ    BX, (DX)\r\n        MOVQ    $0, CX // alertable\r\n        CALL    AX\r\n        RET\r\n\r\nthis improved things a little bit, in that it sometimes exits\r\nsuccessfully, but 1 in 3 times, it still crashes. When it crashes, the\r\nprogram completes more loop iterations successfully.\r\n\r\nIs there a way to ensure that NtYieldExecution has enough stack?  I\r\ntried adding a random amount to the last argument of TEXT, but it made\r\nthe crashiness worse.\r\n\r\n\r\n\r\nOn Wed, Jul 3, 2013 at 2:53 PM, minux <minux.ma@gmail.com> wrote:\r\n>\r\n> On Wed, Jul 3, 2013 at 8:38 PM, <alex.brainman@gmail.com> wrote:\r\n>>\r\n>> Sure, we could try. It might even work for Windows, then we can use it\r\n>>\r\n>> everywhere. There is also similar function runtime.usleep that is in the\r\n>\r\n> as discussed on the issue tracker,\r\n> https://code.google.com/p/go/issues/detail?id=4955,\r\n> NtYieldExecution is not good enough for normal windows use, so i'm afraid\r\n> we have to detect wine and only let wine use that call path.\r\n>>\r\n>> same boat. You didn't have problem with runtime.usleep?\r\n>\r\n> yes, i'd expect runtime.usleep will cause the same problem on wine.\r\n>\r\n> the major uses of runtime.usleep are from GC, parfor (also used by GC) and\r\n> sysmon, and cgo callback in proc.c.\r\n>\r\n> sysmon always runs on its own M, so nothing to worry about.\r\n>\r\n> as the GC is now happening on g0 (OS thread stack), so i'd expect a lot of\r\n> calls\r\n> to usleep will actually be made from OS stack already, and it might explain\r\n> why it\r\n> doesn't surface.\r\n>\r\n> another use of runtime.usleep is in external cgo callback path.\r\n> @hanwen, have you tried to run misc/cgo/test inside wine? it might expose\r\n> other problems (you won't be able to cross compile that test, so you will\r\n> have\r\n> to build it from a windows machine).\r\n\r\n\r\n\r\n--\r\nHan-Wen Nienhuys\r\nGoogle Munich\r\nhanwen@google.com\r\n",
			"disapproval": false,
			"date": "2013-07-03 14:40:15.292550",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"hanwen@google.com",
				"minux.ma@gmail.com",
				"alex.brainman@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/07/03 08:46:16, brainman wrote:\n> On 2013/07/03 08:14:11, hanwen wrote:\n> ...\n> Just change asm to leave room for 4 registers. ...\n\nhanwen, I will try to do it myself tomorrow, if you get nowhere.\n\nAlex",
			"disapproval": false,
			"date": "2013-07-03 09:06:23.264790",
			"approval": false
		},
		{
			"sender": "hanwen@google.com",
			"recipients": [
				"rsc@golang.org",
				"hanwen@google.com",
				"golang-dev@googlegroups.com",
				"alex.brainman@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/03/07 14:18:52, rsc wrote:\n> *** Submitted as https://code.google.com/p/go/source/detail?r=f800157ce425 ***\n> \n> runtime: fix cgo callbacks on windows\n> \n> Fixes issue 4955.\n> \n> R=golang-dev, alex.brainman\n> CC=golang-dev\n> https://codereview.appspot.com/7563043\n\nIt looks like the change to yield causes breakage when running under wine (see https://code.google.com/p/go/issues/detail?id=5831). \n\nWine does the windows emulation in user space, so some of the assumption made here may not hold?  \n\nhttp://blogs.msdn.com/b/oldnewthing/archive/2004/01/14/58579.aspx mentions that there should be space on the stack reserved for register spills. Could that happen when the NT call is implemented in user space? How could I test if this is the case?",
			"disapproval": false,
			"date": "2013-07-03 08:14:11.270380",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"hanwen@google.com",
				"minux.ma@gmail.com",
				"alex.brainman@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/07/03 09:18:03, hanwen wrote:\n> I applied this,\n> \n> $ hg diff\n> diff -r 09e39a9ce38e src/pkg/runtime/sys_windows_amd64.s\n> --- a/src/pkg/runtime/sys_windows_amd64.s Wed Jul 03 00:33:38 2013 +0800\n> +++ b/src/pkg/runtime/sys_windows_amd64.s Wed Jul 03 11:09:29 2013 +0200\n> @@ -335,7 +335,10 @@\n>   MOVQ BX, (R8)\n>   MOVQ $-1, CX // handle\n>   MOVQ $0, DX // alertable\n> +\n> + SUBQ    $32, SP\n>   CALL AX\n> + ADDQ    $32, SP\n>   RET\n> \n> but see the same problem as before.\n> \n\nThis is wrong. Firstly, if you look at what this function does, you will see that it has local variable that would be overwritten still if the callee is to use these 4 stack places. And secondly go linker does not see stack growth when SP is manipulated directly. You must use either PUSH/PULL commands or you could change local space size ($8) at TEXT runtime.osyield.\n\nIf you do this, you might discover, as minux said, that you will run out of stack. As far as I remember, limited stack room is the reason why rsc used NtWaitForSingleObject here. It does not use stack itself, and we don't need to switch stacks to call it. I think, if we try to switch stack here, we will run out of room. So our idea of switching stacks here conditionally or not will not fly. runtime.osyield is marked as \"no stack split\", because it is called by \"no split stack\" function. There might be a few \"no stack split\" functions on the call stack - that is why we are so short of stack space.\n\nI am not sure what to do. Perhaps we should wait for Russ. While we wait you could confirm minux's idea - see how much stack does NtWaitForSingleObject use on Wine. Just use gdb to see where it takes you. If the stack usage is not very large, perhaps we can do something ...\n\nAlex",
			"disapproval": false,
			"date": "2013-07-03 11:43:24.353910",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"hanwen@google.com",
				"minux.ma@gmail.com",
				"alex.brainman@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/07/03 09:08:04, minux wrote:\n> On Wed, Jul 3, 2013 at 4:43 PM, Han-Wen Nienhuys <mailto:hanwen@google.com> wrote:\n> \n> \n> apply a change like this:\n> diff -r bb98e4c9b6b3 src/pkg/runtime/sys_windows_386.s\n\nThis cannot be right. The problem is on windows/amd64 (not windows/386). Isn't it?\n\nAlex",
			"disapproval": false,
			"date": "2013-07-03 09:10:48.504520",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"hanwen@google.com",
				"minux.ma@gmail.com",
				"alex.brainman@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/07/03 12:26:45, hanwen wrote:\n> \n> How big is 'not very large' in this context? ...\n\n20-40 bytes. You could try and increase runtime.osyield frame size and see when the linker complains.\n\n> ... WaitForSingleObject\n> doesn't look too good,\n\nYes.\n\n> However, the point is to finally yield the CPU, right? at the bottom,\n> it calls NtSchedYield, which is an alias for sched_yield(2), see\n> \n>  http://source.winehq.org/source/dlls/ntdll/sync.c#L1191\n> \n> could we conditionally call NtSchedYield instead?\n\nSure, we could try. It might even work for Windows, then we can use it everywhere. There is also similar function runtime.usleep that is in the same boat. You didn't have problem with runtime.usleep?\n\nAlex",
			"disapproval": false,
			"date": "2013-07-03 12:38:06.086230",
			"approval": false
		},
		{
			"sender": "hanwen@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jul 3, 2013 at 1:43 PM,  <alex.brainman@gmail.com> wrote:\r\n> On 2013/07/03 09:18:03, hanwen wrote:\r\n>>\r\n>> I applied this,\r\n>\r\n>\r\n>> $ hg diff\r\n>> diff -r 09e39a9ce38e src/pkg/runtime/sys_windows_amd64.s\r\n>> --- a/src/pkg/runtime/sys_windows_amd64.s Wed Jul 03 00:33:38 2013\r\n>\r\n> +0800\r\n>>\r\n>> +++ b/src/pkg/runtime/sys_windows_amd64.s Wed Jul 03 11:09:29 2013\r\n>\r\n> +0200\r\n>>\r\n>> @@ -335,7 +335,10 @@\r\n>>    MOVQ BX, (R8)\r\n>>    MOVQ $-1, CX // handle\r\n>>    MOVQ $0, DX // alertable\r\n>> +\r\n>> + SUBQ    $32, SP\r\n>>    CALL AX\r\n>> + ADDQ    $32, SP\r\n>>    RET\r\n>\r\n>\r\n>> but see the same problem as before.\r\n>\r\n>\r\n>\r\n> This is wrong. Firstly, if you look at what this function does, you will\r\n> see that it has local variable that would be overwritten still if the\r\n> callee is to use these 4 stack places. And secondly go linker does not\r\n> see stack growth when SP is manipulated directly. You must use either\r\n> PUSH/PULL commands or you could change local space size ($8) at TEXT\r\n> runtime.osyield.\r\n>\r\n> If you do this, you might discover, as minux said, that you will run out\r\n> of stack. As far as I remember, limited stack room is the reason why rsc\r\n> used NtWaitForSingleObject here. It does not use stack itself, and we\r\n> don't need to switch stacks to call it. I think, if we try to switch\r\n> stack here, we will run out of room. So our idea of switching stacks\r\n> here conditionally or not will not fly. runtime.osyield is marked as \"no\r\n> stack split\", because it is called by \"no split stack\" function. There\r\n> might be a few \"no stack split\" functions on the call stack - that is\r\n> why we are so short of stack space.\r\n>\r\n> I am not sure what to do. Perhaps we should wait for Russ. While we wait\r\n> you could confirm minux's idea - see how much stack does\r\n> NtWaitForSingleObject use on Wine. Just use gdb to see where it takes\r\n> you. If the stack usage is not very large, perhaps we can do something\r\n\r\nHow big is 'not very large' in this context? WaitForSingleObject\r\ndoesn't look too good,\r\n\r\n http://source.winehq.org/source/dlls/ntdll/sync.c#L1090\r\n\r\nit has an array of 64 int32s for starters, to store local handles.\r\n\r\nHowever, the point is to finally yield the CPU, right? at the bottom,\r\nit calls NtSchedYield, which is an alias for sched_yield(2), see\r\n\r\n http://source.winehq.org/source/dlls/ntdll/sync.c#L1191\r\n\r\ncould we conditionally call NtSchedYield instead?\r\n\r\n> ...\r\n>\r\n> Alex\r\n>\r\n> https://codereview.appspot.com/7563043/\r\n\r\n\r\n\r\n--\r\nHan-Wen Nienhuys\r\nGoogle Munich\r\nhanwen@google.com\r\n",
			"disapproval": false,
			"date": "2013-07-03 12:26:45.763490",
			"approval": false
		},
		{
			"sender": "hanwen@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "What is the problem with allocating the extra space?\r\n\r\n(sorry for the stupid question; I'm not very familiar with either\r\nwindows or the Go runtime.)\r\n\r\nOn Wed, Jul 3, 2013 at 10:27 AM, minux <minux.ma@gmail.com> wrote:\r\n>\r\n> On Wed, Jul 3, 2013 at 4:14 PM, <hanwen@google.com> wrote:\r\n>>\r\n>> On 2013/03/07 14:18:52, rsc wrote:\r\n>>>\r\n>>> *** Submitted as\r\n>>\r\n>> https://code.google.com/p/go/source/detail?r=f800157ce425 ***\r\n>>\r\n>>> runtime: fix cgo callbacks on windows\r\n>>\r\n>>\r\n>>> Fixes issue 4955.\r\n>>\r\n>>\r\n>>> R=golang-dev, alex.brainman\r\n>>> CC=golang-dev\r\n>>> https://codereview.appspot.com/7563043\r\n>>\r\n>>\r\n>> It looks like the change to yield causes breakage when running under\r\n>> wine (see https://code.google.com/p/go/issues/detail?id=5831).\r\n>>\r\n>> Wine does the windows emulation in user space, so some of the assumption\r\n>> made here may not hold?\r\n>\r\n> yes, very possible.\r\n> windows abi mandates 4 uintptr space below sp, and in fact we did have a cgo\r\n> bug in the past that resulted from violating this.\r\n>\r\n> if we need to support where NtWaitForSingleObject is implemented in user\r\n> space,\r\n> i'm afraid we have to resort to using normal cgocall/stdcall mechanism to\r\n> call it and\r\n> thus incur big overhead for real windows machines.\r\n>\r\n> if we want to fix this problem, perhaps we'd better detect wine and use\r\n> alternative\r\n> call paths.\r\n>>\r\n>>\r\n>> http://blogs.msdn.com/b/oldnewthing/archive/2004/01/14/58579.aspx\r\n>> mentions that there should be space on the stack reserved for register\r\n>> spills. Could that happen when the NT call is implemented in user space?\r\n>> How could I test if this is the case?\r\n\r\n\r\n\r\n-- \r\nHan-Wen Nienhuys\r\nGoogle Munich\r\nhanwen@google.com\r\n",
			"disapproval": false,
			"date": "2013-07-03 08:43:54.879690",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"hanwen@google.com",
				"minux.ma@gmail.com",
				"alex.brainman@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/07/03 14:40:15, hanwen wrote:\n> I tried\n> \n> TEXT runtime\u00b7osyield(SB),7,$0\n>         MOVQ    runtime\u00b7NtYieldExecution(SB), AX\n>         CALL    AX\n>         RET\n> \n> TEXT runtime\u00b7usleep(SB),7,$8\n>         MOVQ    runtime\u00b7NtDelayExecution(SB), AX\n>         MOVL    usec+0(FP), BX\n>         IMULQ   $10, BX\n>         NEGQ    BX\n>         MOVQ    SP, DX // ptime\n> \n>         MOVQ    BX, (DX)\n>         MOVQ    $0, CX // alertable\n>         CALL    AX\n>         RET\n> \n> this improved things a little bit, in that it sometimes exits\n> successfully, but 1 in 3 times, it still crashes. When it crashes, the\n> program completes more loop iterations successfully.\n> \n> Is there a way to ensure that NtYieldExecution has enough stack? \n\nNot realy. You are running on Go stack here. The stack is allocated from heap as any other memory. It is quite small at the start. Every Go function extends it, if need be. Once you are in Wine, no one will extend that stack. So you have to do it somehow here, and have enough to last the distance, since all normal programs (non-Go) assume that stack is unlimited.\n\nThis situation is worse here, because we have few special functions on our stack that \"do not extend stack\", so linker makes sure that they have enough room to run. Here I have changed source to demonstrate:\n\n# hg diff -g\ndiff --git a/src/pkg/runtime/proc.c b/src/pkg/runtime/proc.c\n--- a/src/pkg/runtime/proc.c\n+++ b/src/pkg/runtime/proc.c\n@@ -752,13 +752,11 @@\n lockextra(bool nilokay)\n {\n \tM *mp;\n-\tvoid (*yield)(void);\n \n \tfor(;;) {\n \t\tmp = runtime\u00b7atomicloadp(&runtime\u00b7extram);\n \t\tif(mp == MLOCKED) {\n-\t\t\tyield = runtime\u00b7osyield;\n-\t\t\tyield();\n+\t\t\truntime\u00b7osyield();\n \t\t\tcontinue;\n \t\t}\n \t\tif(mp == nil && !nilokay) {\n@@ -766,8 +764,7 @@\n \t\t\tcontinue;\n \t\t}\n \t\tif(!runtime\u00b7casp(&runtime\u00b7extram, mp, MLOCKED)) {\n-\t\t\tyield = runtime\u00b7osyield;\n-\t\t\tyield();\n+\t\t\truntime\u00b7osyield();\n \t\t\tcontinue;\n \t\t}\n \t\tbreak;\ndiff --git a/src/pkg/runtime/sys_windows_amd64.s b/src/pkg/runtime/sys_windows_amd64.s\n--- a/src/pkg/runtime/sys_windows_amd64.s\n+++ b/src/pkg/runtime/sys_windows_amd64.s\n@@ -322,7 +322,7 @@\n TEXT runtime\u00b7remove_exception_handler(SB),7,$0\n \tRET\n \n-TEXT runtime\u00b7osyield(SB),7,$8\n+TEXT runtime\u00b7osyield(SB),7,$100\n \t// Tried NtYieldExecution but it doesn't yield hard enough.\n \t// NtWaitForSingleObject being used here as Sleep(0).\n \t// The CALL is safe because NtXxx is a system call wrapper:\n# GOOS=windows GOARCH=amd64 go test -c\n# testmain\nruntime.needm: nosplit stack overflow\n        120     assumed on entry to runtime.needm\n        88      after runtime.needm uses 32\n        80      on entry to lockextra\n        48      after lockextra uses 32\n        40      on entry to runtime.osyield\n        -60     after runtime.osyield uses 100\nlockextra: nosplit stack overflow\n        120     assumed on entry to lockextra\n        88      after lockextra uses 32\n        80      on entry to runtime.osyield\n        -20     after runtime.osyield uses 100\n#\n\nSo, assuming runtime\u00b7osyield call requires 100 bytes of stack, the compiler says we are 60 bytes short. So, very little room.\n\n> ... I\n> tried adding a random amount to the last argument of TEXT, but it made\n> the crashiness worse.\n> \n\nSure, you increased runtime\u00b7osyield stack size. More chance for it to blow away someone elses data.\n\nWe could switch onto OS thread here, but standard switching code takes more stack room than we have here. And as far as I remember it uses functions that split stack (once you are in no-split-stack world, you have to stay that way). Perhaps we can write some custom asm code to do it, but my asm is not good. :-)\n\nYou could just try and do nothing in osyield. Just return from there. You might discover that runtime will start hogging cpu, but.\n\nI really don't know what to do. Perhaps Russ will help.\n\nAlex",
			"disapproval": false,
			"date": "2013-07-04 06:49:39.127820",
			"approval": false
		},
		{
			"sender": "hanwen@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jul 3, 2013 at 11:15 AM,  <alex.brainman@gmail.com> wrote:\r\n>> so i think the cause might be that NtWaitForSingleObject requires more\r\n>> stack than\r\n>> available, so it overflows the goroutine stack and causes memory\r\n>\r\n> corruption.\r\n>\r\n> That could well be a problem too. But, then it could be happening on\r\n> Windows too (not just on wine). :-( But I haven't heard anyone complain\r\n> yet. If that is the case, we should go back to switching stacks.\r\n\r\nWouldn't NtWaitForSingleObject execute in the windows kernel address\r\nspace, and hence have a different memory layout, with likely more\r\nstack available?\r\n\r\n--\r\nHan-Wen Nienhuys\r\nGoogle Munich\r\nhanwen@google.com\r\n",
			"disapproval": false,
			"date": "2013-07-03 09:25:12.185030",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"hanwen@google.com",
				"minux.ma@gmail.com",
				"alex.brainman@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/07/03 09:08:04, minux wrote:\n> \n> so i think the cause might be that NtWaitForSingleObject requires more\n> stack than\n> available, so it overflows the goroutine stack and causes memory corruption.\n\nThat could well be a problem too. But, then it could be happening on Windows too (not just on wine). :-( But I haven't heard anyone complain yet. If that is the case, we should go back to switching stacks.\n\nAlex",
			"disapproval": false,
			"date": "2013-07-03 09:15:08.470580",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jul 3, 2013 at 8:38 PM, <alex.brainman@gmail.com> wrote:\r\n\r\n> Sure, we could try. It might even work for Windows, then we can use it\r\n\r\neverywhere. There is also similar function runtime.usleep that is in the\r\n>\r\nas discussed on the issue tracker,\r\nhttps://code.google.com/p/go/issues/detail?id=4955,\r\nNtYieldExecution is not good enough for normal windows use, so i'm afraid\r\nwe have to detect wine and only let wine use that call path.\r\n\r\n> same boat. You didn't have problem with runtime.usleep?\r\n>\r\nyes, i'd expect runtime.usleep will cause the same problem on wine.\r\n\r\nthe major uses of runtime.usleep are from GC, parfor (also used by GC) and\r\nsysmon, and cgo callback in proc.c.\r\n\r\nsysmon always runs on its own M, so nothing to worry about.\r\n\r\nas the GC is now happening on g0 (OS thread stack), so i'd expect a lot of\r\ncalls\r\nto usleep will actually be made from OS stack already, and it might explain\r\nwhy it\r\ndoesn't surface.\r\n\r\nanother use of runtime.usleep is in external cgo callback path.\r\n@hanwen, have you tried to run misc/cgo/test inside wine? it might expose\r\nother problems (you won't be able to cross compile that test, so you will\r\nhave\r\nto build it from a windows machine).\r\n",
			"disapproval": false,
			"date": "2013-07-03 12:53:27.395540",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"hanwen@google.com",
				"minux.ma@gmail.com",
				"alex.brainman@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/07/03 09:29:53, hanwen wrote:\n> According to the wine FAQ we can look for wine_get_version in ntdll.\n> If it's there, we're on Wine.\n\nThat should be doable.\n\n> How would I go about implementing a different call path? ...\n\nLike I said before, switching stacks might not be an option here. :-(\n\nAlex",
			"disapproval": false,
			"date": "2013-07-03 11:45:14.959150",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jul 3, 2013 at 4:14 PM, <hanwen@google.com> wrote:\r\n\r\n> On 2013/03/07 14:18:52, rsc wrote:\r\n>\r\n>> *** Submitted as\r\n>>\r\n> https://code.google.com/p/go/**source/detail?r=f800157ce425<https://code.google.com/p/go/source/detail?r=f800157ce425>***\r\n>\r\n>  runtime: fix cgo callbacks on windows\r\n>>\r\n>\r\n>  Fixes issue 4955.\r\n>>\r\n>\r\n>  R=golang-dev, alex.brainman\r\n>> CC=golang-dev\r\n>> https://codereview.appspot.**com/7563043<https://codereview.appspot.com/7563043>\r\n>>\r\n>\r\n> It looks like the change to yield causes breakage when running under\r\n> wine (see https://code.google.com/p/go/**issues/detail?id=5831<https://code.google.com/p/go/issues/detail?id=5831>\r\n> ).\r\n>\r\n> Wine does the windows emulation in user space, so some of the assumption\r\n> made here may not hold?\r\n>\r\nyes, very possible.\r\nwindows abi mandates 4 uintptr space below sp, and in fact we did have a cgo\r\nbug in the past that resulted from violating this.\r\n\r\nif we need to support where NtWaitForSingleObject is implemented in user\r\nspace,\r\ni'm afraid we have to resort to using normal cgocall/stdcall mechanism to\r\ncall it and\r\nthus incur big overhead for real windows machines.\r\n\r\nif we want to fix this problem, perhaps we'd better detect wine and use\r\nalternative\r\ncall paths.\r\n\r\n>\r\n> http://blogs.msdn.com/b/**oldnewthing/archive/2004/01/**14/58579.aspx<http://blogs.msdn.com/b/oldnewthing/archive/2004/01/14/58579.aspx>\r\n> mentions that there should be space on the stack reserved for register\r\n> spills. Could that happen when the NT call is implemented in user space?\r\n> How could I test if this is the case?\r\n>\r\n",
			"disapproval": false,
			"date": "2013-07-03 08:28:03.898270",
			"approval": false
		},
		{
			"sender": "hanwen@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "According to the wine FAQ we can look for wine_get_version in ntdll.\r\nIf it's there, we're on Wine.\r\n\r\nHow would I go about implementing a different call path? Check the\r\nwine_get_version address in the asm code, write a C wrapper that calls\r\nto the asm code, or make runtime.osyield be something that can be set\r\nat runtime?\r\n\r\nOn Wed, Jul 3, 2013 at 11:25 AM, minux <minux.ma@gmail.com> wrote:\r\n>\r\n> On Wed, Jul 3, 2013 at 5:10 PM, <alex.brainman@gmail.com> wrote:\r\n>>\r\n>> On 2013/07/03 09:08:04, minux wrote:\r\n>>>\r\n>>> On Wed, Jul 3, 2013 at 4:43 PM, Han-Wen Nienhuys\r\n>>\r\n>> <mailto:hanwen@google.com> wrote:\r\n>>\r\n>>\r\n>>> apply a change like this:\r\n>>> diff -r bb98e4c9b6b3 src/pkg/runtime/sys_windows_386.s\r\n>>\r\n>>\r\n>> This cannot be right. The problem is on windows/amd64 (not windows/386).\r\n>> Isn't it?\r\n>\r\n> i looked at the original bug report\r\n> (https://code.google.com/p/go/issues/detail?id=5831)\r\n> and i was misled by the small pc values...\r\n> yes, it should be a problem of the windows/amd64.\r\n>\r\n> On Wed, Jul 3, 2013 at 5:15 PM, <alex.brainman@gmail.com> wrote:\r\n>>\r\n>> On 2013/07/03 09:08:04, minux wrote:\r\n>>\r\n>>> so i think the cause might be that NtWaitForSingleObject requires more\r\n>>> stack than\r\n>>> available, so it overflows the goroutine stack and causes memory\r\n>>\r\n>> corruption.\r\n>>\r\n>> That could well be a problem too. But, then it could be happening on\r\n>> Windows too (not just on wine). :-( But I haven't heard anyone complain\r\n>> yet. If that is the case, we should go back to switching stacks.\r\n>\r\n> i suspect that is the real cause now given hanwen's experiments.\r\n>\r\n> the reason why it doesn't happen on real windows, is that on real windows\r\n> systems, NtWaitForSingleObject in ntdll.ddl is just a syscall (the real\r\n> syscall in\r\n> the sense of int 0x2E/sysenter) wrapper, so it won't use arbitrary user\r\n> space\r\n> stack space. (in fact, as Russ checks in the code, it requires precisely 4\r\n> bytes\r\n> of stack on i386 and no extra stack on amd64)\r\n>\r\n> wine implements ntdll.dll in user space, so it can use arbitrary amount of\r\n> user space stack space, so if we want to support wine, either we\r\n> switch stacks and accept the overhead,\r\n> or use different call path for wine.\r\n\r\n\r\n\r\n-- \r\nHan-Wen Nienhuys\r\nGoogle Munich\r\nhanwen@google.com\r\n",
			"disapproval": false,
			"date": "2013-07-03 09:29:53.707930",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"rsc@golang.org",
				"hanwen@google.com",
				"minux.ma@gmail.com",
				"alex.brainman@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/07/03 08:14:11, hanwen wrote:\n> \n> Wine does the windows emulation in user space, so some of the assumption made\n> here may not hold?  \n\nIt is possible. The api we use is undocumented / non-official.\n\n> http://blogs.msdn.com/b/oldnewthing/archive/2004/01/14/58579.aspx mentions that\n> there should be space on the stack reserved for register spills. Could that\n> happen when the NT call is implemented in user space? How could I test if this\n> is the case?\n\nJust change asm to leave room for 4 registers. You might discover that you won't be able to do that (linker will complain) because this function is marked as \"no split stack\". You might run out of stack.\n\nAlex\n\nPS: I am not convinced your problem is in this function. Your test has a few questions. But lets test your theory first.",
			"disapproval": false,
			"date": "2013-07-03 08:46:16.365630",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jul 3, 2013 at 8:26 PM, Han-Wen Nienhuys <hanwen@google.com> wrote:\r\n>\r\n> How big is 'not very large' in this context? WaitForSingleObject\r\n>\r\ni'd say a few uintptrs. because the linker will check that any chain of\r\nnon-split stack\r\ncalls will use at most 120 bytes of stack.\r\n\r\n> doesn't look too good,\r\n>\r\n>  http://source.winehq.org/source/dlls/ntdll/sync.c#L1090\r\n>\r\n> it has an array of 64 int32s for starters, to store local handles.\r\n>\r\nok, then it's a non-starter.\r\n\r\n>\r\n> However, the point is to finally yield the CPU, right? at the bottom,\r\n> it calls NtSchedYield, which is an alias for sched_yield(2), see\r\n>\r\n>  http://source.winehq.org/source/dlls/ntdll/sync.c#L1191\r\n>\r\n> could we conditionally call NtSchedYield instead?\r\n>\r\ncalling NtSchedYield on normal windows doesn't yield hard enough,\r\nbut i think it's good enough for wine.\r\n\r\nhave you changed experimented with replacing NtWaitForSingleObject with\r\nNtSchedYield in runtime.osyield? does it run well on wine?\r\n",
			"disapproval": false,
			"date": "2013-07-03 12:35:53.329530",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Jul 3, 2013 at 4:43 PM, Han-Wen Nienhuys <hanwen@google.com> wrote:\r\n\r\n> What is the problem with allocating the extra space?\r\n>\r\nwe're calling osyield on segmented goroutine stack, where there might not\r\nbe enough stack\r\nspace for an arbitrary dll functions to run.\r\nso if the NtWaitForSingleObject is implemented as userspace function, we\r\nhave no choice\r\nbut to switch back to the OS stack to call it safely.\r\n\r\n>\r\n> (sorry for the stupid question; I'm not very familiar with either\r\n> windows or the Go runtime.)\r\n\r\napply a change like this:\r\ndiff -r bb98e4c9b6b3 src/pkg/runtime/sys_windows_386.s\r\n--- a/src/pkg/runtime/sys_windows_386.s Tue Jul 02 22:37:19 2013 -0700\r\n+++ b/src/pkg/runtime/sys_windows_386.s Wed Jul 03 16:56:47 2013 +0800\r\n@@ -367,5 +367,5 @@\r\n // (It is just a CALL to the system call dispatch.)\r\n // If the linker okays the call to checkstack4 (a NOSPLIT function)\r\n // then the call to NtWaitForSingleObject is okay too.\r\n-TEXT checkstack4<>(SB),7,$4\r\n+TEXT checkstack4<>(SB),7,$20\r\n  RET\r\n\r\nand see if the linker complains that nonsplit stack overflow, if does\r\ncomplain,\r\nit's very probably this is indeed (or at least, part of) the root cause.\r\nbut if it doesn't complain, it's probably not the root cause (of course, it\r\ndepends on\r\nhow much stack space does the NtWaitForSingleObject call need).\r\n\r\n\r\ni just realized that you found problem on windows/386 port, it seems the\r\nextra register spill area rule doesn't apply to 386 as all arguments are\r\nalways\r\npassed on stack.\r\n\r\nso i think the cause might be that NtWaitForSingleObject requires more\r\nstack than\r\navailable, so it overflows the goroutine stack and causes memory corruption.\r\nif my hypothesis is correct, i think we have to detect wine and use\r\ndifferent call path\r\non wine.\r\n",
			"disapproval": false,
			"date": "2013-07-03 09:08:04.011900",
			"approval": false
		}
	],
	"owner_email": "rsc@golang.org",
	"private": false,
	"base_url": "",
	"owner": "rsc",
	"subject": "code review 7563043: runtime: fix cgo callbacks on windows/386",
	"created": "2013-03-07 04:11:30.410010",
	"patchsets": [
		1,
		2001,
		5001,
		8001,
		9001,
		13001,
		18001
	],
	"modified": "2013-07-11 20:14:12.536280",
	"closed": true,
	"issue": 7563043
}