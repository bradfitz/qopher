{
	"description": "exp/ssa: build fully pruned SSA form.\n\nOverview: Function.finish() now invokes the \"lifting\" pass which replaces local allocs and loads and stores to such cells by SSA registers.  We use very standard machinery:\n\n(1) we build the dominator tree for the function's control flow graph (CFG) using the \"Simple\" Lengauer-Tarjan algorithm.  (Very \"simple\" in fact: even simple path compression is not yet implemented.)\n\nIn sanity-checking mode, we cross check the dominator tree against an alternative implementation using a simple iterative dataflow algorithm.\nThis all lives in dom.go, along with some diagnostic printing routines.\n\n(2) we build the dominance frontier for the entire CFG using the Cytron et al algorithm.  The DF is represented as a slice of slices, keyed by block index.  See buildDomFrontier() in lift.go.\n\n(3) we determine for each Alloc whether it can be lifted: is it only subject to loads and stores?  If so, we traverse the iterated dominance frontier (IDF) creating \u03c6-nodes; they are not prepended to the blocks yet. \nSee liftAlloc() in lift.go.\n\n(4) we perform the SSA renaming algorithm from Cytron et al, replacing all loads to lifted Alloc cells by the value stored by the dominating store operation, and deleting the stores and allocs.  See rename() in lift.go.\n\n(5) we eliminate unneeded \u03c6-nodes, then concatenate the remaining ones with the non-deleted instructions of the block into a new slice.  We eliminate any lifted allocs from Function.Locals.\n\nTo ease reviewing, I have avoided almost all optimisations at this point, though there are many opportunities to explore.  These will be easier to understand as follow-up changes.\n\nAll the existing tests (pending CL 7313062) pass.  (Faster!)\n\nDetails:\n\n\"NaiveForm\" BuilderMode flag suppresses all the new logic.\nExposed as 'ssadump -build=N'.\n\nBasicBlock:\n- add .Index field (b.Func[b.Index]==b), simplifying\n  algorithms such as Kildall-style dataflow with bitvectors.\n- rename the Name field to Comment to better reflect its\n  reduced purpose.  It now has a String() method.\n- 'dom' field holds dominator tree node; private for now.\n- new predIndex method.\n- hasPhi is now a method\n\ndom.go:\n- domTree: a new struct for a node in a dominator tree.\n- buildDomTree builds the dominator tree using the simple\n  variant Lengauer/Tarjan algorithm with Georgiadis'\n  bucket optimizations.\n- sanityCheckDomTree builds dominance relation using\n  Kildall-style dataflow and ensures the same result is\n  obtained.\n- printDomTreeDot prints the CFG/DomTree in GraphViz format.\n\nblockopt.go:\n- perform a mark/sweep pass to eliminate unreachable\n  cycles; the previous prune() opt would only eliminate\n  trivially dead blocks.  (Needed for LT algo.)\n- using .Index, fuseblocks can now delete fused blocks directly.\n- delete prune().\n\nsanity.go: more consistency checks:\n- Phi with missing edge value\n- local Alloc instructions must appear in Function.Locals.\n- BasicBlock.Index, Func consistency\n- CFG edges are all intraprocedural.\n- detect nils in BasicBlock.Instrs.\n- detect Function.Locals with Heap flag set.\n- check fn.Blocks is nil if empty.\n\nAlso:\n- Phi now has Comment field for debugging.\n- Fixed bug in Select.Operands()\n  (took address of temporary copy of field)\n- new Literal constructor zeroLiteral().\n- algorithms steal private fields Alloc.index,\n  BasicBlock.gaps to avoid allocating maps.\n- We print Function.Locals in DumpTo.\n- added profiling support to ssadump.",
	"cc": [
		"iant@golang.org",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"gri@golang.org"
	],
	"messages": [
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 21 February 2013 11:48, <gri@golang.org> wrote:\r\n\r\n>  > btw. , wouldn't used/unused be better than black/white?\r\n>>\r\n>\r\n>  Black/white marking is pretty standard in the literature of both graph\r\n>>\r\n> theory\r\n>\r\n>> and of GC.  I also find it easier to visualise algorithms expressed\r\n>>\r\n> this way.\r\n>\r\n> Sure. But theory is often not easier to understand for the uninvited\r\n> (i.e., not you, but a casual reader). So if you call it used/unused, the\r\n> algorithm becomes immediately clear, while if you call it black/white,\r\n> the reader has to be either familiar with the specific literature, or do\r\n> another mental mapping in his/her head. It's not like this is a very\r\n> complex function that cannot be understood anyway, w/o full knowledge of\r\n> the literature (in that case, I agree that sticking to the same name as\r\n> some documented algorithm in literature is using is better).\r\n>\r\n\r\nOk.  Will change when I'm next in that file.\r\n",
			"disapproval": false,
			"date": "2013-02-21 17:25:14.274140",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"adonovan@google.com",
				"iant@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nI have not studied the large algorithm sections. Overall the code looks pretty clean.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go\nFile src/pkg/exp/ssa/blockopt.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode18\nsrc/pkg/exp/ssa/blockopt.go:18: // markReachable set Index=-1 for all blocks reachable from b.\ns/set/sets/\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode31\nsrc/pkg/exp/ssa/blockopt.go:31: func collectUnreachable(f *Function) {\ns/collectUnreachable/eliminateUnreachable/\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode32\nsrc/pkg/exp/ssa/blockopt.go:32: // We use b.Index as the mark bit: 0 means white, -1 means black.\nperhaps\n\nconst white = 0\nconst black = -1\n\nwhy use comments when you can express it in code\n\nbtw. , wouldn't used/unused be better than black/white?\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode51\nsrc/pkg/exp/ssa/blockopt.go:51: for i, b := range f.Blocks {\nany reason for not compressing f.Blocks now? (remove the nil entries) You're doing most of the work anyway. It's fine if you still want to be able to deal with nil entries elsewhere.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode102\nsrc/pkg/exp/ssa/blockopt.go:102: f.Blocks[b.Index] = nil // delete b\nmake deleteBlock a method of f? - Then you don't need the comment.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode136\nsrc/pkg/exp/ssa/blockopt.go:136: f.Blocks[b.Index] = nil // delete b\ndito\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode146\nsrc/pkg/exp/ssa/blockopt.go:146: collectUnreachable(f)\nbetter name and you don't need the comment\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode178\nsrc/pkg/exp/ssa/blockopt.go:178: // Eliminate nils from Blocks and update Index.\nThe re-indexing and elimination of nil entries happens again here. Definitively should be factored out.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/doc.go\nFile src/pkg/exp/ssa/doc.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/doc.go#newcode37\nsrc/pkg/exp/ssa/doc.go:37: // called \"lifting\", to improve the accuracy and performance of\nthe comma here seems odd to me. remove and replace ; on text line with period?\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go\nFile src/pkg/exp/ssa/dom.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go#newcode11\nsrc/pkg/exp/ssa/dom.go:11: // We also apply the optimisations to SLT described in Georgiadis et\noptimizations ?\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go#newcode26\nsrc/pkg/exp/ssa/dom.go:26: type domTree struct {\nwhy not domNode ?\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go#newcode228\nsrc/pkg/exp/ssa/dom.go:228: for changed {\nfor changed := true; changed; {\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go#newcode262\nsrc/pkg/exp/ssa/dom.go:262: panic(\"sanityCheckDomTree failed for \" + f.FullName())\nanother use for panicf\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go#newcode276\nsrc/pkg/exp/ssa/dom.go:276: // printDomTreeDot prints the dominator tree of f in AT&T GraphViz format.\nwow, really? why not dot format? how much is it different?\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/func.go\nFile src/pkg/exp/ssa/func.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/func.go#newcode44\nsrc/pkg/exp/ssa/func.go:44: panic(fmt.Sprintf(\"no edge %s -> %s\", c, b))\nif you have more of these (seems useful), consider defining panicf.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/func.go#newcode241\nsrc/pkg/exp/ssa/func.go:241: // (value-defining Instructions) in f, to aid deubgging.\ndebugging\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/func.go#newcode546\nsrc/pkg/exp/ssa/func.go:546: // emit.  comment is an optional string to improve readability.\ns/to improve readability/for more readable debugging output/.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/lift.go\nFile src/pkg/exp/ssa/lift.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/lift.go#newcode151\nsrc/pkg/exp/ssa/lift.go:151: // During this pass we will replace deleted some\nreplace deleted some ... ? (sentence)\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/lift.go#newcode256\nsrc/pkg/exp/ssa/lift.go:256: // take removes an arbitrary element from a set s and\nthe algorithm doesn't remove an arbitrary element, though\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/lift.go#newcode399\nsrc/pkg/exp/ssa/lift.go:399: // constructing  it lazily if it's the implicit zero initialization.\ndouble blank\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/sanity.go\nFile src/pkg/exp/ssa/sanity.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/sanity.go#newcode301\nsrc/pkg/exp/ssa/sanity.go:301: // they were \"optimised\" away, even the entry block.\noptimized ?",
			"disapproval": false,
			"date": "2013-02-21 06:35:05.208620",
			"approval": true
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"iant@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=95914f6d6c36 ***\n\nexp/ssa: build fully pruned SSA form.\n\nOverview: Function.finish() now invokes the \"lifting\" pass which replaces local allocs and loads and stores to such cells by SSA registers.  We use very standard machinery:\n\n(1) we build the dominator tree for the function's control flow graph (CFG) using the \"Simple\" Lengauer-Tarjan algorithm.  (Very \"simple\" in fact: even simple path compression is not yet implemented.)\n\nIn sanity-checking mode, we cross check the dominator tree against an alternative implementation using a simple iterative dataflow algorithm.\nThis all lives in dom.go, along with some diagnostic printing routines.\n\n(2) we build the dominance frontier for the entire CFG using the Cytron et al algorithm.  The DF is represented as a slice of slices, keyed by block index.  See buildDomFrontier() in lift.go.\n\n(3) we determine for each Alloc whether it can be lifted: is it only subject to loads and stores?  If so, we traverse the iterated dominance frontier (IDF) creating \u03c6-nodes; they are not prepended to the blocks yet. \nSee liftAlloc() in lift.go.\n\n(4) we perform the SSA renaming algorithm from Cytron et al, replacing all loads to lifted Alloc cells by the value stored by the dominating store operation, and deleting the stores and allocs.  See rename() in lift.go.\n\n(5) we eliminate unneeded \u03c6-nodes, then concatenate the remaining ones with the non-deleted instructions of the block into a new slice.  We eliminate any lifted allocs from Function.Locals.\n\nTo ease reviewing, I have avoided almost all optimisations at this point, though there are many opportunities to explore.  These will be easier to understand as follow-up changes.\n\nAll the existing tests (pending CL 7313062) pass.  (Faster!)\n\nDetails:\n\n\"NaiveForm\" BuilderMode flag suppresses all the new logic.\nExposed as 'ssadump -build=N'.\n\nBasicBlock:\n- add .Index field (b.Func[b.Index]==b), simplifying\n  algorithms such as Kildall-style dataflow with bitvectors.\n- rename the Name field to Comment to better reflect its\n  reduced purpose.  It now has a String() method.\n- 'dom' field holds dominator tree node; private for now.\n- new predIndex method.\n- hasPhi is now a method\n\ndom.go:\n- domTree: a new struct for a node in a dominator tree.\n- buildDomTree builds the dominator tree using the simple\n  variant Lengauer/Tarjan algorithm with Georgiadis'\n  bucket optimizations.\n- sanityCheckDomTree builds dominance relation using\n  Kildall-style dataflow and ensures the same result is\n  obtained.\n- printDomTreeDot prints the CFG/DomTree in GraphViz format.\n\nblockopt.go:\n- perform a mark/sweep pass to eliminate unreachable\n  cycles; the previous prune() opt would only eliminate\n  trivially dead blocks.  (Needed for LT algo.)\n- using .Index, fuseblocks can now delete fused blocks directly.\n- delete prune().\n\nsanity.go: more consistency checks:\n- Phi with missing edge value\n- local Alloc instructions must appear in Function.Locals.\n- BasicBlock.Index, Func consistency\n- CFG edges are all intraprocedural.\n- detect nils in BasicBlock.Instrs.\n- detect Function.Locals with Heap flag set.\n- check fn.Blocks is nil if empty.\n\nAlso:\n- Phi now has Comment field for debugging.\n- Fixed bug in Select.Operands()\n  (took address of temporary copy of field)\n- new Literal constructor zeroLiteral().\n- algorithms steal private fields Alloc.index,\n  BasicBlock.gaps to avoid allocating maps.\n- We print Function.Locals in DumpTo.\n- added profiling support to ssadump.\n\nR=iant, gri\nCC=golang-dev\nhttps://codereview.appspot.com/7229074",
			"disapproval": false,
			"date": "2013-02-21 16:12:03.277520",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"iant@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello iant@golang.org, gri@golang.org (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2013-02-20 21:39:17.848640",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"adonovan@google.com",
				"gri@golang.org",
				"iant@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Just FYI.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go\nFile src/pkg/exp/ssa/blockopt.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode31\nsrc/pkg/exp/ssa/blockopt.go:31: func collectUnreachable(f *Function) {\nOn 2013/02/21 16:03:59, adonovan wrote:\n> On 2013/02/21 06:35:05, gri wrote:\n> > s/collectUnreachable/eliminateUnreachable/\n> \n> Done (actually \"deleteUnreachableBlocks\").\n> \n> (\"Collect\" was intended in the spirit of \"collect garbage\", but I see the\n> confusion when I think of methods like types.collectFields, etc.)\n\nExcept that in GC, unused blocks are actually collected and returned to the pool of free memory. Here nothing is collected and returned.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode32\nsrc/pkg/exp/ssa/blockopt.go:32: // We use b.Index as the mark bit: 0 means white, -1 means black.\nOn 2013/02/21 16:03:59, adonovan wrote:\n> On 2013/02/21 06:35:05, gri wrote:\n> > perhaps\n> > \n> > const white = 0\n> > const black = -1\n> > \n> > why use comments when you can express it in code\n> \n> Done.\n> \n> > btw. , wouldn't used/unused be better than black/white?\n> \n> Black/white marking is pretty standard in the literature of both graph theory\n> and of GC.  I also find it easier to visualise algorithms expressed this way.\n\nSure. But theory is often not easier to understand for the uninvited (i.e., not you, but a casual reader). So if you call it used/unused, the algorithm becomes immediately clear, while if you call it black/white, the reader has to be either familiar with the specific literature, or do another mental mapping in his/her head. It's not like this is a very complex function that cannot be understood anyway, w/o full knowledge of the literature (in that case, I agree that sticking to the same name as some documented algorithm in literature is using is better).",
			"disapproval": false,
			"date": "2013-02-21 16:48:09.269950",
			"approval": false
		},
		{
			"sender": "adonovan@google.com",
			"recipients": [
				"adonovan@google.com",
				"iant@golang.org",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go\nFile src/pkg/exp/ssa/blockopt.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode18\nsrc/pkg/exp/ssa/blockopt.go:18: // markReachable set Index=-1 for all blocks reachable from b.\nOn 2013/02/21 06:35:05, gri wrote:\n> s/set/sets/\n\nDone.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode31\nsrc/pkg/exp/ssa/blockopt.go:31: func collectUnreachable(f *Function) {\nOn 2013/02/21 06:35:05, gri wrote:\n> s/collectUnreachable/eliminateUnreachable/\n\nDone (actually \"deleteUnreachableBlocks\").\n\n(\"Collect\" was intended in the spirit of \"collect garbage\", but I see the confusion when I think of methods like types.collectFields, etc.)\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode32\nsrc/pkg/exp/ssa/blockopt.go:32: // We use b.Index as the mark bit: 0 means white, -1 means black.\nOn 2013/02/21 06:35:05, gri wrote:\n> perhaps\n> \n> const white = 0\n> const black = -1\n> \n> why use comments when you can express it in code\n\nDone.\n\n> btw. , wouldn't used/unused be better than black/white?\n\nBlack/white marking is pretty standard in the literature of both graph theory and of GC.  I also find it easier to visualise algorithms expressed this way.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode51\nsrc/pkg/exp/ssa/blockopt.go:51: for i, b := range f.Blocks {\nOn 2013/02/21 06:35:05, gri wrote:\n> any reason for not compressing f.Blocks now? (remove the nil entries) You're\n> doing most of the work anyway. It's fine if you still want to be able to deal\n> with nil entries elsewhere.\n\nDone; factored into Function.removeNilBlocks.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode102\nsrc/pkg/exp/ssa/blockopt.go:102: f.Blocks[b.Index] = nil // delete b\nOn 2013/02/21 06:35:05, gri wrote:\n> make deleteBlock a method of f? - Then you don't need the comment.\n\nI'd rather not, since (a) it would hide what's going on (introduction of nils, which demands a subsequent call to removeNilBlocks) and (b) a deleteBlock function would have to take a block index, not a *BasicBlock, to be safe to call from within deleteUnreachableBlocks where the Index numbers have been repurposed.  That seems like a confusing interface.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode136\nsrc/pkg/exp/ssa/blockopt.go:136: f.Blocks[b.Index] = nil // delete b\nOn 2013/02/21 06:35:05, gri wrote:\n> dito\n\nDitto.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode146\nsrc/pkg/exp/ssa/blockopt.go:146: collectUnreachable(f)\nOn 2013/02/21 06:35:05, gri wrote:\n> better name and you don't need the comment\n\nDone: \"deleteUnreachableBlocks\".\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/blockopt.go#newcode178\nsrc/pkg/exp/ssa/blockopt.go:178: // Eliminate nils from Blocks and update Index.\nOn 2013/02/21 06:35:05, gri wrote:\n> The re-indexing and elimination of nil entries happens again here. Definitively\n> should be factored out.\n\nDone.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/doc.go\nFile src/pkg/exp/ssa/doc.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/doc.go#newcode37\nsrc/pkg/exp/ssa/doc.go:37: // called \"lifting\", to improve the accuracy and performance of\nOn 2013/02/21 06:35:05, gri wrote:\n> the comma here seems odd to me. remove and replace ; on text line with period?\n\nDone.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go\nFile src/pkg/exp/ssa/dom.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go#newcode11\nsrc/pkg/exp/ssa/dom.go:11: // We also apply the optimisations to SLT described in Georgiadis et\nOn 2013/02/21 06:35:05, gri wrote:\n> optimizations ?\n\nDone, globally.   Though I'm sure there are more Commonwealth than US speakers on the team. :)\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go#newcode26\nsrc/pkg/exp/ssa/dom.go:26: type domTree struct {\nOn 2013/02/21 06:35:05, gri wrote:\n> why not domNode ?\n\nA node is a tree. :)\n\nBut I vacillated.  It's back to domNode again.  It does seem better.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go#newcode228\nsrc/pkg/exp/ssa/dom.go:228: for changed {\nOn 2013/02/21 06:35:05, gri wrote:\n> for changed := true; changed; {\n\nDone.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go#newcode262\nsrc/pkg/exp/ssa/dom.go:262: panic(\"sanityCheckDomTree failed for \" + f.FullName())\nOn 2013/02/21 06:35:05, gri wrote:\n> another use for panicf\n\nAck.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/dom.go#newcode276\nsrc/pkg/exp/ssa/dom.go:276: // printDomTreeDot prints the dominator tree of f in AT&T GraphViz format.\nOn 2013/02/21 06:35:05, gri wrote:\n> wow, really? why not dot format? how much is it different?\n\nIt's the same format, except \"dot\" is less helpful than \"AT&T GraphViz\" as a search term for someone seeing this for the first time.\n\n(Strictly, 'dot' is the name of the tool that renders GraphViz files using the Sugiyama algorithm; there are other tools and algos.)\n\nChanged to \"in AT&T GraphViz (.dot) format\".\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/func.go\nFile src/pkg/exp/ssa/func.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/func.go#newcode44\nsrc/pkg/exp/ssa/func.go:44: panic(fmt.Sprintf(\"no edge %s -> %s\", c, b))\nOn 2013/02/21 06:35:05, gri wrote:\n> if you have more of these (seems useful), consider defining panicf.\n\npanic has different control flow implications than an ordinary function call.  It would be inconvenient to write:\n\n  panicf(\"%s, world\", \"goodbye\")\n  panic(\"no, I really mean it\")\n\neach time I want to abort at the end of a nonvoid function.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/func.go#newcode241\nsrc/pkg/exp/ssa/func.go:241: // (value-defining Instructions) in f, to aid deubgging.\nOn 2013/02/21 06:35:05, gri wrote:\n> debugging\n\nDone.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/func.go#newcode546\nsrc/pkg/exp/ssa/func.go:546: // emit.  comment is an optional string to improve readability.\nOn 2013/02/21 06:35:05, gri wrote:\n> s/to improve readability/for more readable debugging output/.\n\nDone.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/lift.go\nFile src/pkg/exp/ssa/lift.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/lift.go#newcode151\nsrc/pkg/exp/ssa/lift.go:151: // During this pass we will replace deleted some\nOn 2013/02/21 06:35:05, gri wrote:\n> replace deleted some ... ? (sentence)\n\nDone.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/lift.go#newcode256\nsrc/pkg/exp/ssa/lift.go:256: // take removes an arbitrary element from a set s and\nOn 2013/02/21 06:35:05, gri wrote:\n> the algorithm doesn't remove an arbitrary element, though\n\nNo, but since that's all I need from it, that's all I specified in the contract.\n\n\"Arbitrary\" != \"random\", only \"unspecified\".\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/lift.go#newcode399\nsrc/pkg/exp/ssa/lift.go:399: // constructing  it lazily if it's the implicit zero initialization.\nOn 2013/02/21 06:35:05, gri wrote:\n> double blank\n\nDone.\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/sanity.go\nFile src/pkg/exp/ssa/sanity.go (right):\n\nhttps://codereview.appspot.com/7229074/diff/11002/src/pkg/exp/ssa/sanity.go#newcode301\nsrc/pkg/exp/ssa/sanity.go:301: // they were \"optimised\" away, even the entry block.\nOn 2013/02/21 06:35:05, gri wrote:\n> optimized ?\n\nDone.",
			"disapproval": false,
			"date": "2013-02-21 16:03:59.180320",
			"approval": false
		}
	],
	"owner_email": "adonovan@google.com",
	"private": false,
	"base_url": "",
	"owner": "adonovan",
	"subject": "code review 7229074: exp/ssa: build fully pruned SSA form.",
	"created": "2013-02-01 23:20:52.883130",
	"patchsets": [
		1,
		2001,
		5001,
		7001,
		14002,
		11002,
		36001,
		7014
	],
	"modified": "2013-02-21 16:48:09.417870",
	"closed": true,
	"issue": 7229074
}