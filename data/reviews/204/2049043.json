{
	"description": "os/inotify: new package\n\nThis patch adds a new package: os/inotify, which\nprovides a Go wrapper to the Linux inotify system.",
	"cc": [
		"rsc@golang.org",
		"fullung@gmail.com",
		"rogpeppe@gmail.com",
		"jacek.masiulaniec@gmail.com",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "rsc@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Let's do this review in two steps.\n\nCould you drop the os files from this CL, \nso that it's just the syscall changes?\n\nAlso, I have cleaned up some hand-editing\ndrift in the syscall directory, so you will \nneed to sync and rebuild the z files.\nPlease do so on a standard Ubuntu Lucid box.\nThanks.",
			"disapproval": false,
			"date": "2010-09-24 19:39:07.006986",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change.",
			"disapproval": false,
			"date": "2010-09-23 11:52:54.464843",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2010/09/24 19:39:07, rsc1 wrote:\n> Let's do this review in two steps.\n> \n> Could you drop the os files from this CL, \n> so that it's just the syscall changes?\n> \n> Also, I have cleaned up some hand-editing\n> drift in the syscall directory, so you will \n> need to sync and rebuild the z files.\n> Please do so on a standard Ubuntu Lucid box.\n> Thanks.\n\nI've moved the syscall changes into a separate CL:\nhttp://codereview.appspot.com/2241045\nAlso synced and regenerated.\n\nThanks,\nBalazs",
			"disapproval": false,
			"date": "2010-09-27 12:32:14.046450",
			"approval": false
		},
		{
			"sender": "fullung@gmail.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/18001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/18001/src/pkg/os/inotify/inotify_linux.go#newcode77\nsrc/pkg/os/inotify/inotify_linux.go:77: go in.readEvents()\nHello all\n\nI'm not sure what the current thinking is, but should API-type code be spawning goroutines?\n\nMaybe the choice to call in.readEvents() should be left to the user of the API. Some users might spawn goroutines, but others might want to write some kind of loop that is part of a larger function executed by a goroutine.\n\nJust a thought.\n\nCheers\n\nAlbert",
			"disapproval": false,
			"date": "2010-09-29 15:04:40.432603",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/18001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/18001/src/pkg/os/inotify/inotify_linux.go#newcode77\nsrc/pkg/os/inotify/inotify_linux.go:77: go in.readEvents()\nOn 2010/09/29 15:04:40, albert.strasheim wrote:\n> Hello all\n> \n> I'm not sure what the current thinking is, but should API-type code be spawning\n> goroutines?\n\nI think it's correct and idiomatic to do this.\nRun\n$ hg grep 'go .*\\(' | grep ^src/pkg | less\nto see a list of examples.\n\n> \n> Maybe the choice to call in.readEvents() should be left to the user of the API.\n\nMy idea was to make the API straightforward to use and only expose what's really necessary for the user.\nDo you have a concrete recommendation how to expose readEvents()?\n\n> Some users might spawn goroutines, but others might want to write some kind of\n> loop that is part of a larger function executed by a goroutine.\n> \n> Just a thought.\n> \n> Cheers\n> \n> Albert",
			"disapproval": false,
			"date": "2010-09-29 15:26:30.745148",
			"approval": false
		},
		{
			"sender": "fullung@gmail.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello all\n\nOn 2010/09/23 11:52:54, leczb wrote:\n> Hello mailto:golang-dev@googlegroups.com (cc: mailto:golang-dev@googlegroups.com),\n> \n> I'd like you to review this change.\n\nI tried the following:\n\nwatcher, err := inotify.New()\nwatcher.Close()\nwatcher.Close()\n\nThe second Close hangs, which isn't what I would expect.\n\nI also tried:\n\nwatcher, err := inotify.New()\nwatcher.Close()\nerr = watcher.Watch(\"/tmp\")\nfmt.Printf(\"%#v\\n\", err)\n\nerr comes back as nil. I would expect EBADF instead?\n\nRegards\n\nAlbert",
			"disapproval": false,
			"date": "2010-09-30 14:52:37.905744",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2010/09/30 14:52:37, albert.strasheim wrote:\n> Hello all\n> \n> On 2010/09/23 11:52:54, leczb wrote:\n> > Hello mailto:golang-dev@googlegroups.com (cc:\n> mailto:golang-dev@googlegroups.com),\n> > \n> > I'd like you to review this change.\n> \n> I tried the following:\n> \n> watcher, err := inotify.New()\n> watcher.Close()\n> watcher.Close()\n> \n> The second Close hangs, which isn't what I would expect.\n> \n> I also tried:\n> \n> watcher, err := inotify.New()\n> watcher.Close()\n> err = watcher.Watch(\"/tmp\")\n> fmt.Printf(\"%#v\\n\", err)\n> \n> err comes back as nil. I would expect EBADF instead?\n> \n> Regards\n> \n> Albert\n\nThanks for testing it. I'll look into it.\n\nBal\u00e1zs",
			"disapproval": false,
			"date": "2010-09-30 14:54:58.977280",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2010/09/30 14:54:58, leczb wrote:\n> On 2010/09/30 14:52:37, albert.strasheim wrote:\n> > Hello all\n> > \n> > On 2010/09/23 11:52:54, leczb wrote:\n> > > Hello mailto:golang-dev@googlegroups.com (cc:\n> > mailto:golang-dev@googlegroups.com),\n> > > \n> > > I'd like you to review this change.\n> > \n> > I tried the following:\n> > \n> > watcher, err := inotify.New()\n> > watcher.Close()\n> > watcher.Close()\n> > \n> > The second Close hangs, which isn't what I would expect.\n\nI found the problem and fixed it.\n\n> > \n> > I also tried:\n> > \n> > watcher, err := inotify.New()\n> > watcher.Close()\n> > err = watcher.Watch(\"/tmp\")\n> > fmt.Printf(\"%#v\\n\", err)\n> > \n> > err comes back as nil. I would expect EBADF instead?\n\nI've added a guard that returns an error if the inotify instance is already closed. It won't return EBADF though. It will return \"inotify instance already closed\" instead.\n\nBackground:\nThe file descriptor is closed in readEvents(), which is running as a separate goroutine. You are not supposed to execute the close() syscall on a file descriptor that is in use, so it must be closed in readEvents().\nWhen you call watcher.Close(), it sends a \"done\" message to readEvents(), but it's usually blocking on the read() syscall and only gets the message when read() returns. Then it duly closes the file descriptor and returns. This might take forever, if there are no incoming inotify events.\n\nCheers,\nBal\u00e1zs\n\n> > \n> > Regards\n> > \n> > Albert\n> \n> Thanks for testing it. I'll look into it.\n> \n> Bal\u00e1zs",
			"disapproval": false,
			"date": "2010-09-30 15:57:43.131824",
			"approval": false
		},
		{
			"sender": "fullung@gmail.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hello all\n\nOn 2010/09/30 15:57:43, leczb wrote:\n> Background:\n> The file descriptor is closed in readEvents(), which is running as a separate\n> goroutine. You are not supposed to execute the close() syscall on a file\n> descriptor that is in use, so it must be closed in readEvents().\n> When you call watcher.Close(), it sends a \"done\" message to readEvents(), but\n> it's usually blocking on the read() syscall and only gets the message when\n> read() returns. Then it duly closes the file descriptor and returns. This might\n> take forever, if there are no incoming inotify events.\n\nI'm sure this will happen with this API, as an application probably won't call inotify.New/Close too many times in its life, but I can imagine that with patterns like this, one could introduce slow \"goroutine leaks\"?\n\nThis might be fine for a short-running application, but for a server process that runs for days or months, couldn't this become a problem?\n\nRegards\n\nAlbert",
			"disapproval": false,
			"date": "2010-10-01 05:42:18.075551",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "On Fri, Oct 1, 2010 at 06:42, <fullung@gmail.com> wrote:\n\n> Hello all\n>\n>\n> On 2010/09/30 15:57:43, leczb wrote:\n>\n>> Background:\n>> The file descriptor is closed in readEvents(), which is running as a\n>>\n> separate\n>\n>> goroutine. You are not supposed to execute the close() syscall on a\n>>\n> file\n>\n>> descriptor that is in use, so it must be closed in readEvents().\n>> When you call watcher.Close(), it sends a \"done\" message to\n>>\n> readEvents(), but\n>\n>> it's usually blocking on the read() syscall and only gets the message\n>>\n> when\n>\n>> read() returns. Then it duly closes the file descriptor and returns.\n>>\n> This might\n>\n>> take forever, if there are no incoming inotify events.\n>>\n>\n> I'm sure this will happen with this API, as an application probably\n> won't call inotify.New/Close too many times in its life, but I can\n> imagine that with patterns like this, one could introduce slow\n> \"goroutine leaks\"?\n>\n> This might be fine for a short-running application, but for a server\n> process that runs for days or months, couldn't this become a problem?\n>\n\nIn a long running server, you should only call Close() in the server\ntear-down part, so I wouldn't be worried about this.\nAlso, the Close() call will most probably generate at least one IN_IGNORED\nevent, so the reader goroutine will shut down cleanly.\n\nDo you have alternative suggestions for the design to avoid the possible\n\"goroutine leak\"?\n\n\n> Regards\n>\n> Albert\n>\n>\n> http://codereview.appspot.com/2049043/\n>\n",
			"disapproval": false,
			"date": "2010-10-01 16:04:07.125237",
			"approval": false
		},
		{
			"sender": "fullung@gmail.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/26001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/26001/src/pkg/os/inotify/inotify_linux.go#newcode105\nsrc/pkg/os/inotify/inotify_linux.go:105: println(\"adding watch for \" + path)\nProbably didn't mean to have this println in here.",
			"disapproval": false,
			"date": "2010-10-05 14:35:39.514596",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/26001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/26001/src/pkg/os/inotify/inotify_linux.go#newcode105\nsrc/pkg/os/inotify/inotify_linux.go:105: println(\"adding watch for \" + path)\nOn 2010/10/05 14:35:39, albert.strasheim wrote:\n> Probably didn't mean to have this println in here.\n\nOf course not. Removed it.",
			"disapproval": false,
			"date": "2010-10-05 14:41:10.255539",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Hi Russ,\n\nCould you please take a look at it again?\n\n/leczb\n\nOn 2010/09/24 19:39:07, rsc1 wrote:\n> Let's do this review in two steps.\n> \n> Could you drop the os files from this CL, \n> so that it's just the syscall changes?\n> \n> Also, I have cleaned up some hand-editing\n> drift in the syscall directory, so you will \n> need to sync and rebuild the z files.\n> Please do so on a standard Ubuntu Lucid box.\n> Thanks.",
			"disapproval": false,
			"date": "2010-11-17 11:47:53.884059",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "please change the first line of the cl desc to\n\nos/inotify: new package\n\nThis interface is nice and clean, much more so\nthan I expected from having to wrap a Linux API.\nNice job!\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/Makefile\nFile src/pkg/Makefile (right):\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/Makefile#newcode102\nsrc/pkg/Makefile:102: os/inotify\\\nnot sorted right\nbut also will cause other builds to fail.  instead i would add after this list\n\nifeq ($(GOOS),linux)\nDIRS+=\\\n    os/inotify\\\n\nendif\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode5\nsrc/pkg/os/inotify/inotify_linux.go:5: // This package provides a wrapper for the Linux inotify system\nSee http://golang.org/doc/effective_go.html for more on package comments.\n\nShould be one comment before package inotify, and the example should be intended.\n\n/*\nThis package implements a wrapper for the Linux inotify system.\n\nExample:\n    in, err := inotify.New()\n    if err != nil {\n        log.Exit(err)\n    }\n    in.Watch(\"/tmp\")\n    for {\n        select {\n        case ev := <-in.Event:\n            log.Println(\"event:\", ev)\n        case err := <-in.Error:\n            log.Println(\"error:\", err)\n        }\n    }\n\n*/\npackage inotify\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode57\nsrc/pkg/os/inotify/inotify_linux.go:57: errors   chan os.Error     // Errors are sent on this channel\nanother possibility is to add public fields\n\n    Error <-chan os.Error\n    Event <-chan *Event\n\nto the struct and then delete the getters below.\nthis matches the interface to, say, time.Ticker\nand others.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode65\nsrc/pkg/os/inotify/inotify_linux.go:65: func New() (*Inotify, os.Error) {\nWill there be other types?  If there is a good name\nfor this one, you could rely on the package name\nto provide the \"inotify\" word, like inotify.Watcher\nor whatever.  And then this would be func NewWatcher.\n\nSee effective go for comment format.  Comments\nshould start with the noun they describe.\n\n// New creates and returns a new inotify instance using inotify_init(2).\n\nThe part about the event reader goroutine is an implementation detail\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode83\nsrc/pkg/os/inotify/inotify_linux.go:83: // Close an inotify instance\n// Close closes an inotify instance.\n\nit should return os.Error to match io.Closer\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode99\nsrc/pkg/os/inotify/inotify_linux.go:99: // Add a new watch for path (see inotify_add_watch(2))\n// AddWatch adds path to the watched file set.\n// The flags are interpreted as described in inotify_add_watch(2).\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode123\nsrc/pkg/os/inotify/inotify_linux.go:123: // A convenience wrapper for AddWatch()\n// Watch adds path to the watched file set, watching all events.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode129\nsrc/pkg/os/inotify/inotify_linux.go:129: // Remove a watch (see inotify_rm_watch(2))\n...\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode217\nsrc/pkg/os/inotify/inotify_linux.go:217: // Format the event as a human-readable string\ncan drop this comment, because String() is so common.\nor keep it but fix the phrasing:\n\n// String formats the event e in the form\n// \"filename: 0xEventMask = IN_ACCESS|IN_ATTRIB_|...\"\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode221\nsrc/pkg/os/inotify/inotify_linux.go:221: if e.Mask&IN_ACCESS != 0 {\nthis is aching for a table\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode281\nsrc/pkg/os/inotify/inotify_linux.go:281: return fmt.Sprintf(\"\\\"%s\\\": 0x%x == %s\", e.Name, e.Mask, events[1:])\nuse %q\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode289\nsrc/pkg/os/inotify/inotify_linux.go:289: // Options for AddWatch()\ns/()//\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode290\nsrc/pkg/os/inotify/inotify_linux.go:290: IN_DONT_FOLLOW uint32 = syscall.IN_DONT_FOLLOW\nThe IN_ prefix is not really necessary here but it's fine if you want to keep it.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux_test.go\nFile src/pkg/os/inotify/inotify_linux_test.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux_test.go#newcode13\nsrc/pkg/os/inotify/inotify_linux_test.go:13: func TestInotifyEvents(t *testing.T) {\nDo all recent Linuxes support inotify?\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux_test.go#newcode20\nsrc/pkg/os/inotify/inotify_linux_test.go:20: // Add a watch for \"_obj\"\nDoes it matter if _obj is a network file system?",
			"disapproval": false,
			"date": "2010-12-07 19:19:45.421725",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2010/12/09 17:28:00, rsc1 wrote:\n> LGTM\n\nGreat! Thanks for the thorough and patient review again.\n\nI just ran an \"hg sync\", thus the extra patch version.\n\n/leczb\n\n> \n> Please fix nit below and I will submit\n> \n> http://codereview.appspot.com/2049043/diff/63002/src/pkg/Makefile\n> File src/pkg/Makefile (right):\n> \n> http://codereview.appspot.com/2049043/diff/63002/src/pkg/Makefile#newcode144\n> src/pkg/Makefile:144: DIRS+=\\\n> drop leading spaces before DIRS please\n> (we don't typically indent the bodies of ifeq)",
			"disapproval": false,
			"date": "2010-12-09 17:37:16.341546",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Thanks for the constructive review.\nI've changed the code as suggested, but there are still a couple of questions. Please see them inline.\n\n/leczb\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/Makefile\nFile src/pkg/Makefile (right):\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/Makefile#newcode102\nsrc/pkg/Makefile:102: os/inotify\\\nOn 2010/12/07 19:19:45, rsc wrote:\n> not sorted right\n> but also will cause other builds to fail.  instead i would add after this list\n> \n> ifeq ($(GOOS),linux)\n> DIRS+=\\\n>     os/inotify\\\n> \n> endif\n\nI fixed the sorting, but didn't remove it from the list.\nIt should be a noop on non-Linux systems, as src/pkg/os/inotify/Makefile says:\n[...]\nGOFILES_linux=\\\n\tinotify_linux.go\\\n\nGOFILES+=$(GOFILES_$(GOOS))\n[...]\n\nWhat do you think?\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode5\nsrc/pkg/os/inotify/inotify_linux.go:5: // This package provides a wrapper for the Linux inotify system\nOn 2010/12/07 19:19:45, rsc wrote:\n> See http://golang.org/doc/effective_go.html for more on package comments.\n> \n> Should be one comment before package inotify, and the example should be\n> intended.\n> \n> /*\n> This package implements a wrapper for the Linux inotify system.\n> \n> Example:\n>     in, err := inotify.New()\n>     if err != nil {\n>         log.Exit(err)\n>     }\n>     in.Watch(\"/tmp\")\n>     for {\n>         select {\n>         case ev := <-in.Event:\n>             log.Println(\"event:\", ev)\n>         case err := <-in.Error:\n>             log.Println(\"error:\", err)\n>         }\n>     }\n> \n> */\n> package inotify\n\nFixed.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode57\nsrc/pkg/os/inotify/inotify_linux.go:57: errors   chan os.Error     // Errors are sent on this channel\nOn 2010/12/07 19:19:45, rsc wrote:\n> another possibility is to add public fields\n> \n>     Error <-chan os.Error\n>     Event <-chan *Event\n> \n> to the struct and then delete the getters below.\n> this matches the interface to, say, time.Ticker\n> and others.\n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode65\nsrc/pkg/os/inotify/inotify_linux.go:65: func New() (*Inotify, os.Error) {\nOn 2010/12/07 19:19:45, rsc wrote:\n> Will there be other types?  If there is a good name\n> for this one, you could rely on the package name\n> to provide the \"inotify\" word, like inotify.Watcher\n> or whatever.  And then this would be func NewWatcher.\n> \n> See effective go for comment format.  Comments\n> should start with the noun they describe.\n> \n> // New creates and returns a new inotify instance using inotify_init(2).\n> \n> The part about the event reader goroutine is an implementation detail\n> \n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode83\nsrc/pkg/os/inotify/inotify_linux.go:83: // Close an inotify instance\nOn 2010/12/07 19:19:45, rsc wrote:\n> // Close closes an inotify instance.\n> \n> it should return os.Error to match io.Closer\n> \n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode88\nsrc/pkg/os/inotify/inotify_linux.go:88: return\nShould we return an error if it's already closed?\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode99\nsrc/pkg/os/inotify/inotify_linux.go:99: // Add a new watch for path (see inotify_add_watch(2))\nOn 2010/12/07 19:19:45, rsc wrote:\n> // AddWatch adds path to the watched file set.\n> // The flags are interpreted as described in inotify_add_watch(2).\n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode123\nsrc/pkg/os/inotify/inotify_linux.go:123: // A convenience wrapper for AddWatch()\nOn 2010/12/07 19:19:45, rsc wrote:\n> // Watch adds path to the watched file set, watching all events.\n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode129\nsrc/pkg/os/inotify/inotify_linux.go:129: // Remove a watch (see inotify_rm_watch(2))\nOn 2010/12/07 19:19:45, rsc wrote:\n> ...\n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode217\nsrc/pkg/os/inotify/inotify_linux.go:217: // Format the event as a human-readable string\nOn 2010/12/07 19:19:45, rsc wrote:\n> can drop this comment, because String() is so common.\n> or keep it but fix the phrasing:\n> \n> // String formats the event e in the form\n> // \"filename: 0xEventMask = IN_ACCESS|IN_ATTRIB_|...\"\n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode221\nsrc/pkg/os/inotify/inotify_linux.go:221: if e.Mask&IN_ACCESS != 0 {\nOn 2010/12/07 19:19:45, rsc wrote:\n> this is aching for a table\n\nI've added a map. Not sure if this is what you had in mind.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode281\nsrc/pkg/os/inotify/inotify_linux.go:281: return fmt.Sprintf(\"\\\"%s\\\": 0x%x == %s\", e.Name, e.Mask, events[1:])\nOn 2010/12/07 19:19:45, rsc wrote:\n> use %q\n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode289\nsrc/pkg/os/inotify/inotify_linux.go:289: // Options for AddWatch()\nOn 2010/12/07 19:19:45, rsc wrote:\n> s/()//\n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux.go#newcode290\nsrc/pkg/os/inotify/inotify_linux.go:290: IN_DONT_FOLLOW uint32 = syscall.IN_DONT_FOLLOW\nOn 2010/12/07 19:19:45, rsc wrote:\n> The IN_ prefix is not really necessary here but it's fine if you want to keep\n> it.\n\nI would keep it for better greppability.\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux_test.go\nFile src/pkg/os/inotify/inotify_linux_test.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux_test.go#newcode13\nsrc/pkg/os/inotify/inotify_linux_test.go:13: func TestInotifyEvents(t *testing.T) {\nOn 2010/12/07 19:19:45, rsc wrote:\n> Do all recent Linuxes support inotify?\n\nIt's been supported since 2.6.13 and it's turned on by default. Of course, you can compile a kernel without inotify support. Do we have to add guards for that - arguably very rare - case?\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/os/inotify/inotify_linux_test.go#newcode20\nsrc/pkg/os/inotify/inotify_linux_test.go:20: // Add a watch for \"_obj\"\nOn 2010/12/07 19:19:45, rsc wrote:\n> Does it matter if _obj is a network file system?\n\nI don't think it matters.\nNot that it's a proof, but I've tested it on my NFS homedir and it worked.",
			"disapproval": false,
			"date": "2010-12-09 14:17:57.814581",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "> I fixed the sorting, but didn't remove it from the list.\n> It should be a noop on non-Linux systems, as src/pkg/os/inotify/Makefile\n> says:\n> [...]\n> GOFILES_linux=\\\n> \u00a0 \u00a0 \u00a0 \u00a0inotify_linux.go\\\n>\n> GOFILES+=$(GOFILES_$(GOOS))\n> [...]\n>\n> What do you think?\n\nIt doesn't seem too useful to have a package\nthat you can import but not use, so I'd say don't\nbuild it at all.  (Also I think it is not allowed to\nhave a zero-file package, because then there\nis no package statement.)\n\n> src/pkg/os/inotify/inotify_linux.go:221: if e.Mask&IN_ACCESS != 0 {\n> On 2010/12/07 19:19:45, rsc wrote:\n>>\n>> this is aching for a table\n>\n> I've added a map. Not sure if this is what you had in mind.\n\nNot quite; will reply via codereview.\n\n>> Do all recent Linuxes support inotify?\n>\n> It's been supported since 2.6.13 and it's turned on by default. Of\n> course, you can compile a kernel without inotify support. Do we have to\n> add guards for that - arguably very rare - case?\n\nNo, that should be fine.\nIf not we can always make the test look at the\nkernel version and just not run on old kernels.\nBut for now just leave it there always.\n\nRuss\n",
			"disapproval": false,
			"date": "2010-12-09 14:55:00.017362",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go#newcode209\nsrc/pkg/os/inotify/inotify_linux.go:209: for event_mask, event_name := range event_names {\nlook for _ in yuor program; there shouldn't be any\n\nbelow, eventNames.\nhere, can just drop event_ entirely since it's\na local variable.\n\nwith the change below\n\nfor b := range eventBits {\n    if e.Mask&b.Value != 0 {\n        events += \"|\" + b.Name\n    }\n}\n\nhttp://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go#newcode261\nsrc/pkg/os/inotify/inotify_linux.go:261: var (\ndrop ( ) and indentation\n\nhttp://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go#newcode262\nsrc/pkg/os/inotify/inotify_linux.go:262: event_names = map[uint32]string{\nThis is okay but kind of overkill since you never\nactually look up by value, which is what map adds\nover a plain slice.  For an iterable-only list\nof key,value pairs it's more efficient to use a slice:\n\nvar eventBits = []struct{\n    Value uint32\n    Name string\n}{\n    {IN_ACCESS, \"IN_ACCESS\"},\n    {IN_ATTRIB, \"IN_ATTRIB\"},\n    ...,\n}",
			"disapproval": false,
			"date": "2010-12-09 14:55:02.316755",
			"approval": false
		},
		{
			"sender": "rogpeppe@gmail.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go#newcode209\nsrc/pkg/os/inotify/inotify_linux.go:209: for event_mask, event_name := range event_names {\nOn 2010/12/09 14:55:02, rsc wrote:\n> look for _ in yuor program; there shouldn't be any\n> for b := range eventBits {\n\nfor _, b := range eventBits {",
			"disapproval": false,
			"date": "2010-12-09 15:10:21.863517",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": "The deps.bash problem is probably that the\nscript is too clever about pulling out the\nvalue of DIRS.  It would be fine to add a rule\n\necho-dirs:\n    @echo $(DIRS)\n\nto the src/pkg/Makefile and change deps.bash\nto use that.\n\nRuss\n",
			"disapproval": false,
			"date": "2010-12-09 15:29:54.503340",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/36001/src/pkg/Makefile\nFile src/pkg/Makefile (right):\n\nhttp://codereview.appspot.com/2049043/diff/36001/src/pkg/Makefile#newcode102\nsrc/pkg/Makefile:102: os/inotify\\\nOn 2010/12/07 19:19:45, rsc wrote:\n> not sorted right\n> but also will cause other builds to fail.  instead i would add after this list\n> \n> ifeq ($(GOOS),linux)\n> DIRS+=\\\n>     os/inotify\\\n> \n> endif\n\nThis doesn't seem to work.\nall.bash fails with:\n[...]\nmake[1]: Entering directory `/usr/local/google/go/src/pkg/os/inotify'\n6g -o _go_.6  inotify_linux.go \ninotify_linux.go:27: can't find import: fmt\nmake[1]: *** [_go_.6] Error 1\nmake[1]: Leaving directory `/usr/local/google/go/src/pkg/os/inotify'\n\nI'm pretty sure it's something trivial, but I don't know how to fix it.\n\nhttp://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go#newcode209\nsrc/pkg/os/inotify/inotify_linux.go:209: for event_mask, event_name := range event_names {\nOn 2010/12/09 14:55:02, rsc wrote:\n> look for _ in yuor program; there shouldn't be any\n> \n> below, eventNames.\n> here, can just drop event_ entirely since it's\n> a local variable.\n> \n> with the change below\n> \n> for b := range eventBits {\n>     if e.Mask&b.Value != 0 {\n>         events += \"|\" + b.Name\n>     }\n> }\n\nGot it. Fixed.\n\nhttp://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go#newcode209\nsrc/pkg/os/inotify/inotify_linux.go:209: for event_mask, event_name := range event_names {\nOn 2010/12/09 15:10:22, rog wrote:\n> On 2010/12/09 14:55:02, rsc wrote:\n> > look for _ in yuor program; there shouldn't be any\n> > for b := range eventBits {\n> \n> for _, b := range eventBits {\n> \n> \n\nThanks! I figured it out too, just when you sent this comment ;)\n\nhttp://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go#newcode261\nsrc/pkg/os/inotify/inotify_linux.go:261: var (\nOn 2010/12/09 14:55:02, rsc wrote:\n> drop ( ) and indentation\n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/49001/src/pkg/os/inotify/inotify_linux.go#newcode262\nsrc/pkg/os/inotify/inotify_linux.go:262: event_names = map[uint32]string{\nOn 2010/12/09 14:55:02, rsc wrote:\n> This is okay but kind of overkill since you never\n> actually look up by value, which is what map adds\n> over a plain slice.  For an iterable-only list\n> of key,value pairs it's more efficient to use a slice:\n> \n> var eventBits = []struct{\n>     Value uint32\n>     Name string\n> }{\n>     {IN_ACCESS, \"IN_ACCESS\"},\n>     {IN_ATTRIB, \"IN_ATTRIB\"},\n>     ...,\n> }\n> \n\nDone.",
			"disapproval": false,
			"date": "2010-12-09 15:26:04.277265",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview.appspotmail.com"
			],
			"text": ">> not sorted right\n>> but also will cause other builds to fail. \u00a0instead i would add after\n>\n> this list\n>\n>> ifeq ($(GOOS),linux)\n>> DIRS+=\\\n>> \u00a0 \u00a0 os/inotify\\\n>\n>> endif\n>\n> This doesn't seem to work.\n> all.bash fails with:\n> [...]\n> make[1]: Entering directory `/usr/local/google/go/src/pkg/os/inotify'\n> 6g -o _go_.6 \u00a0inotify_linux.go\n> inotify_linux.go:27: can't find import: fmt\n> make[1]: *** [_go_.6] Error 1\n> make[1]: Leaving directory `/usr/local/google/go/src/pkg/os/inotify'\n>\n> I'm pretty sure it's something trivial, but I don't know how to fix it.\n\nThe script src/pkg/deps.bash is not generating a line for os/inotify.\nI don't know why.  I'll look later if you don't beat me to it.\n\nRuss\n",
			"disapproval": false,
			"date": "2010-12-09 15:29:06.034903",
			"approval": false
		},
		{
			"sender": "Jacek.Masiulaniec@gmail.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/58001/src/pkg/Makefile\nFile src/pkg/Makefile (right):\n\nhttp://codereview.appspot.com/2049043/diff/58001/src/pkg/Makefile#newcode103\nsrc/pkg/Makefile:103: os/inotify\\\nUse tab instead of 8 spaces; they're visible in raw patch set.",
			"disapproval": false,
			"date": "2010-12-09 15:33:21.107782",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2010/12/09 15:29:54, rsc wrote:\n> The deps.bash problem is probably that the\n> script is too clever about pulling out the\n> value of DIRS.  It would be fine to add a rule\n> \n> echo-dirs:\n>     @echo $(DIRS)\n> \n> to the src/pkg/Makefile and change deps.bash\n> to use that.\n> \n> Russ\n\nDone.",
			"disapproval": false,
			"date": "2010-12-09 15:41:50.642778",
			"approval": false
		},
		{
			"sender": "Jacek.Masiulaniec@gmail.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/55002/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/55002/src/pkg/os/inotify/inotify_linux.go#newcode217\nsrc/pkg/os/inotify/inotify_linux.go:217: events = \" UNKOWN\"\ns/UNKOWN/UNKNOWN/",
			"disapproval": false,
			"date": "2010-12-09 16:14:09.098751",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/55002/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/55002/src/pkg/os/inotify/inotify_linux.go#newcode217\nsrc/pkg/os/inotify/inotify_linux.go:217: events = \" UNKOWN\"\nOn 2010/12/09 16:14:09, jacekm wrote:\n> s/UNKOWN/UNKNOWN/\n\nWell spotted! Fixed.",
			"disapproval": false,
			"date": "2010-12-09 16:25:22.512451",
			"approval": false
		},
		{
			"sender": "Jacek.Masiulaniec@gmail.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/72001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/72001/src/pkg/os/inotify/inotify_linux.go#newcode13\nsrc/pkg/os/inotify/inotify_linux.go:13: watcher.Watch(\"/tmp\")\nExamples should not contain bugs so please don't skip error checking.",
			"disapproval": false,
			"date": "2010-12-09 16:47:07.620338",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/55002/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/55002/src/pkg/os/inotify/inotify_linux.go#newcode217\nsrc/pkg/os/inotify/inotify_linux.go:217: events = \" UNKOWN\"\nOn 2010/12/09 16:25:22, leczb wrote:\n> On 2010/12/09 16:14:09, jacekm wrote:\n> > s/UNKOWN/UNKNOWN/\n> \n> Well spotted! Fixed.\n\nI think this handling of unknown bits is not\ngeneral enough.  It is far more likely to have\none or two unknown bits than for all of them\nto be unknown.  I suggest:\n\nm := e.Mask\nfor _, b := ... {\n   if ... {\n        m &^= b.Value\n        events += \"|\" + b.Name\n    }\n}\nif m != 0 {\n    events += fmt.Sprintf(\"|%#x\", m)\n}\nif len(events) > 0 {\n    events = \" == \" + events[1:]\n}\n\nreturn fmt.Sprintf(\"%q: %#x%s\", e.Name, e.Mask, events)",
			"disapproval": false,
			"date": "2010-12-09 17:12:13.637633",
			"approval": false
		},
		{
			"sender": "Jacek.Masiulaniec@gmail.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/72001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/72001/src/pkg/os/inotify/inotify_linux.go#newcode69\nsrc/pkg/os/inotify/inotify_linux.go:69: done:    make(chan bool, 1)}\nMulti-line literals usually end with a closing brace on separate line.",
			"disapproval": false,
			"date": "2010-12-09 17:15:03.176250",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "On 2010/12/09 17:12:13, rsc1 wrote:\n> http://codereview.appspot.com/2049043/diff/55002/src/pkg/os/inotify/inotify_linux.go\n> File src/pkg/os/inotify/inotify_linux.go (right):\n> \n> http://codereview.appspot.com/2049043/diff/55002/src/pkg/os/inotify/inotify_linux.go#newcode217\n> src/pkg/os/inotify/inotify_linux.go:217: events = \" UNKOWN\"\n> On 2010/12/09 16:25:22, leczb wrote:\n> > On 2010/12/09 16:14:09, jacekm wrote:\n> > > s/UNKOWN/UNKNOWN/\n> > \n> > Well spotted! Fixed.\n> \n> I think this handling of unknown bits is not\n> general enough.  It is far more likely to have\n> one or two unknown bits than for all of them\n> to be unknown.  I suggest:\n> \n> m := e.Mask\n> for _, b := ... {\n>    if ... {\n>         m &^= b.Value\n>         events += \"|\" + b.Name\n>     }\n> }\n> if m != 0 {\n>     events += fmt.Sprintf(\"|%#x\", m)\n> }\n> if len(events) > 0 {\n>     events = \" == \" + events[1:]\n> }\n> \n> return fmt.Sprintf(\"%q: %#x%s\", e.Name, e.Mask, events)\n\nSGTM. Implemented.",
			"disapproval": false,
			"date": "2010-12-09 17:22:04.000982",
			"approval": false
		},
		{
			"sender": "rsc@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "LGTM\n\nPlease fix nit below and I will submit\n\nhttp://codereview.appspot.com/2049043/diff/63002/src/pkg/Makefile\nFile src/pkg/Makefile (right):\n\nhttp://codereview.appspot.com/2049043/diff/63002/src/pkg/Makefile#newcode144\nsrc/pkg/Makefile:144: DIRS+=\\\ndrop leading spaces before DIRS please\n(we don't typically indent the bodies of ifeq)",
			"disapproval": false,
			"date": "2010-12-09 17:28:00.761958",
			"approval": true
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Thanks Jacek for the review.\n\nBalazs\n\nhttp://codereview.appspot.com/2049043/diff/72001/src/pkg/os/inotify/inotify_linux.go\nFile src/pkg/os/inotify/inotify_linux.go (right):\n\nhttp://codereview.appspot.com/2049043/diff/72001/src/pkg/os/inotify/inotify_linux.go#newcode13\nsrc/pkg/os/inotify/inotify_linux.go:13: watcher.Watch(\"/tmp\")\nOn 2010/12/09 16:47:07, jacekm wrote:\n> Examples should not contain bugs so please don't skip error checking.\n\nDone.\n\nhttp://codereview.appspot.com/2049043/diff/72001/src/pkg/os/inotify/inotify_linux.go#newcode69\nsrc/pkg/os/inotify/inotify_linux.go:69: done:    make(chan bool, 1)}\nOn 2010/12/09 17:15:03, jacekm wrote:\n> Multi-line literals usually end with a closing brace on separate line.\n\nDone.",
			"disapproval": false,
			"date": "2010-12-09 17:28:12.980822",
			"approval": false
		},
		{
			"sender": "leczb@google.com",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/2049043/diff/63002/src/pkg/Makefile\nFile src/pkg/Makefile (right):\n\nhttp://codereview.appspot.com/2049043/diff/63002/src/pkg/Makefile#newcode144\nsrc/pkg/Makefile:144: DIRS+=\\\nOn 2010/12/09 17:28:00, rsc1 wrote:\n> drop leading spaces before DIRS please\n> (we don't typically indent the bodies of ifeq)\n\nVery thorough. I like it! ;)\nDone.",
			"disapproval": false,
			"date": "2010-12-09 17:37:26.850139",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"leczb@google.com",
				"rsc@golang.org",
				"fullung@gmail.com",
				"rogpeppe@gmail.com",
				"jacek.masiulaniec@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "*** Submitted as 354e81112204 ***\n\nos/inotify: new package\n\nThis patch adds a new package: os/inotify, which\nprovides a Go wrapper to the Linux inotify system.\n\nR=rsc, albert.strasheim, rog, jacek.masiulaniec\nCC=golang-dev\nhttp://codereview.appspot.com/2049043\n\nCommitter: Russ Cox <rsc@golang.org>",
			"disapproval": false,
			"date": "2010-12-09 18:11:41.465393",
			"approval": false
		}
	],
	"owner_email": "leczb@google.com",
	"private": false,
	"base_url": "",
	"owner": "leczb",
	"subject": "code review 2049043: Add Linux inotify support",
	"created": "2010-08-30 14:21:32.147688",
	"patchsets": [
		1,
		2001,
		7001,
		12002,
		14001,
		18001,
		26001,
		36001,
		44001,
		49001,
		58001,
		66001,
		55002,
		72001,
		63002,
		80001,
		47014,
		50006,
		90001
	],
	"modified": "2010-12-09 18:11:41.465393",
	"closed": false,
	"issue": 2049043
}