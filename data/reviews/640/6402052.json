{
	"description": "bn256: add package\n\nPackage bn256 implements a particular bilinear group at the 128-bit\nsecurity level.",
	"cc": [
		"golang-dev@googlegroups.com",
		"remyoudompheng@gmail.com",
		"r@google.com",
		"r@golang.org",
		"akumar@mail.nanosouffle.net"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This is crypto code so cryptic comments are appropriate.\r\n\r\n-rob\r\n\r\n\r\n\r\nOn Mon, Jul 16, 2012 at 12:42 PM, <remyoudompheng@gmail.com> wrote:\r\n\r\n> I have some stupid grammar remarks. What is the \"Jacobian form\"?\r\n>\r\n>\r\n> http://codereview.appspot.com/**6402052/diff/5001/bn256/**constants.go<http://codereview.appspot.com/6402052/diff/5001/bn256/constants.go>\r\n> File bn256/constants.go (right):\r\n>\r\n> http://codereview.appspot.com/**6402052/diff/5001/bn256/**\r\n> constants.go#newcode25<http://codereview.appspot.com/6402052/diff/5001/bn256/constants.go#newcode25>\r\n> bn256/constants.go:25: // xiToPMinus1Over3 is \u03be^((p-1)/6) where \u03be = i+3.\r\n> s/Over3/Over6\r\n>\r\n> http://codereview.appspot.com/**6402052/diff/5001/bn256/gfp6.**go<http://codereview.appspot.com/6402052/diff/5001/bn256/gfp6.go>\r\n> File bn256/gfp6.go (right):\r\n>\r\n> http://codereview.appspot.com/**6402052/diff/5001/bn256/gfp6.**\r\n> go#newcode120<http://codereview.appspot.com/6402052/diff/5001/bn256/gfp6.go#newcode120>\r\n> bn256/gfp6.go:120: // Section 4, Katasuba method.\r\n> s/Katasuba/Karatsuba\r\n>\r\n> http://codereview.appspot.com/**6402052/diff/5001/bn256/**optate.go<http://codereview.appspot.com/6402052/diff/5001/bn256/optate.go>\r\n> File bn256/optate.go (right):\r\n>\r\n> http://codereview.appspot.com/**6402052/diff/5001/bn256/**\r\n> optate.go#newcode263<http://codereview.appspot.com/6402052/diff/5001/bn256/optate.go#newcode263>\r\n> bn256/optate.go:263: // For Q2 we are applying the p\u00b2 Forbenius. The two\r\n> conjuctions cancel\r\n> Frobenius?\r\n> conjugations?\r\n>\r\n> http://codereview.appspot.com/**6402052/<http://codereview.appspot.com/6402052/>\r\n>\r\n",
			"disapproval": false,
			"date": "2012-07-16 19:45:39.828890",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Thanks. I just did a pass adding all the comments and typoed a few it seems :)\n\nJacobian form is a representation of points in an elliptic curve group. For a point (x,y) the Jacobian form is (x',y',z) where x = x' * z^2 and y = y' * z^3. The advantage of holding it in this form is that the group operations are faster. Generally the faster group operations more than make up for the cost of converting back to affine form at the end.\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/constants.go\nFile bn256/constants.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/constants.go#newcode25\nbn256/constants.go:25: // xiToPMinus1Over3 is \u03be^((p-1)/6) where \u03be = i+3.\nOn 2012/07/16 19:42:04, remyoudompheng wrote:\n> s/Over3/Over6\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/gfp6.go\nFile bn256/gfp6.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/gfp6.go#newcode120\nbn256/gfp6.go:120: // Section 4, Katasuba method.\nOn 2012/07/16 19:42:04, remyoudompheng wrote:\n> s/Katasuba/Karatsuba\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/optate.go\nFile bn256/optate.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/optate.go#newcode263\nbn256/optate.go:263: // For Q2 we are applying the p\u00b2 Forbenius. The two conjuctions cancel\nOn 2012/07/16 19:42:04, remyoudompheng wrote:\n> Frobenius?\n> conjugations?\n\nDone.",
			"disapproval": false,
			"date": "2012-07-16 19:51:25.296280",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://code.google.com/p/go.crypto",
			"disapproval": false,
			"date": "2012-07-16 19:08:08.253140",
			"approval": false
		},
		{
			"sender": "remyoudompheng@gmail.com",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I have some stupid grammar remarks. What is the \"Jacobian form\"?\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/constants.go\nFile bn256/constants.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/constants.go#newcode25\nbn256/constants.go:25: // xiToPMinus1Over3 is \u03be^((p-1)/6) where \u03be = i+3.\ns/Over3/Over6\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/gfp6.go\nFile bn256/gfp6.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/gfp6.go#newcode120\nbn256/gfp6.go:120: // Section 4, Katasuba method.\ns/Katasuba/Karatsuba\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/optate.go\nFile bn256/optate.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/5001/bn256/optate.go#newcode263\nbn256/optate.go:263: // For Q2 we are applying the p\u00b2 Forbenius. The two conjuctions cancel\nFrobenius?\nconjugations?",
			"disapproval": false,
			"date": "2012-07-16 19:42:04.869210",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "this is a pretty big blodge of inscrutableness. is there an itch it scratches?\n\ni've only looked quickly at the first file. i'll look at more later.\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go\nFile bn256/bn256.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode13\nbn256/bn256.go:13: // bn256 specifically implements the Optimal Ate pairing over a 256-bit\ns/b/B/ English sentences start with capital letters. If you don't like that, please rephrase.\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode29\nbn256/bn256.go:29: // G1 is an abstract cyclic group. The zero value is suitable for using as the\ns/using/use/\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode111\nbn256/bn256.go:111: func (out *G1) Unmarshal(m []byte) (*G1, bool) {\n// doc comment?\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode162\nbn256/bn256.go:162: // ScalarBaseMult sets out to g*k where g is the generator of the group and\nthe use of 'out' as a receiver name is unidiomatic and renders these comments hard to parse.\n\ntoday i set out to do the following: to set out to g*k.\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode211\nbn256/bn256.go:211: func (out *G2) Unmarshal(m []byte) (*G2, bool) {\n// doc comment\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode248\nbn256/bn256.go:248: func (out *GT) ScalarMult(a *GT, k *big.Int) *GT {\nditto about 'out'",
			"disapproval": false,
			"date": "2012-07-17 00:06:54.157570",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"akumar@mail.nanosouffle.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6402052/diff/10002/bn256/bn256_test.go\nFile bn256/bn256_test.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/bn256_test.go#newcode160\nbn256/bn256_test.go:160: \nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> I suggest adding a stupid test like:\n> \n> func TestGenG2(t *testing.T) {\n>       g := new(G2).ScalarBaseMult(Order)\n>       if !g.p.IsInfinity() {\n>             t.Error(\"twistPoint does have order n in G\u2082\")\n>       }\n> }\n\nDone (for G1, G2 and GT. I don't specify the order of GT, but it's the same.)\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/bn256_test.go#newcode196\nbn256/bn256_test.go:196: }\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> Marshal/Unmarshal round trip fails for infinity points:\n\nThis was deliberate because I wanted to avoid people having to worry about zero in TDH. (Tor, previously, has been broken by failing to check for zero in a DH exchange.)\n\nHowever, having checked a few other pairing based protocols it seems that they will need zero to marshal/unmarshal correctly so I've done that.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/bn256_test.go#newcode197\nbn256/bn256_test.go:197: \nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> the following test fails, why?\n> \n> func TestG2Identity(t *testing.T) {\n>       g := new(G2).ScalarBaseMult(new(big.Int).SetInt64(0))\n>       if !g.p.IsInfinity() {\n>             t.Error(\"failure\")\n>       }\n> }\n\nThat's a good catch. The code that the paper is based on is broken in the same way and it seems it's because their elliptic addition formula aren't complete. This is doubly unfortunately because I thought that the Bernstein-Lange formulas *were* complete so I'll have to check crypto/elliptic on that point.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/constants.go\nFile bn256/constants.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/constants.go#newcode16\nbn256/constants.go:16: // u is the BN parameter that determines the prime\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> since u is not written explicit in the reference paper, I suggest mentioning\n> that u = 1868033\u00b3\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/constants.go#newcode19\nbn256/constants.go:19: // p is a prime over which we form a basic field.\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> similarly, mention that p = 36u\u2074+36u\u00b3+24u\u00b3+6u+1 ?\n\nDone (and for Order)\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/constants.go#newcode37\nbn256/constants.go:37: // xiToPSquaredMinus1Over6 is \u03be^((p\u00b2-1)/6) where \u03be = i+3.\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> (a cubic root of unity modulo p).\n\nDone (and above).\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/curve.go\nFile bn256/curve.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/curve.go#newcode12\nbn256/curve.go:12: // Jacobian form and t=z\u00b2 when valid.\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> // G\u2081 is the set of points of this curve on GF(p).\n> \n> (or a similar sentence)\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/curve.go#newcode55\nbn256/curve.go:55: func (c *curvePoint) IsOnCurve() bool {\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> this function only works for points in affine form.\n\nYep. Added comment to that effect.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp12.go\nFile bn256/gfp12.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp12.go#newcode79\nbn256/gfp12.go:79: func (e *gfP12) Frobenius(a *gfP12, pool *bnPool) *gfP12 {\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> Computes (x\u03c9+y)^p = x^p \u03c9\u00b7\u03be^((p-1)/6) + y^p\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp12.go#newcode86\nbn256/gfp12.go:86: func (e *gfP12) FrobeniusP2(a *gfP12, pool *bnPool) *gfP12 {\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> F(a\u03c9+b) = F(a)\u00b7\u03c9^p\u00b2 + F(b) = F(a)\u00b7\u03c9\u00b7\u03be^(p\u00b2-1/6) + F(b)\n> where does the negative come from? \n\nSorry, this was a (very minor) speed up that I forgot about and then got tangled in when cleaning up the code. The old value of xiToPSquaredMinus1Over6 was actually the forth power of that value and, since it's a cube root of -1, the negative made it work. It was slightly faster because the forth power is a small number but it's probably too subtle to be worth it so I dropped it.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp2.go\nFile bn256/gfp2.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp2.go#newcode126\nbn256/gfp2.go:126: func (e *gfP2) MulElements(a *gfP2, b *big.Int) *gfP2 {\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> MulElements looks weird to me. MulScalar or MulInt maybe? \n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp2.go#newcode173\nbn256/gfp2.go:173: func (e *gfP2) Invert(a *gfP2, pool *bnPool) *gfP2 {\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> mention that you are computing 1/(ai+b) = (-ai+b)/(a\u00b2+b\u00b2) ?\n\nIn other cases I referenced the paper in question, so I've added that here. (I might be able to derive quadratic field extension inversion, but I'd probably be stuck on cubic inversion without a reference :) )\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp6.go\nFile bn256/gfp6.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp6.go#newcode86\nbn256/gfp6.go:86: func (e *gfP6) FrobeniusP2(a *gfP6) *gfP6 {\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> Computes (x\u03c4\u00b2+y\u03c4+z)^(p\u00b2) = x\u03c4^(2p\u00b2) + y\u03c4^(p\u00b2) + z\n> so y gets multiplied by \u03c4^(p\u00b2-1) = \u03be^(p\u00b2-1/3) = z\u00b2\n>    x gets multiplied by \u03c4^2(p\u00b2-1) = z\u2074\n> (where z = xiToPSquaredMinus1Over6)\n\nI'm afraid that I've lead you astray with by mistake of misnaming the constant in GF(p12)'s FrobeniusP2. The factor applied to x should be \n\u03be^((2p\u00b2-2)/3) and, in fact it was, but I had it named wrong.\n\n> Oh, wait, it's worth mentioning that z is a cubic root of unity.\n\n(z is a cube root of -1, rather than 1.)\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp6.go#newcode184\nbn256/gfp6.go:184: func (e *gfP6) MulTau(a *gfP6, pool *bnPool) {\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> seems obvious but it computes\n> \u03c4\u00b7(a\u03c4\u00b2+b\u03c4+c) = b\u03c4\u00b2+c\u03c4+a\u03be\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/twist.go\nFile bn256/twist.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/twist.go#newcode12\nbn256/twist.go:12: // kept in Jacobian form and t=z\u00b2 when valid.\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> // The group G\u2082 is the set of n-torsion points of this curve over GF(p\u00b2) (where\n> n = Order)\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/twist.go#newcode22\nbn256/twist.go:22: // twistGen is the generator of group G\u2081.\nOn 2012/07/21 06:41:55, remyoudompheng wrote:\n> s/G\u2081/G\u2082/\n\nDone.",
			"disapproval": false,
			"date": "2012-07-21 18:26:00.382140",
			"approval": false
		},
		{
			"sender": "remyoudompheng@gmail.com",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"akumar@mail.nanosouffle.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Comments about the elliptic curve group law implementation. I have not reviewed the Tate pairing computation because I have not yet an idea of what it is computing.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/curve.go\nFile bn256/curve.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/curve.go#newcode238\nbn256/curve.go:238: c.t.SetInt64(0)\nwhy violate the assumption that t=z\u00b2 ? actually it doesn't seem to be used (nor true) outside of the pairing computation anyway\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go\nFile bn256/curve.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode77\nbn256/curve.go:77: func (c *curvePoint) Add(a, b *curvePoint, pool *bnPool) {\nThe Add function is not suitable for a == b and will return zero coordinates if it happens. This means that the following test (possible using public API functions) will fail (so the fact should be documented or correctly handled by redirecting to the Double function):\n\nfunc TestG1AddSelf(t *testing.T) {\n  a := new(G1).ScalarBaseMult(new(big.Int).SetInt64(64))\n  b := new(G1).Add(a, a)\n  s := b.Marshal()\n  _, ok := new(G1).Unmarshal(s)\n  if !ok {\n    t.Fatal(\"marshal of a\u00b7a failed\")\n  }               \n}\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode88\nbn256/curve.go:88: z1z1 := pool.Get().Mul(a.z, a.z)\nI personnally prefer formulas over assembly-like programs so I try to suggest comments that make it easier to digest (feel free to choose classical notations for coordinates over mine): \n\n// Normalize the points by replacing a = [x1:y1:z1] and b = [x2:y2:z2]\n// by [u1:s1:z1\u00b7z2] and [u2:s2:z1\u00b7z2]\n// where u1 = x1\u00b7z2\u00b2, s1 = y1\u00b7z2\u00b3 and u1 = x2\u00b7z1\u00b2, s2 = y2\u00b7z1\u00b3\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode107\nbn256/curve.go:107: h := pool.Get().Sub(u2, u1)\n// Compute x = (2h)\u00b2(s\u00b2-u1-u2)\n// where s = (s2-s1)/(u2-u1) is the slope of the line through\n// (u1,s1) and (u2,s2). The extra factor 2h = 2(u2-u1) comes from the value of z below.\n// This is also:\n// 4(s2-s1)\u00b2 - 4h\u00b2(u1+u2) = 4(s2-s1)\u00b2 - 4h\u00b3 - 4h\u00b2(2u1)\n//                        = r\u00b2 - j - 2v\n// with the notations below.\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode110\nbn256/curve.go:110: i := pool.Get().Mul(t, t)\n// i = 4h\u00b2\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode112\nbn256/curve.go:112: j := pool.Get().Mul(h, i)\n// j = 4h\u00b3\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode121\nbn256/curve.go:121: t4 := pool.Get().Mul(r, r)\n// t4 = 4(s2-s1)\u00b2\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode127\nbn256/curve.go:127: t.Sub(v, c.x) // t7\n// Set y = -(2h)\u00b3(s1 + s*(x/4h\u00b2-u1))\n// This is also\n// y = - 2\u00b7s1\u00b7j - (s2-s1)(2x - 2i\u00b7u1) = r(v-x) - 2\u00b7s1\u00b7j\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode135\nbn256/curve.go:135: t.Add(a.z, b.z) // t11\n// Set z = 2(u2-u1)\u00b7z1\u00b7z2 = 2h\u00b7z1\u00b7z2\n\nSeems like 2z1\u00b7z2 is computed as (z1+z2)\u00b2-z1\u00b2-z2\u00b2. Weird.\nI would have said (it seems to have similar performance):\n\nt.Add(h, h)\nt.Mul(t, a.z)\nt.Mul(t, b.z)\nc.z.Mod(t, p)\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/twist.go\nFile bn256/twist.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/twist.go#newcode100\nbn256/twist.go:100: // See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/addition/add-2007-bl.op3\nit seems the code is identical to the non-twisted curve so no need for extra comments here.",
			"disapproval": false,
			"date": "2012-07-21 19:42:00.713050",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This is indeed pretty obscure. I'm afraid that I'm not going to make bilinear groups and field extensions easy to understand in this code, although I've tried to make them easy to use.\n\nThis package is also pretty obscure. It allows one to write lots of neat cryptosystems (identity based encryption, group signatures, proxy re-signatures etc), but those aren't in common use. It's certain sub-repository material and possibly not even that interesting. I can certainly put it in github if you would prefer.\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go\nFile bn256/bn256.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode13\nbn256/bn256.go:13: // bn256 specifically implements the Optimal Ate pairing over a 256-bit\nOn 2012/07/17 00:06:54, r wrote:\n> s/b/B/ English sentences start with capital letters. If you don't like that,\n> please rephrase.\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode29\nbn256/bn256.go:29: // G1 is an abstract cyclic group. The zero value is suitable for using as the\nOn 2012/07/17 00:06:54, r wrote:\n> s/using/use/\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode111\nbn256/bn256.go:111: func (out *G1) Unmarshal(m []byte) (*G1, bool) {\nOn 2012/07/17 00:06:54, r wrote:\n> // doc comment?\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode162\nbn256/bn256.go:162: // ScalarBaseMult sets out to g*k where g is the generator of the group and\nOn 2012/07/17 00:06:54, r wrote:\n> the use of 'out' as a receiver name is unidiomatic and renders these comments\n> hard to parse.\n> \n> today i set out to do the following: to set out to g*k.\n\nI've changed all the uses of |out| as a receiver to |e| and updated the comments accordingly. ('e' for 'element' since they're elements of the group.)\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode211\nbn256/bn256.go:211: func (out *G2) Unmarshal(m []byte) (*G2, bool) {\nOn 2012/07/17 00:06:54, r wrote:\n> // doc comment\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode248\nbn256/bn256.go:248: func (out *GT) ScalarMult(a *GT, k *big.Int) *GT {\nOn 2012/07/17 00:06:54, r wrote:\n> ditto about 'out'\n\nDone.",
			"disapproval": false,
			"date": "2012-07-18 15:00:28.338780",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I don't mind it being in the subrepo. That's what the subrepo is for.\r\n\r\nThe package doc is a little odd - it reads almost like an apology. Can\r\nyou rephrase it to a 'just the facts ma'am', put in a more general\r\ncitation, and then add a separate comment with more detail along the\r\nlines of (but more expansive than) what you wrote here? So someone\r\ninterested enough to read the code can see more about it? That general\r\napproach keeps godoc output clean but gives context for the dedicated\r\nuser.\r\n\r\nI'll do a proper review later in the week.\r\n\r\n-rob\r\n",
			"disapproval": false,
			"date": "2012-07-18 15:17:00.599660",
			"approval": false
		},
		{
			"sender": "remyoudompheng@gmail.com",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"akumar@mail.nanosouffle.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6402052/diff/23001/bn256/optate.go\nFile bn256/optate.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/optate.go#newcode302\nbn256/optate.go:302: // finalExponentiation compuates the steps 13-15 of algorithm 1 from\nI would say that since GT is the group of Order-th roots of unity in GF(p^12):\n\nfinalExponentiation computes the (p\u00b9\u00b2-1)/Order-th power of an element of GF(p\u00b9\u00b2) to obtain an element of GT (steps 13-15 of...)",
			"disapproval": false,
			"date": "2012-07-21 22:58:57.788730",
			"approval": false
		},
		{
			"sender": "akumar@mail.nanosouffle.net",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 18 July 2012 08:00,  <agl@golang.org> wrote:\r\n> http://codereview.appspot.com/6402052/diff/2003/bn256/bn256.go#newcode162\r\n> bn256/bn256.go:162: // ScalarBaseMult sets out to g*k where g is the\r\n> generator of the group and\r\n> On 2012/07/17 00:06:54, r wrote:\r\n>>\r\n>> the use of 'out' as a receiver name is unidiomatic and renders these\r\n>\r\n> comments\r\n>>\r\n>> hard to parse.\r\n>\r\n>\r\n>> today i set out to do the following: to set out to g*k.\r\n>\r\n>\r\n> I've changed all the uses of |out| as a receiver to |e| and updated the\r\n> comments accordingly. ('e' for 'element' since they're elements of the\r\n> group.)\r\n\r\n`e' is usually the identity element when talking about abstract groups. :-P\r\n\r\n\r\nak\r\n",
			"disapproval": false,
			"date": "2012-07-18 17:02:08.044870",
			"approval": false
		},
		{
			"sender": "remyoudompheng@gmail.com",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"akumar@mail.nanosouffle.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "A first round of comments or possible suggestions. I didn't look at the elliptic curve part yet.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/bn256_test.go\nFile bn256/bn256_test.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/bn256_test.go#newcode160\nbn256/bn256_test.go:160: \nI suggest adding a stupid test like:\n\nfunc TestGenG2(t *testing.T) {\n      g := new(G2).ScalarBaseMult(Order)\n      if !g.p.IsInfinity() {\n            t.Error(\"twistPoint does have order n in G\u2082\")\n      }\n}\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/bn256_test.go#newcode196\nbn256/bn256_test.go:196: }\nMarshal/Unmarshal round trip fails for infinity points:\n\nfunc TestG2MarshalInfinity(t *testing.T) {\n      g := new(G2).ScalarBaseMult(Order)\n      if !g.p.IsInfinity() {\n            t.Error(\"not infinity\")\n      }\n      form := g.Marshal()\n      t.Logf(\"%+v\", form)\n      _, ok := new(G2).Unmarshal(form)\n      if !ok {\n            t.Fatalf(\"failed to unmarshal\")\n      }\n}\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/bn256_test.go#newcode197\nbn256/bn256_test.go:197: \nthe following test fails, why?\n\nfunc TestG2Identity(t *testing.T) {\n      g := new(G2).ScalarBaseMult(new(big.Int).SetInt64(0))\n      if !g.p.IsInfinity() {\n            t.Error(\"failure\")\n      }\n}\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/constants.go\nFile bn256/constants.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/constants.go#newcode16\nbn256/constants.go:16: // u is the BN parameter that determines the prime\nsince u is not written explicit in the reference paper, I suggest mentioning that u = 1868033\u00b3\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/constants.go#newcode19\nbn256/constants.go:19: // p is a prime over which we form a basic field.\nsimilarly, mention that p = 36u\u2074+36u\u00b3+24u\u00b3+6u+1 ?\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/constants.go#newcode37\nbn256/constants.go:37: // xiToPSquaredMinus1Over6 is \u03be^((p\u00b2-1)/6) where \u03be = i+3.\n(a cubic root of unity modulo p).\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/curve.go\nFile bn256/curve.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/curve.go#newcode12\nbn256/curve.go:12: // Jacobian form and t=z\u00b2 when valid.\n// G\u2081 is the set of points of this curve on GF(p).\n\n(or a similar sentence)\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/curve.go#newcode55\nbn256/curve.go:55: func (c *curvePoint) IsOnCurve() bool {\nthis function only works for points in affine form.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp12.go\nFile bn256/gfp12.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp12.go#newcode79\nbn256/gfp12.go:79: func (e *gfP12) Frobenius(a *gfP12, pool *bnPool) *gfP12 {\nComputes (x\u03c9+y)^p = x^p \u03c9\u00b7\u03be^((p-1)/6) + y^p\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp12.go#newcode86\nbn256/gfp12.go:86: func (e *gfP12) FrobeniusP2(a *gfP12, pool *bnPool) *gfP12 {\nF(a\u03c9+b) = F(a)\u00b7\u03c9^p\u00b2 + F(b) = F(a)\u00b7\u03c9\u00b7\u03be^(p\u00b2-1/6) + F(b)\nwhere does the negative come from?\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp2.go\nFile bn256/gfp2.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp2.go#newcode126\nbn256/gfp2.go:126: func (e *gfP2) MulElements(a *gfP2, b *big.Int) *gfP2 {\nMulElements looks weird to me. MulScalar or MulInt maybe?\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp2.go#newcode173\nbn256/gfp2.go:173: func (e *gfP2) Invert(a *gfP2, pool *bnPool) *gfP2 {\nmention that you are computing 1/(ai+b) = (-ai+b)/(a\u00b2+b\u00b2) ?\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp6.go\nFile bn256/gfp6.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp6.go#newcode86\nbn256/gfp6.go:86: func (e *gfP6) FrobeniusP2(a *gfP6) *gfP6 {\nComputes (x\u03c4\u00b2+y\u03c4+z)^(p\u00b2) = x\u03c4^(2p\u00b2) + y\u03c4^(p\u00b2) + z\nso y gets multiplied by \u03c4^(p\u00b2-1) = \u03be^(p\u00b2-1/3) = z\u00b2\n   x gets multiplied by \u03c4^2(p\u00b2-1) = z\u2074\n(where z = xiToPSquaredMinus1Over6)\n\nOh, wait, it's worth mentioning that z is a cubic root of unity.\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/gfp6.go#newcode184\nbn256/gfp6.go:184: func (e *gfP6) MulTau(a *gfP6, pool *bnPool) {\nseems obvious but it computes\n\u03c4\u00b7(a\u03c4\u00b2+b\u03c4+c) = b\u03c4\u00b2+c\u03c4+a\u03be\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/twist.go\nFile bn256/twist.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/twist.go#newcode12\nbn256/twist.go:12: // kept in Jacobian form and t=z\u00b2 when valid.\n// The group G\u2082 is the set of n-torsion points of this curve over GF(p\u00b2) (where n = Order)\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/twist.go#newcode22\nbn256/twist.go:22: // twistGen is the generator of group G\u2081.\ns/G\u2081/G\u2082/",
			"disapproval": false,
			"date": "2012-07-21 06:41:54.973640",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"akumar@mail.nanosouffle.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "remy's comments seem spot-on. otherwise LGTM",
			"disapproval": false,
			"date": "2012-07-21 16:26:44.324900",
			"approval": true
		},
		{
			"sender": "remyoudompheng@gmail.com",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"akumar@mail.nanosouffle.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6402052/diff/23001/bn256/curve.go\nFile bn256/curve.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode77\nbn256/curve.go:77: func (c *curvePoint) Add(a, b *curvePoint, pool *bnPool) {\nOh if a+b = infinity, h=0 too and the same problem occurs.\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/gfp6.go\nFile bn256/gfp6.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/gfp6.go#newcode243\nbn256/gfp6.go:243: // ftp://136.206.11.249/pub/crypto/pairings.pdf\nis that URL really persistent?\n\nHere we can give a short explanation of how it works: let j be a cubic root of unity in GF(p\u00b2) so that 1+j+j\u00b2=0.\nThen (x\u03c4\u00b2 + y\u03c4 + z)(xj\u00b2\u03c4\u00b2 + yj\u03c4 + z)(xj\u03c4\u00b2 + yj\u00b2\u03c4 + z)\n= (x\u03c4\u00b2 + y\u03c4 + z)(C\u03c4\u00b2+B\u03c4+A)\n= (x\u00b3\u03be\u00b2+y\u00b3\u03be+z\u00b3-3\u03bexyz) = F is an element of the base field (the norm).\n\nOn the other hand (xj\u00b2\u03c4\u00b2 + yj\u03c4 + z)(xj\u03c4\u00b2 + yj\u00b2\u03c4 + z)\n= \u03c4\u00b2(y\u00b2-\u03bexz) + \u03c4(\u03bex\u00b2-yz) + (z\u00b2-\u03bexy)\n\nSo that's why A = (z\u00b2-\u03bexy), B = (\u03bex\u00b2-yz), C = (y\u00b2-\u03bexz)",
			"disapproval": false,
			"date": "2012-07-21 20:23:34.633300",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"akumar@mail.nanosouffle.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6402052/diff/10002/bn256/curve.go\nFile bn256/curve.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/10002/bn256/curve.go#newcode238\nbn256/curve.go:238: c.t.SetInt64(0)\nOn 2012/07/21 19:42:00, remyoudompheng wrote:\n> why violate the assumption that t=z\u00b2 ? actually it doesn't seem to be used (nor\n> true) outside of the pairing computation anyway\n\nIt's used to save computation in the Tate function, but not otherwise. It's not worth maintaining it outside of that function and |t| is mostly a suitable place for the Tate function to store this value.\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go\nFile bn256/curve.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode77\nbn256/curve.go:77: func (c *curvePoint) Add(a, b *curvePoint, pool *bnPool) {\nOn 2012/07/21 19:42:00, remyoudompheng wrote:\n> The Add function is not suitable for a == b and will return zero coordinates if\n> it happens. This means that the following test (possible using public API\n> functions) will fail (so the fact should be documented or correctly handled by\n> redirecting to the Double function):\n> \n> func TestG1AddSelf(t *testing.T) {\n>   a := new(G1).ScalarBaseMult(new(big.Int).SetInt64(64))\n>   b := new(G1).Add(a, a)\n>   s := b.Marshal()\n>   _, ok := new(G1).Unmarshal(s)\n>   if !ok {\n>     t.Fatal(\"marshal of a\u00b7a failed\")\n>   }               \n> }\n\nI think the a+b=infinity case works fine, but you are correct that a+a doesn't. That's not usually a problem because we don't hit that case in the double-and-add loop for multiplication but, by exposing it to the world, we might.\n\nI think I'll land this code as is, but with a BUG marker for now. I want to investigate whether it's better to add a test in this code, or to try and find a complete function for addition on this curve. (I'm not aware if there is a complete function for a=0 curves, but I believe that there is for a=-3.)\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode88\nbn256/curve.go:88: z1z1 := pool.Get().Mul(a.z, a.z)\nOn 2012/07/21 19:42:00, remyoudompheng wrote:\n> I personnally prefer formulas over assembly-like programs so I try to suggest\n> comments that make it easier to digest (feel free to choose classical notations\n> for coordinates over mine): \n> \n> // Normalize the points by replacing a = [x1:y1:z1] and b = [x2:y2:z2]\n> // by [u1:s1:z1\u00b7z2] and [u2:s2:z1\u00b7z2]\n> // where u1 = x1\u00b7z2\u00b2, s1 = y1\u00b7z2\u00b3 and u1 = x2\u00b7z1\u00b2, s2 = y2\u00b7z1\u00b3\n\nHappy to import your comments wholesale. I'll add a pointer to twist.go rather than duplicating them there.\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/gfp6.go\nFile bn256/gfp6.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/gfp6.go#newcode243\nbn256/gfp6.go:243: // ftp://136.206.11.249/pub/crypto/pairings.pdf\nOn 2012/07/21 20:23:34, remyoudompheng wrote:\n> is that URL really persistent?\n\nIt's the only location that I (or Google) could find.\n\n> \n> Here we can give a short explanation of how it works: let j be a cubic root of\n> unity in GF(p\u00b2) so that 1+j+j\u00b2=0.\n> Then (x\u03c4\u00b2 + y\u03c4 + z)(xj\u00b2\u03c4\u00b2 + yj\u03c4 + z)(xj\u03c4\u00b2 + yj\u00b2\u03c4 + z)\n> = (x\u03c4\u00b2 + y\u03c4 + z)(C\u03c4\u00b2+B\u03c4+A)\n> = (x\u00b3\u03be\u00b2+y\u00b3\u03be+z\u00b3-3\u03bexyz) = F is an element of the base field (the norm).\n> \n> On the other hand (xj\u00b2\u03c4\u00b2 + yj\u03c4 + z)(xj\u03c4\u00b2 + yj\u00b2\u03c4 + z)\n> = \u03c4\u00b2(y\u00b2-\u03bexz) + \u03c4(\u03bex\u00b2-yz) + (z\u00b2-\u03bexy)\n> \n> So that's why A = (z\u00b2-\u03bexy), B = (\u03bex\u00b2-yz), C = (y\u00b2-\u03bexz)\n\nThanks! Have copied that in.\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/optate.go\nFile bn256/optate.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/optate.go#newcode302\nbn256/optate.go:302: // finalExponentiation compuates the steps 13-15 of algorithm 1 from\nOn 2012/07/21 22:58:57, remyoudompheng wrote:\n> I would say that since GT is the group of Order-th roots of unity in GF(p^12):\n> \n> finalExponentiation computes the (p\u00b9\u00b2-1)/Order-th power of an element of GF(p\u00b9\u00b2)\n> to obtain an element of GT (steps 13-15 of...)\n\nDone.\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/twist.go\nFile bn256/twist.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/twist.go#newcode100\nbn256/twist.go:100: // See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/addition/add-2007-bl.op3\nOn 2012/07/21 19:42:00, remyoudompheng wrote:\n> it seems the code is identical to the non-twisted curve so no need for extra\n> comments here.\n\nYes. I did originally use interfaces to eliminate this code duplication, but it made a mess and, in the end, I decided that duplicating the code was the lesser of the two evils.",
			"disapproval": false,
			"date": "2012-07-24 23:18:45.475120",
			"approval": false
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"akumar@mail.nanosouffle.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/6402052/diff/23001/bn256/curve.go\nFile bn256/curve.go (right):\n\nhttp://codereview.appspot.com/6402052/diff/23001/bn256/curve.go#newcode77\nbn256/curve.go:77: func (c *curvePoint) Add(a, b *curvePoint, pool *bnPool) {\nOn 2012/07/24 23:18:45, agl1 wrote:\n> I think I'll land this code as is, but with a BUG marker for now. I want to\n> investigate whether it's better to add a test in this code, or to try and find a\n> complete function for addition on this curve. (I'm not aware if there is a\n> complete function for a=0 curves, but I believe that there is for a=-3.)\n\nI forgot to hit `send' on the previous set of comments, but I've checked into complete formulas and they're more trouble than they're worth for these curves. So I've added a test that, if the x and y values are equal, we call Double. The formula does work for P+(-P).",
			"disapproval": false,
			"date": "2012-07-24 23:20:32.463110",
			"approval": false
		},
		{
			"sender": "remyoudompheng@gmail.com",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"akumar@mail.nanosouffle.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM",
			"disapproval": false,
			"date": "2012-07-25 04:27:22.963530",
			"approval": true
		},
		{
			"sender": "agl@golang.org",
			"recipients": [
				"agl@golang.org",
				"golang-dev@googlegroups.com",
				"remyoudompheng@gmail.com",
				"r@google.com",
				"r@golang.org",
				"akumar@mail.nanosouffle.net",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=c349712b1885&repo=crypto ***\n\nbn256: add package\n\nPackage bn256 implements a particular bilinear group at the 128-bit\nsecurity level.\n\nR=golang-dev, remyoudompheng, r, r, akumar\nCC=golang-dev\nhttp://codereview.appspot.com/6402052",
			"disapproval": false,
			"date": "2012-07-27 16:55:13.402100",
			"approval": false
		}
	],
	"owner_email": "agl@golang.org",
	"private": false,
	"base_url": "",
	"owner": "agl1",
	"subject": "code review 6402052: bn256: add package",
	"created": "2012-07-16 19:06:07.351940",
	"patchsets": [
		1,
		2001,
		5001,
		2003,
		10002,
		23001,
		28001,
		31003
	],
	"modified": "2012-07-27 16:55:14.516790",
	"closed": true,
	"issue": 6402052
}