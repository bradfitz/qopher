{
	"description": "runtime, syscall, os: add os.Executable() (string, error)\nwhich returns the path of the current executable.\n\nFixes issue 4057.",
	"cc": [
		"golang-dev@googlegroups.com",
		"ality@pbrane.org"
	],
	"reviewers": [
		"bradfitz@golang.org",
		"remyoudompheng@gmail.com",
		"alex.brainman@gmail.com",
		"taruti@taruti.net",
		"kardianos@gmail.com",
		"rsc@golang.org",
		"r@golang.org",
		"jsing@google.com",
		"aram@mgk.ro"
	],
	"messages": [
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Oct 24, 2012 at 3:48 AM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n>\r\n> On Tue, Oct 23, 2012 at 12:37 PM, minux <minux.ma@gmail.com> wrote:\r\n>\r\n>>\r\n>> On Wed, Oct 24, 2012 at 3:27 AM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n>>\r\n>>> I like the API addition, but the name sounds too imperative to me (like\r\n>>> it's going to try go \"exec\" the provided path).  It doesn't sound like a\r\n>>> getter.\r\n>>\r\n>> How about GetExecPath() or GetProcPath() ?\r\n>>\r\n>\r\n> Go generally avoids the prefix \"Get\".  The existing functions named \"Get\"\r\n> in the os package are named after common libc/syscall functions.\r\n>\r\nhow about os.CurrentExecutablePath() ?\r\n\r\nthis function won't be frequently used, so a slightly longer name is\r\nacceptable imo.\r\n",
			"disapproval": false,
			"date": "2012-10-23 19:56:15.287990",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Oct 24, 2012 at 3:27 AM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n\r\n> I like the API addition, but the name sounds too imperative to me (like\r\n> it's going to try go \"exec\" the provided path).  It doesn't sound like a\r\n> getter.\r\n\r\nHow about GetExecPath() or GetProcPath() ?\r\n",
			"disapproval": false,
			"date": "2012-10-23 19:37:48.847040",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I'd like to solicit opinion about the name and signature of the new func.\n\npackage os\n    import \"os\"\n\nFUNCTIONS\nfunc ExecPath() (string, error)\n    ExecPath returns the absolute pathname of the current executing file; if\n    error occurs, it will return whatever it current gets and the error.",
			"disapproval": false,
			"date": "2012-10-23 19:05:44.486160",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6736069/diff/8005/src/pkg/os/execpath_windows.go\nFile src/pkg/os/execpath_windows.go (right):\n\nhttps://codereview.appspot.com/6736069/diff/8005/src/pkg/os/execpath_windows.go#newcode11\nsrc/pkg/os/execpath_windows.go:11: // ExecPath returns the absolute pathname of the current\nI would only document this once, in a common file, like:\n\n// ExecPath returns ...\nfunc ExecPath() (string, error) {\n   return execPath()\n}\n\nAnd then implement the lowercase OS-specific execPath in +build-restricted files.",
			"disapproval": false,
			"date": "2012-10-23 19:27:40.195630",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I like the API addition, but the name sounds too imperative to me (like\r\nit's going to try go \"exec\" the provided path).  It doesn't sound like a\r\ngetter.\r\n\r\nOn Tue, Oct 23, 2012 at 12:05 PM, <minux.ma@gmail.com> wrote:\r\n\r\n> I'd like to solicit opinion about the name and signature of the new\r\n> func.\r\n>\r\n> package os\r\n>     import \"os\"\r\n>\r\n> FUNCTIONS\r\n> func ExecPath() (string, error)\r\n>     ExecPath returns the absolute pathname of the current executing\r\n> file; if\r\n>     error occurs, it will return whatever it current gets and the error.\r\n>\r\n> https://codereview.appspot.**com/6736069/<https://codereview.appspot.com/6736069/>\r\n>\r\n",
			"disapproval": false,
			"date": "2012-10-23 19:27:57.846410",
			"approval": false
		},
		{
			"sender": "remyoudompheng@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "What about \"ProgramPath\"? unless program is ambiguous and could refer to source code?",
			"disapproval": false,
			"date": "2012-10-23 21:35:17.762180",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Oct 23, 2012 at 12:37 PM, minux <minux.ma@gmail.com> wrote:\r\n\r\n>\r\n> On Wed, Oct 24, 2012 at 3:27 AM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n>\r\n>> I like the API addition, but the name sounds too imperative to me (like\r\n>> it's going to try go \"exec\" the provided path).  It doesn't sound like a\r\n>> getter.\r\n>\r\n> How about GetExecPath() or GetProcPath() ?\r\n>\r\n\r\nGo generally avoids the prefix \"Get\".  The existing functions named \"Get\"\r\nin the os package are named after common libc/syscall functions.\r\n",
			"disapproval": false,
			"date": "2012-10-23 19:48:54.900710",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com (cc: golang-dev@googlegroups.com),\n\nI'd like you to review this change to\nhttps://code.google.com/p/go/",
			"disapproval": false,
			"date": "2012-10-23 19:04:12.186160",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Tue, Oct 23, 2012 at 12:55 PM, minux <minux.ma@gmail.com> wrote:\r\n\r\n>\r\n> On Wed, Oct 24, 2012 at 3:48 AM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n>>\r\n>> On Tue, Oct 23, 2012 at 12:37 PM, minux <minux.ma@gmail.com> wrote:\r\n>>\r\n>>>\r\n>>> On Wed, Oct 24, 2012 at 3:27 AM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n>>>\r\n>>>> I like the API addition, but the name sounds too imperative to me (like\r\n>>>> it's going to try go \"exec\" the provided path).  It doesn't sound like a\r\n>>>> getter.\r\n>>>\r\n>>> How about GetExecPath() or GetProcPath() ?\r\n>>>\r\n>>\r\n>> Go generally avoids the prefix \"Get\".  The existing functions named \"Get\"\r\n>> in the os package are named after common libc/syscall functions.\r\n>>\r\n> how about os.CurrentExecutablePath() ?\r\n>\r\n> this function won't be frequently used, so a slightly longer name is\r\n> acceptable imo.\r\n>\r\n\r\n\"Current\" implies that it can change over time.  Which I guess is true, if\r\nchroot is called?\r\n\r\nCurrentExecutablePath seems okay to me, if a little long, but I defer to\r\nothers.\r\n",
			"disapproval": false,
			"date": "2012-10-23 21:33:26.170120",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Oct 24, 2012 5:33 AM, \"Brad Fitzpatrick\" <bradfitz@golang.org> wrote:\r\n> \"Current\" implies that it can change over time.  Which I guess is true,\r\nif chroot is called?\r\nunfortunately, at least on some systems the value won't change over time.\r\n> CurrentExecutablePath seems okay to me, if a little long, but I defer to\r\nothers.\r\nhow about StartupExecutablePath() then?\r\nit emphasizes that the returned value is corresponding\r\nto the moment the program starts, which is correct\r\nmeaning.\r\n\r\noh, it seems we must store cwd at program start to\r\ngive accurate path (some machenisms can return\r\nrelative paths).\r\n",
			"disapproval": false,
			"date": "2012-10-24 04:15:53.947580",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Oct 24, 2012 5:35 AM, <remyoudompheng@gmail.com> wrote:\r\n> What about \"ProgramPath\"? unless program is ambiguous and could refer to\r\n> source code?\r\ni think it's ok. but i'd prefer StartupProgramPath\r\nnow.\r\n",
			"disapproval": false,
			"date": "2012-10-24 04:18:06.811480",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6736069/diff/32004/src/pkg/os/progpath_test.go\nFile src/pkg/os/progpath_test.go (right):\n\nhttps://codereview.appspot.com/6736069/diff/32004/src/pkg/os/progpath_test.go#newcode12\nsrc/pkg/os/progpath_test.go:12: oexec \"os/exec\"\nYou didn't tell me why you are renaming \"os/exec\" to oexec.",
			"disapproval": false,
			"date": "2012-10-25 06:25:09.058110",
			"approval": false
		},
		{
			"sender": "taruti@taruti.net",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "We frequently run go things inside chroots without /proc - please don't make this impossible. Just having this API does not break things, but any code in the stdlib depending on this working would be nasty.",
			"disapproval": false,
			"date": "2012-10-24 07:30:00.859370",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "ProcessPath is the best name I've heard.\r\n\r\nOn Wed, Oct 24, 2012 at 9:23 AM, Daniel Theophanes <kardianos@gmail.com>wrote:\r\n\r\n> I'd personally like this to go it. If there is a dependency on /proc on\r\n> linux, then we can document that as a BUG for now(?). I've already coded\r\n> similar code for linux,windows, and osx (using cgo), so I personally\r\n> require and use the functionality this provides on multiple platforms. I\r\n> think this would also be fine for a go get package, but osx requires\r\n> runtime changes for this to work without cgo.\r\n>\r\n> name suggestion? ProcessFilePath(), ProcessPath()\r\n>\r\n> Use cases for this call:\r\n>  * Get a path to the exec when creating a \"service\" on windows, upstart,\r\n> launchd.\r\n>  * I often bundle resources next to the exec for easy deployment.\r\n>    Without this I have to watch my working directory when I call it. Not\r\n> horrible,\r\n>    but much easier just to get the path the OS already knows, no guesswork\r\n> required,\r\n>    same deployment on all systems.\r\n>\r\n> .. I understand these use cases are not relevant for many projects for\r\n> many people, but they\r\n> are useful to me, especially when I have a number of smaller one off\r\n> projects on different platforms,\r\n> it greatly simplifies my code and deployment to use this functionality...\r\n>\r\n>\r\n> On Wednesday, October 24, 2012 1:12:43 AM UTC-7, minux wrote:\r\n>>\r\n>> On 2012/10/24 07:30:00, taruti wrote:\r\n>> > We frequently run go things inside chroots without /proc - please\r\n>> don't make\r\n>> > this impossible. Just having this API does not break things, but any\r\n>> code in the\r\n>> the fact that this API depends on procfs doesn't mean you cannot run Go\r\n>> programs\r\n>> without procfs, you just cannot use the new API.\r\n>> > stdlib depending on this working would be nasty.\r\n>> Why? procfs is standard part of Linux, and lots of things will break if\r\n>> it's missing.\r\n>> I think you must understand this implication when you chroot to a\r\n>> directory\r\n>> without procfs.\r\n>>\r\n>> for instance, the os package is already using /proc/sys/kernel/hostname\r\n>> to\r\n>> get the hostname. Because procfs is a integrated part of linux, there\r\n>> are problems\r\n>> that are not solvable without it (for example, ps(1)), AFAIK.\r\n>>\r\n>> However, if you could provide a portable way to implement this API on\r\n>> Linux\r\n>> without resorting to procfs, i'd like to adapt it.\r\n>> (by portable, I mean it needs to support Linux 2.6.23+)\r\n>>\r\n>> https://codereview.appspot.**com/6736069/<https://codereview.appspot.com/6736069/>\r\n>>\r\n>\r\n",
			"disapproval": false,
			"date": "2012-10-24 20:08:05.881690",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM,\n\nbut wait for others.\n\nAlex\n\nhttp://codereview.appspot.com/6736069/diff/16026/src/pkg/os/execpath_test.go\nFile src/pkg/os/execpath_test.go (right):\n\nhttp://codereview.appspot.com/6736069/diff/16026/src/pkg/os/execpath_test.go#newcode12\nsrc/pkg/os/execpath_test.go:12: oexec \"os/exec\"\nwhy rename?\n\nhttp://codereview.appspot.com/6736069/diff/16026/src/pkg/os/execpath_test.go#newcode21\nsrc/pkg/os/execpath_test.go:21: t.Errorf(\"ExecPath failed: %v\", err)\ns/Errorf/Fatalf/\n\nthen you will not need the following \"return\".\n\nSame everywhere else.\n\nhttp://codereview.appspot.com/6736069/diff/16026/src/pkg/syscall/syscall_windows.go\nFile src/pkg/syscall/syscall_windows.go (right):\n\nhttp://codereview.appspot.com/6736069/diff/16026/src/pkg/syscall/syscall_windows.go#newcode774\nsrc/pkg/syscall/syscall_windows.go:774: func GetModuleFileName(handle Handle) (string, error) {\nPlease, move this to os. Provide GetModuleFileName, as it is published in windows api, instead.\n\nhttp://codereview.appspot.com/6736069/diff/16026/src/pkg/syscall/syscall_windows.go#newcode783\nsrc/pkg/syscall/syscall_windows.go:783: if r == n {\nI would revert the condition and break first. Then you will not need continue.",
			"disapproval": false,
			"date": "2012-10-24 04:19:15.016390",
			"approval": true
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "thank you.\r\n\r\nOn Oct 24, 2012 12:19 PM, <alex.brainman@gmail.com> wrote:\r\n>\r\nhttp://codereview.appspot.com/6736069/diff/16026/src/pkg/os/execpath_test.go#newcode12\r\n> src/pkg/os/execpath_test.go:12: oexec \"os/exec\"\r\n> why rename?\r\nbecause the os package has a function named exec.\r\n\r\n>\r\nhttp://codereview.appspot.com/6736069/diff/16026/src/pkg/syscall/syscall_windows.go#newcode774\r\n> src/pkg/syscall/syscall_windows.go:774: func GetModuleFileName(handle\r\n> Handle) (string, error) {\r\n> Please, move this to os. Provide GetModuleFileName, as it is published\r\n> in windows api, instead.\r\ni think os is just for portable functions.\r\ndoesn't this function belong to pkg syscall?\r\n\r\ni can export the original verion of the api in\r\nsyscall, but the user still needs to write some\r\ncode to use it in Go properly.\r\n\r\nbtw, what's your opinion about the new api?\r\ndo you have suggestions about its name?\r\n",
			"disapproval": false,
			"date": "2012-10-24 04:31:11.947140",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Oct 25, 2012 at 2:25 PM, <alex.brainman@gmail.com> wrote:\r\n\r\n> https://codereview.appspot.**com/6736069/diff/32004/src/**\r\n> pkg/os/progpath_test.go#**newcode12<https://codereview.appspot.com/6736069/diff/32004/src/pkg/os/progpath_test.go#newcode12>\r\n> src/pkg/os/progpath_test.go:**12: oexec \"os/exec\"\r\n> You didn't tell me why you are renaming \"os/exec\" to oexec.\r\n>\r\nhttps://codereview.appspot.com/6736069/#msg13\r\n\r\nthere is a function named exec in pkg os_test (file os_test.go).\r\n",
			"disapproval": false,
			"date": "2012-10-25 06:29:50.600180",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/10/24 04:31:11, minux wrote:\n> > ...\n> > Please, move this to os. Provide GetModuleFileName, as it is published\n> > in windows api, instead.\n> i think os is just for portable functions.\n> doesn't this function belong to pkg syscall?\n\nDo not export os.GetModuleFileName. You already have *_windows.go file - put all your code in there. And do not export it from os.\n\n> \n> i can export the original verion of the api in\n> syscall, ...\n\nYes, please leave api as per Microsoft documentation (just leave //sys line). If someone decides to use it in some particular way, it is as documented.\n\n> ... but the user still needs to write some\n> code to use it in Go properly.\n\nSure. This is syscall package - no batteries included. :-)\n\n> ... \n> do you have suggestions about its name?\n\nGetppath. Just joking.\nI do not have good suggestions.\n\nAlex",
			"disapproval": false,
			"date": "2012-10-24 05:47:25.791740",
			"approval": false
		},
		{
			"sender": "kardianos@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I'd personally like this to go it. If there is a dependency on /proc on \r\nlinux, then we can document that as a BUG for now(?). I've already coded \r\nsimilar code for linux,windows, and osx (using cgo), so I personally \r\nrequire and use the functionality this provides on multiple platforms. I \r\nthink this would also be fine for a go get package, but osx requires \r\nruntime changes for this to work without cgo.\r\n\r\nname suggestion? ProcessFilePath(), ProcessPath()\r\n\r\nUse cases for this call:\r\n * Get a path to the exec when creating a \"service\" on windows, upstart, \r\nlaunchd.\r\n * I often bundle resources next to the exec for easy deployment.\r\n   Without this I have to watch my working directory when I call it. Not \r\nhorrible,\r\n   but much easier just to get the path the OS already knows, no guesswork \r\nrequired,\r\n   same deployment on all systems.\r\n\r\n.. I understand these use cases are not relevant for many projects for many \r\npeople, but they\r\nare useful to me, especially when I have a number of smaller one off \r\nprojects on different platforms,\r\nit greatly simplifies my code and deployment to use this functionality...\r\n\r\n\r\nOn Wednesday, October 24, 2012 1:12:43 AM UTC-7, minux wrote:\r\n>\r\n> On 2012/10/24 07:30:00, taruti wrote: \r\n> > We frequently run go things inside chroots without /proc - please \r\n> don't make \r\n> > this impossible. Just having this API does not break things, but any \r\n> code in the \r\n> the fact that this API depends on procfs doesn't mean you cannot run Go \r\n> programs \r\n> without procfs, you just cannot use the new API. \r\n> > stdlib depending on this working would be nasty. \r\n> Why? procfs is standard part of Linux, and lots of things will break if \r\n> it's missing. \r\n> I think you must understand this implication when you chroot to a \r\n> directory \r\n> without procfs. \r\n>\r\n> for instance, the os package is already using /proc/sys/kernel/hostname \r\n> to \r\n> get the hostname. Because procfs is a integrated part of linux, there \r\n> are problems \r\n> that are not solvable without it (for example, ps(1)), AFAIK. \r\n>\r\n> However, if you could provide a portable way to implement this API on \r\n> Linux \r\n> without resorting to procfs, i'd like to adapt it. \r\n> (by portable, I mean it needs to support Linux 2.6.23+) \r\n>\r\n> https://codereview.appspot.com/6736069/ \r\n>\r\n",
			"disapproval": false,
			"date": "2012-10-24 16:23:37.213920",
			"approval": false
		},
		{
			"sender": "alex.brainman@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/10/25 06:29:50, minux wrote:\n> ...\n> there is a function named exec in pkg os_test (file os_test.go).\n\nAh, yes. Thank you. :-)\n\nAlex",
			"disapproval": false,
			"date": "2012-10-25 06:32:08.029720",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL. Patch Set 22 is using the name ProgramPath.\n\nI've tested on Mac OS X 10.6/amd64, Linux/amd64, FreeBSD 9/amd64,\nNetBSD 6/amd64, Windows/386.\n(OpenBSD is known to fail, because it doesn't provide procfs by default,\nand I couldn't find an alternative way)",
			"disapproval": false,
			"date": "2012-10-25 05:38:17.340260",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/10/24 07:30:00, taruti wrote:\n> We frequently run go things inside chroots without /proc - please don't make\n> this impossible. Just having this API does not break things, but any code in the\nthe fact that this API depends on procfs doesn't mean you cannot run Go programs\nwithout procfs, you just cannot use the new API.\n> stdlib depending on this working would be nasty.\nWhy? procfs is standard part of Linux, and lots of things will break if it's missing.\nI think you must understand this implication when you chroot to a directory\nwithout procfs.\n\nfor instance, the os package is already using /proc/sys/kernel/hostname to\nget the hostname. Because procfs is a integrated part of linux, there are problems\nthat are not solvable without it (for example, ps(1)), AFAIK.\n\nHowever, if you could provide a portable way to implement this API on Linux\nwithout resorting to procfs, i'd like to adapt it.\n(by portable, I mean it needs to support Linux 2.6.23+)",
			"disapproval": false,
			"date": "2012-10-24 08:12:42.499560",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Sorry, but ProcessPath sounds like you are processing a path. Let's\r\nwait on this until Rob's back (next week).\r\n",
			"disapproval": false,
			"date": "2012-10-25 21:16:49.627560",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "how about \"Executable\"?\r\n",
			"disapproval": false,
			"date": "2012-10-26 16:26:49.738510",
			"approval": false
		},
		{
			"sender": "ality@pbrane.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "minux.ma@gmail.com once said:\r\n> On 2012/10/29 01:06:08, ality wrote:\r\n> >> btw, how to implement this on Plan 9?\r\n> >func executable() (string, error) {\r\n> >\tf, err := Open(\"/proc/\" + itoa(Getpid()) + \"/text\")\r\n> >\tif err != nil {\r\n> >\t\treturn \"\", err\r\n> >\t}\r\n> >\tdefer f.Close()\r\n> >\treturn syscall.Fd2path(int(f.Fd()))\r\n> >}\r\n> Thank you. I originally assumed fd2path on /proc/PID/text would\r\n> return \"/proc/PID/text\".\r\n\r\nYeah, that's a reasonable assumption but the man page for\r\nfd2path(2) is careful with its words. There are only a few\r\nplaces in the kernel where this distinction is made. The\r\nprime example is the dup(3) device: when you open either\r\nof the fd files, a reference to the underlying channel is\r\nreturned.\r\n\r\nIt's similar for /proc/$pid/text.\r\n\r\nWhen you call exec(2) on an executable file, the kernel\r\nopens the file internally and saves a reference to the\r\ncorresponding channel (along with some other state) into\r\nsomething called the \"image cache\". Then, when you open\r\n/proc/$pid/text, the original channel is retrieved from\r\nthe cache and returned.\r\n",
			"disapproval": false,
			"date": "2012-10-30 21:13:50.722890",
			"approval": false
		},
		{
			"sender": "kardianos@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Would it be possible to get in a CL just for darwin, and only have the call\r\nin syscall?\r\n\r\n\r\nOn Fri, Nov 2, 2012 at 1:20 PM, Russ Cox <rsc@golang.org> wrote:\r\n\r\n> There is enough disagreement about this that I would like to leave it\r\n> for a 3rd-party package to implement, at least for now. I don't want\r\n> to add an API that we'll be stuck with and regret.\r\n>\r\n> Thanks.\r\n> Russ\r\n>\r\n",
			"disapproval": false,
			"date": "2012-11-02 20:23:38.180280",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Saturday, October 27, 2012, Rob Pike wrote:\r\n\r\n> how about \"Executable\"?\r\n>\r\nwithout mentioning path?\r\n",
			"disapproval": false,
			"date": "2012-10-26 16:31:18.510750",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Oct 26, 2012 at 9:31 AM, minux <minux.ma@gmail.com> wrote:\r\n>\r\n> On Saturday, October 27, 2012, Rob Pike wrote:\r\n>>\r\n>> how about \"Executable\"?\r\n>\r\n> without mentioning path?\r\n\r\nis your name minuxName?\r\n\r\n-rob\r\n",
			"disapproval": false,
			"date": "2012-10-26 16:36:37.415270",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/10/28 15:48:45, r wrote:\n> The file names are inappropriate now.\ndo you have suggestions for the filenames? i think executable is\na bit too long, and exec might confuse with the exec syscall.\nhow about the original execpath?\n\n> For Plan 9, it depends what you want this for. /proc/PID/text is\n> always a working name for the executable. Otherwise I don't know if\n> it's possible.\nI've thought about /proc/PID/text, in fact it can pass the test, but\ni think the main use of this to determine the original binary's path\nso that the binary can access its bundled asset files, for example.\n\ni'd also like to test we can indeed find the other files around the\nbinary, but given the current go test's behavior, this is difficult\nto test.",
			"disapproval": false,
			"date": "2012-10-28 15:57:44.815250",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/10/28 17:47:49, r wrote:\nhttps://codereview.appspot.com/6736069/diff/43014/src/pkg/os/executable.go#newcode7\n> src/pkg/os/executable.go:7: // Executable returns the absolute pathname of the\n> current\n> \"the absolute pathname\" sounds definitive but is actually not well-defined.\ni agree it is difficult to define its precise behavior.\nhowever, i think the following description is reasonable:\nthe return value of Executable is an absolute path that matches the path used\nto launch the executable (assuming no one is modifying the intermediate paths).\n\nhttps://codereview.appspot.com/6736069/diff/43014/src/pkg/os/executable_darwin.go#newcode7\n> src/pkg/os/executable_darwin.go:7: var progPath string // set by\n> ../runtime/progpath_darwin.c\n> you've still got some progpaths around, in different casings.\nAll fixed.",
			"disapproval": false,
			"date": "2012-10-28 18:18:41.019640",
			"approval": false
		},
		{
			"sender": "kardianos@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "This is what I currently use this call for on Windows, Linux, and darwin \r\nright now:\r\n\r\n * Get a path to the exec when creating a \"service\" on windows, upstart, \r\nlaunchd.\r\n * I often bundle resources next to the exec for easy deployment.\r\n   Without this I have to watch my working directory when I call it. Not \r\nhorrible,\r\n   but much easier just to get the path the OS already knows, no guesswork \r\nrequired,\r\n   same deployment on all systems.\r\n\r\nPrior to this\r\n * On Linux I had to be sure to set the WD before starting (with nohup).\r\n * Couldn't get related files without this on Windows at all when running \r\nas a windows service.\r\n\r\nDoes this answer your question?\r\n\r\nThanks,\r\n-Daniel\r\n\r\n\r\nOn Tuesday, October 30, 2012 8:46:40 PM UTC-7, Rob Pike wrote:\r\n>\r\n> No one has answered Russ's question (and mine). What is this _for_? \r\n>\r\n> -rob \r\n>\r\n",
			"disapproval": false,
			"date": "2012-10-31 03:52:43.943960",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"ality@pbrane.org",
				"jsing@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL. All supported OSes have working implementations now.\nExcept perhaps OpenBSD, where procfs is not mounted by\ndefault, but I don't know any alternatives.\n\n+jsing.\n\nOn 2012/10/29 01:06:08, ality wrote:\n> > btw, how to implement this on Plan 9? \n> func executable() (string, error) {\n> \tf, err := Open(\"/proc/\" + itoa(Getpid()) + \"/text\")\n> \tif err != nil {\n> \t\treturn \"\", err\n> \t}\n> \tdefer f.Close()\n> \treturn syscall.Fd2path(int(f.Fd()))\n> }\nThank you. I originally assumed fd2path on /proc/PID/text would\nreturn \"/proc/PID/text\".",
			"disapproval": false,
			"date": "2012-10-30 15:50:03.635630",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "The complexity of the implementation needs to be paid for by general\r\nutility. I haven't heard anyone claiming they need or would use this\r\nfunction (except to find associated files, which I don't want to\r\nsupport this way).\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2012-11-01 17:30:33.600810",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "The file names are inappropriate now.\r\n\r\nFor Plan 9, it depends what you want this for. /proc/PID/text is\r\nalways a working name for the executable. Otherwise I don't know if\r\nit's possible.\r\n\r\n-rob\r\n",
			"disapproval": false,
			"date": "2012-10-28 15:48:45.686830",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL.\n\nPatch Set 24 is the same as Patch Set 23 except\ns/progpath/executable/ in filenames.",
			"disapproval": false,
			"date": "2012-10-28 17:35:09.074810",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"minux.ma@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"ality@pbrane.org",
				"jsing@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/6736069/diff/37032/src/pkg/os/executable.go\nFile src/pkg/os/executable.go (right):\n\nhttps://codereview.appspot.com/6736069/diff/37032/src/pkg/os/executable.go#newcode7\nsrc/pkg/os/executable.go:7: // Executable returns the absolute pathname of the current\nIn general this is impossible, of course, so it would be nice to be more specific about what the return value is good for. \n\nFor example, if we wrote:\n// Executable returns a path that can be used to reinvoke the current program.\n// It may not be valid after the current program exits.\n\nthen on Linux you could just return \"/proc/PID/exe\" and on Plan 9 \"/proc/PID/text\". \n\nOn the other hand, if there are subtler reasons for wanting this information, like trying to find associated files, then we'd need to be more clear that those are not acceptable answers. Personally, I don't believe we should try to support that use case, so my inclination would be to use just the description above and not do any kind of readlink or fd2path or anything like that.",
			"disapproval": false,
			"date": "2012-10-30 21:29:45.464240",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Using \"Executable\" to find related files bothers me quite a bit. I\r\nthink Go doesn't have a good story for finding associated files, but\r\nif we want to address that I think we should do it head on instead of\r\nslipping it into a mostly unrelated function.\r\n\r\nIf this were just for re-running the current executable I wouldn't\r\nmind. But it sounds like that's not why people want it. So my\r\ninclination is to leave it out for now.\r\n",
			"disapproval": false,
			"date": "2012-11-01 16:46:51.088590",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Nov 2, 2012 at 5:59 PM, Aram H\u0103v\u0103rneanu <aram@mgk.ro> wrote:\r\n\r\n> A very big -1 on this change.  The original problem was \"how to find\r\n> assets bundled with binaries\", a potentially valid concern, but when\r\n> we found we can't solve that problem with the input we had, we decided\r\n> to search for a new problem that fit the already implemented solution,\r\n> \"how to return a absolute path to re-invoke the same program\", a\r\n> problem no one asked.\r\n>\r\nAs I've explained, my original patch set does implement the required\r\nbehavior\r\non all supported OSes.\r\nThe problem is how to write correct document for it (e.g. how to precisely\r\ndefine the behavior).\r\n\r\n>\r\n> The semantics are different on each operating system, and on Plan 9\r\n> they don't make sense at all.\r\n>\r\nWhy they don't make sense on Plan 9?\r\n\r\nTo obtain proper asset filepath, you can do this to path obtained from\r\nExecutable:\r\nOn Unix, just readlink the returned path.\r\nOn Plan 9, you need to open that file, and fd2path.\r\nOn Windows, you don't need to do anything.\r\n",
			"disapproval": false,
			"date": "2012-11-02 12:07:30.226850",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2012/10/26 16:36:37, r wrote:\n> is your name minuxName?\ngood point. PTAL.\n\nbtw, how to implement this on Plan 9?",
			"disapproval": false,
			"date": "2012-10-28 15:43:54.234940",
			"approval": false
		},
		{
			"sender": "kardianos@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "As an observation, what you have mentioned is true, but is true for\r\nany path related api, such as os,Getwd(), or even os.Open. You don't\r\nactually know for sure that is correct until tested. And granted, some\r\nsituations the path is more unstable then others. As an observer, I\r\ncontinue to not see the argument against it, though I understand it\r\nmay not be useful to you. But this being my last comment here, should\r\nthis not go in, I'll move what I can (most everything except darwin)\r\ninto a third party package (if that's alright with minux to use his\r\ncode for some of the platforms I don't have).\r\n\r\n-Daniel\r\n\r\n\r\nOn Oct 30, 2012 2:46 PM, \"Rob Pike\" <r@golang.org> wrote:\r\n>\r\n> Names are not unique, well-defined, or stable. It's the kind of thing\r\n> that usually works but won't always, and the failures will be subtle.\r\n> Code that depends on this interface will be buggy and maybe insecure.\r\n>\r\n> -rob\r\n",
			"disapproval": false,
			"date": "2012-10-31 03:42:01.614880",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "No one has answered Russ's question (and mine). What is this _for_?\r\n\r\n-rob\r\n",
			"disapproval": false,
			"date": "2012-10-31 03:46:35.251640",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Let's leave 4057 as priority-someday. Thanks.\r\n",
			"disapproval": false,
			"date": "2012-11-06 19:35:30.521480",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Names are not unique, well-defined, or stable. It's the kind of thing\r\nthat usually works but won't always, and the failures will be subtle.\r\nCode that depends on this interface will be buggy and maybe insecure.\r\n\r\n-rob\r\n",
			"disapproval": false,
			"date": "2012-10-30 21:46:03.781050",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Nov 2, 2012 at 1:23 AM, Russ Cox <rsc@golang.org> wrote:\r\n\r\n> If we limit Executable to that smaller scope it sounds like no one\r\n> wants it anymore. So I would be inclined to leave it out.\r\n>\r\nDarwin, FreeBSD, Windows and Plan 9 all have non-trivial implementation for\r\nos.Executable (e.g. don't return a constant string)\r\n",
			"disapproval": false,
			"date": "2012-11-01 17:26:46.084220",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"minux.ma@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"ality@pbrane.org",
				"jsing@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL.\n\nOn 2012/11/01 17:49:57, rsc wrote:\n> If you change the doc comment to\n> // Executable returns a path that can be used to reinvoke the current\n> program.\n> // It may not be valid after the current program exits.\n> \n> and simplify the Plan 9 and Linux implementations, then I'll go along with\n> this.\n> (On Plan 9 use /proc/+itoa(pid)+/text.)\nDone.\n\nOn 2012/11/01 19:20:40, r wrote:\n> I'd still prefer to leave it out, for the reasons rsc said. I still\n> believe it's a weak solution to a poorly-defined problem that's not\nnow the problem is well defined: return a absolute path to re-invoke the\nsame program.\n> the one most people actually want solved. and once it goes in we can't\n> take it out or change its semantics to be something genuinely useful.\nOn Unix systems, you simply readlink the returned string, and you will\nget what you want. we just don't make that guarantee.",
			"disapproval": false,
			"date": "2012-11-01 20:00:53.046500",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Oct 31, 2012 at 5:29 AM, <rsc@golang.org> wrote:\r\n\r\n> src/pkg/os/executable.go:7: // Executable returns the absolute pathname\r\n> of the current\r\n> In general this is impossible, of course, so it would be nice to be more\r\n> specific about what the return value is good for.\r\n>\r\nWhy impossible in general? Assumes nothing changes the environment (that is,\r\nnothing renames files, deletes files, etc.), this CL implemented the\r\nbehavior on\r\nall supported OSes.\r\n",
			"disapproval": false,
			"date": "2012-10-30 21:44:20.196060",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I would use this in things like gorunas, launching child processes of\r\nmyself, since we don't have fork.\r\n\r\nIn tests I always just use os.Args(0) which isn't guaranteed to be portable\r\nor even work always on Linux.\r\n On Nov 1, 2012 6:30 PM, \"Russ Cox\" <rsc@golang.org> wrote:\r\n\r\n> The complexity of the implementation needs to be paid for by general\r\n> utility. I haven't heard anyone claiming they need or would use this\r\n> function (except to find associated files, which I don't want to\r\n> support this way).\r\n>\r\n> Russ\r\n>\r\n",
			"disapproval": false,
			"date": "2012-11-01 17:35:57.828930",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "If you change the doc comment to\r\n\r\n// Executable returns a path that can be used to reinvoke the current\r\nprogram.\r\n// It may not be valid after the current program exits.\r\n\r\nand simplify the Plan 9 and Linux implementations, then I'll go along with this.\r\n(On Plan 9 use /proc/+itoa(pid)+/text.)\r\n\r\n\r\nOn Thu, Nov 1, 2012 at 1:35 PM, Brad Fitzpatrick <bradfitz@golang.org> wrote:\r\n> I would use this in things like gorunas, launching child processes of\r\n> myself, since we don't have fork.\r\n>\r\n> In tests I always just use os.Args(0) which isn't guaranteed to be portable\r\n> or even work always on Linux.\r\n>\r\n> On Nov 1, 2012 6:30 PM, \"Russ Cox\" <rsc@golang.org> wrote:\r\n>>\r\n>> The complexity of the implementation needs to be paid for by general\r\n>> utility. I haven't heard anyone claiming they need or would use this\r\n>> function (except to find associated files, which I don't want to\r\n>> support this way).\r\n>>\r\n>> Russ\r\n",
			"disapproval": false,
			"date": "2012-11-01 17:49:57.899070",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I'd still prefer to leave it out, for the reasons rsc said. I still\r\nbelieve it's a weak solution to a poorly-defined problem that's not\r\nthe one most people actually want solved. and once it goes in we can't\r\ntake it out or change its semantics to be something genuinely useful.\r\n\r\nThat's not a veto, just a statement of preference. One use case does\r\nnot a must-last-forever feature make.\r\n\r\n-rob\r\n",
			"disapproval": false,
			"date": "2012-11-01 19:20:40.600480",
			"approval": false
		},
		{
			"sender": "aram@mgk.ro",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "A very big -1 on this change.  The original problem was \"how to find\r\nassets bundled with binaries\", a potentially valid concern, but when\r\nwe found we can't solve that problem with the input we had, we decided\r\nto search for a new problem that fit the already implemented solution,\r\n\"how to return a absolute path to re-invoke the same program\", a\r\nproblem no one asked.\r\n\r\nThe semantics are different on each operating system, and on Plan 9\r\nthey don't make sense at all.\r\n\r\n-- Aram\r\n",
			"disapproval": false,
			"date": "2012-11-02 09:59:53.300790",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"minux.ma@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "i'm still not convinced by the idea behind this. the idea seems intrinsically too unportable to be elevated to the standard library. i expect to be outvoted.\n\nhttps://codereview.appspot.com/6736069/diff/43014/src/pkg/os/executable.go\nFile src/pkg/os/executable.go (right):\n\nhttps://codereview.appspot.com/6736069/diff/43014/src/pkg/os/executable.go#newcode7\nsrc/pkg/os/executable.go:7: // Executable returns the absolute pathname of the current\n\"the absolute pathname\" sounds definitive but is actually not well-defined.\n\nhttps://codereview.appspot.com/6736069/diff/43014/src/pkg/os/executable_darwin.go\nFile src/pkg/os/executable_darwin.go (right):\n\nhttps://codereview.appspot.com/6736069/diff/43014/src/pkg/os/executable_darwin.go#newcode7\nsrc/pkg/os/executable_darwin.go:7: var progPath string // set by ../runtime/progpath_darwin.c\nyou've still got some progpaths around, in different casings.",
			"disapproval": false,
			"date": "2012-10-28 17:47:49.772330",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "If we limit Executable to that smaller scope it sounds like no one\r\nwants it anymore. So I would be inclined to leave it out.\r\n\r\nRuss\r\n",
			"disapproval": false,
			"date": "2012-11-01 17:23:10.207580",
			"approval": false
		},
		{
			"sender": "ality@pbrane.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "minux.ma@gmail.com once said:\r\n> On 2012/10/26 16:36:37, r wrote:\r\n> >is your name minuxName?\r\n> good point. PTAL.\r\n> \r\n> btw, how to implement this on Plan 9?\r\n\r\nfunc executable() (string, error) {\r\n\tf, err := Open(\"/proc/\" + itoa(Getpid()) + \"/text\")\r\n\tif err != nil {\r\n\t\treturn \"\", err\r\n\t}\r\n\tdefer f.Close()\r\n\treturn syscall.Fd2path(int(f.Fd()))\r\n}\r\n",
			"disapproval": false,
			"date": "2012-10-29 01:06:08.892740",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Fri, Nov 2, 2012 at 12:46 AM, Russ Cox <rsc@golang.org> wrote:\r\n\r\n> Using \"Executable\" to find related files bothers me quite a bit. I\r\n> think Go doesn't have a good story for finding associated files, but\r\n> if we want to address that I think we should do it head on instead of\r\n> slipping it into a mostly unrelated function.\r\n>\r\n> If this were just for re-running the current executable I wouldn't\r\n> mind. But it sounds like that's not why people want it. So my\r\n> inclination is to leave it out for now.\r\n>\r\nOK, fair enough. I think we can do this.\r\nstop saying that the return path can be used to find related files\r\n(it just happen to be able to do this on major platforms, just readlink\r\nthe returned path), and just address the re-running the current\r\nexecutable problem.\r\n\r\nI will remove all Readlink calls, and instead just return something\r\nlike /proc/self/exe (I will keep the Plan 9 code, because the solution\r\nis not apparent).\r\n\r\nwhat do you think?\r\n",
			"disapproval": false,
			"date": "2012-11-01 16:55:44.020080",
			"approval": false
		},
		{
			"sender": "taruti@taruti.net",
			"recipients": [
				"minux.ma@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"ality@pbrane.org",
				"jsing@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Why not simply have a (using os/exec):\n\nfunc SelfCommand(arg ...string) (*exec.Cmd, error)\n\nIf the idea is to have re-execute the current command.\n\nWould be much cleaner and allow for potentially better implementations.",
			"disapproval": false,
			"date": "2012-11-01 22:14:01.377050",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "There is enough disagreement about this that I would like to leave it\r\nfor a 3rd-party package to implement, at least for now. I don't want\r\nto add an API that we'll be stuck with and regret.\r\n\r\nThanks.\r\nRuss\r\n",
			"disapproval": false,
			"date": "2012-11-02 20:20:33.369820",
			"approval": false
		},
		{
			"sender": "minux.ma@gmail.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Sat, Nov 3, 2012 at 4:20 AM, Russ Cox <rsc@golang.org> wrote:\r\n\r\n> There is enough disagreement about this that I would like to leave it\r\n> for a 3rd-party package to implement, at least for now. I don't want\r\n> to add an API that we'll be stuck with and regret.\r\n>\r\nIt's fine for me to move this into a go-gettable package.\r\nI've found ways to implement the required functionality on\r\nDarwin without runtime changes.\r\n\r\nWhat about issue 4057? Should I close it with status unfortunate?\r\n",
			"disapproval": false,
			"date": "2012-11-03 06:15:11.996470",
			"approval": false
		},
		{
			"sender": "ality@pbrane.org",
			"recipients": [
				"minux.ma@gmail.com",
				"bradfitz@golang.org",
				"remyoudompheng@gmail.com",
				"alex.brainman@gmail.com",
				"taruti@taruti.net",
				"kardianos@gmail.com",
				"rsc@golang.org",
				"r@golang.org",
				"jsing@google.com",
				"aram@mgk.ro",
				"golang-dev@googlegroups.com",
				"ality@pbrane.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Removing myself from reviewers.",
			"disapproval": false,
			"date": "2013-07-20 06:50:57.738640",
			"approval": false
		}
	],
	"owner_email": "minux.ma@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "minux",
	"subject": "code review 6736069: runtime, syscall, os: add os.ExecPath() (string, error)",
	"created": "2012-10-23 09:41:32.673440",
	"patchsets": [
		1,
		2001,
		4001,
		6001,
		6002,
		8004,
		14002,
		3005,
		4002,
		23,
		14003,
		8005,
		6004,
		17009,
		16026,
		24001,
		30001,
		23004,
		24004,
		20014,
		23014,
		32004,
		41001,
		43014,
		45013,
		37032,
		45037,
		49002,
		41006,
		48004,
		54011,
		62001
	],
	"modified": "2013-07-20 06:50:59.010170",
	"closed": false,
	"issue": 6736069
}