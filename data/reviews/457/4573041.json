{
	"description": "big: Improved speed of big-to-string conversion for printing\n\nThree optimizations: First, special-case power of two bases\nthat partion a Word(), bases 2, 4, 16, and 256. These can\nbe moved directly from internal Word() storage to the output\nwithout multiprecision operations. Next, same approach for\nthe other power-of-two bases, 8, 32, 64, and 128. These\ndon't fill a Word() evenly, so special handling is needed\nfor those cases where input spans the high-bits of one Word\nand the low bis of the next one.  Finally, implement the\ngeneral case for others bases in 2 <= base <= 256 using\nsuperbases, the largest power of base representable in a\nWord(). For base ten, this is 9 digits and a superbase of\n10^9 for 32-bit Words and 19 digits and 10^19 for 64-bit\ncompiles. This way we do just 1/9th or 1/19th of the expensive\nmultiprecision divisions, unpacking superdigits using fast\nnative machine arithmetic.\n\nSpeedups compared to the previous version range from 200x\nthe rate (hexadadecimal) down to 17x for decimal in 64 bit,\nand faster still (relatively) in 32-bit since the multi-\nprecision code is not as tuned there.",
	"cc": [
		"golang-dev@googlegroups.com"
	],
	"reviewers": [
		"gri@golang.org"
	],
	"messages": [
		{
			"sender": "gri@golang.org",
			"recipients": [
				"michael.jones@gmail.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Very nice.\n\nLots of comments, but mostly on the use of variable names. I tried to be fairly consistent in the use of variable names in this code because there are often many variables, and it's easy to get confused.\n\nThe conventions I have used:\n\nm, n for the lengths of vectors len(x), len(y)\n\ni, j, k for indices\n\nd, r for digits\n\ndd, w for super-digits (what you call a group), or a word\n\nPlease add a benchmark to nat_test.go so we can track the performance. For an example, look at nat_test.go:355 .\n\nRegarding the faster scanning code you sent: Let's just do this CL first, and then we'll gave another look at that code.\n\nAt that point it may even make sense to move all this conversion code into a separate file (say conv.go) as it is becoming fairly substantial. Also a separate CL.\n\nFinally: Please keep two empty lines between functions for improved readability.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go\nFile src/pkg/big/nat.go (right):\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode114\nsrc/pkg/big/nat.go:114: func (z nat) appendBits(bits uint, w Word) nat {\nthis function doen't appear to be used\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode628\nsrc/pkg/big/nat.go:628: const MaxBase = ('z' - 'a' + 1) + 10 // = hexValue('z') + 1\nIf you want to add parentheses, please group as:\n\n('z' - 'a' + 10) + 1\n\nsince that matches hexValue('z') + 1\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode643\nsrc/pkg/big/nat.go:643: // scan returns the natural number corresponding to the longest\nPlease leave this comment unchanged (looks like you merged in the old comment again).\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode756\nsrc/pkg/big/nat.go:756: // handle power-of-two bases where digits partition fill Word\ns/partition fill/completely partition/\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode758\nsrc/pkg/big/nat.go:758: switch {\nchange to:\n\nswitch base {\ncase 2:\n   shift = 1\ncase 4:\n   shift = 2\ncase 16:\n   shift = 4\ncase 256:\n   shift = 8\n}\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode769\nsrc/pkg/big/nat.go:769: words := len(x)\ns/words/m/\n\nThe convention in this file is to use m for len(x), and n for len(y). This convention is used fairly rigorously, please use it, too.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode770\nsrc/pkg/big/nat.go:770: digits := int(_W / shift)\ns/digits/ndigits/\n\nsee also comment below (line 845), for consistency\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode771\nsrc/pkg/big/nat.go:771: mask := Word((1 << shift) - 1)\nmask := Word(1) << shift - 1\n\n- no need for extra parens, << is a multiplicative operator in Go\n- also, make sure that 1 is of type Word\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode773\nsrc/pkg/big/nat.go:773: for w := 0; w < words-1; w++ {\nfor _, w := range x[0:m-1] { ...\n\n(with m = len(x) from above)\n\nand use w instead of group\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode774\nsrc/pkg/big/nat.go:774: group := x[w]\nget rid of this\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode775\nsrc/pkg/big/nat.go:775: for d := 0; d < digits; d++ {\ns/d/j/\n\n(you use j for the equivalent loop in the general case below)\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode781\nsrc/pkg/big/nat.go:781: group := x[words-1]\nw := x[m-1]\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode782\nsrc/pkg/big/nat.go:782: for d := 0; d < digits && group != 0; d++ { // most-significant word (omit leading zeros)\ns/d/j/\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode803\nsrc/pkg/big/nat.go:803: words := len(x)\nsame here: s/words/m/\n\nAlso, can do this once in the beginning, for all code.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode804\nsrc/pkg/big/nat.go:804: mask := Word((1 << shift) - 1)\nmask := Word(1) << shift - 1\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode805\nsrc/pkg/big/nat.go:805: bits := uint(_W) // unconverted bits in group\n// remaining bits in word w\n\n??\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode809\nsrc/pkg/big/nat.go:809: for w := 0; w < words-1; {\nfor j, w := range x[0:m-1] { ...\n\nand use j where you use w below\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode842\nsrc/pkg/big/nat.go:842: // compute maximum number of base 'base' digits which fit in a Word without filling it\ns/without filling it/entirely/\n\n(it would be ok if they fill the word, except those cases are already handled above)\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode845\nsrc/pkg/big/nat.go:845: for t := Word(_M); t >= base; t /= base {\nThis can be done w/o repeated division:\n\nndigits := 0\nfor max := _M/base; groupBase <= max; groupBase *= base {\n\tndigits++\n}\n\nAlso: no need for groupDigits to be of type Word; int is fine, and you can get rid of a whole bunch of conversions below.\n\nIn the scan code above, I call the base \"b\" and the groupBase \"bb\". Perhaps use the same names? And can we call groupDigits \"ndigits\" instead?  (groupDigits sounds like it is the digits of the group, but it's really the number of digits = ndigits).\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode852\nsrc/pkg/big/nat.go:852: r := Word(0)\nvar r Word\n\n(this is the style used elsewhere where we don't want to make a point that the initial value matters)\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode855\nsrc/pkg/big/nat.go:855: if base == 10 { // hard-coding for ten here speeds this up by 1.25x\ns/ten/10/\n\nto match the \"base == 10\"\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode858\nsrc/pkg/big/nat.go:858: q, r = q.divW(q, groupBase) // N.B. >82% of time is here. Optimize divWVW\ns/divWVW/divW/\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode860\nsrc/pkg/big/nat.go:860: group := r\nget rid of this declaration and just use r instead of group below\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode863\nsrc/pkg/big/nat.go:863: for j := Word(0); j < groupDigits && group != 0; j++ {\nj := 0\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode869\nsrc/pkg/big/nat.go:869: for j := Word(0); j < groupDigits; j++ {\nj := 0\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode879\nsrc/pkg/big/nat.go:879: q, r = q.divW(q, groupBase) // N.B. >82% of time is here. Optimize divWVW\ns/divWVW/divW/\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode881\nsrc/pkg/big/nat.go:881: group := r\nget rid of this declaration and just use r instead of group below\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode884\nsrc/pkg/big/nat.go:884: for j := Word(0); j < groupDigits && group != 0; j++ {\nj := 0\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode890\nsrc/pkg/big/nat.go:890: for j := Word(0); j < groupDigits; j++ {\nj := 0",
			"disapproval": false,
			"date": "2011-06-03 22:56:46.825893",
			"approval": false
		},
		{
			"sender": "michael.jones@gmail.com",
			"recipients": [
				"michael.jones@gmail.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "Wow, so wonderfully assistive! Thanks!\n\nI did all but three of the suggested changes. Details of the three are in the edits below, but summary is: \n\n1. Loop construct in second instance is a little bit subtle\n2. Comment about bb loop needs some kind of caveat\n3. My general struggle with Go int size conformance. \n\nDid everything else, and did as much of these as I understood to be right and clear (little of #1, most of #2, none of #3.) Ready for more feedback. ;-)\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go\nFile src/pkg/big/nat.go (right):\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode114\nsrc/pkg/big/nat.go:114: func (z nat) appendBits(bits uint, w Word) nat {\nOn 2011/06/03 22:56:46, gri wrote:\n> this function doen't appear to be used\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode628\nsrc/pkg/big/nat.go:628: const MaxBase = ('z' - 'a' + 1) + 10 // = hexValue('z') + 1\nOn 2011/06/03 22:56:46, gri wrote:\n> If you want to add parentheses, please group as:\n> \n> ('z' - 'a' + 10) + 1\n> \n> since that matches hexValue('z') + 1\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode643\nsrc/pkg/big/nat.go:643: // scan returns the natural number corresponding to the longest\nOn 2011/06/03 22:56:46, gri wrote:\n> Please leave this comment unchanged (looks like you merged in the old comment\n> again).\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode756\nsrc/pkg/big/nat.go:756: // handle power-of-two bases where digits partition fill Word\nOn 2011/06/03 22:56:46, gri wrote:\n> s/partition fill/completely partition/\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode758\nsrc/pkg/big/nat.go:758: switch {\nOn 2011/06/03 22:56:46, gri wrote:\n> change to:\n> \n> switch base {\n> case 2:\n>    shift = 1\n> case 4:\n>    shift = 2\n> case 16:\n>    shift = 4\n> case 256:\n>    shift = 8\n> }\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode769\nsrc/pkg/big/nat.go:769: words := len(x)\nOn 2011/06/03 22:56:46, gri wrote:\n> s/words/m/\n> \n> The convention in this file is to use m for len(x), and n for len(y). This\n> convention is used fairly rigorously, please use it, too.\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode770\nsrc/pkg/big/nat.go:770: digits := int(_W / shift)\nOn 2011/06/03 22:56:46, gri wrote:\n> s/digits/ndigits/\n> \n> see also comment below (line 845), for consistency\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode773\nsrc/pkg/big/nat.go:773: for w := 0; w < words-1; w++ {\nOn 2011/06/03 22:56:46, gri wrote:\n> for _, w := range x[0:m-1] { ...\n> \n> (with m = len(x) from above)\n> \n> and use w instead of group\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode775\nsrc/pkg/big/nat.go:775: for d := 0; d < digits; d++ {\nOn 2011/06/03 22:56:46, gri wrote:\n> s/d/j/\n> \n> (you use j for the equivalent loop in the general case below)\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode781\nsrc/pkg/big/nat.go:781: group := x[words-1]\nOn 2011/06/03 22:56:46, gri wrote:\n> w := x[m-1]\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode782\nsrc/pkg/big/nat.go:782: for d := 0; d < digits && group != 0; d++ { // most-significant word (omit leading zeros)\nOn 2011/06/03 22:56:46, gri wrote:\n> s/d/j/\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode803\nsrc/pkg/big/nat.go:803: words := len(x)\nOn 2011/06/03 22:56:46, gri wrote:\n> same here: s/words/m/\n> \n> Also, can do this once in the beginning, for all code.\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode804\nsrc/pkg/big/nat.go:804: mask := Word((1 << shift) - 1)\nOn 2011/06/03 22:56:46, gri wrote:\n> mask := Word(1) << shift - 1\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode805\nsrc/pkg/big/nat.go:805: bits := uint(_W) // unconverted bits in group\nOn 2011/06/03 22:56:46, gri wrote:\n> // remaining bits in word w\n> \n> ??\n\nchanged comment:\nnbits := uint(_W) // number of unprocessed bits in w\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode805\nsrc/pkg/big/nat.go:805: bits := uint(_W) // unconverted bits in group\nOn 2011/06/03 22:56:46, gri wrote:\n> // remaining bits in word w\n> \n> ??\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode809\nsrc/pkg/big/nat.go:809: for w := 0; w < words-1; {\nOn 2011/06/03 22:56:46, gri wrote:\n> for j, w := range x[0:m-1] { ...\n> \n> and use j where you use w below\n\nchanged variable names but not loop construct. also moved the index increment up to the loop construct. This is different than the loop above. Instead of feeding words to a parser we have a parser that consumes words and changes the word it is peeking at. I think it would be strange to modify the input number in situ just so that the range-based loop could habd the same Word back to me on the next iteration...so...I want to say no to this change. No ego about it, happy to have a better arrangement, better code style, better use of Go idioms, etc. Just need to express idea that a bb-sized window is scanning across the huge array of words from right to left What is expressed is \"for window starts at right, LSD side; while window has not reached the word containing the MSD; keep sliding.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode842\nsrc/pkg/big/nat.go:842: // compute maximum number of base 'base' digits which fit in a Word without filling it\nOn 2011/06/03 22:56:46, gri wrote:\n> s/without filling it/entirely/\n> \n> (it would be ok if they fill the word, except those cases are already handled\n> above)\n\ntrue, but my code and yours both undercount by one in those specific cases. I did not want to burn in effigy later when someone figured that out. ;-)\n\nTry this...\n\n\npackage main\nimport (\"fmt\")\n\nconst _M = 1<<64 - 1\n\nfunc main() {\n    for b := uint64(2); b <= 256; b++ {\n\tbb := uint64(1)\n\tndigits := 0\n\tfor max := uint64(_M/b); bb <= max; bb *= b {\n\t    ndigits++\n\t}\n\tfmt.Printf(\"base %3d: %2d %20d\\n\", b, ndigits, bb)\n    \tswitch b {\n\tcase 2, 4, 16, 256:\n\t    fmt.Printf(\"    NOTE: should be %3d: %2d and bb = 2^64\\n\", b, ndigits+1)\n\t}\n    }\n}\n\n...I will gladly change the comment as long as it remains true. You can see if what I did works for you.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode845\nsrc/pkg/big/nat.go:845: for t := Word(_M); t >= base; t /= base {\nOn 2011/06/03 22:56:46, gri wrote:\n> This can be done w/o repeated division:\n> \n> ndigits := 0\n> for max := _M/base; groupBase <= max; groupBase *= base {\n> \tndigits++\n> }\n> \n> Also: no need for groupDigits to be of type Word; int is fine, and you can get\n> rid of a whole bunch of conversions below.\n> \n> In the scan code above, I call the base \"b\" and the groupBase \"bb\". Perhaps use\n> the same names? And can we call groupDigits \"ndigits\" instead?  (groupDigits\n> sounds like it is the digits of the group, but it's really the number of digits\n> = ndigits).\n\nam i assured that int and uintptr (aka, type Word) are of the same size in 32 bit and 64 bit modes?\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode852\nsrc/pkg/big/nat.go:852: r := Word(0)\nOn 2011/06/03 22:56:46, gri wrote:\n> var r Word\n> \n> (this is the style used elsewhere where we don't want to make a point that the\n> initial value matters)\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode855\nsrc/pkg/big/nat.go:855: if base == 10 { // hard-coding for ten here speeds this up by 1.25x\nOn 2011/06/03 22:56:46, gri wrote:\n> s/ten/10/\n> \n> to match the \"base == 10\"\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode858\nsrc/pkg/big/nat.go:858: q, r = q.divW(q, groupBase) // N.B. >82% of time is here. Optimize divWVW\nOn 2011/06/03 22:56:46, gri wrote:\n> s/divWVW/divW/\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode860\nsrc/pkg/big/nat.go:860: group := r\nOn 2011/06/03 22:56:46, gri wrote:\n> get rid of this declaration and just use r instead of group below\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode863\nsrc/pkg/big/nat.go:863: for j := Word(0); j < groupDigits && group != 0; j++ {\nOn 2011/06/03 22:56:46, gri wrote:\n> j := 0\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode869\nsrc/pkg/big/nat.go:869: for j := Word(0); j < groupDigits; j++ {\nOn 2011/06/03 22:56:46, gri wrote:\n> j := 0\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode879\nsrc/pkg/big/nat.go:879: q, r = q.divW(q, groupBase) // N.B. >82% of time is here. Optimize divWVW\nOn 2011/06/03 22:56:46, gri wrote:\n> s/divWVW/divW/\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode881\nsrc/pkg/big/nat.go:881: group := r\nOn 2011/06/03 22:56:46, gri wrote:\n> get rid of this declaration and just use r instead of group below\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode884\nsrc/pkg/big/nat.go:884: for j := Word(0); j < groupDigits && group != 0; j++ {\nOn 2011/06/03 22:56:46, gri wrote:\n> j := 0\n\nDone.\n\nhttp://codereview.appspot.com/4573041/diff/2001/src/pkg/big/nat.go#newcode890\nsrc/pkg/big/nat.go:890: for j := Word(0); j < groupDigits; j++ {\nOn 2011/06/03 22:56:46, gri wrote:\n> j := 0\n\nDone.",
			"disapproval": false,
			"date": "2011-06-04 08:21:42.039877",
			"approval": false
		},
		{
			"sender": "michael.jones@gmail.com",
			"recipients": [
				"michael.jones@gmail.com",
				"gri@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview.appspotmail.com"
			],
			"text": "I also added benchmark tests for bases 2, 8, 10, and 16. Here are the results with the old code:\n\n\nmtj-macbookpro:big mtj$ make bench\ngotest -test.bench=. -test.run=\"Do not run tests\"\nrm -f _test/big.a\nrm -f _test/big.a\ngopack grc _test/big.a _gotest_.6 arith_amd64.6 \nPASS\nbig.BenchmarkHilbert\t     500\t   5833338 ns/op\nbig.BenchmarkBitset\t20000000\t       132 ns/op\nbig.BenchmarkBitsetNeg\t10000000\t       240 ns/op\nbig.BenchmarkBitsetOrig\t 5000000\t       606 ns/op\nbig.BenchmarkBitsetNegOrig\t 1000000\t      1029 ns/op\nbig.BenchmarkMul\t     500\t   3193490 ns/op\nbig.BenchmarkScanPi\t   10000\t    243586 ns/op\nbig.BenchmarkString2\t      10\t 137214700 ns/op\nbig.BenchmarkString8\t      50\t  61214940 ns/op\nbig.BenchmarkString10\t      50\t  56151740 ns/op\nbig.BenchmarkString16\t      50\t  47801960 ns/op\n\n...and with the new...\n\n\nmtj-macbookpro:big mtj$ make bench\ngotest -test.bench=. -test.run=\"Do not run tests\"\nrm -f _test/big.a\nrm -f _test/big.a\ngopack grc _test/big.a _gotest_.6 arith_amd64.6 \nPASS\nbig.BenchmarkHilbert\t     500\t   5823440 ns/op\nbig.BenchmarkBitset\t20000000\t       133 ns/op\nbig.BenchmarkBitsetNeg\t10000000\t       238 ns/op\nbig.BenchmarkBitsetOrig\t 5000000\t       601 ns/op\nbig.BenchmarkBitsetNegOrig\t 1000000\t      1029 ns/op\nbig.BenchmarkMul\t     500\t   3190486 ns/op\nbig.BenchmarkScanPi\t   10000\t    243989 ns/op\nbig.BenchmarkString2\t   10000\t    203773 ns/op\nbig.BenchmarkString8\t   50000\t     72232 ns/op\nbig.BenchmarkString10\t     500\t   3124502 ns/op\nbig.BenchmarkString16\t   50000\t     53168 ns/op\n\n...the speedups are notable.\n\n\"%b\" = 673x\n\"%o\" = 847x\n\"%d\" = 17x\n\"%x\" = 899x",
			"disapproval": false,
			"date": "2011-06-04 19:19:53.148790",
			"approval": false
		}
	],
	"owner_email": "michael.jones@gmail.com",
	"private": false,
	"base_url": "",
	"owner": "mtj",
	"subject": "big: Improved speed of big-to-string conversion for printing",
	"created": "2011-06-03 16:25:49.050452",
	"patchsets": [
		1,
		2001
	],
	"modified": "2011-06-04 19:19:53.148790",
	"closed": false,
	"issue": 4573041
}