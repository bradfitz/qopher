{
	"description": "cmd/5l, cmd/6l, cmd/8l, cmd/gc, runtime: generate and use bitmaps of argument pointer locations\n\nWith this change the compiler emits a bitmap for each function\ncovering its stack frame arguments area.  If an argument word\nis known to contain a pointer, a bit is set.  The garbage\ncollector reads this information when scanning the stack by\nframes and uses it to ignores locations known to not contain a\npointer.",
	"cc": [
		"golang-dev@googlegroups.com",
		"bradfitz@golang.org",
		"daniel.morsing@gmail.com",
		"dvyukov@google.com",
		"khr@golang.org",
		"khr@google.com",
		"iant@golang.org"
	],
	"reviewers": [
		"fullung@gmail.com",
		"cshapiro@golang.org"
	],
	"messages": [
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://code.google.com/p/go/",
			"disapproval": false,
			"date": "2013-05-08 02:22:10.181270",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Impressive code/test ratio!\r\n\r\nUpdate Issue nnnn?\r\n\r\nDoes this make anything better which you can demonstrate with some Go code?\r\n\r\n\r\n\r\nOn Tue, May 7, 2013 at 7:22 PM, <cshapiro@google.com> wrote:\r\n\r\n> Reviewers: golang-dev1,\r\n>\r\n> Message:\r\n> Hello golang-dev@googlegroups.com,\r\n>\r\n> I'd like you to review this change to\r\n> https://code.google.com/p/go/\r\n>\r\n>\r\n> Description:\r\n> cmd/5l, cmd/6l, cmd/8l, cmd/gc, runtime: generate and use bitmaps of\r\n> argument pointer locations\r\n>\r\n> Please review this at https://codereview.appspot.**com/9223046/<https://codereview.appspot.com/9223046/>\r\n>\r\n> Affected files:\r\n>   M src/cmd/5l/5.out.h\r\n>   M src/cmd/5l/l.h\r\n>   M src/cmd/5l/obj.c\r\n>   M src/cmd/6l/6.out.h\r\n>   M src/cmd/6l/l.h\r\n>   M src/cmd/6l/obj.c\r\n>   M src/cmd/6l/optab.c\r\n>   M src/cmd/8l/8.out.h\r\n>   M src/cmd/8l/l.h\r\n>   M src/cmd/8l/obj.c\r\n>   M src/cmd/8l/optab.c\r\n>   A src/cmd/gc/bv.c\r\n>   M src/cmd/gc/go.h\r\n>   M src/cmd/gc/pgen.c\r\n>   M src/cmd/ld/lib.c\r\n>   M src/pkg/runtime/mgc0.c\r\n>   M src/pkg/runtime/runtime.h\r\n>   M src/pkg/runtime/symtab.c\r\n>\r\n>\r\n> --\r\n>\r\n> ---You received this message because you are subscribed to the Google\r\n> Groups \"golang-dev\" group.\r\n> To unsubscribe from this group and stop receiving emails from it, send an\r\n> email to golang-dev+unsubscribe@**googlegroups.com<golang-dev%2Bunsubscribe@googlegroups.com>\r\n> .\r\n> For more options, visit https://groups.google.com/**groups/opt_out<https://groups.google.com/groups/opt_out>\r\n> .\r\n>\r\n>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-05-08 03:35:06.142750",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/8001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/8001/src/pkg/runtime/symtab.c#newcode239\nsrc/pkg/runtime/symtab.c:239: fgc[nfunc-1] = runtime\u00b7mallocgc(sym->value*sizeof(*fgc), FlagNoPointers, 0, 1);\nis it meant to be sizeof(**fgc)?\n\nhttps://codereview.appspot.com/9223046/diff/8001/src/pkg/runtime/symtab.c#newcode239\nsrc/pkg/runtime/symtab.c:239: fgc[nfunc-1] = runtime\u00b7mallocgc(sym->value*sizeof(*fgc), FlagNoPointers, 0, 1);\nI am a bit concerned about lots of small and markable allocations.\nHow many can be there?\nCan we allocate it from a big FlagNoGC buffer or construct statically?",
			"disapproval": false,
			"date": "2013-05-08 18:14:25.112020",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I will update the change description with the relevant issue.\r\n\r\nThis infrastructure is currently hidden behind a disabled flag so it should\r\nhave no effect.  When the flag is enabled there are pointers ignored that\r\nwould otherwise be scanned.  However, it is hard to quantify how much this\r\n\"helps\" as even with this change locations in the out area are scanned\r\nbefore they are initialized.  At the moment, the benefit is largely a\r\nfunction of how many garbage values are hanging around on your stack.\r\n\r\nA forthcoming change will extend the bitmap to cover all locals and be\r\nliveness precise.  That is when we will see a real benefit.  It will also\r\nbe much easier to empirically validate correctness.\r\n\r\nOn Tue, May 7, 2013 at 8:35 PM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n\r\n> Impressive code/test ratio!\r\n>\r\n> Update Issue nnnn?\r\n>\r\n> Does this make anything better which you can demonstrate with some Go code?\r\n>\r\n>\r\n>\r\n> On Tue, May 7, 2013 at 7:22 PM, <cshapiro@google.com> wrote:\r\n>\r\n>> Reviewers: golang-dev1,\r\n>>\r\n>> Message:\r\n>> Hello golang-dev@googlegroups.com,\r\n>>\r\n>> I'd like you to review this change to\r\n>> https://code.google.com/p/go/\r\n>>\r\n>>\r\n>> Description:\r\n>> cmd/5l, cmd/6l, cmd/8l, cmd/gc, runtime: generate and use bitmaps of\r\n>> argument pointer locations\r\n>>\r\n>> Please review this at https://codereview.appspot.**com/9223046/<https://codereview.appspot.com/9223046/>\r\n>>\r\n>> Affected files:\r\n>>   M src/cmd/5l/5.out.h\r\n>>   M src/cmd/5l/l.h\r\n>>   M src/cmd/5l/obj.c\r\n>>   M src/cmd/6l/6.out.h\r\n>>   M src/cmd/6l/l.h\r\n>>   M src/cmd/6l/obj.c\r\n>>   M src/cmd/6l/optab.c\r\n>>   M src/cmd/8l/8.out.h\r\n>>   M src/cmd/8l/l.h\r\n>>   M src/cmd/8l/obj.c\r\n>>   M src/cmd/8l/optab.c\r\n>>   A src/cmd/gc/bv.c\r\n>>   M src/cmd/gc/go.h\r\n>>   M src/cmd/gc/pgen.c\r\n>>   M src/cmd/ld/lib.c\r\n>>   M src/pkg/runtime/mgc0.c\r\n>>   M src/pkg/runtime/runtime.h\r\n>>   M src/pkg/runtime/symtab.c\r\n>>\r\n>>\r\n>> --\r\n>>\r\n>> ---You received this message because you are subscribed to the Google\r\n>> Groups \"golang-dev\" group.\r\n>> To unsubscribe from this group and stop receiving emails from it, send an\r\n>> email to golang-dev+unsubscribe@**googlegroups.com<golang-dev%2Bunsubscribe@googlegroups.com>\r\n>> .\r\n>> For more options, visit https://groups.google.com/**groups/opt_out<https://groups.google.com/groups/opt_out>\r\n>> .\r\n>>\r\n>>\r\n>>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-05-08 05:08:44.420890",
			"approval": false
		},
		{
			"sender": "bradfitz@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Cool, thanks for the background.  Putting some of that in the issue and/or\r\nCL description would be helpful.\r\n\r\n\r\n\r\nOn Tue, May 7, 2013 at 10:08 PM, Carl Shapiro <cshapiro@google.com> wrote:\r\n\r\n> I will update the change description with the relevant issue.\r\n>\r\n> This infrastructure is currently hidden behind a disabled flag so it\r\n> should have no effect.  When the flag is enabled there are pointers ignored\r\n> that would otherwise be scanned.  However, it is hard to quantify how much\r\n> this \"helps\" as even with this change locations in the out area are scanned\r\n> before they are initialized.  At the moment, the benefit is largely a\r\n> function of how many garbage values are hanging around on your stack.\r\n>\r\n> A forthcoming change will extend the bitmap to cover all locals and be\r\n> liveness precise.  That is when we will see a real benefit.  It will also\r\n> be much easier to empirically validate correctness.\r\n>\r\n> On Tue, May 7, 2013 at 8:35 PM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n>\r\n>> Impressive code/test ratio!\r\n>>\r\n>> Update Issue nnnn?\r\n>>\r\n>> Does this make anything better which you can demonstrate with some Go\r\n>> code?\r\n>>\r\n>>\r\n>>\r\n>> On Tue, May 7, 2013 at 7:22 PM, <cshapiro@google.com> wrote:\r\n>>\r\n>>> Reviewers: golang-dev1,\r\n>>>\r\n>>> Message:\r\n>>> Hello golang-dev@googlegroups.com,\r\n>>>\r\n>>> I'd like you to review this change to\r\n>>> https://code.google.com/p/go/\r\n>>>\r\n>>>\r\n>>> Description:\r\n>>> cmd/5l, cmd/6l, cmd/8l, cmd/gc, runtime: generate and use bitmaps of\r\n>>> argument pointer locations\r\n>>>\r\n>>> Please review this at https://codereview.appspot.**com/9223046/<https://codereview.appspot.com/9223046/>\r\n>>>\r\n>>> Affected files:\r\n>>>   M src/cmd/5l/5.out.h\r\n>>>   M src/cmd/5l/l.h\r\n>>>   M src/cmd/5l/obj.c\r\n>>>   M src/cmd/6l/6.out.h\r\n>>>   M src/cmd/6l/l.h\r\n>>>   M src/cmd/6l/obj.c\r\n>>>   M src/cmd/6l/optab.c\r\n>>>   M src/cmd/8l/8.out.h\r\n>>>   M src/cmd/8l/l.h\r\n>>>   M src/cmd/8l/obj.c\r\n>>>   M src/cmd/8l/optab.c\r\n>>>   A src/cmd/gc/bv.c\r\n>>>   M src/cmd/gc/go.h\r\n>>>   M src/cmd/gc/pgen.c\r\n>>>   M src/cmd/ld/lib.c\r\n>>>   M src/pkg/runtime/mgc0.c\r\n>>>   M src/pkg/runtime/runtime.h\r\n>>>   M src/pkg/runtime/symtab.c\r\n>>>\r\n>>>\r\n>>> --\r\n>>>\r\n>>> ---You received this message because you are subscribed to the Google\r\n>>> Groups \"golang-dev\" group.\r\n>>> To unsubscribe from this group and stop receiving emails from it, send\r\n>>> an email to golang-dev+unsubscribe@**googlegroups.com<golang-dev%2Bunsubscribe@googlegroups.com>\r\n>>> .\r\n>>> For more options, visit https://groups.google.com/**groups/opt_out<https://groups.google.com/groups/opt_out>\r\n>>> .\r\n>>>\r\n>>>\r\n>>>\r\n>>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-05-08 05:12:01.393520",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Will do.  Thanks.\r\n\r\n\r\nOn Tue, May 7, 2013 at 10:11 PM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n\r\n> Cool, thanks for the background.  Putting some of that in the issue and/or\r\n> CL description would be helpful.\r\n>\r\n>\r\n>\r\n> On Tue, May 7, 2013 at 10:08 PM, Carl Shapiro <cshapiro@google.com> wrote:\r\n>\r\n>> I will update the change description with the relevant issue.\r\n>>\r\n>> This infrastructure is currently hidden behind a disabled flag so it\r\n>> should have no effect.  When the flag is enabled there are pointers ignored\r\n>> that would otherwise be scanned.  However, it is hard to quantify how much\r\n>> this \"helps\" as even with this change locations in the out area are scanned\r\n>> before they are initialized.  At the moment, the benefit is largely a\r\n>> function of how many garbage values are hanging around on your stack.\r\n>>\r\n>> A forthcoming change will extend the bitmap to cover all locals and be\r\n>> liveness precise.  That is when we will see a real benefit.  It will also\r\n>> be much easier to empirically validate correctness.\r\n>>\r\n>> On Tue, May 7, 2013 at 8:35 PM, Brad Fitzpatrick <bradfitz@golang.org>wrote:\r\n>>\r\n>>> Impressive code/test ratio!\r\n>>>\r\n>>> Update Issue nnnn?\r\n>>>\r\n>>> Does this make anything better which you can demonstrate with some Go\r\n>>> code?\r\n>>>\r\n>>>\r\n>>>\r\n>>> On Tue, May 7, 2013 at 7:22 PM, <cshapiro@google.com> wrote:\r\n>>>\r\n>>>> Reviewers: golang-dev1,\r\n>>>>\r\n>>>> Message:\r\n>>>> Hello golang-dev@googlegroups.com,\r\n>>>>\r\n>>>> I'd like you to review this change to\r\n>>>> https://code.google.com/p/go/\r\n>>>>\r\n>>>>\r\n>>>> Description:\r\n>>>> cmd/5l, cmd/6l, cmd/8l, cmd/gc, runtime: generate and use bitmaps of\r\n>>>> argument pointer locations\r\n>>>>\r\n>>>> Please review this at https://codereview.appspot.**com/9223046/<https://codereview.appspot.com/9223046/>\r\n>>>>\r\n>>>> Affected files:\r\n>>>>   M src/cmd/5l/5.out.h\r\n>>>>   M src/cmd/5l/l.h\r\n>>>>   M src/cmd/5l/obj.c\r\n>>>>   M src/cmd/6l/6.out.h\r\n>>>>   M src/cmd/6l/l.h\r\n>>>>   M src/cmd/6l/obj.c\r\n>>>>   M src/cmd/6l/optab.c\r\n>>>>   M src/cmd/8l/8.out.h\r\n>>>>   M src/cmd/8l/l.h\r\n>>>>   M src/cmd/8l/obj.c\r\n>>>>   M src/cmd/8l/optab.c\r\n>>>>   A src/cmd/gc/bv.c\r\n>>>>   M src/cmd/gc/go.h\r\n>>>>   M src/cmd/gc/pgen.c\r\n>>>>   M src/cmd/ld/lib.c\r\n>>>>   M src/pkg/runtime/mgc0.c\r\n>>>>   M src/pkg/runtime/runtime.h\r\n>>>>   M src/pkg/runtime/symtab.c\r\n>>>>\r\n>>>>\r\n>>>> --\r\n>>>>\r\n>>>> ---You received this message because you are subscribed to the Google\r\n>>>> Groups \"golang-dev\" group.\r\n>>>> To unsubscribe from this group and stop receiving emails from it, send\r\n>>>> an email to golang-dev+unsubscribe@**googlegroups.com<golang-dev%2Bunsubscribe@googlegroups.com>\r\n>>>> .\r\n>>>> For more options, visit https://groups.google.com/**groups/opt_out<https://groups.google.com/groups/opt_out>\r\n>>>> .\r\n>>>>\r\n>>>>\r\n>>>>\r\n>>>\r\n>>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-05-08 05:28:23.020010",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/8001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/8001/src/cmd/gc/pgen.c#newcode283\nsrc/cmd/gc/pgen.c:283: stackmap(Node *fn)\nWith the addition of the TYPE instruction, it should be possible to do this entirely in the linker, without having to deal with which fields are inargs or outargs. It is also done after allocauto, so the final locations of the stack variables will also be determined.\n\nThe compiler will have to be modified to put out liveness info at some point, but might as well build on the stuff that's already there.",
			"disapproval": false,
			"date": "2013-05-08 09:04:55.282450",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/8001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/8001/src/cmd/gc/pgen.c#newcode283\nsrc/cmd/gc/pgen.c:283: stackmap(Node *fn)\nI started out trying to implement this at link time.  It turned out to be more difficult than I had hoped.  Many of the data structured needed (for example, the type information data structures) are not readily available at link time.  I could unpack all of the information being sent to the linker, but that  turned out to be a lot more work than I would have liked.  \n\nRight now I am just generating information for the argument list but my next change will be adding information for locals.  It looks like the same data structure will be used for locals and for the argument list and its simpler to compute it all at once.  Doing that work at link time would require recomputing  a lot of state available at compile time and teaching the linker about data structures known to the compiler.",
			"disapproval": false,
			"date": "2013-05-08 18:25:16.491810",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/8001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/8001/src/pkg/runtime/symtab.c#newcode239\nsrc/pkg/runtime/symtab.c:239: fgc[nfunc-1] = runtime\u00b7mallocgc(sym->value*sizeof(*fgc), FlagNoPointers, 0, 1);\nYes, that is my near-term plan.\n\nThis information should be suitable for allocation in a read only segment of the executable.  Moreoever, I expect there to be a lot of repeated data and some space will be saved through coalescing.\n\nI am defering any effort to efficiently store this until I have finalized the representation of the pointer descriptions.  I keep discovering corner cases that influence how things should be done.\n\nIn the mean time, if you think it would be helpful, I can put a TODO here.\n\nhttps://codereview.appspot.com/9223046/diff/8001/src/pkg/runtime/symtab.c#newcode239\nsrc/pkg/runtime/symtab.c:239: fgc[nfunc-1] = runtime\u00b7mallocgc(sym->value*sizeof(*fgc), FlagNoPointers, 0, 1);\nYes, you are right.  I'll fix that shortly.",
			"disapproval": false,
			"date": "2013-05-08 18:30:30.937150",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/8001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/8001/src/pkg/runtime/symtab.c#newcode239\nsrc/pkg/runtime/symtab.c:239: fgc[nfunc-1] = runtime\u00b7mallocgc(sym->value*sizeof(*fgc), FlagNoPointers, 0, 1);\nOn 2013/05/08 18:30:31, cshapiro1 wrote:\n> Yes, that is my near-term plan.\n> \n> This information should be suitable for allocation in a read only segment of the\n> executable.  Moreoever, I expect there to be a lot of repeated data and some\n> space will be saved through coalescing.\n> \n> I am defering any effort to efficiently store this until I have finalized the\n> representation of the pointer descriptions.  I keep discovering corner cases\n> that influence how things should be done.\n> \n> In the mean time, if you think it would be helpful, I can put a TODO here.\n\nTODO is fine",
			"disapproval": false,
			"date": "2013-05-09 09:18:05.075490",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttps://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/go.h#newcode286\nsrc/cmd/gc/go.h:286: Bvec*\tbv;\nI am normally all in favor of long, descriptive names.  That does not seem to be the style in this code, nor use the use of underscores in variable names.  I'll rename \"bv\" to the more descriptive \"stackmap\" which should be somewhat less cryptic.  Let me know if you think otherwise.\n\nhttps://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/pgen.c#newcode175\nsrc/cmd/gc/pgen.c:175: walktype1(Type *t, vlong *xoffset, Bvec *bv)\nI am not sure I fully understand what you mean by allocating slots for arguments.  The way I think about this code is it sets a bit in bv for each pointer value offset in t.\n\nI contemplated writing a call-back driven interface for this code.  Unfortunately, there are a lot of one offs for this sort of thing and so either way I was going to end up with one more way do walk a type.  I just discovered an iterator type for structs which would allow at least the bottom-most case to be eliminated.\n\nThere is certainly an opportunity for a clean-up.\n\nhttps://codereview.appspot.com/9223046/diff/22001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/22001/src/pkg/runtime/mgc0.c#newcode1411\nsrc/pkg/runtime/mgc0.c:1411: if(f->args > 0) {\nI would add an assert but we don't do asserts.  I can check the condition a compile time.  What do you think?",
			"disapproval": false,
			"date": "2013-05-09 22:00:39.476940",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/8001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/8001/src/pkg/runtime/symtab.c#newcode239\nsrc/pkg/runtime/symtab.c:239: fgc[nfunc-1] = runtime\u00b7mallocgc(sym->value*sizeof(*fgc), FlagNoPointers, 0, 1);\nThanks.  Done.",
			"disapproval": false,
			"date": "2013-05-09 21:02:49.878270",
			"approval": false
		},
		{
			"sender": "khr@golang.org",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttps://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/go.h#newcode286\nsrc/cmd/gc/go.h:286: Bvec*\tbv;\nThis should be called \"arg_pointer_map\" or something, not just \"bv\".\n\nhttps://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/pgen.c#newcode175\nsrc/cmd/gc/pgen.c:175: walktype1(Type *t, vlong *xoffset, Bvec *bv)\nThis code allocates slots for the arguments.  We must already have such code somewhere, right?  Shouldn't we be sharing that code instead of duplicating it?\n\nhttps://codereview.appspot.com/9223046/diff/22001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/22001/src/pkg/runtime/mgc0.c#newcode1411\nsrc/pkg/runtime/mgc0.c:1411: if(f->args > 0) {\nShouldn't there be some agreement between f->args and f->ptrs.len that we can check?",
			"disapproval": false,
			"date": "2013-05-09 21:49:53.203740",
			"approval": false
		},
		{
			"sender": "khr@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, May 9, 2013 at 3:00 PM, <cshapiro@google.com> wrote:\r\n\r\n>\r\n> https://codereview.appspot.**com/9223046/diff/22001/src/**cmd/gc/go.h<https://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/go.h>\r\n> File src/cmd/gc/go.h (right):\r\n>\r\n> https://codereview.appspot.**com/9223046/diff/22001/src/**\r\n> cmd/gc/go.h#newcode286<https://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/go.h#newcode286>\r\n> src/cmd/gc/go.h:286: Bvec*      bv;\r\n> I am normally all in favor of long, descriptive names.  That does not\r\n> seem to be the style in this code, nor use the use of underscores in\r\n> variable names.  I'll rename \"bv\" to the more descriptive \"stackmap\"\r\n> which should be somewhat less cryptic.  Let me know if you think\r\n> otherwise.\r\n>\r\n> That's better.  I was somewhat confused while reading that this is a map\r\nof the\r\nargument list, not a map of the locals.  So maybe \"argmap\"?\r\n\r\n>\r\n> https://codereview.appspot.**com/9223046/diff/22001/src/**cmd/gc/pgen.c<https://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/pgen.c>\r\n> File src/cmd/gc/pgen.c (right):\r\n>\r\n> https://codereview.appspot.**com/9223046/diff/22001/src/**\r\n> cmd/gc/pgen.c#newcode175<https://codereview.appspot.com/9223046/diff/22001/src/cmd/gc/pgen.c#newcode175>\r\n> src/cmd/gc/pgen.c:175: walktype1(Type *t, vlong *xoffset, Bvec *bv)\r\n> I am not sure I fully understand what you mean by allocating slots for\r\n> arguments.  The way I think about this code is it sets a bit in bv for\r\n> each pointer value offset in t.\r\n>\r\n> I contemplated writing a call-back driven interface for this code.\r\n> Unfortunately, there are a lot of one offs for this sort of thing and so\r\n> either way I was going to end up with one more way do walk a type.  I\r\n> just discovered an iterator type for structs which would allow at least\r\n> the bottom-most case to be eliminated.\r\n>\r\n> There is certainly an opportunity for a clean-up.\r\n>\r\n>  There has to be code somewhere in the compiler/linker that decides at\r\nwhat offset\r\neach argument goes.  You're just duplicating that logic.\r\n\r\n>\r\n> https://codereview.appspot.**com/9223046/diff/22001/src/**\r\n> pkg/runtime/mgc0.c<https://codereview.appspot.com/9223046/diff/22001/src/pkg/runtime/mgc0.c>\r\n> File src/pkg/runtime/mgc0.c (right):\r\n>\r\n> https://codereview.appspot.**com/9223046/diff/22001/src/**\r\n> pkg/runtime/mgc0.c#newcode1411<https://codereview.appspot.com/9223046/diff/22001/src/pkg/runtime/mgc0.c#newcode1411>\r\n> src/pkg/runtime/mgc0.c:1411: if(f->args > 0) {\r\n> I would add an assert but we don't do asserts.  I can check the\r\n> condition a compile time.  What do you think?\r\n>\r\nCheck it at runtime and runtime\u00b7throw if it is bad.\r\n\r\n>\r\n> https://codereview.appspot.**com/9223046/<https://codereview.appspot.com/9223046/>\r\n>\r\n",
			"disapproval": false,
			"date": "2013-05-09 22:26:37.131110",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, May 9, 2013 at 3:26 PM, Keith Randall <khr@google.com> wrote:\r\n\r\n> That's better.  I was somewhat confused while reading that this is a map\r\n> of the\r\n> argument list, not a map of the locals.  So maybe \"argmap\"?\r\n>\r\n\r\nAt the moment the map covers only the argument area.  That will change and\r\nthis map will cover arguments and locals.  The type will also change\r\nslightly as a new map needs to be generated at each call instruction but\r\nthe name can certainly stay the same.\r\n\r\n\r\n>  There has to be code somewhere in the compiler/linker that decides at\r\n> what offset\r\n> each argument goes.  You're just duplicating that logic.\r\n>\r\n\r\nStrinctly speaking, I believe this statement is true.  However, if we are\r\nthinking about the same code that assigns offsets, that code is much more\r\ngeneral and complicated.  Among other things, it needs to handle the case\r\nof type information not yet known.\r\n\r\n\r\n> Check it at runtime and runtime\u00b7throw if it is bad.\r\n>\r\n\r\n Will do.  I will re-upload shortly.\r\n",
			"disapproval": false,
			"date": "2013-05-09 22:35:54.075050",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/05/09 22:26:37, khr1 wrote:\n> Check it at runtime and runtime\u00b7throw if it is bad.\n\nI forgot that the ptrs.len is the number of 32-bit words of the bitmap and is equal to or greater than the number of argument bytes.  I can ensure \"f->args/sizeof(uintptr) <= f->ptrs.len*32\" though that is unsatisfying as most procedures have less than 32 words of arguments.",
			"disapproval": false,
			"date": "2013-05-10 00:52:08.373270",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Ping?",
			"disapproval": false,
			"date": "2013-05-20 20:39:32.751210",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/runtime.h\nFile src/pkg/runtime/runtime.h (right):\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/runtime.h#newcode813\nsrc/pkg/runtime/runtime.h:813: #pragma\tvarargck\ttype\t\"a\"\tSlice\nplease send this is a separate CL",
			"disapproval": false,
			"date": "2013-05-21 06:55:55.074170",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c#newcode1405\nsrc/pkg/runtime/mgc0.c:1405: if(f->locals == 0 || *(bool*)doframe == true)\nadd a comment what this condition means\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c#newcode1409\nsrc/pkg/runtime/mgc0.c:1409: addroot((Obj){sp + outs, f->locals, 0});\nadd a comment here and for other addroot() parts what exactly parts we scan -- args, out args, locals\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c#newcode1412\nsrc/pkg/runtime/mgc0.c:1412: if(f->ptrs.array != nil) {\nwhen does array==nil possible?\ndo we generate info not for all functions?\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c#newcode1415\nsrc/pkg/runtime/mgc0.c:1415: for(i = 0; i < f->ptrs.len; ++i) {\ni++\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/symtab.c#newcode240\nsrc/pkg/runtime/symtab.c:240: fgc[nfunc-1] = runtime\u00b7mallocgc(sym->value*sizeof(**fgc), FlagNoPointers, 0, 1);\nadd a check that args is consistent with nptrs, otherwise GC will break later\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/symtab.c#newcode240\nsrc/pkg/runtime/symtab.c:240: fgc[nfunc-1] = runtime\u00b7mallocgc(sym->value*sizeof(**fgc), FlagNoPointers, 0, 1);\njust allocate it with FlagNoPointers|FlagNoGC, then you do not need the global fgc array at all",
			"disapproval": false,
			"date": "2013-05-21 07:21:40.650280",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c#newcode1405\nsrc/pkg/runtime/mgc0.c:1405: if(f->locals == 0 || *(bool*)doframe == true)\nThis is actually documented in the comment above the function.  Are you suggesting that I move the comment down to this line?\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c#newcode1409\nsrc/pkg/runtime/mgc0.c:1409: addroot((Obj){sp + outs, f->locals, 0});\nOn 2013/05/21 07:21:40, dvyukov wrote:\n> add a comment here and for other addroot() parts what exactly parts we scan --\n> args, out args, locals\n\nDone.\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c#newcode1412\nsrc/pkg/runtime/mgc0.c:1412: if(f->ptrs.array != nil) {\nAt the moment there are many classes of functions (assembly routines, varargs routines, etc.) that do not have any pointer information available.\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c#newcode1415\nsrc/pkg/runtime/mgc0.c:1415: for(i = 0; i < f->ptrs.len; ++i) {\nOn 2013/05/21 07:21:40, dvyukov wrote:\n> i++\n\nDone.\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/runtime.h\nFile src/pkg/runtime/runtime.h (right):\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/runtime.h#newcode813\nsrc/pkg/runtime/runtime.h:813: #pragma\tvarargck\ttype\t\"a\"\tSlice\nOn 2013/05/21 06:55:55, dvyukov wrote:\n> please send this is a separate CL\n\nDone.\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/symtab.c#newcode240\nsrc/pkg/runtime/symtab.c:240: fgc[nfunc-1] = runtime\u00b7mallocgc(sym->value*sizeof(**fgc), FlagNoPointers, 0, 1);\nGood idea, done.\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/symtab.c#newcode240\nsrc/pkg/runtime/symtab.c:240: fgc[nfunc-1] = runtime\u00b7mallocgc(sym->value*sizeof(**fgc), FlagNoPointers, 0, 1);\nThe best I can do is ensure that nptrs <= args/widthptr.  I have added such a check.",
			"disapproval": false,
			"date": "2013-05-21 23:08:56.854670",
			"approval": false
		},
		{
			"sender": "iant@golang.org",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/51001/src/cmd/5l/obj.c\nFile src/cmd/5l/obj.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/5l/obj.c#newcode632\nsrc/cmd/5l/obj.c:632: goto casdef;\ns/casdef/casedef/\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/5l/obj.c#newcode640\nsrc/cmd/5l/obj.c:640: goto casdef;\ns/casdef/casedef/\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/5l/obj.c#newcode641\nsrc/cmd/5l/obj.c:641: cursym->ptrs[p->from.offset] = p->to.offset;\nIn general we want to avoid crashing if somebody sneaks in an invalid .5 file, for increased reliability on the playground and other places where people compile Go code.  So I think you should check for p->from.offset >= cursym->nptrs.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/6l/obj.c\nFile src/cmd/6l/obj.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/6l/obj.c#newcode630\nsrc/cmd/6l/obj.c:630: cursym->ptrs[p->from.offset] = p->to.offset;\nCheck for p->from.offset >= cursym->nptrs.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/6l/optab.c\nFile src/cmd/6l/optab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/6l/optab.c#newcode1340\nsrc/cmd/6l/optab.c:1340: { ANPTRS },\nDo these need to be in 5l/optab.c, or does that work differently?\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/8l/obj.c\nFile src/cmd/8l/obj.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/8l/obj.c#newcode640\nsrc/cmd/8l/obj.c:640: cursym->ptrs[p->from.offset] = p->to.offset;\nCheck for p->from.offset >= cursym->nptrs.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/bv.c\nFile src/cmd/gc/bv.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/bv.c#newcode12\nsrc/cmd/gc/bv.c:12: WORDBITS = WORDSIZE << WORDSIZELOG2,\nI may be misreading, but WORDSIZE == 4, so this makes WORDBITS == 4 << 2 == 16.  Shouldn't it be 32?\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/bv.c#newcode16\nsrc/cmd/gc/bv.c:16: size(uintptr n)\ns/size/bvsize/\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/bv.c#newcode69\nsrc/cmd/gc/bv.c:69: return (word ? 1 : 0);\nI think the style is to omit the parentheses here.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/go.h#newcode703\nsrc/cmd/gc/go.h:703: uint32\tb[];\nAs far as I know we don't currently use C99 flexible array members anywhere else in the toolchain.  I guess it should be OK by now, though.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode224\nsrc/cmd/gc/pgen.c:224: // struct { Itab* tab;  void* data; }\nThis comment is slightly misleading as the data field is not necessarily a pointer.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode234\nsrc/cmd/gc/pgen.c:234: if(t->bound < -1)\nI don't think you should write this check here.  If you want to check, in the !isslice case, that t->bound >= 0, that seems fine.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode237\nsrc/cmd/gc/pgen.c:237: // struct { byte* array; uint32 len; uint32 cap; }\ns/uint32/int/g\nThe len and cap fields have Go type int now.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode275\nsrc/cmd/gc/pgen.c:275: roundup(int32 x, int32 n)\nI think you can just use rnd, defined in align.c, rather than defining your own version.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode305\nsrc/cmd/gc/pgen.c:305: bv = bvalloc((thiswidth + inargwidth + outargwidth) / widthptr);\nHere you create the bitvector with the total of the widths.  But when you walk over the types, you restart each walk at offset 0.  Shouldn't the walks start from some offset?  Right now it seems like you may set the same bits several times.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode312\nsrc/cmd/gc/pgen.c:312: if(bvpopcnt(bv) == 0) {\nIf this is the only use of bvpopcnt then I think it would be better to have a bvempty or something that just looks for all zero values.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode323\nsrc/cmd/gc/pgen.c:323: prog->from.offset = i;\nHere you are setting the offset as a multiple of 32, but in the linker you are taking the offset as a constant.  Is that right?\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/pkg/runtime/runtime.h\nFile src/pkg/runtime/runtime.h (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/pkg/runtime/runtime.h#newcode415\nsrc/pkg/runtime/runtime.h:415: Slice\tptrs;\t// pointer map\nWhen you change this struct you should also change Func in extern.go in this directory.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/pkg/runtime/symtab.c#newcode236\nsrc/pkg/runtime/symtab.c:236: //if(func[nfunc-1].args==ArgsSizeUnknown)runtime\u00b7printf(\"unknown: %S\\n\",func[nfunc-1].name);\nIf you want to keep this, break the line before the function call.",
			"disapproval": false,
			"date": "2013-05-22 00:41:00.169490",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/5l/obj.c\nFile src/cmd/5l/obj.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/5l/obj.c#newcode632\nsrc/cmd/5l/obj.c:632: goto casdef;\nDone.  I will submit a clean-up after this change.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/5l/obj.c#newcode640\nsrc/cmd/5l/obj.c:640: goto casdef;\nDitto.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/5l/obj.c#newcode641\nsrc/cmd/5l/obj.c:641: cursym->ptrs[p->from.offset] = p->to.offset;\nI wrote an expanded set of checks that addresses this comment as well as those from Dmitry.  They will appear in my next upload.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/6l/obj.c\nFile src/cmd/6l/obj.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/6l/obj.c#newcode630\nsrc/cmd/6l/obj.c:630: cursym->ptrs[p->from.offset] = p->to.offset;\nDitto.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/6l/optab.c\nFile src/cmd/6l/optab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/6l/optab.c#newcode1340\nsrc/cmd/6l/optab.c:1340: { ANPTRS },\nThis is a style difference.  I ran into this issue when adding ALOCALS and concluded that it had to be done this way.  The 5 compilers are much more fussy about instructions than the 6 and 8 computers.\n\nI think the 5 compilers should not be different in this regard.   I will file a issue for this.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/8l/obj.c\nFile src/cmd/8l/obj.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/8l/obj.c#newcode640\nsrc/cmd/8l/obj.c:640: cursym->ptrs[p->from.offset] = p->to.offset;\nDitto.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/bv.c\nFile src/cmd/gc/bv.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/bv.c#newcode12\nsrc/cmd/gc/bv.c:12: WORDBITS = WORDSIZE << WORDSIZELOG2,\nYou are right.  I have revised these definitions.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/bv.c#newcode16\nsrc/cmd/gc/bv.c:16: size(uintptr n)\nSure, renamed.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/bv.c#newcode69\nsrc/cmd/gc/bv.c:69: return (word ? 1 : 0);\nParenthesis are gone.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/go.h\nFile src/cmd/gc/go.h (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/go.h#newcode703\nsrc/cmd/gc/go.h:703: uint32\tb[];\nI am happy to remove this and have the variable length data follow n, or make b a 0 element array.  What would you prefer?\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode224\nsrc/cmd/gc/pgen.c:224: // struct { Itab* tab;  void* data; }\nThese definitions come from runtime.h and a void* is used there as well.  I will add a union definition in the comment for clarity.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode234\nsrc/cmd/gc/pgen.c:234: if(t->bound < -1)\nThe case I am guarding against is negative values of bound that are not -1.  Types are initialized with a bound of -100 to indicate that the type needs some values filled in.  The definition of isslice, unfortunately, assumes that any negative value indicates a slice, which confuses incomplete types to with slices.\n\nThis is subtle.  I will add a comment.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode237\nsrc/cmd/gc/pgen.c:237: // struct { byte* array; uint32 len; uint32 cap; }\nThanks.  I have updated the comment here and below TSTRING as well.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode275\nsrc/cmd/gc/pgen.c:275: roundup(int32 x, int32 n)\nI do not think rnd is useful here.  With rnd you can rounding to power of 2 boundary between 1 and 8.  All other values will signal an error at runtime.  My initial intuition was to use rnd.  I defined my own rounding function to work around that limitation.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode305\nsrc/cmd/gc/pgen.c:305: bv = bvalloc((thiswidth + inargwidth + outargwidth) / widthptr);\nThis is very subtle.  The offset is primed in the structure case starting on line 252.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode312\nsrc/cmd/gc/pgen.c:312: if(bvpopcnt(bv) == 0) {\nSure, right now bvpopcnt is overkill.  I defined it so I can count the number of 1 bits and short circuit emitting pointer map data when there is a long run of 0s at the end of the bit vector.  I have replaced bvpopcnt with bvisempty for the time being.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/cmd/gc/pgen.c#newcode323\nsrc/cmd/gc/pgen.c:323: prog->from.offset = i;\nYou are right.  That is what I get for having many pending changes in one client.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/pkg/runtime/runtime.h\nFile src/pkg/runtime/runtime.h (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/pkg/runtime/runtime.h#newcode415\nsrc/pkg/runtime/runtime.h:415: Slice\tptrs;\t// pointer map\nThanks.  I did that, actually, but neglected to add the file.  extern.go is now part of the changelist.\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/51001/src/pkg/runtime/symtab.c#newcode236\nsrc/pkg/runtime/symtab.c:236: //if(func[nfunc-1].args==ArgsSizeUnknown)runtime\u00b7printf(\"unknown: %S\\n\",func[nfunc-1].name);\nThis is clutter let over from an experiment.  I have removed it.",
			"disapproval": false,
			"date": "2013-05-22 06:35:21.159360",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/cmd/5g/peep.c\nFile src/cmd/5g/peep.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/cmd/5g/peep.c#newcode82\nsrc/cmd/5g/peep.c:82: case APTRS:\nAgreed.  Done.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/cmd/gc/pgen.c#newcode309\nsrc/cmd/gc/pgen.c:309: if(thistype != nil)\nI started by using the fn->dcl list but I had difficulty getting complete information in all cases.  I believe the issue was with retrieving the this pointer type but I might be misremembering.\n\nYou are absolutely right about doing the analysis after allocauto.  That is what my next change, which integrates local variables, does.  This code will look different after that as the pointer map computation will be driven by a data flow based liveness computation.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1397\nsrc/pkg/runtime/mgc0.c:1397: // locals need to be scanned.\nYes, when *doframe is true we scan everything between the SP and the (virtual) FP.  This has the effect of scanning the caller's locals area and the arguments area for the callee.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1425\nsrc/pkg/runtime/mgc0.c:1425: for((j = (rem < 32) ? rem : 32); j > 0; j--) {\nI have been thinking the same thing.  Compiler intrinsics for all the common bit operations will be helpful.  I suspect other parts of the GC are performance limited by bitmap scanning.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1426\nsrc/pkg/runtime/mgc0.c:1426: if(w & b) {\nDone.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1434\nsrc/pkg/runtime/mgc0.c:1434: } else {\nDone.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/symtab.c#newcode238\nsrc/pkg/runtime/symtab.c:238: if (sym->value > func[nfunc-1].args/sizeof(uintptr)) {\nSorry, there is some units confusion here.  I have changed .nptrs to consistently be the number of bits in the map.  So, this check does what it is supposed to.",
			"disapproval": false,
			"date": "2013-05-22 23:19:10.821590",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1397\nsrc/pkg/runtime/mgc0.c:1397: // locals need to be scanned.\nOn 2013/05/22 23:19:11, cshapiro1 wrote:\n> Yes, when *doframe is true we scan everything between the SP and the (virtual)\n> FP.  This has the effect of scanning the caller's locals area and the arguments\n> area for the callee.\n\nYou \"Scan the entire stack frame\" and then you additionally scan args in \"if(f->args > 0) {\".\nWhat is true?\n1. The comment is incorrect.\n2. The code under \"if\" is not supposed to be executed in this case.\n3. Args is not a part of the entire stack frame.\n4. I am missing something.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1425\nsrc/pkg/runtime/mgc0.c:1425: for((j = (rem < 32) ? rem : 32); j > 0; j--) {\nOn 2013/05/22 23:19:11, cshapiro1 wrote:\n> I have been thinking the same thing.  Compiler intrinsics for all the common bit\n> operations will be helpful.  I suspect other parts of the GC are performance\n> limited by bitmap scanning.\n\nThere is no other bitmap scanning in GC AFAIR.\n\nhttps://codereview.appspot.com/9223046/diff/75001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/75001/src/pkg/runtime/symtab.c#newcode201\nsrc/pkg/runtime/symtab.c:201: roundup(int32 x, int32 n)\nuse ROUND macro",
			"disapproval": false,
			"date": "2013-05-23 05:28:58.239200",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/38001/src/pkg/runtime/mgc0.c#newcode1405\nsrc/pkg/runtime/mgc0.c:1405: if(f->locals == 0 || *(bool*)doframe == true)\nOn 2013/05/21 23:08:57, cshapiro1 wrote:\n> This is actually documented in the comment above the function.  Are you\n> suggesting that I move the comment down to this line?\n\nAh, OK\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1397\nsrc/pkg/runtime/mgc0.c:1397: // locals need to be scanned.\nBut you also scan args in this case?\nI am just trying to understand how exactly it works.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1425\nsrc/pkg/runtime/mgc0.c:1425: for((j = (rem < 32) ? rem : 32); j > 0; j--) {\nI guess we will need BSF intrinsic in future... just thinking aloud\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1426\nsrc/pkg/runtime/mgc0.c:1426: if(w & b) {\ndrop {}\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1434\nsrc/pkg/runtime/mgc0.c:1434: } else {\ndrop {}\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/symtab.c#newcode238\nsrc/pkg/runtime/symtab.c:238: if (sym->value > func[nfunc-1].args/sizeof(uintptr)) {\n>The best I can do is ensure that nptrs <= args/widthptr\ndo you mean that .ptrs does not cover the tail of args if there are no pointers?\n\neach .ptrs value covers 32*sizeof(uintptr) of arg space.\nthe check seems to imply that it covers only sizeof(uintptr).",
			"disapproval": false,
			"date": "2013-05-22 07:07:13.939330",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/62001/src/cmd/5g/peep.c\nFile src/cmd/5g/peep.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/cmd/5g/peep.c#newcode82\nsrc/cmd/5g/peep.c:82: case APTRS:\nAdd these 5g changes to 6g and 8g as well.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/cmd/gc/pgen.c#newcode309\nsrc/cmd/gc/pgen.c:309: if(thistype != nil)\nThis could be done more cleanly by using the fn->dcl list. Move the pointermap call to after allocauto and it can be generalized to handle local variables as well.",
			"disapproval": false,
			"date": "2013-05-22 09:29:47.901870",
			"approval": false
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "https://codereview.appspot.com/9223046/diff/62001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/cmd/gc/pgen.c#newcode309\nsrc/cmd/gc/pgen.c:309: if(thistype != nil)\nOn 2013/05/22 23:19:11, cshapiro1 wrote:\n> I started by using the fn->dcl list but I had difficulty getting complete\n> information in all cases.  I believe the issue was with retrieving the this\n> pointer type but I might be misremembering.\n> \n\nThe this parameter shows up in dcl as a node with class PPARAM. The initial offset of the parameters should be in their xoffset field.\n\nYou're doing a lot of extra work trying to figure out how the arguments are arranged, when we already have this information in the AST.",
			"disapproval": false,
			"date": "2013-05-23 06:25:09.480000",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/05/23 06:25:09, DMorsing wrote:\n> The this parameter shows up in dcl as a node with class PPARAM. The initial\n> offset of the parameters should be in their xoffset field.\n\nI believe this statement to not generally be true.\n\nConsider the following function definition \n\n  func (*TypeAssertionError) RuntimeError() {}\n\nIf I follow your suggestion I will mistake this function as not having a receiver argument as curfn->dcl will be NULL.  This might not be the only issue but it was the first I encountered.\n\n> You're doing a lot of extra work trying to figure out how the arguments are\n> arranged, when we already have this information in the AST.\n\nI am not yet convinced there is a convenient and reliable way to get this from the AST.  I am happy to be proven wrong.\n\nAs I mentioned up-thread, my next change will be computing this information somewhat differently so this code (which I agree is not the most elegant) will be relatively short lived.",
			"disapproval": false,
			"date": "2013-05-23 21:56:10.994510",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1397\nsrc/pkg/runtime/mgc0.c:1397: // locals need to be scanned.\nOn 2013/05/23 05:28:58, dvyukov wrote:\n> You \"Scan the entire stack frame\" and then you additionally scan args in\n> \"if(f->args > 0) {\".\n> What is true?\n> 1. The comment is incorrect.\n> 2. The code under \"if\" is not supposed to be executed in this case.\n> 3. Args is not a part of the entire stack frame.\n> 4. I am missing something.\n\nItem number 3 is true.  Arguments are located at addresses above the virtual FP which is within the stack frame of the caller, not the stack frame currently being scanned.\n\nThe callee has knowledge of what arguments are live in the frame of the caller.  This is why we scan part of the caller frame in the callee.  The doframe signal is used when the callee does not have knowledge of the argument size.  In that case the caller scans the arguments area within its own frame.\n\nIf you think some of this information is not correctly described by my comment, I am happy to rewrite it to emphasize any subtlties.  Just let me know what might be missing.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1425\nsrc/pkg/runtime/mgc0.c:1425: for((j = (rem < 32) ? rem : 32); j > 0; j--) {\nOn 2013/05/23 05:28:58, dvyukov wrote:\n> There is no other bitmap scanning in GC AFAIR.\n\nThat should have read \"I suspect other parts of the GC are performance\n*will be* limited by bitmap scanning.\"  At the moment, I believe you are right.\n\nhttps://codereview.appspot.com/9223046/diff/75001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/75001/src/pkg/runtime/symtab.c#newcode201\nsrc/pkg/runtime/symtab.c:201: roundup(int32 x, int32 n)\nDone.\n\nThere are too many ways to round a number in this system.",
			"disapproval": false,
			"date": "2013-05-23 22:14:54.965530",
			"approval": false
		},
		{
			"sender": "dvyukov@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM on the runtime part\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1397\nsrc/pkg/runtime/mgc0.c:1397: // locals need to be scanned.\nOn 2013/05/23 22:14:55, cshapiro1 wrote:\n> On 2013/05/23 05:28:58, dvyukov wrote:\n> > You \"Scan the entire stack frame\" and then you additionally scan args in\n> > \"if(f->args > 0) {\".\n> > What is true?\n> > 1. The comment is incorrect.\n> > 2. The code under \"if\" is not supposed to be executed in this case.\n> > 3. Args is not a part of the entire stack frame.\n> > 4. I am missing something.\n> \n> Item number 3 is true.  Arguments are located at addresses above the virtual FP\n> which is within the stack frame of the caller, not the stack frame currently\n> being scanned.\n> \n> The callee has knowledge of what arguments are live in the frame of the caller. \n> This is why we scan part of the caller frame in the callee.  The doframe signal\n> is used when the callee does not have knowledge of the argument size.  In that\n> case the caller scans the arguments area within its own frame.\n> \n> If you think some of this information is not correctly described by my comment,\n> I am happy to rewrite it to emphasize any subtlties.  Just let me know what\n> might be missing.\n\nI think now I am starting to understand. Thanks!\nYes, please add the first 2 paragraphs of your answer to the comment.",
			"disapproval": false,
			"date": "2013-05-24 04:42:07.599510",
			"approval": true
		},
		{
			"sender": "daniel.morsing@gmail.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/05/23 21:56:10, cshapiro1 wrote:\n> On 2013/05/23 06:25:09, DMorsing wrote:\n> > The this parameter shows up in dcl as a node with class PPARAM. The initial\n> > offset of the parameters should be in their xoffset field.\n> \n> I believe this statement to not generally be true.\n> \n> Consider the following function definition \n> \n>   func (*TypeAssertionError) RuntimeError() {}\n> \n> If I follow your suggestion I will mistake this function as not having a\n> receiver argument as curfn->dcl will be NULL.  This might not be the only issue\n> but it was the first I encountered.\n> \n> > You're doing a lot of extra work trying to figure out how the arguments are\n> > arranged, when we already have this information in the AST.\n> \n> I am not yet convinced there is a convenient and reliable way to get this from\n> the AST.  I am happy to be proven wrong.\n> \n> As I mentioned up-thread, my next change will be computing this information\n> somewhat differently so this code (which I agree is not the most elegant) will\n> be relatively short lived.\n\nYou're right, Sorry for being so pushy.\n\nIn any case, you can get the width of the function parameters via fn->type->argwid and you can get an iterator that walks the receiver and arguments via funcfirst() and funcnext().",
			"disapproval": false,
			"date": "2013-05-24 06:15:45.259780",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/05/24 06:15:45, DMorsing wrote:\n> You're right, Sorry for being so pushy.\n\nNo problem.  Not having the receiver in curfn->dcl seems like an oversight.  It might be something worth fixing.\n\n> In any case, you can get the width of the function parameters via\n> fn->type->argwid and you can get an iterator that walks the receiver and\n> arguments via funcfirst() and funcnext().\n\nThanks, fn->type->argwid is a significant improvement.  It is in my most recent upload. \n\nThe funcfirst and funcnext calls would still leave me walking the out arguments by the means already in place.  I should be able to switch to using it once I treat the out arguments like local variables.  As an aside, I think the internals of walktype might look a little better if it used structfirst and structnext.  I plan to clean that up in subsequent change.",
			"disapproval": false,
			"date": "2013-05-28 21:07:55.058090",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL",
			"disapproval": false,
			"date": "2013-05-28 21:08:11.380760",
			"approval": false
		},
		{
			"sender": "iant@golang.org",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM\n\nLet's get this in.  Thanks to you and to all the reviewers.\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/cmd/gc/pgen.c#newcode273\nsrc/cmd/gc/pgen.c:273: xoffset = 0;\nI think we should have a comment somewhere explaining why this xoffset = 0 is, in a sense, not used.  That is, why calling walktype multiple times in pointermap works OK.\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/pkg/runtime/mgc0.c#newcode1418\nsrc/pkg/runtime/mgc0.c:1418: // Scan the arguments area.\nShould we have a check here that f->ptrs.len is large enough to cover the entire argument area?\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/pkg/runtime/symtab.c#newcode248\nsrc/pkg/runtime/symtab.c:248: ((uint32*)func[nfunc-1].ptrs.array)[func[nfunc-1].ptrs.len++] = sym->value;\nAdd a check that .ptrs.len < .ptrs.cap?",
			"disapproval": false,
			"date": "2013-05-28 21:23:35.547480",
			"approval": true
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I addressed the remaining review comments in my last upload.  I will submit after doing a final sync and test.\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/62001/src/pkg/runtime/mgc0.c#newcode1397\nsrc/pkg/runtime/mgc0.c:1397: // locals need to be scanned.\nI have improved the comment.  Let me know what you think.\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/cmd/gc/pgen.c\nFile src/cmd/gc/pgen.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/cmd/gc/pgen.c#newcode273\nsrc/cmd/gc/pgen.c:273: xoffset = 0;\nDone.\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/pkg/runtime/mgc0.c\nFile src/pkg/runtime/mgc0.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/pkg/runtime/mgc0.c#newcode1418\nsrc/pkg/runtime/mgc0.c:1418: // Scan the arguments area.\nThese values are produced by the symbol table construction.  I have a check in the symbol table construction to ensure the pointer map is not too large.\n\nI would like to start dropping long runs of trailing 0s at the end of the pointer map so this check would be short lived.  However, I can probably do a better job checking this sort of stuf once I resolve issues in the compiler regarding nosplits, varargs, and other things that confused the argument size tracking.\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/pkg/runtime/symtab.c\nFile src/pkg/runtime/symtab.c (right):\n\nhttps://codereview.appspot.com/9223046/diff/88001/src/pkg/runtime/symtab.c#newcode248\nsrc/pkg/runtime/symtab.c:248: ((uint32*)func[nfunc-1].ptrs.array)[func[nfunc-1].ptrs.len++] = sym->value;\nDone.",
			"disapproval": false,
			"date": "2013-05-29 00:29:19.649950",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"cshapiro@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Abandoned ***",
			"disapproval": false,
			"date": "2013-05-29 00:54:19.181090",
			"approval": false
		},
		{
			"sender": "cshapiro@google.com",
			"recipients": [
				"cshapiro@google.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"cshapiro@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as https://code.google.com/p/go/source/detail?r=02e5cb24c95a ***\n\ncmd/5l, cmd/6l, cmd/8l, cmd/gc, runtime: generate and use bitmaps of argument pointer locations\n\nWith this change the compiler emits a bitmap for each function\ncovering its stack frame arguments area.  If an argument word\nis known to contain a pointer, a bit is set.  The garbage\ncollector reads this information when scanning the stack by\nframes and uses it to ignores locations known to not contain a\npointer.\n\nR=golang-dev, bradfitz, daniel.morsing, dvyukov, khr, khr, iant, cshapiro\nCC=golang-dev\nhttps://codereview.appspot.com/9223046",
			"disapproval": false,
			"date": "2013-05-29 00:59:16.425230",
			"approval": false
		},
		{
			"sender": "fullung@gmail.com",
			"recipients": [
				"cshapiro@google.com",
				"fullung@gmail.com",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"cshapiro@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 2013/05/29 00:59:16, cshapiro1 wrote:\n> *** Submitted as https://code.google.com/p/go/source/detail?r=02e5cb24c95a ***\n> cmd/5l, cmd/6l, cmd/8l, cmd/gc, runtime: generate and use bitmaps of argument\n> pointer locations\n\nI've run into some fun with this change...\n\nhttps://code.google.com/p/go/issues/detail?id=5621",
			"disapproval": false,
			"date": "2013-06-03 09:45:12.747580",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"cshapiro@google.com",
				"fullung@gmail.com",
				"cshapiro@golang.org",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Abandoned ***",
			"disapproval": false,
			"date": "2013-08-03 00:29:22.388100",
			"approval": false
		},
		{
			"sender": "cshapiro@golang.org",
			"recipients": [
				"cshapiro@google.com",
				"fullung@gmail.com",
				"cshapiro@golang.org",
				"golang-dev@googlegroups.com",
				"bradfitz@golang.org",
				"daniel.morsing@gmail.com",
				"dvyukov@google.com",
				"khr@golang.org",
				"khr@google.com",
				"iant@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Abandoned ***",
			"disapproval": false,
			"date": "2013-08-03 00:29:31.654300",
			"approval": false
		}
	],
	"owner_email": "cshapiro@google.com",
	"private": false,
	"base_url": "",
	"owner": "cshapiro1",
	"subject": "code review 9223046: cmd/5l, cmd/6l, cmd/8l, cmd/gc, runtime: generate and u...",
	"created": "2013-05-08 01:08:28.033580",
	"patchsets": [
		1,
		2001,
		5001,
		8001,
		11003,
		22001,
		22002,
		36001,
		38001,
		47001,
		51001,
		62001,
		73001,
		75001,
		79001,
		88001,
		95001,
		100001
	],
	"modified": "2013-08-03 00:29:32.569540",
	"closed": true,
	"issue": 9223046
}