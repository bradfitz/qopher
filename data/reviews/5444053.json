{
	"description": "spec: var x = 'a' defaults to type rune",
	"cc": [
		"gri@golang.org",
		"r@golang.org",
		"r@google.com",
		"adg@golang.org",
		"iant@google.com",
		"ken@google.com",
		"golang-dev@googlegroups.com"
	],
	"reviewers": [],
	"messages": [
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Dec 7, 2011 at 17:12,  <gri@golang.org> wrote:\n> I am strongly in favor of the ordering\n>\n> character, integer, floating point, complex\n> (32bit -> 32/64bit -> 32/64bit -> 64/128bit)\n\nI am equally strongly in favor of the ordering\nin this CL: if 'x' defaults to rune, so should 'x'+1.\nUltimately it affects very little code; the rules\nin this CL are less surprising than the ones\nyou are proposing.\n\n> As we have seen, it removes extra casts as well.\n\nIt removed one conversion in one line of code.\n\n>  I have not seen a good argument for the\n> proposed order yet.\n\nThe proposed order is very easy to remember:\nif you see an i anywhere, it's complex;\nif you see an e or . anywhere, it's float;\nif you see a ' anywhere, it's rune;\notherwise it's an integer.\n\nThe argument is that it is the least surprising.\nReversing rune and integer breaks the symmetry.\n\nI have not seen an argument for putting\ncharacter before integer.  You mentioned\nn*10 + digit - '0' at one point, but that typically\nn and digit are variables, so it would not be\naffected by the ordering here.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-07 22:22:45.489751",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Hello golang-dev@googlegroups.com,\n\nI'd like you to review this change to\nhttps://go.googlecode.com/hg/",
			"disapproval": false,
			"date": "2011-12-07 22:00:48.776263",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Dec 7, 2011 at 2:22 PM, Russ Cox <rsc@golang.org> wrote:\n> On Wed, Dec 7, 2011 at 17:12, \u00a0<gri@golang.org> wrote:\n>> I am strongly in favor of the ordering\n>>\n>> character, integer, floating point, complex\n>> (32bit -> 32/64bit -> 32/64bit -> 64/128bit)\n>\n> I am equally strongly in favor of the ordering\n> in this CL: if 'x' defaults to rune, so should 'x'+1.\n> Ultimately it affects very little code; the rules\n> in this CL are less surprising than the ones\n> you are proposing.\n>\n>> As we have seen, it removes extra casts as well.\n>\n> It removed one conversion in one line of code.\n\nActually two, in two lines of code.\n\n>\n>> \u00a0I have not seen a good argument for the\n>> proposed order yet.\n>\n> The proposed order is very easy to remember:\n> if you see an i anywhere, it's complex;\n> if you see an e or . anywhere, it's float;\n> if you see a ' anywhere, it's rune;\n> otherwise it's an integer.\n\nunless the values are constant names, in which case one has to look\nthem up, of course\n\nthe proposal I am suggestion is just as simple:\n\nunless it's all characters, the current rules apply\n\n(and formulated out it's the same list as yours with the last two lines swapped)\n\n>\n> The argument is that it is the least surprising.\n> Reversing rune and integer breaks the symmetry.\n\nI don't understand this argument at all. Which symmetry? Runes are\n\"smaller\" than ints.\n>\n> I have not seen an argument for putting\n> character before integer. \u00a0You mentioned\n> n*10 + digit - '0' at one point, but that typically\n> n and digit are variables, so it would not be\n> affected by the ordering here.\n\n- possibly fewer casts (we have 2 cases)\n- sizeof(rune) <= sizeof(int)\n\n- gri\n\n>\n> Russ\n",
			"disapproval": false,
			"date": "2011-12-07 22:36:30.613707",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"gri@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I am strongly in favor of the ordering\n\ncharacter, integer, floating point, complex\n(32bit -> 32/64bit -> 32/64bit -> 64/128bit)\n\nAs we have seen, it removes extra casts as well. I have not seen a good argument for the proposed order yet.\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html\nFile doc/go_spec.html (right):\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode2\ndoc/go_spec.html:2: <!-- subtitle Version of December 5, 2011 -->\nDecember 7\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode517\ndoc/go_spec.html:517: <i>character constants</i>,\nI would mention them before integer constants\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode519\ndoc/go_spec.html:519: and <i>string constants</i>. Integer, character, floating-point,\nCharacter, integer, floating-point, ...\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode527\ndoc/go_spec.html:527: <a href=\"#Character_literals\">character</a>,\nsame here - before integer\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode3420\ndoc/go_spec.html:3420: the kind that appears later the list: integer, character, floating-point, complex.\nthe sentence is garbled (later in the list) - but even with the missing \"in\", it's not easy to understand what is meant.\n\nAlso, I am still much in favor of the order: character, integer, floating-point, complex. It's really odd the other way around.\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode3447\ndoc/go_spec.html:3447: const j = 'w' + 1          // j == 'x'   (untyped character constant)\ninteger constant\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode3455\ndoc/go_spec.html:3455: integer, character, or floating-point constants yields\ncharacter, integer, or ...\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode3761\ndoc/go_spec.html:3761: respectively, depending on whether the value is a boolean, integer,\nboolean, character, integer...",
			"disapproval": false,
			"date": "2011-12-07 22:12:37.539278",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"gri@golang.org",
				"r@golang.org",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html\nFile doc/go_spec.html (right):\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode517\ndoc/go_spec.html:517: <i>character constants</i>,\nOn 2011/12/07 22:12:37, gri wrote:\n> I would mention them before integer constants\n\ninteger constants seem more fundamental. i'm happy to have them first.\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode3420\ndoc/go_spec.html:3420: the kind that appears later the list: integer, character, floating-point, complex.\ni'm fine with the order but agree this is a peculiar sentence. it's not clear what list you mean. be clear.\n\nhttp://codereview.appspot.com/5444053/diff/5001/doc/go_spec.html#newcode3447\ndoc/go_spec.html:3447: const j = 'w' + 1          // j == 'x'   (untyped character constant)\ncharacter constant",
			"disapproval": false,
			"date": "2011-12-08 00:30:14.573325",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Dec 7, 2011 at 19:30,  <r@golang.org> wrote:\n>> I would mention them before integer constants\n> integer constants seem more fundamental. i'm happy to have them first.\n\nDoes anyone have arguments one way or another to bring up?\nI don't see an easy resolution right now.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-08 02:56:54.752606",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "\nOn Dec 7, 2011, at 6:56 PM, Russ Cox wrote:\n\n> On Wed, Dec 7, 2011 at 19:30,  <r@golang.org> wrote:\n>>> I would mention them before integer constants\n>> integer constants seem more fundamental. i'm happy to have them first.\n> \n> Does anyone have arguments one way or another to bring up?\n> I don't see an easy resolution right now.\n\nThe only one I have is that 'x'+1 should be of type rune because the runeness should color the type, just as 1.0+1 colors it to float. It seems bizarre to me even to argue that it should promote to int, the most generic type.\n\n-rob\n\n\n",
			"disapproval": false,
			"date": "2011-12-08 04:11:23.411620",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "edit: Just saw Rob's mail, and my point is essentially the same.\n\nOn 8 December 2011 13:56, Russ Cox <rsc@golang.org> wrote:\n> Does anyone have arguments one way or another to bring up?\n> I don't see an easy resolution right now.\n\nI am strongly in favor of\n\n  var x = 'a' + 1\n\nbeing of type rune.\n\nWere it an int, I would have a hard time explaining it. So far that's\nbeen a pretty good litmus test (for me) as to whether we're heading in\nthe right direction or not.\n\nAndrew\n",
			"disapproval": false,
			"date": "2011-12-08 04:14:02.587181",
			"approval": false
		},
		{
			"sender": "iant@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Russ Cox <rsc@golang.org> writes:\n\n> On Wed, Dec 7, 2011 at 19:30,  <r@golang.org> wrote:\n>>> I would mention them before integer constants\n>> integer constants seem more fundamental. i'm happy to have them first.\n>\n> Does anyone have arguments one way or another to bring up?\n> I don't see an easy resolution right now.\n\nThe issue is all about the type to give to an untyped constant\nexpression, right?  I mean, we're agreed that in\n\ta := 1\n        b := 'a'\nthen a has type int and b has type rune aka int32.  The only question is\ngiven\n\tc := 'a' + 1\nwhether the type of c is int or rune.\n\nThe rune type is a little funny because we normally expect a variable of\ntype rune to hold some sort of character.  If we write '9' - '0' we get\na rune, even though that doesn't make much sense; an int 9 would be more\nnatural than a rune '\\x09'.  On the other hand if we write 'a' + 1 then\nwe would expect type rune, namely 'b', rather than an int 98, and if we\nwrite '9' - 1 we expect '8' rather than an int 56.  In fact the na\u00efve\nideal approach seems pretty simple: combining two values of type rune\nalways yields a value of type int, except that adding or subtracting an\nint from a rune yields a rune.  But clearly we don't want to make rune\nbe different from other types in this regard.\n\nStill, perhaps this can show us the way.  I assume we can all agree that\n'9' - '0' is going to (counterintuitively) give us a rune.  And I assume\nwe can all agree that 'a' + 1, the expression in question, should\nideally give us a rune.  Given that we are definitely going to get a\nrune in the case where we probably don't want it, and that we do want a\nrune in a common case of combining a rune and an int, it seems to me\nthat we ought to lean toward making a combination of an int and a rune\nbe a rune.  Otherwise we will get a rune when we don't want it and an\nint when we don't want it.  It seems like it might be better to at least\nget one of those right.\n\nIan\n",
			"disapproval": false,
			"date": "2011-12-08 05:34:00.599208",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "[resending - this time to everybody - GMail flaking out on me]\n\nOn Wed, Dec 7, 2011 at 8:11 PM, Rob 'Commander' Pike <r@google.com> wrote:\n>\n> On Dec 7, 2011, at 6:56 PM, Russ Cox wrote:\n>\n>> On Wed, Dec 7, 2011 at 19:30, \u00a0<r@golang.org> wrote:\n>>>> I would mention them before integer constants\n>>> integer constants seem more fundamental. i'm happy to have them first.\n>>\n>> Does anyone have arguments one way or another to bring up?\n>> I don't see an easy resolution right now.\n>\n> The only one I have is that 'x'+1 should be of type rune because the runeness should color the type, just as 1.0+1 colors it to float. It seems bizarre to me even to argue that it should promote to int, the most generic type.\n\nI find that argument not convincing. Why should rune-ness color the\ntype and not int-ness? Is it because a rune literal is a more complex\nliteral with special characters (')? And a float has even more special\nchars (. and e), and complex even more (., e, and i)?\n\nThe fact is that every rune can be represented by an int, but not\nevery int fits into a rune. For any rune constant r\n\nvar v = r + 0\n\nwill work if r + 0 defaults to int. However, if the expression\ndefaults to rune type\n\nvar v = i + '\\x00'\n\nwill not work for any int constant i, since i might be too large (a\n64bit int value) to fit into a (32bit) rune.\n\nFinally, by setting the order as\n\nrune -> int -> float -> complex\n\nthe behavior of untyped constant expressions is exactly as now unless\nall operands are untyped runes. I would call _that_ following the\nprinciple of least surprise.\n\nUntyped constant expressions where all operands are runes are not that\ncommon, and those would be the only ones behaving differently from\nwhat we have now (and most likely are of the form ch := 'a', where it makes\na lot of sense for ch to be of type rune).\n\n- gri\n",
			"disapproval": false,
			"date": "2011-12-08 05:27:04.398223",
			"approval": false
		},
		{
			"sender": "adg@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On 8 December 2011 16:27, Robert Griesemer <gri@golang.org> wrote:\n> The fact is that every rune can be represented by an int, but not\n> every int fits into a rune. For any rune constant r\n>\n> var v = r + 0\n>\n> will work if r + 0 defaults to int. However, if the expression\n> defaults to rune type\n>\n> var v = i + '\\x00'\n>\n> will not work for any int constant i, since i might be too large (a\n> 64bit int value) to fit into a (32bit) rune.\n\nIMO the compiler error generated in that case would be a help, not a\nhindrance. Why would you want to add a rune value to some huge integer\nconstant? Seems like an error to me. Better to be explicit in that case:\n\nvar v = i + int('\\x00') // yep, I really mean this\n\nAndrew\n",
			"disapproval": false,
			"date": "2011-12-08 06:08:05.522024",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Wed, Dec 7, 2011 at 9:33 PM, Ian Lance Taylor <iant@google.com> wrote:\n> Still, perhaps this can show us the way. \u00a0I assume we can all agree that\n> '9' - '0' is going to (counterintuitively) give us a rune. \u00a0And I assume\n> we can all agree that 'a' + 1, the expression in question, should\n> ideally give us a rune. \u00a0Given that we are definitely going to get a\n> rune in the case where we probably don't want it, and that we do want a\n> rune in a common case of combining a rune and an int, it seems to me\n> that we ought to lean toward making a combination of an int and a rune\n> be a rune. \u00a0Otherwise we will get a rune when we don't want it and an\n> int when we don't want it. \u00a0It seems like it might be better to at least\n> get one of those right.\n\nThat sounds great but the fact is that this appears to require more\ncasts in the current code than my alternative proposal. To me that\nmeans that either our code is not representative (possible), or that\nthis intuition is wrong (also possible). Looking at rsc's CL again, by\nfar the majority of places where a rune cast can be avoided are of the\nform\n\nv := 'x'\n\nwhich makes a lot of sense, of course. There are two places where int\ncasts have to be introduced because the standing proposal (calling it\n#1) changes current behavior:\n\nhttp://codereview.appspot.com/5448091/diff/4001/src/pkg/math/big/nat.go?context=10&column_width=80\nhttp://codereview.appspot.com/5448091/diff/4001/src/pkg/strings/strings_test.go?context=10&column_width=80\n\nThose casts wouldn't be needed with my proposal (calling it #2) which\ndoes not change current behavior in this case (principle of least\nsurprise).\n\nHere's another proposal (calling it #3):\n\n#3) If and only if an expression consists of a single untyped rune,\nthe default type is rune. Otherwise, things remain as before.\n\nThis is a bit irregular, but it would not change anything except for\nthe really common case. It would also make 'a' - 'b' an int (as\nbefore).\n\nThat said, I still believe #2 is the correct approach. It's regular,\ndoes the job, is easy to explain (rune -> int -> float -> complex),\nand doesn't lead to weird corner case errors (an int always fits into\na rune).\n\n- gri\n",
			"disapproval": false,
			"date": "2011-12-08 16:59:18.858316",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "\nOn Dec 8, 2011, at 11:22 AM, Robert Griesemer wrote:\n\n> How is it different from:\n> \n> \tx := int(61)+1.0\n> \ty := 61 + 1.0\n> \n> ?\n> \n> x will have type int, but y is float64. With the same argument one\n> could say that y should be int. It may look bizarre, but it makes\n> perfect sense (just maybe not emotional sense).\n\nIt's different because 61 is an untyped integer constant, so in isolation int(61) is different in effect from rune(61).\n\n-rob\n\n",
			"disapproval": false,
			"date": "2011-12-08 19:37:33.220011",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PS: I meant to say at the end: \"a rune always fits into an int\", of course.\n- gri\n\nOn Thu, Dec 8, 2011 at 8:59 AM, Robert Griesemer <gri@golang.org> wrote:\n> On Wed, Dec 7, 2011 at 9:33 PM, Ian Lance Taylor <iant@google.com> wrote:\n>> Still, perhaps this can show us the way. \u00a0I assume we can all agree that\n>> '9' - '0' is going to (counterintuitively) give us a rune. \u00a0And I assume\n>> we can all agree that 'a' + 1, the expression in question, should\n>> ideally give us a rune. \u00a0Given that we are definitely going to get a\n>> rune in the case where we probably don't want it, and that we do want a\n>> rune in a common case of combining a rune and an int, it seems to me\n>> that we ought to lean toward making a combination of an int and a rune\n>> be a rune. \u00a0Otherwise we will get a rune when we don't want it and an\n>> int when we don't want it. \u00a0It seems like it might be better to at least\n>> get one of those right.\n>\n> That sounds great but the fact is that this appears to require more\n> casts in the current code than my alternative proposal. To me that\n> means that either our code is not representative (possible), or that\n> this intuition is wrong (also possible). Looking at rsc's CL again, by\n> far the majority of places where a rune cast can be avoided are of the\n> form\n>\n> v := 'x'\n>\n> which makes a lot of sense, of course. There are two places where int\n> casts have to be introduced because the standing proposal (calling it\n> #1) changes current behavior:\n>\n> http://codereview.appspot.com/5448091/diff/4001/src/pkg/math/big/nat.go?context=10&column_width=80\n> http://codereview.appspot.com/5448091/diff/4001/src/pkg/strings/strings_test.go?context=10&column_width=80\n>\n> Those casts wouldn't be needed with my proposal (calling it #2) which\n> does not change current behavior in this case (principle of least\n> surprise).\n>\n> Here's another proposal (calling it #3):\n>\n> #3) If and only if an expression consists of a single untyped rune,\n> the default type is rune. Otherwise, things remain as before.\n>\n> This is a bit irregular, but it would not change anything except for\n> the really common case. It would also make 'a' - 'b' an int (as\n> before).\n>\n> That said, I still believe #2 is the correct approach. It's regular,\n> does the job, is easy to explain (rune -> int -> float -> complex),\n> and doesn't lead to weird corner case errors (an int always fits into\n> a rune).\n>\n> - gri\n",
			"disapproval": false,
			"date": "2011-12-08 17:01:01.057208",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 8, 2011 at 9:48 AM, Ian Lance Taylor <iant@google.com> wrote:\n> Robert Griesemer <gri@golang.org> writes:\n>\n>> Looking at rsc's CL again, by\n>> far the majority of places where a rune cast can be avoided are of the\n>> form\n>>\n>> v := 'x'\n>>\n>> which makes a lot of sense, of course.\n>\n> I don't quite understand this. \u00a0I thought we all agreed that in a\n> statement like\n> \u00a0 \u00a0 \u00a0 \u00a0v := 'x'\n> that v would get type rune. \u00a0Are you saying that we do not all agree on\n> that?\n\nNo. We do all agree on that. With all proposals we will get that\neffect, which is what we want.\n\n- gri\n",
			"disapproval": false,
			"date": "2011-12-08 17:56:42.835047",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 8, 2011 at 13:22, Robert Griesemer <gri@golang.org> wrote:\n> I don't understand why all of a sudden 'a' should become so special in\n> a situation like 'a' + 1 when until now we were perfectly happy with\n> it defaulting to int type. After all, the rune type _is_ int32. Why\n> should a constant expression a + b where a defaults to int32 and b\n> defaults to int together default to int32? Makes no sense to me at\n> all.\n\nint32 and 'character constant' are different concepts.\nWe are not talking about int32 + int.\nWe are talking about character constant + integer constant.\nYou keep mentioning representation, but that's not actually\nrelevant, since these are ideal constants.  You can have\na 100-bit character constant the same as you can have\na 100-bit integer constant.\n\nI never want to have to explain this error to someone:\n\nvar (\n    x = 'a'\n    y = 'a'+1\n    alpha = []rune{x, y}  // ER\n)\n\nx.go:6: cannot use y (type int) as type rune in array element\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-08 18:32:23.475177",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 8, 2011 at 11:37 AM, Rob 'Commander' Pike <r@google.com> wrote:\n>\n> On Dec 8, 2011, at 11:22 AM, Robert Griesemer wrote:\n>\n>> How is it different from:\n>>\n>> \u00a0 \u00a0 \u00a0 x := int(61)+1.0\n>> \u00a0 \u00a0 \u00a0 y := 61 + 1.0\n>>\n>> ?\n>>\n>> x will have type int, but y is float64. With the same argument one\n>> could say that y should be int. It may look bizarre, but it makes\n>> perfect sense (just maybe not emotional sense).\n>\n> It's different because 61 is an untyped integer constant, so in isolation int(61) is different in effect from rune(61).\n>\n> -rob\n>\nMaybe I should have written:\n\n\tx := byte(61.0)+1.0\n\ty := 0x3d + 1.0\n\nIn isolation 61.0 is float64 (61 is int in Ken's example), and 0x3d is\nint ('a' is rune). But x is byte (rune in Ken's example), y is float64\n(int). 0x3d + 1.0 \"looks line a byte\" but defaults to float64;\nsimilarly, 'a' + 1 looks like a rune but defaults to int (with #2).\n\nBut all these examples are contrived.\n\nI think if an untyped constant expression should default to rune type,\nit better not have anything but character literals in it. Most of the\ntime it's exactly one (probably 99% of the time). In all other cases,\nwe have some kind of computation and the result should probably not be\na rune (it's a difference, or some maximum, or what have you).\n\nOne more argument in favor of #2: If 'a' + 1 should default to a rune,\none can always write 'a' + '\\x01' with prop #2. But I have no way to\nmake 'a' + 1 be an untyped constant that defaults to int with #1.\n\n- gri\n",
			"disapproval": false,
			"date": "2011-12-08 20:44:55.379955",
			"approval": false
		},
		{
			"sender": "iant@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Robert Griesemer <gri@golang.org> writes:\n\n> Looking at rsc's CL again, by\n> far the majority of places where a rune cast can be avoided are of the\n> form\n>\n> v := 'x'\n>\n> which makes a lot of sense, of course.\n\nI don't quite understand this.  I thought we all agreed that in a\nstatement like\n\tv := 'x'\nthat v would get type rune.  Are you saying that we do not all agree on\nthat?\n\nIan\n",
			"disapproval": false,
			"date": "2011-12-08 17:49:01.347772",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "A counterproposal for your consideration:\n\n\t'a'\n\nis an untyped integer constant. That's the status quo, and it's easy to understand and doesn't introduce any of this confusion. It also requires no code changes relative to the current tip.\n\n-rob\n\n",
			"disapproval": false,
			"date": "2011-12-08 17:55:33.368168",
			"approval": false
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I spoke to Ken and he suggested comparing these two declarations,\n\nx := rune(61)+1\ny := 'a' + 1\n\nUnder gri's approach as we understand it, x and y would have different types. That seems bizarre. Under rsc's approach they would both have type rune.\n\n-rob\n\n",
			"disapproval": false,
			"date": "2011-12-08 19:01:37.976407",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 8, 2011 at 11:59, Robert Griesemer <gri@golang.org> wrote:\n> There are two places where int\n> casts have to be introduced because the standing proposal (calling it\n> #1) changes current behavior:\n\nLet's look at both of these.  Here's the first:\n\nconst MaxBase = 'z' - 'a' + 10 + 1 // = hexValue('z') + 1\n\n func hexValue(ch rune) Word {\n-\td := MaxBase + 1 // illegal base\n+\td := int(MaxBase + 1) // illegal base\n\nThis was not the right change.  The right change is const MaxBase = 36.\nMaxBase should be an integer constant, not a character constant,\nbecause it is 36, not '$'.  Then there's no conversion.\n\nThis, Robert, seems to be the heart of your argument: that occasionally\nyou are doing math on characters and want an int.  But in every other\ncase in the language, we require a conversion for a concept change\nlike that.  It is inconsistent to drop the conversion here.\n\nHere's the second:\n\n \t// Make a string of all the runes.\n-\tnumRunes := unicode.MaxRune + 1\n+\tnumRunes := int(unicode.MaxRune + 1)\n\nThis is converting from a rune value to an integer.\nI'm not describing the type system; I'm describing the\nactual operation: unicode.MaxRune is clearly a rune,\nand numRunes is clearly an int.  So there's a conversion.\nThat is far less magical than the +1 turning it into int.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-08 17:59:27.149953",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 8, 2011 at 13:29, Robert Griesemer <gri@golang.org> wrote:\n> It seems to me that at the heart of proposal #1 is the feeling that a\n> rune 'a' is now some special new type. But it's not. An 'a' is still\n> just a plain vanilla integer value, and a short one at that. There's\n> no reason to make it anything better. Proposal #2 accepts that and\n> simply fits it into the existing hierarchy.\n\nYou seem to be the only one arguing against\nwhat's in this CL, it almost never matters in\npractice, there have been no truly new points\nmade in this discussion, and I'd like to move on\nto other, less controversial work.  I think we've\nspent far more time on this than it merits.\n\nI am uncomfortable that we have not reached\nan actual consensus on 'x'+1, but we all seem\nto agree that 'x' should default to rune, and that\nis 99% of what this CL is about.  I propose that\nwe close the discussion, check in the current CL,\nand get some experience with this behavior.\nIf something more compelling arises in actual use,\nwe still have time to change it later.\n\nObjections?\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-08 18:37:52.421786",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 8, 2011 at 9:59 AM, Russ Cox <rsc@golang.org> wrote:\n> On Thu, Dec 8, 2011 at 11:59, Robert Griesemer <gri@golang.org> wrote:\n>> There are two places where int\n>> casts have to be introduced because the standing proposal (calling it\n>> #1) changes current behavior:\n>\n> Let's look at both of these. \u00a0Here's the first:\n>\n> const MaxBase = 'z' - 'a' + 10 + 1 // = hexValue('z') + 1\n>\n> \u00a0func hexValue(ch rune) Word {\n> - \u00a0 \u00a0 \u00a0 d := MaxBase + 1 // illegal base\n> + \u00a0 \u00a0 \u00a0 d := int(MaxBase + 1) // illegal base\n>\n> This was not the right change. \u00a0The right change is const MaxBase = 36.\n> MaxBase should be an integer constant, not a character constant,\n> because it is 36, not '$'. \u00a0Then there's no conversion.\n\nI agree, the change was not correct. It should have been in the const\ndeclaration - which then would have needed an int type (same as doing\nthe cast there). MaxBase would be an integer constant with my proposal\n#2 w/o any changes.\n\n>\n> This, Robert, seems to be the heart of your argument: that occasionally\n> you are doing math on characters and want an int. \u00a0But in every other\n> case in the language, we require a conversion for a concept change\n> like that. \u00a0It is inconsistent to drop the conversion here.\n\nExactly: I am doing math and I want the right thing to happen for the\nmathematically exact constants we have in Go. Like when I write 1 +\n2.3 I want this to become a floating point constant expression. And\nwhy? Because 1 + 2.3 can be represented as float type when it needs to\ndefault, but not as int type in general. The same is true for 'a' + 1\n- there is no difference whatsoever.\n\n> Here's the second:\n>\n> \u00a0 \u00a0 \u00a0 \u00a0// Make a string of all the runes.\n> - \u00a0 \u00a0 \u00a0 numRunes := unicode.MaxRune + 1\n> + \u00a0 \u00a0 \u00a0 numRunes := int(unicode.MaxRune + 1)\n>\n> This is converting from a rune value to an integer.\n> I'm not describing the type system; I'm describing the\n> actual operation: unicode.MaxRune is clearly a rune,\n> and numRunes is clearly an int. \u00a0So there's a conversion.\n\nThere should be no conversion - they are both untyped numerical constants.\n\nI don't understand why all of a sudden 'a' should become so special in\na situation like 'a' + 1 when until now we were perfectly happy with\nit defaulting to int type. After all, the rune type _is_ int32. Why\nshould a constant expression a + b where a defaults to int32 and b\ndefaults to int together default to int32? Makes no sense to me at\nall.\n\n- gri\n",
			"disapproval": false,
			"date": "2011-12-08 18:22:20.475102",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "How is it different from:\n\n\tx := int(61)+1.0\n\ty := 61 + 1.0\n\n?\n\nx will have type int, but y is float64. With the same argument one\ncould say that y should be int. It may look bizarre, but it makes\nperfect sense (just maybe not emotional sense).\n\n- gri\n\nOn Thu, Dec 8, 2011 at 11:01 AM, Rob 'Commander' Pike <r@google.com> wrote:\n> I spoke to Ken and he suggested comparing these two declarations,\n>\n> x := rune(61)+1\n> y := 'a' + 1\n>\n> Under gri's approach as we understand it, x and y would have different types. That seems bizarre. Under rsc's approach they would both have type rune.\n>\n> -rob\n>\n",
			"disapproval": false,
			"date": "2011-12-08 19:25:03.406977",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "It seems to me that at the heart of proposal #1 is the feeling that a\nrune 'a' is now some special new type. But it's not. An 'a' is still\njust a plain vanilla integer value, and a short one at that. There's\nno reason to make it anything better. Proposal #2 accepts that and\nsimply fits it into the existing hierarchy.\n\n- gri\n",
			"disapproval": false,
			"date": "2011-12-08 18:29:52.224948",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I am all for moving forward.\n\nBut I am not convinced that this is the right step. I believe I have\nbrought up concrete evidence why #2 is more sound than #1 (fewer casts\nor type declarations in existing code, behavior closer to what we have\nnow, mathematically makes more sense). I'd like to hear a concrete\nargument in favor of #1 (as opposed to an emotional one).\n\nAlso, let's be frank: \"moving forward and gaining experience with this\nCL\" actually means: \"let's get used to it, and in a couple of weeks\nit's not important enough to change\", especially because #1 is\n\"workable\". So, no, I am not really in favor of that.\n\nWe can either democracy or The Decider make the decision. I am for #2\nor the status quo: #2 for all the stated reasons, and status quo\nbecause it's simpler and doesn't introduce irregularities.\n\n- gri\n\nPS: Regarding your last argument: 'a' + 1 is a numerical constant\nexpression. It may not fit into an int32, so the error is not unusual.\nThe same applies to this piece of code. There's no difference:\n\nvar (\n    x = 1\n    y = 1 + 2.0\n    vector = []int{x, y} // ER\n)\n\nOn Thu, Dec 8, 2011 at 10:37 AM, Russ Cox <rsc@golang.org> wrote:\n> On Thu, Dec 8, 2011 at 13:29, Robert Griesemer <gri@golang.org> wrote:\n>> It seems to me that at the heart of proposal #1 is the feeling that a\n>> rune 'a' is now some special new type. But it's not. An 'a' is still\n>> just a plain vanilla integer value, and a short one at that. There's\n>> no reason to make it anything better. Proposal #2 accepts that and\n>> simply fits it into the existing hierarchy.\n>\n> You seem to be the only one arguing against\n> what's in this CL, it almost never matters in\n> practice, there have been no truly new points\n> made in this discussion, and I'd like to move on\n> to other, less controversial work. \u00a0I think we've\n> spent far more time on this than it merits.\n>\n> I am uncomfortable that we have not reached\n> an actual consensus on 'x'+1, but we all seem\n> to agree that 'x' should default to rune, and that\n> is 99% of what this CL is about. \u00a0I propose that\n> we close the discussion, check in the current CL,\n> and get some experience with this behavior.\n> If something more compelling arises in actual use,\n> we still have time to change it later.\n>\n> Objections?\n>\n> Russ\n",
			"disapproval": false,
			"date": "2011-12-08 19:24:36.595755",
			"approval": false
		},
		{
			"sender": "ken@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "i do not understand robert's argument.\n'a' is a typed constant with a value.\nrune(0x61) is a typed constant with a value.\nthey should have the exact same semantic meaning.\nit seems that everyone knows what\n     rune(0x61)+1\nmeans, but can't decide what\n    'a'+1\nmeans. they are the same. it should all fall out from the\naddition of a typed constant and an untyped constant.\ni think it is the same as 'b' (not by definition, but by ascii.)\n\nOn Thu, Dec 8, 2011 at 11:37 AM, Rob 'Commander' Pike <r@google.com> wrote:\n>\n> On Dec 8, 2011, at 11:22 AM, Robert Griesemer wrote:\n>\n>> How is it different from:\n>>\n>> \u00a0 \u00a0 \u00a0 x := int(61)+1.0\n>> \u00a0 \u00a0 \u00a0 y := 61 + 1.0\n>>\n>> ?\n>>\n>> x will have type int, but y is float64. With the same argument one\n>> could say that y should be int. It may look bizarre, but it makes\n>> perfect sense (just maybe not emotional sense).\n>\n> It's different because 61 is an untyped integer constant, so in isolation int(61) is different in effect from rune(61).\n>\n> -rob\n>\n",
			"disapproval": false,
			"date": "2011-12-08 20:56:22.126304",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "they would be the same if 'a' were a typed constant\n\nbut 'a' is an untyped constant that defaults to rune type by itself,\nand may default to something else in context. for:\n\n    ch := 'a' + 1\n\nprop #1 says: ch is of type rune (because there's a character literal\nin the untyped constant expression)\nprop #2 says: ch is of type int (because there's an int literal in the\nuntyped constant expression)\n\n- robert\n\n\nOn Thu, Dec 8, 2011 at 12:56 PM, Ken Thompson <ken@google.com> wrote:\n> i do not understand robert's argument.\n> 'a' is a typed constant with a value.\n> rune(0x61) is a typed constant with a value.\n> they should have the exact same semantic meaning.\n> it seems that everyone knows what\n> \u00a0 \u00a0 rune(0x61)+1\n> means, but can't decide what\n> \u00a0 \u00a0'a'+1\n> means. they are the same. it should all fall out from the\n> addition of a typed constant and an untyped constant.\n> i think it is the same as 'b' (not by definition, but by ascii.)\n>\n> On Thu, Dec 8, 2011 at 11:37 AM, Rob 'Commander' Pike <r@google.com> wrote:\n>>\n>> On Dec 8, 2011, at 11:22 AM, Robert Griesemer wrote:\n>>\n>>> How is it different from:\n>>>\n>>> \u00a0 \u00a0 \u00a0 x := int(61)+1.0\n>>> \u00a0 \u00a0 \u00a0 y := 61 + 1.0\n>>>\n>>> ?\n>>>\n>>> x will have type int, but y is float64. With the same argument one\n>>> could say that y should be int. It may look bizarre, but it makes\n>>> perfect sense (just maybe not emotional sense).\n>>\n>> It's different because 61 is an untyped integer constant, so in isolation int(61) is different in effect from rune(61).\n>>\n>> -rob\n>>\n",
			"disapproval": false,
			"date": "2011-12-08 21:49:02.501320",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"rsc@golang.org",
				"golang-dev@googlegroups.com",
				"gri@golang.org",
				"r@golang.org",
				"r@google.com",
				"adg@golang.org",
				"iant@google.com",
				"ken@google.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "http://codereview.appspot.com/5444053/diff/27001/doc/go_spec.html\nFile doc/go_spec.html (right):\n\nhttp://codereview.appspot.com/5444053/diff/27001/doc/go_spec.html#newcode520\ndoc/go_spec.html:520: and <i>string constants</i>. Integer, character, floating-point,\nCharacter, integer, ...\n\nhttp://codereview.appspot.com/5444053/diff/27001/doc/go_spec.html#newcode3760\ndoc/go_spec.html:3760: to type <code>bool</code>, <code>int</code>, <code>rune</code>, <code>float64</code>,\nbool, rune, int, float64 ...\n\nhttp://codereview.appspot.com/5444053/diff/27001/doc/go_spec.html#newcode3762\ndoc/go_spec.html:3762: respectively, depending on whether the value is a boolean, integer,\nboolean, character, integer, floating-point,",
			"disapproval": false,
			"date": "2011-12-08 22:45:41.589231",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"gri@golang.org",
				"r@golang.org",
				"r@google.com",
				"adg@golang.org",
				"iant@google.com",
				"ken@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n\nhttp://codereview.appspot.com/5444053/diff/27001/doc/go_spec.html\nFile doc/go_spec.html (right):\n\nhttp://codereview.appspot.com/5444053/diff/27001/doc/go_spec.html#newcode520\ndoc/go_spec.html:520: and <i>string constants</i>. Integer, character, floating-point,\nOn 2011/12/08 22:45:41, gri wrote:\n> Character, integer, ...\n\nDone.\n\nhttp://codereview.appspot.com/5444053/diff/27001/doc/go_spec.html#newcode3760\ndoc/go_spec.html:3760: to type <code>bool</code>, <code>int</code>, <code>rune</code>, <code>float64</code>,\nOn 2011/12/08 22:45:41, gri wrote:\n> bool, rune, int, float64 ...\n\nDone.\n\nhttp://codereview.appspot.com/5444053/diff/27001/doc/go_spec.html#newcode3762\ndoc/go_spec.html:3762: respectively, depending on whether the value is a boolean, integer,\nOn 2011/12/08 22:45:41, gri wrote:\n> boolean, character, integer, floating-point, \n\nDone.",
			"disapproval": false,
			"date": "2011-12-08 22:49:23.766171",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"rsc@golang.org",
				"gri@golang.org",
				"r@golang.org",
				"r@google.com",
				"adg@golang.org",
				"iant@google.com",
				"ken@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Leaving for r.\n\nhttp://codereview.appspot.com/5444053/diff/23005/doc/go_spec.html\nFile doc/go_spec.html (right):\n\nhttp://codereview.appspot.com/5444053/diff/23005/doc/go_spec.html#newcode3421\ndoc/go_spec.html:3421: the kind that appears later in this list: integer, character, floating-point, complex.\nI would write:\n\ncharacter, integer, floating-point, complex.\n\nleaving for r.\n\nhttp://codereview.appspot.com/5444053/diff/23005/doc/go_spec.html#newcode3448\ndoc/go_spec.html:3448: const j = 'w' + 1          // j == 'x'   (untyped character constant)\nconst 'w' + '\\x01'\n\nwould be my choice",
			"disapproval": false,
			"date": "2011-12-08 22:55:44.701932",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 8, 2011 at 16:49, Robert Griesemer <gri@golang.org> wrote:\n> but 'a' is an untyped constant that defaults to rune type by itself,\n> and may default to something else in context. for:\n>\n> \u00a0 \u00a0ch := 'a' + 1\n>\n> prop #1 says: ch is of type rune (because there's a character literal\n> in the untyped constant expression)\n> prop #2 says: ch is of type int (because there's an int literal in the\n> untyped constant expression)\n\nThis is definitely the key distinction.\nI just can't imagine a time when you'd write\n\nch := 'a'+1\n\nand expect to get ch := 98 instead of ch := 'b'.\n\nAs Rob said last night, integers feel like the most\ngeneric of the constants.  Making them more special\nthan character constants, in the same way that\nfloating-point constants are currently more special\nthan integers, seems very strange.\n\nUltimately I don't think we will come up with\ntechnical arguments that will satisfy everyone.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-08 21:53:26.652333",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "Independent of the outcome of the rune default discussion, I think the\nenumeration of the various literal types should be\n\nboolean, character, integer, floating-point, complex\n\nHaving the character literal between integer and floating point is\nodd. booleans are before ints, for instance. Especially if #1 is\nchosen, a character feels even less like a numeric type. Certainly not\none between int and float.\n\n- gri\n\nOn Thu, Dec 8, 2011 at 2:11 PM, Russ Cox <rsc@golang.org> wrote:\n> PTAL\n>\n> On Wed, Dec 7, 2011 at 19:30, \u00a0<r@golang.org> wrote:\n>> doc/go_spec.html:3420: the kind that appears later the list: integer,\n>> character, floating-point, complex.\n>> i'm fine with the order but agree this is a peculiar sentence. it's not\n>> clear what list you mean. be clear.\n>\n> changed to \"this list\":\n>\n> Except for shift operations, if the operands of a binary operation are\n> different kinds of untyped constants, the operation and result use\n> the kind that appears later in this list: integer, character,\n> floating-point, complex.\n> For example, an untyped integer constant divided by an\n> untyped complex constant yields an untyped complex constant.\n",
			"disapproval": false,
			"date": "2011-12-08 22:22:39.930269",
			"approval": false
		},
		{
			"sender": "gri@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Thu, Dec 8, 2011 at 1:53 PM, Russ Cox <rsc@golang.org> wrote:\n> On Thu, Dec 8, 2011 at 16:49, Robert Griesemer <gri@golang.org> wrote:\n>> but 'a' is an untyped constant that defaults to rune type by itself,\n>> and may default to something else in context. for:\n>>\n>> \u00a0 \u00a0ch := 'a' + 1\n>>\n>> prop #1 says: ch is of type rune (because there's a character literal\n>> in the untyped constant expression)\n>> prop #2 says: ch is of type int (because there's an int literal in the\n>> untyped constant expression)\n>\n> This is definitely the key distinction.\n> I just can't imagine a time when you'd write\n>\n> ch := 'a'+1\n>\n> and expect to get ch := 98 instead of ch := 'b'.\n\nExcept that in all cases in our code where we have code like that, we\nactually want an int (and #1 requires conversions that didn't exist\nbefore). I understand the emotional feel but it is contrary to the\nevidence we have.\n\nI can always write:\n\nch := 'a' + '\\01'\n\nand get exactly 'b' with both #1 and #2. But with proposal #1 I cannot write\n\nch := 'a' + 1\n\nand get 98 with a cast or type specification. In the past, we decided\nin favor of the more powerful mechanism.\n\n>\n> As Rob said last night, integers feel like the most\n> generic of the constants. \u00a0Making them more special\n> than character constants, in the same way that\n> floating-point constants are currently more special\n> than integers, seems very strange.\n\nWith emphasis on feeling; and I actually share that feeling. But it\nseems mathematically incorrect. Floating-point constants are more\nspecial than ints because typically a floating point constant cannot\nbe represented as an integral value. Arguably, an int value is more\nspecial because typically an an arbitrary integer constant cannot be\nrepresented as a character literal (e.g., a '\\U...' value goes only to\n32bits); also when defaulting to a rune, an int value may not fit into\n32bits and lead to a hard to explain error.\n\nAnyway, I give up. I've made my point.\n- Robert\n\n\n\n>\n> Ultimately I don't think we will come up with\n> technical arguments that will satisfy everyone.\n>\n> Russ\n",
			"disapproval": false,
			"date": "2011-12-08 22:06:32.829777",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "I chose 'character constant'\nto avoid the type name rune.\nIt has rune type by default, but\n\nvar x int64 = 'x'\n\nis still okay.  And you can make a typed constant\nwith type rune\n\nconst x rune = 100\n\n(and then var y int64 = x is not okay)\nso in all it seemed clearer not to reuse the type\nname.  We write integer or floating-point constant,\nnot int constant or float64 constant.\n\nRuss\n",
			"disapproval": false,
			"date": "2011-12-09 00:52:24.228302",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "On Sat, Dec 10, 2011 at 03:13, Ken Thompson <ken@google.com> wrote:\n> i dont understand the line\n>\n> const \u03a3 = 1 - 0.707 \u00a0 \u00a0 \u00a0 \u00a0// \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(untyped complex constant)\n>\n> there should be an i in there somewhere.\n\noops.  i lost the i in 0.707i during copy+paste.\nthanks.\n\nruss\n",
			"disapproval": false,
			"date": "2011-12-10 16:27:49.391243",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"rsc@golang.org",
				"gri@golang.org",
				"r@golang.org",
				"r@google.com",
				"adg@golang.org",
				"iant@google.com",
				"ken@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "*** Submitted as http://code.google.com/p/go/source/detail?r=1100c91c2087 ***\n\nspec: var x = 'a' defaults to type rune\n\nR=gri, r, r, adg, iant, ken\nCC=golang-dev\nhttp://codereview.appspot.com/5444053",
			"disapproval": false,
			"date": "2011-12-09 02:48:28.696185",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n\nOn Wed, Dec 7, 2011 at 19:30,  <r@golang.org> wrote:\n> doc/go_spec.html:3420: the kind that appears later the list: integer,\n> character, floating-point, complex.\n> i'm fine with the order but agree this is a peculiar sentence. it's not\n> clear what list you mean. be clear.\n\nchanged to \"this list\":\n\nExcept for shift operations, if the operands of a binary operation are\ndifferent kinds of untyped constants, the operation and result use\nthe kind that appears later in this list: integer, character,\nfloating-point, complex.\nFor example, an untyped integer constant divided by an\nuntyped complex constant yields an untyped complex constant.\n",
			"disapproval": false,
			"date": "2011-12-08 22:11:17.810988",
			"approval": false
		},
		{
			"sender": "rsc@golang.org",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "PTAL\n",
			"disapproval": false,
			"date": "2011-12-08 22:29:12.845251",
			"approval": false
		},
		{
			"sender": "ken@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "i dont understand the line\n\nconst \u03a3 = 1 - 0.707        //            (untyped complex constant)\n\nthere should be an i in there somewhere.\n\nOn Thu, Dec 8, 2011 at 6:48 PM,  <rsc@golang.org> wrote:\n> *** Submitted as\n> http://code.google.com/p/go/source/detail?r=1100c91c2087 ***\n>\n> spec: var x = 'a' defaults to type rune\n>\n> R=gri, r, r, adg, iant, ken\n> CC=golang-dev\n> http://codereview.appspot.com/5444053\n>\n>\n> http://codereview.appspot.com/5444053/\n",
			"disapproval": false,
			"date": "2011-12-10 08:13:21.031779",
			"approval": false
		},
		{
			"sender": "r@golang.org",
			"recipients": [
				"rsc@golang.org",
				"gri@golang.org",
				"r@golang.org",
				"r@google.com",
				"adg@golang.org",
				"iant@google.com",
				"ken@google.com",
				"golang-dev@googlegroups.com",
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "LGTM but there's a wording change here others might want to check\n\nhttp://codereview.appspot.com/5444053/diff/23005/doc/go_spec.html\nFile doc/go_spec.html (right):\n\nhttp://codereview.appspot.com/5444053/diff/23005/doc/go_spec.html#newcode364\ndoc/go_spec.html:364: A character literal represents a <a href=\"#Constants\">character constant</a>,\nthis should be called a character literal representing a rune constant\n\nhttp://codereview.appspot.com/5444053/diff/23005/doc/go_spec.html#newcode3421\ndoc/go_spec.html:3421: the kind that appears later in this list: integer, character, floating-point, complex.\nkeep the order but s/character/rune/\n\nhttp://codereview.appspot.com/5444053/diff/23005/doc/go_spec.html#newcode3448\ndoc/go_spec.html:3448: const j = 'w' + 1          // j == 'x'   (untyped character constant)\nadd gri's example\nalso s/character/rune/\n\nhttp://codereview.appspot.com/5444053/diff/23005/doc/go_spec.html#newcode3456\ndoc/go_spec.html:3456: integer, character, or floating-point constants yields\ns/character/rune/\n\nhttp://codereview.appspot.com/5444053/diff/23005/doc/go_spec.html#newcode3763\ndoc/go_spec.html:3763: character, integer, floating-point, complex, or string constant.\ns/character/rune/",
			"disapproval": false,
			"date": "2011-12-09 00:12:30.705440",
			"approval": true
		},
		{
			"sender": "r@google.com",
			"recipients": [
				"reply@codereview-hr.appspotmail.com"
			],
			"text": "\nOn Dec 8, 2011, at 4:52 PM, Russ Cox wrote:\n\n> I chose 'character constant'\n> to avoid the type name rune.\n> It has rune type by default, but\n> \n> var x int64 = 'x'\n> \n> is still okay.  And you can make a typed constant\n> with type rune\n> \n> const x rune = 100\n> \n> (and then var y int64 = x is not okay)\n> so in all it seemed clearer not to reuse the type\n> name.  We write integer or floating-point constant,\n> not int constant or float64 constant.\n\nthat's fine, and i'm happy with 'character constant'. my point was to push back on the idea that it's just a byte (char), but maybe i don't need to worry about that any more.\n\nLGTM either way\n\n-rob\n\n",
			"disapproval": false,
			"date": "2011-12-09 00:59:08.288276",
			"approval": true
		}
	],
	"owner_email": "rsc@golang.org",
	"private": false,
	"base_url": "",
	"owner": "rsc",
	"subject": "code review 5444053: spec: var x = 'a' defaults to type rune",
	"created": "2011-12-07 22:00:07.770409",
	"patchsets": [
		1,
		2001,
		5001,
		22002,
		27001,
		23005,
		14004
	],
	"modified": "2011-12-09 00:59:08.288276",
	"closed": true,
	"issue": 5444053
}